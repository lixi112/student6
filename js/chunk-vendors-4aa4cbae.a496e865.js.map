{"version":3,"file":"js/chunk-vendors-4aa4cbae.a496e865.js","mappings":"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","sources":["webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/errors.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/utils/executor_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/utils/generic_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/backend/state.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/keras_format/common.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/common.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/utils/math_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/backend/common.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/backend/tfjs_backend.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/keras_format/initializer_config.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/initializers.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/utils/types_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/utils/variable_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/variables.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/engine/topology.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/engine/input_layer.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/engine/executor.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/flags_layers.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/constraints.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/logs.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/base_callbacks.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/serialization.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/losses.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/metrics.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/optimizers.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/user_defined_metadata.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/utils/layer_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/utils/serialization_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/version.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/engine/container.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/engine/training_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/engine/training_dataset.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/engine/training_tensors.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/engine/training.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/models.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/activations.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/regularizers.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/advanced_activations.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/utils/conv_utils.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_depthwise.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/recurrent.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/convolutional_recurrent.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/core.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/embeddings.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/merge.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/noise.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/normalization.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/padding.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/pooling.js","webpack://student1/./node_modules/@tensorflow/tfjs-layers/dist/layers/wrappers.js","webpack://student1/./node_modules/@tensorflow/tfjs/dist/version.js","webpack://student1/./node_modules/@tensorflow/tfjs/dist/index.js"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Explicit error types.\n *\n * See the following link for more information about why the code includes\n * calls to setPrototypeOf:\n *\n * https://github.com/Microsoft/TypeScript-wiki/blob/master/Breaking-Changes.md#extending-built-ins-like-error-array-and-map-may-no-longer-work\n */\n// tslint:enable\n/**\n * Equivalent of Python's AttributeError.\n */\nexport class AttributeError extends Error {\n    constructor(message) {\n        super(message);\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, AttributeError.prototype);\n    }\n}\n/**\n * Equivalent of Python's RuntimeError.\n */\nexport class RuntimeError extends Error {\n    constructor(message) {\n        super(message);\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, RuntimeError.prototype);\n    }\n}\n/**\n * Equivalent of Python's ValueError.\n */\nexport class ValueError extends Error {\n    constructor(message) {\n        super(message);\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, ValueError.prototype);\n    }\n}\n/**\n * Equivalent of Python's NotImplementedError.\n */\nexport class NotImplementedError extends Error {\n    constructor(message) {\n        super(message);\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, NotImplementedError.prototype);\n    }\n}\n/**\n * Equivalent of Python's AssertionError.\n */\nexport class AssertionError extends Error {\n    constructor(message) {\n        super(message);\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, AssertionError.prototype);\n    }\n}\n/**\n * Equivalent of Python's IndexError.\n */\nexport class IndexError extends Error {\n    constructor(message) {\n        super(message);\n        // Set the prototype explicitly.\n        Object.setPrototypeOf(this, IndexError.prototype);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2Vycm9ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOzs7Ozs7O0dBT0c7QUFDSCxnQkFBZ0I7QUFFaEI7O0dBRUc7QUFDSCxNQUFNLE9BQU8sY0FBZSxTQUFRLEtBQUs7SUFDdkMsWUFBWSxPQUFnQjtRQUMxQixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixnQ0FBZ0M7UUFDaEMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsY0FBYyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3hELENBQUM7Q0FDRjtBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFPLFlBQWEsU0FBUSxLQUFLO0lBQ3JDLFlBQVksT0FBZ0I7UUFDMUIsS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDO1FBQ2YsZ0NBQWdDO1FBQ2hDLE1BQU0sQ0FBQyxjQUFjLENBQUMsSUFBSSxFQUFFLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUN0RCxDQUFDO0NBQ0Y7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxVQUFXLFNBQVEsS0FBSztJQUNuQyxZQUFZLE9BQWdCO1FBQzFCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNmLGdDQUFnQztRQUNoQyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxVQUFVLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDcEQsQ0FBQztDQUNGO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sbUJBQW9CLFNBQVEsS0FBSztJQUM1QyxZQUFZLE9BQWdCO1FBQzFCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNmLGdDQUFnQztRQUNoQyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxtQkFBbUIsQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUM3RCxDQUFDO0NBQ0Y7QUFFRDs7R0FFRztBQUNILE1BQU0sT0FBTyxjQUFlLFNBQVEsS0FBSztJQUN2QyxZQUFZLE9BQWdCO1FBQzFCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUNmLGdDQUFnQztRQUNoQyxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksRUFBRSxjQUFjLENBQUMsU0FBUyxDQUFDLENBQUM7SUFDeEQsQ0FBQztDQUNGO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLE9BQU8sVUFBVyxTQUFRLEtBQUs7SUFDbkMsWUFBWSxPQUFnQjtRQUMxQixLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7UUFDZixnQ0FBZ0M7UUFDaEMsTUFBTSxDQUFDLGNBQWMsQ0FBQyxJQUFJLEVBQUUsVUFBVSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ3BELENBQUM7Q0FDRiIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogRXhwbGljaXQgZXJyb3IgdHlwZXMuXG4gKlxuICogU2VlIHRoZSBmb2xsb3dpbmcgbGluayBmb3IgbW9yZSBpbmZvcm1hdGlvbiBhYm91dCB3aHkgdGhlIGNvZGUgaW5jbHVkZXNcbiAqIGNhbGxzIHRvIHNldFByb3RvdHlwZU9mOlxuICpcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9NaWNyb3NvZnQvVHlwZVNjcmlwdC13aWtpL2Jsb2IvbWFzdGVyL0JyZWFraW5nLUNoYW5nZXMubWQjZXh0ZW5kaW5nLWJ1aWx0LWlucy1saWtlLWVycm9yLWFycmF5LWFuZC1tYXAtbWF5LW5vLWxvbmdlci13b3JrXG4gKi9cbi8vIHRzbGludDplbmFibGVcblxuLyoqXG4gKiBFcXVpdmFsZW50IG9mIFB5dGhvbidzIEF0dHJpYnV0ZUVycm9yLlxuICovXG5leHBvcnQgY2xhc3MgQXR0cmlidXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5LlxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBBdHRyaWJ1dGVFcnJvci5wcm90b3R5cGUpO1xuICB9XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCBvZiBQeXRob24ncyBSdW50aW1lRXJyb3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBSdW50aW1lRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5LlxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBSdW50aW1lRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgb2YgUHl0aG9uJ3MgVmFsdWVFcnJvci5cbiAqL1xuZXhwb3J0IGNsYXNzIFZhbHVlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5LlxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBWYWx1ZUVycm9yLnByb3RvdHlwZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IG9mIFB5dGhvbidzIE5vdEltcGxlbWVudGVkRXJyb3IuXG4gKi9cbmV4cG9ydCBjbGFzcyBOb3RJbXBsZW1lbnRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgZXhwbGljaXRseS5cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgTm90SW1wbGVtZW50ZWRFcnJvci5wcm90b3R5cGUpO1xuICB9XG59XG5cbi8qKlxuICogRXF1aXZhbGVudCBvZiBQeXRob24ncyBBc3NlcnRpb25FcnJvci5cbiAqL1xuZXhwb3J0IGNsYXNzIEFzc2VydGlvbkVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICBjb25zdHJ1Y3RvcihtZXNzYWdlPzogc3RyaW5nKSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgLy8gU2V0IHRoZSBwcm90b3R5cGUgZXhwbGljaXRseS5cbiAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YodGhpcywgQXNzZXJ0aW9uRXJyb3IucHJvdG90eXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIEVxdWl2YWxlbnQgb2YgUHl0aG9uJ3MgSW5kZXhFcnJvci5cbiAqL1xuZXhwb3J0IGNsYXNzIEluZGV4RXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gIGNvbnN0cnVjdG9yKG1lc3NhZ2U/OiBzdHJpbmcpIHtcbiAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAvLyBTZXQgdGhlIHByb3RvdHlwZSBleHBsaWNpdGx5LlxuICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZih0aGlzLCBJbmRleEVycm9yLnByb3RvdHlwZSk7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2022 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * LruCache: A mapping from the String to T. If the number of the entries is\n * exceeding the `maxEntries`, the LruCache will delete the least recently\n * used entry.\n */\nexport class LruCache {\n    constructor(maxEntries) {\n        this.maxEntries = maxEntries || 100;\n        this.cache = new Map();\n    }\n    /**\n     * Get the entry for the key and mark it as used recently.\n     */\n    get(key) {\n        let entry;\n        if (this.cache.has(key)) {\n            entry = this.cache.get(key);\n            this.cache.delete(key);\n            this.cache.set(key, entry);\n        }\n        return entry;\n    }\n    /**\n     * Put the entry into the cache. If the key already existed, mark the key as\n     * used recently.\n     */\n    put(key, value) {\n        if (this.cache.has(key)) {\n            this.cache.delete(key);\n        }\n        else if (this.cache.size >= this.maxEntries) {\n            const keyToDelete = this.cache.keys().next().value;\n            this.cache.delete(keyToDelete);\n        }\n        this.cache.set(key, value);\n    }\n    /**\n     * Get the MaxEntries of the cache.\n     */\n    getMaxEntries() {\n        return this.maxEntries;\n    }\n    /**\n     * Set the MaxEntries of the cache. If the maxEntries is decreased, reduce\n     * entries in the cache.\n     */\n    setMaxEntries(maxEntries) {\n        if (maxEntries < 0) {\n            throw new Error(`The maxEntries of LRU caches must be at least 0, but got ${maxEntries}.`);\n        }\n        if (this.maxEntries > maxEntries) {\n            for (let i = 0; i < this.maxEntries - maxEntries; i++) {\n                const keyToDelete = this.cache.keys().next().value;\n                this.cache.delete(keyToDelete);\n            }\n        }\n        this.maxEntries = maxEntries;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlY3V0b3JfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvdXRpbHMvZXhlY3V0b3JfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFDSDs7OztHQUlHO0FBRUgsTUFBTSxPQUFPLFFBQVE7SUFJbkIsWUFBWSxVQUFtQjtRQUM3QixJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsSUFBSSxHQUFHLENBQUM7UUFDcEMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLEdBQUcsRUFBYSxDQUFDO0lBQ3BDLENBQUM7SUFFRDs7T0FFRztJQUNJLEdBQUcsQ0FBQyxHQUFXO1FBQ3BCLElBQUksS0FBUSxDQUFDO1FBQ2IsSUFBSSxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsRUFBRTtZQUN2QixLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDNUIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDdkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxFQUFFLEtBQUssQ0FBQyxDQUFDO1NBQzVCO1FBQ0QsT0FBTyxLQUFLLENBQUM7SUFDZixDQUFDO0lBRUQ7OztPQUdHO0lBQ0ksR0FBRyxDQUFDLEdBQVcsRUFBRSxLQUFRO1FBQzlCLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLEVBQUU7WUFDdkIsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7U0FDeEI7YUFBTSxJQUFJLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxVQUFVLEVBQUU7WUFDN0MsTUFBTSxXQUFXLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsQ0FBQyxJQUFJLEVBQUUsQ0FBQyxLQUFLLENBQUM7WUFDbkQsSUFBSSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUM7U0FDaEM7UUFDRCxJQUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsQ0FBQyxHQUFHLEVBQUUsS0FBSyxDQUFDLENBQUM7SUFDN0IsQ0FBQztJQUVEOztPQUVHO0lBQ0ksYUFBYTtRQUNsQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUM7SUFDekIsQ0FBQztJQUVEOzs7T0FHRztJQUNJLGFBQWEsQ0FBQyxVQUFrQjtRQUNyQyxJQUFJLFVBQVUsR0FBRyxDQUFDLEVBQUU7WUFDbEIsTUFBTSxJQUFJLEtBQUssQ0FDWCw0REFDSSxVQUFVLEdBQUcsQ0FBQyxDQUFDO1NBQ3hCO1FBRUQsSUFBSSxJQUFJLENBQUMsVUFBVSxHQUFHLFVBQVUsRUFBRTtZQUNoQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLEVBQUUsQ0FBQyxFQUFFLEVBQUU7Z0JBQ3JELE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxFQUFFLENBQUMsSUFBSSxFQUFFLENBQUMsS0FBSyxDQUFDO2dCQUNuRCxJQUFJLENBQUMsS0FBSyxDQUFDLE1BQU0sQ0FBQyxXQUFXLENBQUMsQ0FBQzthQUNoQztTQUNGO1FBRUQsSUFBSSxDQUFDLFVBQVUsR0FBRyxVQUFVLENBQUM7SUFDL0IsQ0FBQztDQUNGIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cbi8qKlxuICogTHJ1Q2FjaGU6IEEgbWFwcGluZyBmcm9tIHRoZSBTdHJpbmcgdG8gVC4gSWYgdGhlIG51bWJlciBvZiB0aGUgZW50cmllcyBpc1xuICogZXhjZWVkaW5nIHRoZSBgbWF4RW50cmllc2AsIHRoZSBMcnVDYWNoZSB3aWxsIGRlbGV0ZSB0aGUgbGVhc3QgcmVjZW50bHlcbiAqIHVzZWQgZW50cnkuXG4gKi9cblxuZXhwb3J0IGNsYXNzIExydUNhY2hlPFQ+IHtcbiAgcHJpdmF0ZSBjYWNoZTogTWFwPHN0cmluZywgVD47XG4gIHByaXZhdGUgbWF4RW50cmllczogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKG1heEVudHJpZXM/OiBudW1iZXIpIHtcbiAgICB0aGlzLm1heEVudHJpZXMgPSBtYXhFbnRyaWVzIHx8IDEwMDtcbiAgICB0aGlzLmNhY2hlID0gbmV3IE1hcDxzdHJpbmcsIFQ+KCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBlbnRyeSBmb3IgdGhlIGtleSBhbmQgbWFyayBpdCBhcyB1c2VkIHJlY2VudGx5LlxuICAgKi9cbiAgcHVibGljIGdldChrZXk6IHN0cmluZyk6IFQge1xuICAgIGxldCBlbnRyeTogVDtcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgZW50cnkgPSB0aGlzLmNhY2hlLmdldChrZXkpO1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICAgIHRoaXMuY2FjaGUuc2V0KGtleSwgZW50cnkpO1xuICAgIH1cbiAgICByZXR1cm4gZW50cnk7XG4gIH1cblxuICAvKipcbiAgICogUHV0IHRoZSBlbnRyeSBpbnRvIHRoZSBjYWNoZS4gSWYgdGhlIGtleSBhbHJlYWR5IGV4aXN0ZWQsIG1hcmsgdGhlIGtleSBhc1xuICAgKiB1c2VkIHJlY2VudGx5LlxuICAgKi9cbiAgcHVibGljIHB1dChrZXk6IHN0cmluZywgdmFsdWU6IFQpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5jYWNoZS5oYXMoa2V5KSkge1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5KTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuY2FjaGUuc2l6ZSA+PSB0aGlzLm1heEVudHJpZXMpIHtcbiAgICAgIGNvbnN0IGtleVRvRGVsZXRlID0gdGhpcy5jYWNoZS5rZXlzKCkubmV4dCgpLnZhbHVlO1xuICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5VG9EZWxldGUpO1xuICAgIH1cbiAgICB0aGlzLmNhY2hlLnNldChrZXksIHZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIE1heEVudHJpZXMgb2YgdGhlIGNhY2hlLlxuICAgKi9cbiAgcHVibGljIGdldE1heEVudHJpZXMoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5tYXhFbnRyaWVzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgTWF4RW50cmllcyBvZiB0aGUgY2FjaGUuIElmIHRoZSBtYXhFbnRyaWVzIGlzIGRlY3JlYXNlZCwgcmVkdWNlXG4gICAqIGVudHJpZXMgaW4gdGhlIGNhY2hlLlxuICAgKi9cbiAgcHVibGljIHNldE1heEVudHJpZXMobWF4RW50cmllczogbnVtYmVyKTogdm9pZCB7XG4gICAgaWYgKG1heEVudHJpZXMgPCAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFRoZSBtYXhFbnRyaWVzIG9mIExSVSBjYWNoZXMgbXVzdCBiZSBhdCBsZWFzdCAwLCBidXQgZ290ICR7XG4gICAgICAgICAgICAgIG1heEVudHJpZXN9LmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLm1heEVudHJpZXMgPiBtYXhFbnRyaWVzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubWF4RW50cmllcyAtIG1heEVudHJpZXM7IGkrKykge1xuICAgICAgICBjb25zdCBrZXlUb0RlbGV0ZSA9IHRoaXMuY2FjaGUua2V5cygpLm5leHQoKS52YWx1ZTtcbiAgICAgICAgdGhpcy5jYWNoZS5kZWxldGUoa2V5VG9EZWxldGUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMubWF4RW50cmllcyA9IG1heEVudHJpZXM7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: utils/generic_utils.py */\nimport { util } from '@tensorflow/tfjs-core';\nimport { AssertionError, ValueError } from '../errors';\n// tslint:enable\n/**\n * If `value` is an Array, equivalent to Python's `value * numValues`.\n * If `value` is not an Array, equivalent to Python's `[value] * numValues`\n */\n// tslint:disable-next-line:no-any\nexport function pyListRepeat(value, numValues) {\n    if (Array.isArray(value)) {\n        // tslint:disable-next-line:no-any\n        let newArray = [];\n        for (let i = 0; i < numValues; i++) {\n            newArray = newArray.concat(value);\n        }\n        return newArray;\n    }\n    else {\n        const newArray = new Array(numValues);\n        newArray.fill(value);\n        return newArray;\n    }\n}\nexport function assert(val, message) {\n    if (!val) {\n        throw new AssertionError(message);\n    }\n}\n/**\n * Count the number of elements of the `array` that are equal to `reference`.\n */\nexport function count(array, refernce) {\n    let counter = 0;\n    for (const item of array) {\n        if (item === refernce) {\n            counter++;\n        }\n    }\n    return counter;\n}\n/**\n * If an array is of length 1, just return the first element. Otherwise, return\n * the full array.\n * @param tensors\n */\nexport function singletonOrArray(xs) {\n    if (xs.length === 1) {\n        return xs[0];\n    }\n    return xs;\n}\n/**\n * Normalizes a list/tensor into a list.\n *\n * If a tensor is passed, we return\n * a list of size 1 containing the tensor.\n *\n * @param x target object to be normalized.\n */\n// tslint:disable-next-line:no-any\nexport function toList(x) {\n    if (Array.isArray(x)) {\n        return x;\n    }\n    return [x];\n}\n/**\n * Generate a UID for a list\n */\n// tslint:disable-next-line:no-any\nexport function objectListUid(objs) {\n    const objectList = toList(objs);\n    let retVal = '';\n    for (const obj of objectList) {\n        if (obj.id == null) {\n            throw new ValueError(`Object ${obj} passed to objectListUid without an id`);\n        }\n        if (retVal !== '') {\n            retVal = retVal + ', ';\n        }\n        retVal = `${retVal}${Math.abs(obj.id)}`;\n    }\n    return retVal;\n}\n/**\n * Converts string to snake-case.\n * @param name\n */\nexport function toSnakeCase(name) {\n    const intermediate = name.replace(/(.)([A-Z][a-z0-9]+)/g, '$1_$2');\n    const insecure = intermediate.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();\n    /*\n     If the class is private the name starts with \"_\" which is not secure\n     for creating scopes. We prefix the name with \"private\" in this case.\n     */\n    if (insecure[0] !== '_') {\n        return insecure;\n    }\n    return 'private' + insecure;\n}\nexport function toCamelCase(identifier) {\n    // quick return for empty string or single character strings\n    if (identifier.length <= 1) {\n        return identifier;\n    }\n    // Check for the underscore indicating snake_case\n    if (identifier.indexOf('_') === -1) {\n        return identifier;\n    }\n    return identifier.replace(/[_]+(\\w|$)/g, (m, p1) => p1.toUpperCase());\n}\n// tslint:disable-next-line:no-any\nlet _GLOBAL_CUSTOM_OBJECTS = {};\nexport function serializeKerasObject(instance) {\n    if (instance === null || instance === undefined) {\n        return null;\n    }\n    const dict = {};\n    dict['className'] = instance.getClassName();\n    dict['config'] = instance.getConfig();\n    return dict;\n}\n/**\n * Replace ndarray-style scalar objects in serialization objects with numbers.\n *\n * Background: In some versions of tf.keras, certain scalar values in the HDF5\n * model save file can be serialized as: `{'type': 'ndarray', 'value': num}`,\n * where in `num` is a plain number. This method converts such serialization\n * to a `number`.\n *\n * @param config The keras-format serialization object to be processed\n *   (in place).\n */\nfunction convertNDArrayScalarsInConfig(config) {\n    if (config == null || typeof config !== 'object') {\n        return;\n    }\n    else if (Array.isArray(config)) {\n        config.forEach(configItem => convertNDArrayScalarsInConfig(configItem));\n    }\n    else {\n        const fields = Object.keys(config);\n        for (const field of fields) {\n            const value = config[field];\n            if (value != null && typeof value === 'object') {\n                if (!Array.isArray(value) && value['type'] === 'ndarray' &&\n                    typeof value['value'] === 'number') {\n                    config[field] = value['value'];\n                }\n                else {\n                    convertNDArrayScalarsInConfig(value);\n                }\n            }\n        }\n    }\n}\n/**\n * Deserialize a saved Keras Object\n * @param identifier either a string ID or a saved Keras dictionary\n * @param moduleObjects a list of Python class names to object constructors\n * @param customObjects a list of Python class names to object constructors\n * @param printableModuleName debug text for the object being reconstituted\n * @param fastWeightInit Optional flag to use fast weight initialization\n *   during deserialization. This is applicable to cases in which\n *   the initialization will be immediately overwritten by loaded weight\n *   values. Default: `false`.\n * @returns a TensorFlow.js Layers object\n */\n// tslint:disable:no-any\nexport function deserializeKerasObject(identifier, moduleObjects = {}, customObjects = {}, printableModuleName = 'object', fastWeightInit = false) {\n    // tslint:enable\n    if (typeof identifier === 'string') {\n        const functionName = identifier;\n        let fn;\n        if (functionName in customObjects) {\n            fn = customObjects[functionName];\n        }\n        else if (functionName in _GLOBAL_CUSTOM_OBJECTS) {\n            fn = _GLOBAL_CUSTOM_OBJECTS[functionName];\n        }\n        else {\n            fn = moduleObjects[functionName];\n            if (fn == null) {\n                throw new ValueError(`Unknown ${printableModuleName}: ${identifier}. ` +\n                    `This may be due to one of the following reasons:\\n` +\n                    `1. The ${printableModuleName} is defined in Python, in which ` +\n                    `case it needs to be ported to TensorFlow.js or your JavaScript ` +\n                    `code.\\n` +\n                    `2. The custom ${printableModuleName} is defined in JavaScript, ` +\n                    `but is not registered properly with ` +\n                    `tf.serialization.registerClass().`);\n                // TODO(cais): Add link to tutorial page on custom layers.\n            }\n        }\n        return fn;\n    }\n    else {\n        // In this case we are dealing with a Keras config dictionary.\n        const config = identifier;\n        if (config['className'] == null || config['config'] == null) {\n            throw new ValueError(`${printableModuleName}: Improper config format: ` +\n                `${JSON.stringify(config)}.\\n` +\n                `'className' and 'config' must set.`);\n        }\n        const className = config['className'];\n        let cls, fromConfig;\n        if (className in customObjects) {\n            [cls, fromConfig] = customObjects[className];\n        }\n        else if (className in _GLOBAL_CUSTOM_OBJECTS) {\n            [cls, fromConfig] = _GLOBAL_CUSTOM_OBJECTS['className'];\n        }\n        else if (className in moduleObjects) {\n            [cls, fromConfig] = moduleObjects[className];\n        }\n        if (cls == null) {\n            throw new ValueError(`Unknown ${printableModuleName}: ${className}. ` +\n                `This may be due to one of the following reasons:\\n` +\n                `1. The ${printableModuleName} is defined in Python, in which ` +\n                `case it needs to be ported to TensorFlow.js or your JavaScript ` +\n                `code.\\n` +\n                `2. The custom ${printableModuleName} is defined in JavaScript, ` +\n                `but is not registered properly with ` +\n                `tf.serialization.registerClass().`);\n            // TODO(cais): Add link to tutorial page on custom layers.\n        }\n        if (fromConfig != null) {\n            // Porting notes: Instead of checking to see whether fromConfig accepts\n            // customObjects, we create a customObjects dictionary and tack it on to\n            // config['config'] as config['config'].customObjects. Objects can use it,\n            // if they want.\n            // tslint:disable-next-line:no-any\n            const customObjectsCombined = {};\n            for (const key of Object.keys(_GLOBAL_CUSTOM_OBJECTS)) {\n                customObjectsCombined[key] = _GLOBAL_CUSTOM_OBJECTS[key];\n            }\n            for (const key of Object.keys(customObjects)) {\n                customObjectsCombined[key] = customObjects[key];\n            }\n            // Add the customObjects to config\n            const nestedConfig = config['config'];\n            nestedConfig['customObjects'] = customObjectsCombined;\n            const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);\n            for (const key of Object.keys(customObjects)) {\n                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];\n            }\n            convertNDArrayScalarsInConfig(config['config']);\n            const returnObj = fromConfig(cls, config['config'], customObjects, fastWeightInit);\n            _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);\n            return returnObj;\n        }\n        else {\n            // Then `cls` may be a function returning a class.\n            // In this case by convention `config` holds\n            // the kwargs of the function.\n            const backupCustomObjects = Object.assign({}, _GLOBAL_CUSTOM_OBJECTS);\n            for (const key of Object.keys(customObjects)) {\n                _GLOBAL_CUSTOM_OBJECTS[key] = customObjects[key];\n            }\n            // In python this is **config['config'], for tfjs-layers we require\n            // classes that use this fall-through construction method to take\n            // a config interface that mimics the expansion of named parameters.\n            const returnObj = new cls(config['config']);\n            _GLOBAL_CUSTOM_OBJECTS = Object.assign({}, backupCustomObjects);\n            return returnObj;\n        }\n    }\n}\n/**\n * Compares two numbers for sorting.\n * @param a\n * @param b\n */\nexport function numberCompare(a, b) {\n    return (a < b) ? -1 : ((a > b) ? 1 : 0);\n}\n/**\n * Comparison of two numbers for reverse sorting.\n * @param a\n * @param b\n */\nexport function reverseNumberCompare(a, b) {\n    return -1 * numberCompare(a, b);\n}\n/**\n * Convert a string into the corresponding DType.\n * @param dtype\n * @returns An instance of DType.\n */\nexport function stringToDType(dtype) {\n    switch (dtype) {\n        case 'float32':\n            return 'float32';\n        default:\n            throw new ValueError(`Invalid dtype: ${dtype}`);\n    }\n}\n/**\n * Test the element-by-element equality of two Arrays of strings.\n * @param xs First array of strings.\n * @param ys Second array of strings.\n * @returns Wether the two arrays are all equal, element by element.\n */\nexport function stringsEqual(xs, ys) {\n    if (xs == null || ys == null) {\n        return xs === ys;\n    }\n    if (xs.length !== ys.length) {\n        return false;\n    }\n    for (let i = 0; i < xs.length; ++i) {\n        if (xs[i] !== ys[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Get the unique elements of an array.\n * @param xs Array.\n * @returns An Array consisting of the unique elements in `xs`.\n */\nexport function unique(xs) {\n    if (xs == null) {\n        return xs;\n    }\n    const out = [];\n    // TODO(cais): Maybe improve performance by sorting.\n    for (const x of xs) {\n        if (out.indexOf(x) === -1) {\n            out.push(x);\n        }\n    }\n    return out;\n}\n/**\n * Determine if an Object is empty (i.e., does not have own properties).\n * @param obj Object\n * @returns Whether the Object is empty.\n * @throws ValueError: If object is `null` or `undefined`.\n */\nexport function isObjectEmpty(obj) {\n    if (obj == null) {\n        throw new ValueError(`Invalid value in obj: ${JSON.stringify(obj)}`);\n    }\n    for (const key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Helper function used to build type union/enum run-time checkers.\n * @param values The list of allowed values.\n * @param label A string name for the type\n * @param value The value to test.\n * @throws ValueError: If the value is not in values nor `undefined`/`null`.\n */\nexport function checkStringTypeUnionValue(values, label, value) {\n    if (value == null) {\n        return;\n    }\n    if (values.indexOf(value) < 0) {\n        throw new ValueError(`${value} is not a valid ${label}.  Valid values are ${values} or null/undefined.`);\n    }\n}\n/**\n * Helper function for verifying the types of inputs.\n *\n * Ensures that the elements of `x` are all of type `expectedType`.\n * Also verifies that the length of `x` is within bounds.\n *\n * @param x Object to test.\n * @param expectedType The string expected type of all of the elements in the\n * Array.\n * @param minLength Return false if x.length is less than this.\n * @param maxLength Return false if x.length is greater than this.\n * @returns true if and only if `x` is an `Array<expectedType>` with\n * length >= `minLength` and <= `maxLength`.\n */\n// tslint:disable:no-any\nexport function checkArrayTypeAndLength(x, expectedType, minLength = 0, maxLength = Infinity) {\n    assert(minLength >= 0);\n    assert(maxLength >= minLength);\n    return (Array.isArray(x) && x.length >= minLength && x.length <= maxLength &&\n        x.every(e => typeof e === expectedType));\n}\n// tslint:enable:no-any\n/**\n * Assert that a value or an array of value are positive integer.\n *\n * @param value The value being asserted on. May be a single number or an array\n *   of numbers.\n * @param name Name of the value, used to make the error message.\n */\nexport function assertPositiveInteger(value, name) {\n    if (Array.isArray(value)) {\n        util.assert(value.length > 0, () => `${name} is unexpectedly an empty array.`);\n        value.forEach((v, i) => assertPositiveInteger(v, `element ${i + 1} of ${name}`));\n    }\n    else {\n        util.assert(Number.isInteger(value) && value > 0, () => `Expected ${name} to be a positive integer, but got ` +\n            `${formatAsFriendlyString(value)}.`);\n    }\n}\n/**\n * Format a value into a display-friendly, human-readable fashion.\n *\n * - `null` is formatted as `'null'`\n * - Strings are formated with flanking pair of quotes.\n * - Arrays are formatted with flanking pair of square brackets.\n *\n * @param value The value to display.\n * @return Formatted string.\n */\n// tslint:disable-next-line:no-any\nexport function formatAsFriendlyString(value) {\n    if (value === null) {\n        return 'null';\n    }\n    else if (Array.isArray(value)) {\n        return '[' + value.map(v => formatAsFriendlyString(v)).join(',') + ']';\n    }\n    else if (typeof value === 'string') {\n        return `\"${value}\"`;\n    }\n    else {\n        return `${value}`;\n    }\n}\n/**\n * Returns a function `f2` (decorator) which wraps the original function\n * `f`. `f2` guarantees that `f` can be called at most once\n * every `waitMs` ms. If `f2` is called more often, it will return\n * the last returned result of `f`.\n *\n * @param f The original function `f` to wrap.\n * @param waitMs The time between two consecutive calls to `f` in ms.\n */\nexport function debounce(f, waitMs, nowFunc) {\n    let lastTime = nowFunc != null ? nowFunc() : util.now();\n    let lastResult;\n    const f2 = (...args) => {\n        const now = nowFunc != null ? nowFunc() : util.now();\n        if (now - lastTime < waitMs) {\n            return lastResult;\n        }\n        lastTime = now;\n        lastResult = f(...args);\n        return lastResult;\n    };\n    return f2;\n}\n/**\n * Returns the fusable activation given a layers identifier.\n *\n * @param activationName The layers identifier string.\n * @return The name of the fusable activation.\n */\nexport function mapActivationToFusedKernel(activationName) {\n    if (activationName === 'relu') {\n        return 'relu';\n    }\n    if (activationName === 'linear') {\n        return 'linear';\n    }\n    if (activationName === 'elu') {\n        return 'elu';\n    }\n    return null;\n}\n/**\n * Returns the cartesian product of sets of values.\n * This works the same as itertools.product in Python.\n *\n * Example:\n *\n * filters = [128, 256, 512]\n * paddings = ['same', 'valid']\n *\n * product = [ [128, 'same'], [128, 'valid'], [256, 'same'], [256, 'valid'],\n * [512, 'same'], [512, 'valid']]\n *\n * @param arrayOfValues List/array of values.\n * @return The cartesian product.\n */\nexport function getCartesianProductOfValues(...arrayOfValues) {\n    assert(arrayOfValues.length > 0, 'arrayOfValues is empty');\n    for (const values of arrayOfValues) {\n        assert(Array.isArray(values), 'one of the values is not an array');\n        assert(values.length > 0, 'one of the values is empty');\n    }\n    return arrayOfValues.reduce((products, values) => {\n        if (products.length === 0) {\n            return values.map(value => [value]);\n        }\n        return values\n            .map(value => {\n            return products.map((prevValue) => [...prevValue, value]);\n        })\n            .reduce((flattenedProduct, unflattenedProduct) => {\n            return flattenedProduct.concat(unflattenedProduct);\n        }, []);\n    }, []);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ2VuZXJpY191dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy91dGlscy9nZW5lcmljX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsNkNBQTZDO0FBRTdDLE9BQU8sRUFBaUMsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFM0UsT0FBTyxFQUFDLGNBQWMsRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFFckQsZ0JBQWdCO0FBRWhCOzs7R0FHRztBQUNILGtDQUFrQztBQUNsQyxNQUFNLFVBQVUsWUFBWSxDQUFDLEtBQVUsRUFBRSxTQUFpQjtJQUN4RCxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDeEIsa0NBQWtDO1FBQ2xDLElBQUksUUFBUSxHQUFVLEVBQUUsQ0FBQztRQUN6QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsU0FBUyxFQUFFLENBQUMsRUFBRSxFQUFFO1lBQ2xDLFFBQVEsR0FBRyxRQUFRLENBQUMsTUFBTSxDQUFDLEtBQUssQ0FBQyxDQUFDO1NBQ25DO1FBQ0QsT0FBTyxRQUFRLENBQUM7S0FDakI7U0FBTTtRQUNMLE1BQU0sUUFBUSxHQUFHLElBQUksS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDO1FBQ3RDLFFBQVEsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDckIsT0FBTyxRQUFRLENBQUM7S0FDakI7QUFDSCxDQUFDO0FBRUQsTUFBTSxVQUFVLE1BQU0sQ0FBQyxHQUFZLEVBQUUsT0FBZ0I7SUFDbkQsSUFBSSxDQUFDLEdBQUcsRUFBRTtRQUNSLE1BQU0sSUFBSSxjQUFjLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDbkM7QUFDSCxDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsS0FBSyxDQUFJLEtBQVUsRUFBRSxR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QyxDQUFDO1NBQ3JDO1FBRUQsT0FBTyxNQUFNO2FBQ1IsR0FBRyxDQUFDLEtBQUssQ0FBQyxFQUFFO1lBQ1gsT0FBTyxRQUFRLENBQUMsR0FBRyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsU0FBUyxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7UUFDNUQsQ0FBQyxDQUFDO2FBQ0QsTUFBTSxDQUFDLENBQUMsZ0JBQWdCLEVBQUUsa0JBQWtCLEVBQUUsRUFBRTtZQUMvQyxPQUFPLGdCQUFnQixDQUFDLE1BQU0sQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO1FBQ3JELENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQztJQUNiLENBQUMsRUFBRSxFQUFvQixDQUFDLENBQUM7QUFDM0IsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qIE9yaWdpbmFsIHNvdXJjZTogdXRpbHMvZ2VuZXJpY191dGlscy5weSAqL1xuXG5pbXBvcnQge0RhdGFUeXBlLCBmdXNlZCwgc2VyaWFsaXphdGlvbiwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtBc3NlcnRpb25FcnJvciwgVmFsdWVFcnJvcn0gZnJvbSAnLi4vZXJyb3JzJztcblxuLy8gdHNsaW50OmVuYWJsZVxuXG4vKipcbiAqIElmIGB2YWx1ZWAgaXMgYW4gQXJyYXksIGVxdWl2YWxlbnQgdG8gUHl0aG9uJ3MgYHZhbHVlICogbnVtVmFsdWVzYC5cbiAqIElmIGB2YWx1ZWAgaXMgbm90IGFuIEFycmF5LCBlcXVpdmFsZW50IHRvIFB5dGhvbidzIGBbdmFsdWVdICogbnVtVmFsdWVzYFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gcHlMaXN0UmVwZWF0KHZhbHVlOiBhbnksIG51bVZhbHVlczogbnVtYmVyKTogYW55W10ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgbGV0IG5ld0FycmF5OiBhbnlbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtVmFsdWVzOyBpKyspIHtcbiAgICAgIG5ld0FycmF5ID0gbmV3QXJyYXkuY29uY2F0KHZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5ld0FycmF5ID0gbmV3IEFycmF5KG51bVZhbHVlcyk7XG4gICAgbmV3QXJyYXkuZmlsbCh2YWx1ZSk7XG4gICAgcmV0dXJuIG5ld0FycmF5O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlcnQodmFsOiBib29sZWFuLCBtZXNzYWdlPzogc3RyaW5nKTogdm9pZCB7XG4gIGlmICghdmFsKSB7XG4gICAgdGhyb3cgbmV3IEFzc2VydGlvbkVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbi8qKlxuICogQ291bnQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBvZiB0aGUgYGFycmF5YCB0aGF0IGFyZSBlcXVhbCB0byBgcmVmZXJlbmNlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50PFQ+KGFycmF5OiBUW10sIHJlZmVybmNlOiBUKSB7XG4gIGxldCBjb3VudGVyID0gMDtcbiAgZm9yIChjb25zdCBpdGVtIG9mIGFycmF5KSB7XG4gICAgaWYgKGl0ZW0gPT09IHJlZmVybmNlKSB7XG4gICAgICBjb3VudGVyKys7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudGVyO1xufVxuXG4vKipcbiAqIElmIGFuIGFycmF5IGlzIG9mIGxlbmd0aCAxLCBqdXN0IHJldHVybiB0aGUgZmlyc3QgZWxlbWVudC4gT3RoZXJ3aXNlLCByZXR1cm5cbiAqIHRoZSBmdWxsIGFycmF5LlxuICogQHBhcmFtIHRlbnNvcnNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpbmdsZXRvbk9yQXJyYXk8VD4oeHM6IFRbXSk6IFR8VFtdIHtcbiAgaWYgKHhzLmxlbmd0aCA9PT0gMSkge1xuICAgIHJldHVybiB4c1swXTtcbiAgfVxuICByZXR1cm4geHM7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBhIGxpc3QvdGVuc29yIGludG8gYSBsaXN0LlxuICpcbiAqIElmIGEgdGVuc29yIGlzIHBhc3NlZCwgd2UgcmV0dXJuXG4gKiBhIGxpc3Qgb2Ygc2l6ZSAxIGNvbnRhaW5pbmcgdGhlIHRlbnNvci5cbiAqXG4gKiBAcGFyYW0geCB0YXJnZXQgb2JqZWN0IHRvIGJlIG5vcm1hbGl6ZWQuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbmV4cG9ydCBmdW5jdGlvbiB0b0xpc3QoeDogYW55KTogYW55W10ge1xuICBpZiAoQXJyYXkuaXNBcnJheSh4KSkge1xuICAgIHJldHVybiB4O1xuICB9XG4gIHJldHVybiBbeF07XG59XG5cbi8qKlxuICogR2VuZXJhdGUgYSBVSUQgZm9yIGEgbGlzdFxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gb2JqZWN0TGlzdFVpZChvYmpzOiBhbnl8YW55W10pOiBzdHJpbmcge1xuICBjb25zdCBvYmplY3RMaXN0ID0gdG9MaXN0KG9ianMpO1xuICBsZXQgcmV0VmFsID0gJyc7XG4gIGZvciAoY29uc3Qgb2JqIG9mIG9iamVjdExpc3QpIHtcbiAgICBpZiAob2JqLmlkID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBPYmplY3QgJHtvYmp9IHBhc3NlZCB0byBvYmplY3RMaXN0VWlkIHdpdGhvdXQgYW4gaWRgKTtcbiAgICB9XG4gICAgaWYgKHJldFZhbCAhPT0gJycpIHtcbiAgICAgIHJldFZhbCA9IHJldFZhbCArICcsICc7XG4gICAgfVxuICAgIHJldFZhbCA9IGAke3JldFZhbH0ke01hdGguYWJzKG9iai5pZCl9YDtcbiAgfVxuICByZXR1cm4gcmV0VmFsO1xufVxuLyoqXG4gKiBDb252ZXJ0cyBzdHJpbmcgdG8gc25ha2UtY2FzZS5cbiAqIEBwYXJhbSBuYW1lXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB0b1NuYWtlQ2FzZShuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICBjb25zdCBpbnRlcm1lZGlhdGUgPSBuYW1lLnJlcGxhY2UoLyguKShbQS1aXVthLXowLTldKykvZywgJyQxXyQyJyk7XG4gIGNvbnN0IGluc2VjdXJlID1cbiAgICAgIGludGVybWVkaWF0ZS5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDFfJDInKS50b0xvd2VyQ2FzZSgpO1xuICAvKlxuICAgSWYgdGhlIGNsYXNzIGlzIHByaXZhdGUgdGhlIG5hbWUgc3RhcnRzIHdpdGggXCJfXCIgd2hpY2ggaXMgbm90IHNlY3VyZVxuICAgZm9yIGNyZWF0aW5nIHNjb3Blcy4gV2UgcHJlZml4IHRoZSBuYW1lIHdpdGggXCJwcml2YXRlXCIgaW4gdGhpcyBjYXNlLlxuICAgKi9cbiAgaWYgKGluc2VjdXJlWzBdICE9PSAnXycpIHtcbiAgICByZXR1cm4gaW5zZWN1cmU7XG4gIH1cbiAgcmV0dXJuICdwcml2YXRlJyArIGluc2VjdXJlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9DYW1lbENhc2UoaWRlbnRpZmllcjogc3RyaW5nKTogc3RyaW5nIHtcbiAgLy8gcXVpY2sgcmV0dXJuIGZvciBlbXB0eSBzdHJpbmcgb3Igc2luZ2xlIGNoYXJhY3RlciBzdHJpbmdzXG4gIGlmIChpZGVudGlmaWVyLmxlbmd0aCA8PSAxKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIHRoZSB1bmRlcnNjb3JlIGluZGljYXRpbmcgc25ha2VfY2FzZVxuICBpZiAoaWRlbnRpZmllci5pbmRleE9mKCdfJykgPT09IC0xKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gIH1cbiAgcmV0dXJuIGlkZW50aWZpZXIucmVwbGFjZSgvW19dKyhcXHd8JCkvZywgKG0sIHAxKSA9PiBwMS50b1VwcGVyQ2FzZSgpKTtcbn1cblxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxubGV0IF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMgPSB7fSBhcyB7W29iak5hbWU6IHN0cmluZ106IGFueX07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVLZXJhc09iamVjdChpbnN0YW5jZTogc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUpOlxuICAgIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFZhbHVlIHtcbiAgaWYgKGluc3RhbmNlID09PSBudWxsIHx8IGluc3RhbmNlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBjb25zdCBkaWN0OiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RWYWx1ZSA9IHt9O1xuICBkaWN0WydjbGFzc05hbWUnXSA9IGluc3RhbmNlLmdldENsYXNzTmFtZSgpO1xuICBkaWN0Wydjb25maWcnXSA9IGluc3RhbmNlLmdldENvbmZpZygpO1xuICByZXR1cm4gZGljdDtcbn1cblxuLyoqXG4gKiBSZXBsYWNlIG5kYXJyYXktc3R5bGUgc2NhbGFyIG9iamVjdHMgaW4gc2VyaWFsaXphdGlvbiBvYmplY3RzIHdpdGggbnVtYmVycy5cbiAqXG4gKiBCYWNrZ3JvdW5kOiBJbiBzb21lIHZlcnNpb25zIG9mIHRmLmtlcmFzLCBjZXJ0YWluIHNjYWxhciB2YWx1ZXMgaW4gdGhlIEhERjVcbiAqIG1vZGVsIHNhdmUgZmlsZSBjYW4gYmUgc2VyaWFsaXplZCBhczogYHsndHlwZSc6ICduZGFycmF5JywgJ3ZhbHVlJzogbnVtfWAsXG4gKiB3aGVyZSBpbiBgbnVtYCBpcyBhIHBsYWluIG51bWJlci4gVGhpcyBtZXRob2QgY29udmVydHMgc3VjaCBzZXJpYWxpemF0aW9uXG4gKiB0byBhIGBudW1iZXJgLlxuICpcbiAqIEBwYXJhbSBjb25maWcgVGhlIGtlcmFzLWZvcm1hdCBzZXJpYWxpemF0aW9uIG9iamVjdCB0byBiZSBwcm9jZXNzZWRcbiAqICAgKGluIHBsYWNlKS5cbiAqL1xuZnVuY3Rpb24gY29udmVydE5EQXJyYXlTY2FsYXJzSW5Db25maWcoY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RWYWx1ZSk6XG4gICAgdm9pZCB7XG4gIGlmIChjb25maWcgPT0gbnVsbCB8fCB0eXBlb2YgY29uZmlnICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybjtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICBjb25maWcuZm9yRWFjaChjb25maWdJdGVtID0+IGNvbnZlcnROREFycmF5U2NhbGFyc0luQ29uZmlnKGNvbmZpZ0l0ZW0pKTtcbiAgfSBlbHNlIHtcbiAgICBjb25zdCBmaWVsZHMgPSBPYmplY3Qua2V5cyhjb25maWcpO1xuICAgIGZvciAoY29uc3QgZmllbGQgb2YgZmllbGRzKSB7XG4gICAgICBjb25zdCB2YWx1ZSA9IGNvbmZpZ1tmaWVsZF07XG4gICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWVbJ3R5cGUnXSA9PT0gJ25kYXJyYXknICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWVbJ3ZhbHVlJ10gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uZmlnW2ZpZWxkXSA9IHZhbHVlWyd2YWx1ZSddO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnZlcnROREFycmF5U2NhbGFyc0luQ29uZmlnKHZhbHVlIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBEZXNlcmlhbGl6ZSBhIHNhdmVkIEtlcmFzIE9iamVjdFxuICogQHBhcmFtIGlkZW50aWZpZXIgZWl0aGVyIGEgc3RyaW5nIElEIG9yIGEgc2F2ZWQgS2VyYXMgZGljdGlvbmFyeVxuICogQHBhcmFtIG1vZHVsZU9iamVjdHMgYSBsaXN0IG9mIFB5dGhvbiBjbGFzcyBuYW1lcyB0byBvYmplY3QgY29uc3RydWN0b3JzXG4gKiBAcGFyYW0gY3VzdG9tT2JqZWN0cyBhIGxpc3Qgb2YgUHl0aG9uIGNsYXNzIG5hbWVzIHRvIG9iamVjdCBjb25zdHJ1Y3RvcnNcbiAqIEBwYXJhbSBwcmludGFibGVNb2R1bGVOYW1lIGRlYnVnIHRleHQgZm9yIHRoZSBvYmplY3QgYmVpbmcgcmVjb25zdGl0dXRlZFxuICogQHBhcmFtIGZhc3RXZWlnaHRJbml0IE9wdGlvbmFsIGZsYWcgdG8gdXNlIGZhc3Qgd2VpZ2h0IGluaXRpYWxpemF0aW9uXG4gKiAgIGR1cmluZyBkZXNlcmlhbGl6YXRpb24uIFRoaXMgaXMgYXBwbGljYWJsZSB0byBjYXNlcyBpbiB3aGljaFxuICogICB0aGUgaW5pdGlhbGl6YXRpb24gd2lsbCBiZSBpbW1lZGlhdGVseSBvdmVyd3JpdHRlbiBieSBsb2FkZWQgd2VpZ2h0XG4gKiAgIHZhbHVlcy4gRGVmYXVsdDogYGZhbHNlYC5cbiAqIEByZXR1cm5zIGEgVGVuc29yRmxvdy5qcyBMYXllcnMgb2JqZWN0XG4gKi9cbi8vIHRzbGludDpkaXNhYmxlOm5vLWFueVxuZXhwb3J0IGZ1bmN0aW9uIGRlc2VyaWFsaXplS2VyYXNPYmplY3QoXG4gICAgaWRlbnRpZmllcjogc3RyaW5nfHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCxcbiAgICBtb2R1bGVPYmplY3RzID0ge30gYXMge1tvYmpOYW1lOiBzdHJpbmddOiBhbnl9LFxuICAgIGN1c3RvbU9iamVjdHMgPSB7fSBhcyB7W29iak5hbWU6IHN0cmluZ106IGFueX0sXG4gICAgcHJpbnRhYmxlTW9kdWxlTmFtZSA9ICdvYmplY3QnLCBmYXN0V2VpZ2h0SW5pdCA9IGZhbHNlKTogYW55IHtcbiAgLy8gdHNsaW50OmVuYWJsZVxuICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgZnVuY3Rpb25OYW1lID0gaWRlbnRpZmllcjtcbiAgICBsZXQgZm47XG4gICAgaWYgKGZ1bmN0aW9uTmFtZSBpbiBjdXN0b21PYmplY3RzKSB7XG4gICAgICBmbiA9IGN1c3RvbU9iamVjdHNbZnVuY3Rpb25OYW1lXTtcbiAgICB9IGVsc2UgaWYgKGZ1bmN0aW9uTmFtZSBpbiBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTKSB7XG4gICAgICBmbiA9IF9HTE9CQUxfQ1VTVE9NX09CSkVDVFNbZnVuY3Rpb25OYW1lXTtcbiAgICB9IGVsc2Uge1xuICAgICAgZm4gPSBtb2R1bGVPYmplY3RzW2Z1bmN0aW9uTmFtZV07XG4gICAgICBpZiAoZm4gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBVbmtub3duICR7cHJpbnRhYmxlTW9kdWxlTmFtZX06ICR7aWRlbnRpZmllcn0uIGAgK1xuICAgICAgICAgICAgYFRoaXMgbWF5IGJlIGR1ZSB0byBvbmUgb2YgdGhlIGZvbGxvd2luZyByZWFzb25zOlxcbmAgK1xuICAgICAgICAgICAgYDEuIFRoZSAke3ByaW50YWJsZU1vZHVsZU5hbWV9IGlzIGRlZmluZWQgaW4gUHl0aG9uLCBpbiB3aGljaCBgICtcbiAgICAgICAgICAgIGBjYXNlIGl0IG5lZWRzIHRvIGJlIHBvcnRlZCB0byBUZW5zb3JGbG93LmpzIG9yIHlvdXIgSmF2YVNjcmlwdCBgICtcbiAgICAgICAgICAgIGBjb2RlLlxcbmAgK1xuICAgICAgICAgICAgYDIuIFRoZSBjdXN0b20gJHtwcmludGFibGVNb2R1bGVOYW1lfSBpcyBkZWZpbmVkIGluIEphdmFTY3JpcHQsIGAgK1xuICAgICAgICAgICAgYGJ1dCBpcyBub3QgcmVnaXN0ZXJlZCBwcm9wZXJseSB3aXRoIGAgK1xuICAgICAgICAgICAgYHRmLnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcygpLmApO1xuICAgICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgbGluayB0byB0dXRvcmlhbCBwYWdlIG9uIGN1c3RvbSBsYXllcnMuXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmbjtcbiAgfSBlbHNlIHtcbiAgICAvLyBJbiB0aGlzIGNhc2Ugd2UgYXJlIGRlYWxpbmcgd2l0aCBhIEtlcmFzIGNvbmZpZyBkaWN0aW9uYXJ5LlxuICAgIGNvbnN0IGNvbmZpZyA9IGlkZW50aWZpZXI7XG4gICAgaWYgKGNvbmZpZ1snY2xhc3NOYW1lJ10gPT0gbnVsbCB8fCBjb25maWdbJ2NvbmZpZyddID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGAke3ByaW50YWJsZU1vZHVsZU5hbWV9OiBJbXByb3BlciBjb25maWcgZm9ybWF0OiBgICtcbiAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeShjb25maWcpfS5cXG5gICtcbiAgICAgICAgICBgJ2NsYXNzTmFtZScgYW5kICdjb25maWcnIG11c3Qgc2V0LmApO1xuICAgIH1cbiAgICBjb25zdCBjbGFzc05hbWUgPSBjb25maWdbJ2NsYXNzTmFtZSddIGFzIHN0cmluZztcbiAgICBsZXQgY2xzLCBmcm9tQ29uZmlnO1xuICAgIGlmIChjbGFzc05hbWUgaW4gY3VzdG9tT2JqZWN0cykge1xuICAgICAgW2NscywgZnJvbUNvbmZpZ10gPSBjdXN0b21PYmplY3RzW2NsYXNzTmFtZV07XG4gICAgfSBlbHNlIGlmIChjbGFzc05hbWUgaW4gX0dMT0JBTF9DVVNUT01fT0JKRUNUUykge1xuICAgICAgW2NscywgZnJvbUNvbmZpZ10gPSBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTWydjbGFzc05hbWUnXTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSBpbiBtb2R1bGVPYmplY3RzKSB7XG4gICAgICBbY2xzLCBmcm9tQ29uZmlnXSA9IG1vZHVsZU9iamVjdHNbY2xhc3NOYW1lXTtcbiAgICB9XG4gICAgaWYgKGNscyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgVW5rbm93biAke3ByaW50YWJsZU1vZHVsZU5hbWV9OiAke2NsYXNzTmFtZX0uIGAgK1xuICAgICAgICAgIGBUaGlzIG1heSBiZSBkdWUgdG8gb25lIG9mIHRoZSBmb2xsb3dpbmcgcmVhc29uczpcXG5gICtcbiAgICAgICAgICBgMS4gVGhlICR7cHJpbnRhYmxlTW9kdWxlTmFtZX0gaXMgZGVmaW5lZCBpbiBQeXRob24sIGluIHdoaWNoIGAgK1xuICAgICAgICAgIGBjYXNlIGl0IG5lZWRzIHRvIGJlIHBvcnRlZCB0byBUZW5zb3JGbG93LmpzIG9yIHlvdXIgSmF2YVNjcmlwdCBgICtcbiAgICAgICAgICBgY29kZS5cXG5gICtcbiAgICAgICAgICBgMi4gVGhlIGN1c3RvbSAke3ByaW50YWJsZU1vZHVsZU5hbWV9IGlzIGRlZmluZWQgaW4gSmF2YVNjcmlwdCwgYCArXG4gICAgICAgICAgYGJ1dCBpcyBub3QgcmVnaXN0ZXJlZCBwcm9wZXJseSB3aXRoIGAgK1xuICAgICAgICAgIGB0Zi5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoKS5gKTtcbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBsaW5rIHRvIHR1dG9yaWFsIHBhZ2Ugb24gY3VzdG9tIGxheWVycy5cbiAgICB9XG4gICAgaWYgKGZyb21Db25maWcgIT0gbnVsbCkge1xuICAgICAgLy8gUG9ydGluZyBub3RlczogSW5zdGVhZCBvZiBjaGVja2luZyB0byBzZWUgd2hldGhlciBmcm9tQ29uZmlnIGFjY2VwdHNcbiAgICAgIC8vIGN1c3RvbU9iamVjdHMsIHdlIGNyZWF0ZSBhIGN1c3RvbU9iamVjdHMgZGljdGlvbmFyeSBhbmQgdGFjayBpdCBvbiB0b1xuICAgICAgLy8gY29uZmlnWydjb25maWcnXSBhcyBjb25maWdbJ2NvbmZpZyddLmN1c3RvbU9iamVjdHMuIE9iamVjdHMgY2FuIHVzZSBpdCxcbiAgICAgIC8vIGlmIHRoZXkgd2FudC5cblxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgY29uc3QgY3VzdG9tT2JqZWN0c0NvbWJpbmVkID0ge30gYXMge1tvYmpOYW1lOiBzdHJpbmddOiBhbnl9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoX0dMT0JBTF9DVVNUT01fT0JKRUNUUykpIHtcbiAgICAgICAgY3VzdG9tT2JqZWN0c0NvbWJpbmVkW2tleV0gPSBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW2tleV07XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjdXN0b21PYmplY3RzKSkge1xuICAgICAgICBjdXN0b21PYmplY3RzQ29tYmluZWRba2V5XSA9IGN1c3RvbU9iamVjdHNba2V5XTtcbiAgICAgIH1cbiAgICAgIC8vIEFkZCB0aGUgY3VzdG9tT2JqZWN0cyB0byBjb25maWdcbiAgICAgIGNvbnN0IG5lc3RlZENvbmZpZyA9IGNvbmZpZ1snY29uZmlnJ10gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0O1xuICAgICAgbmVzdGVkQ29uZmlnWydjdXN0b21PYmplY3RzJ10gPSBjdXN0b21PYmplY3RzQ29tYmluZWQ7XG5cbiAgICAgIGNvbnN0IGJhY2t1cEN1c3RvbU9iamVjdHMgPSB7Li4uX0dMT0JBTF9DVVNUT01fT0JKRUNUU307XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjdXN0b21PYmplY3RzKSkge1xuICAgICAgICBfR0xPQkFMX0NVU1RPTV9PQkpFQ1RTW2tleV0gPSBjdXN0b21PYmplY3RzW2tleV07XG4gICAgICB9XG4gICAgICBjb252ZXJ0TkRBcnJheVNjYWxhcnNJbkNvbmZpZyhjb25maWdbJ2NvbmZpZyddKTtcbiAgICAgIGNvbnN0IHJldHVybk9iaiA9XG4gICAgICAgICAgZnJvbUNvbmZpZyhjbHMsIGNvbmZpZ1snY29uZmlnJ10sIGN1c3RvbU9iamVjdHMsIGZhc3RXZWlnaHRJbml0KTtcbiAgICAgIF9HTE9CQUxfQ1VTVE9NX09CSkVDVFMgPSB7Li4uYmFja3VwQ3VzdG9tT2JqZWN0c307XG5cbiAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZW4gYGNsc2AgbWF5IGJlIGEgZnVuY3Rpb24gcmV0dXJuaW5nIGEgY2xhc3MuXG4gICAgICAvLyBJbiB0aGlzIGNhc2UgYnkgY29udmVudGlvbiBgY29uZmlnYCBob2xkc1xuICAgICAgLy8gdGhlIGt3YXJncyBvZiB0aGUgZnVuY3Rpb24uXG4gICAgICBjb25zdCBiYWNrdXBDdXN0b21PYmplY3RzID0gey4uLl9HTE9CQUxfQ1VTVE9NX09CSkVDVFN9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY3VzdG9tT2JqZWN0cykpIHtcbiAgICAgICAgX0dMT0JBTF9DVVNUT01fT0JKRUNUU1trZXldID0gY3VzdG9tT2JqZWN0c1trZXldO1xuICAgICAgfVxuICAgICAgLy8gSW4gcHl0aG9uIHRoaXMgaXMgKipjb25maWdbJ2NvbmZpZyddLCBmb3IgdGZqcy1sYXllcnMgd2UgcmVxdWlyZVxuICAgICAgLy8gY2xhc3NlcyB0aGF0IHVzZSB0aGlzIGZhbGwtdGhyb3VnaCBjb25zdHJ1Y3Rpb24gbWV0aG9kIHRvIHRha2VcbiAgICAgIC8vIGEgY29uZmlnIGludGVyZmFjZSB0aGF0IG1pbWljcyB0aGUgZXhwYW5zaW9uIG9mIG5hbWVkIHBhcmFtZXRlcnMuXG4gICAgICBjb25zdCByZXR1cm5PYmogPSBuZXcgY2xzKGNvbmZpZ1snY29uZmlnJ10pO1xuICAgICAgX0dMT0JBTF9DVVNUT01fT0JKRUNUUyA9IHsuLi5iYWNrdXBDdXN0b21PYmplY3RzfTtcbiAgICAgIHJldHVybiByZXR1cm5PYmo7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ29tcGFyZXMgdHdvIG51bWJlcnMgZm9yIHNvcnRpbmcuXG4gKiBAcGFyYW0gYVxuICogQHBhcmFtIGJcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG51bWJlckNvbXBhcmUoYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgcmV0dXJuIChhIDwgYikgPyAtMSA6ICgoYSA+IGIpID8gMSA6IDApO1xufVxuXG4vKipcbiAqIENvbXBhcmlzb24gb2YgdHdvIG51bWJlcnMgZm9yIHJldmVyc2Ugc29ydGluZy5cbiAqIEBwYXJhbSBhXG4gKiBAcGFyYW0gYlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmV2ZXJzZU51bWJlckNvbXBhcmUoYTogbnVtYmVyLCBiOiBudW1iZXIpIHtcbiAgcmV0dXJuIC0xICogbnVtYmVyQ29tcGFyZShhLCBiKTtcbn1cblxuLyoqXG4gKiBDb252ZXJ0IGEgc3RyaW5nIGludG8gdGhlIGNvcnJlc3BvbmRpbmcgRFR5cGUuXG4gKiBAcGFyYW0gZHR5cGVcbiAqIEByZXR1cm5zIEFuIGluc3RhbmNlIG9mIERUeXBlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RyaW5nVG9EVHlwZShkdHlwZTogc3RyaW5nKTogRGF0YVR5cGUge1xuICBzd2l0Y2ggKGR0eXBlKSB7XG4gICAgY2FzZSAnZmxvYXQzMic6XG4gICAgICByZXR1cm4gJ2Zsb2F0MzInO1xuICAgIGRlZmF1bHQ6XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgSW52YWxpZCBkdHlwZTogJHtkdHlwZX1gKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlc3QgdGhlIGVsZW1lbnQtYnktZWxlbWVudCBlcXVhbGl0eSBvZiB0d28gQXJyYXlzIG9mIHN0cmluZ3MuXG4gKiBAcGFyYW0geHMgRmlyc3QgYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEBwYXJhbSB5cyBTZWNvbmQgYXJyYXkgb2Ygc3RyaW5ncy5cbiAqIEByZXR1cm5zIFdldGhlciB0aGUgdHdvIGFycmF5cyBhcmUgYWxsIGVxdWFsLCBlbGVtZW50IGJ5IGVsZW1lbnQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdHJpbmdzRXF1YWwoeHM6IHN0cmluZ1tdLCB5czogc3RyaW5nW10pOiBib29sZWFuIHtcbiAgaWYgKHhzID09IG51bGwgfHwgeXMgPT0gbnVsbCkge1xuICAgIHJldHVybiB4cyA9PT0geXM7XG4gIH1cbiAgaWYgKHhzLmxlbmd0aCAhPT0geXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgeHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoeHNbaV0gIT09IHlzW2ldKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiAqIEdldCB0aGUgdW5pcXVlIGVsZW1lbnRzIG9mIGFuIGFycmF5LlxuICogQHBhcmFtIHhzIEFycmF5LlxuICogQHJldHVybnMgQW4gQXJyYXkgY29uc2lzdGluZyBvZiB0aGUgdW5pcXVlIGVsZW1lbnRzIGluIGB4c2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1bmlxdWU8VD4oeHM6IFRbXSk6IFRbXSB7XG4gIGlmICh4cyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIHhzO1xuICB9XG4gIGNvbnN0IG91dDogVFtdID0gW107XG4gIC8vIFRPRE8oY2Fpcyk6IE1heWJlIGltcHJvdmUgcGVyZm9ybWFuY2UgYnkgc29ydGluZy5cbiAgZm9yIChjb25zdCB4IG9mIHhzKSB7XG4gICAgaWYgKG91dC5pbmRleE9mKHgpID09PSAtMSkge1xuICAgICAgb3V0LnB1c2goeCk7XG4gICAgfVxuICB9XG4gIHJldHVybiBvdXQ7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGFuIE9iamVjdCBpcyBlbXB0eSAoaS5lLiwgZG9lcyBub3QgaGF2ZSBvd24gcHJvcGVydGllcykuXG4gKiBAcGFyYW0gb2JqIE9iamVjdFxuICogQHJldHVybnMgV2hldGhlciB0aGUgT2JqZWN0IGlzIGVtcHR5LlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBJZiBvYmplY3QgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNPYmplY3RFbXB0eShvYmo6IHt9KTogYm9vbGVhbiB7XG4gIGlmIChvYmogPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBJbnZhbGlkIHZhbHVlIGluIG9iajogJHtKU09OLnN0cmluZ2lmeShvYmopfWApO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIG9iaikge1xuICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCB0byBidWlsZCB0eXBlIHVuaW9uL2VudW0gcnVuLXRpbWUgY2hlY2tlcnMuXG4gKiBAcGFyYW0gdmFsdWVzIFRoZSBsaXN0IG9mIGFsbG93ZWQgdmFsdWVzLlxuICogQHBhcmFtIGxhYmVsIEEgc3RyaW5nIG5hbWUgZm9yIHRoZSB0eXBlXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIHRlc3QuXG4gKiBAdGhyb3dzIFZhbHVlRXJyb3I6IElmIHRoZSB2YWx1ZSBpcyBub3QgaW4gdmFsdWVzIG5vciBgdW5kZWZpbmVkYC9gbnVsbGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFxuICAgIHZhbHVlczogc3RyaW5nW10sIGxhYmVsOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcpOiB2b2lkIHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKHZhbHVlcy5pbmRleE9mKHZhbHVlKSA8IDApIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgJHt2YWx1ZX0gaXMgbm90IGEgdmFsaWQgJHtsYWJlbH0uICBWYWxpZCB2YWx1ZXMgYXJlICR7XG4gICAgICAgIHZhbHVlc30gb3IgbnVsbC91bmRlZmluZWQuYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHZlcmlmeWluZyB0aGUgdHlwZXMgb2YgaW5wdXRzLlxuICpcbiAqIEVuc3VyZXMgdGhhdCB0aGUgZWxlbWVudHMgb2YgYHhgIGFyZSBhbGwgb2YgdHlwZSBgZXhwZWN0ZWRUeXBlYC5cbiAqIEFsc28gdmVyaWZpZXMgdGhhdCB0aGUgbGVuZ3RoIG9mIGB4YCBpcyB3aXRoaW4gYm91bmRzLlxuICpcbiAqIEBwYXJhbSB4IE9iamVjdCB0byB0ZXN0LlxuICogQHBhcmFtIGV4cGVjdGVkVHlwZSBUaGUgc3RyaW5nIGV4cGVjdGVkIHR5cGUgb2YgYWxsIG9mIHRoZSBlbGVtZW50cyBpbiB0aGVcbiAqIEFycmF5LlxuICogQHBhcmFtIG1pbkxlbmd0aCBSZXR1cm4gZmFsc2UgaWYgeC5sZW5ndGggaXMgbGVzcyB0aGFuIHRoaXMuXG4gKiBAcGFyYW0gbWF4TGVuZ3RoIFJldHVybiBmYWxzZSBpZiB4Lmxlbmd0aCBpcyBncmVhdGVyIHRoYW4gdGhpcy5cbiAqIEByZXR1cm5zIHRydWUgaWYgYW5kIG9ubHkgaWYgYHhgIGlzIGFuIGBBcnJheTxleHBlY3RlZFR5cGU+YCB3aXRoXG4gKiBsZW5ndGggPj0gYG1pbkxlbmd0aGAgYW5kIDw9IGBtYXhMZW5ndGhgLlxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZTpuby1hbnlcbmV4cG9ydCBmdW5jdGlvbiBjaGVja0FycmF5VHlwZUFuZExlbmd0aChcbiAgICB4OiBhbnksIGV4cGVjdGVkVHlwZTogc3RyaW5nLCBtaW5MZW5ndGggPSAwLFxuICAgIG1heExlbmd0aCA9IEluZmluaXR5KTogYm9vbGVhbiB7XG4gIGFzc2VydChtaW5MZW5ndGggPj0gMCk7XG4gIGFzc2VydChtYXhMZW5ndGggPj0gbWluTGVuZ3RoKTtcbiAgcmV0dXJuIChcbiAgICAgIEFycmF5LmlzQXJyYXkoeCkgJiYgeC5sZW5ndGggPj0gbWluTGVuZ3RoICYmIHgubGVuZ3RoIDw9IG1heExlbmd0aCAmJlxuICAgICAgeC5ldmVyeShlID0+IHR5cGVvZiBlID09PSBleHBlY3RlZFR5cGUpKTtcbn1cbi8vIHRzbGludDplbmFibGU6bm8tYW55XG5cbi8qKlxuICogQXNzZXJ0IHRoYXQgYSB2YWx1ZSBvciBhbiBhcnJheSBvZiB2YWx1ZSBhcmUgcG9zaXRpdmUgaW50ZWdlci5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIGJlaW5nIGFzc2VydGVkIG9uLiBNYXkgYmUgYSBzaW5nbGUgbnVtYmVyIG9yIGFuIGFycmF5XG4gKiAgIG9mIG51bWJlcnMuXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB2YWx1ZSwgdXNlZCB0byBtYWtlIHRoZSBlcnJvciBtZXNzYWdlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKHZhbHVlOiBudW1iZXJ8bnVtYmVyW10sIG5hbWU6IHN0cmluZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgdmFsdWUubGVuZ3RoID4gMCwgKCkgPT4gYCR7bmFtZX0gaXMgdW5leHBlY3RlZGx5IGFuIGVtcHR5IGFycmF5LmApO1xuICAgIHZhbHVlLmZvckVhY2goXG4gICAgICAgICh2LCBpKSA9PiBhc3NlcnRQb3NpdGl2ZUludGVnZXIodiwgYGVsZW1lbnQgJHtpICsgMX0gb2YgJHtuYW1lfWApKTtcbiAgfSBlbHNlIHtcbiAgICB1dGlsLmFzc2VydChcbiAgICAgICAgTnVtYmVyLmlzSW50ZWdlcih2YWx1ZSkgJiYgdmFsdWUgPiAwLFxuICAgICAgICAoKSA9PiBgRXhwZWN0ZWQgJHtuYW1lfSB0byBiZSBhIHBvc2l0aXZlIGludGVnZXIsIGJ1dCBnb3QgYCArXG4gICAgICAgICAgICBgJHtmb3JtYXRBc0ZyaWVuZGx5U3RyaW5nKHZhbHVlKX0uYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBGb3JtYXQgYSB2YWx1ZSBpbnRvIGEgZGlzcGxheS1mcmllbmRseSwgaHVtYW4tcmVhZGFibGUgZmFzaGlvbi5cbiAqXG4gKiAtIGBudWxsYCBpcyBmb3JtYXR0ZWQgYXMgYCdudWxsJ2BcbiAqIC0gU3RyaW5ncyBhcmUgZm9ybWF0ZWQgd2l0aCBmbGFua2luZyBwYWlyIG9mIHF1b3Rlcy5cbiAqIC0gQXJyYXlzIGFyZSBmb3JtYXR0ZWQgd2l0aCBmbGFua2luZyBwYWlyIG9mIHNxdWFyZSBicmFja2V0cy5cbiAqXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIHRvIGRpc3BsYXkuXG4gKiBAcmV0dXJuIEZvcm1hdHRlZCBzdHJpbmcuXG4gKi9cbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRBc0ZyaWVuZGx5U3RyaW5nKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICBpZiAodmFsdWUgPT09IG51bGwpIHtcbiAgICByZXR1cm4gJ251bGwnO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuICdbJyArIHZhbHVlLm1hcCh2ID0+IGZvcm1hdEFzRnJpZW5kbHlTdHJpbmcodikpLmpvaW4oJywnKSArICddJztcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIGBcIiR7dmFsdWV9XCJgO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBgJHt2YWx1ZX1gO1xuICB9XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIGBmMmAgKGRlY29yYXRvcikgd2hpY2ggd3JhcHMgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uXG4gKiBgZmAuIGBmMmAgZ3VhcmFudGVlcyB0aGF0IGBmYCBjYW4gYmUgY2FsbGVkIGF0IG1vc3Qgb25jZVxuICogZXZlcnkgYHdhaXRNc2AgbXMuIElmIGBmMmAgaXMgY2FsbGVkIG1vcmUgb2Z0ZW4sIGl0IHdpbGwgcmV0dXJuXG4gKiB0aGUgbGFzdCByZXR1cm5lZCByZXN1bHQgb2YgYGZgLlxuICpcbiAqIEBwYXJhbSBmIFRoZSBvcmlnaW5hbCBmdW5jdGlvbiBgZmAgdG8gd3JhcC5cbiAqIEBwYXJhbSB3YWl0TXMgVGhlIHRpbWUgYmV0d2VlbiB0d28gY29uc2VjdXRpdmUgY2FsbHMgdG8gYGZgIGluIG1zLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVib3VuY2U8VD4oXG4gICAgZjogKC4uLmFyZ3M6IEFycmF5PHt9PikgPT4gVCwgd2FpdE1zOiBudW1iZXIsXG4gICAgbm93RnVuYz86IEZ1bmN0aW9uKTogKC4uLmFyZ3M6IEFycmF5PHt9PikgPT4gVCB7XG4gIGxldCBsYXN0VGltZSA9IG5vd0Z1bmMgIT0gbnVsbCA/IG5vd0Z1bmMoKSA6IHV0aWwubm93KCk7XG4gIGxldCBsYXN0UmVzdWx0OiBUO1xuICBjb25zdCBmMiA9ICguLi5hcmdzOiBBcnJheTx7fT4pID0+IHtcbiAgICBjb25zdCBub3cgPSBub3dGdW5jICE9IG51bGwgPyBub3dGdW5jKCkgOiB1dGlsLm5vdygpO1xuICAgIGlmIChub3cgLSBsYXN0VGltZSA8IHdhaXRNcykge1xuICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XG4gICAgfVxuICAgIGxhc3RUaW1lID0gbm93O1xuICAgIGxhc3RSZXN1bHQgPSBmKC4uLmFyZ3MpO1xuICAgIHJldHVybiBsYXN0UmVzdWx0O1xuICB9O1xuICByZXR1cm4gZjI7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZnVzYWJsZSBhY3RpdmF0aW9uIGdpdmVuIGEgbGF5ZXJzIGlkZW50aWZpZXIuXG4gKlxuICogQHBhcmFtIGFjdGl2YXRpb25OYW1lIFRoZSBsYXllcnMgaWRlbnRpZmllciBzdHJpbmcuXG4gKiBAcmV0dXJuIFRoZSBuYW1lIG9mIHRoZSBmdXNhYmxlIGFjdGl2YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtYXBBY3RpdmF0aW9uVG9GdXNlZEtlcm5lbChhY3RpdmF0aW9uTmFtZTogc3RyaW5nKTpcbiAgICBmdXNlZC5BY3RpdmF0aW9uIHtcbiAgaWYgKGFjdGl2YXRpb25OYW1lID09PSAncmVsdScpIHtcbiAgICByZXR1cm4gJ3JlbHUnO1xuICB9XG4gIGlmIChhY3RpdmF0aW9uTmFtZSA9PT0gJ2xpbmVhcicpIHtcbiAgICByZXR1cm4gJ2xpbmVhcic7XG4gIH1cbiAgaWYgKGFjdGl2YXRpb25OYW1lID09PSAnZWx1Jykge1xuICAgIHJldHVybiAnZWx1JztcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxudHlwZSBQb3NzaWJsZVZhbHVlcyA9IEFycmF5PEFycmF5PGJvb2xlYW58c3RyaW5nfG51bWJlcj4+O1xuXG4vKipcbiAqIFJldHVybnMgdGhlIGNhcnRlc2lhbiBwcm9kdWN0IG9mIHNldHMgb2YgdmFsdWVzLlxuICogVGhpcyB3b3JrcyB0aGUgc2FtZSBhcyBpdGVydG9vbHMucHJvZHVjdCBpbiBQeXRob24uXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBmaWx0ZXJzID0gWzEyOCwgMjU2LCA1MTJdXG4gKiBwYWRkaW5ncyA9IFsnc2FtZScsICd2YWxpZCddXG4gKlxuICogcHJvZHVjdCA9IFsgWzEyOCwgJ3NhbWUnXSwgWzEyOCwgJ3ZhbGlkJ10sIFsyNTYsICdzYW1lJ10sIFsyNTYsICd2YWxpZCddLFxuICogWzUxMiwgJ3NhbWUnXSwgWzUxMiwgJ3ZhbGlkJ11dXG4gKlxuICogQHBhcmFtIGFycmF5T2ZWYWx1ZXMgTGlzdC9hcnJheSBvZiB2YWx1ZXMuXG4gKiBAcmV0dXJuIFRoZSBjYXJ0ZXNpYW4gcHJvZHVjdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldENhcnRlc2lhblByb2R1Y3RPZlZhbHVlcyguLi5hcnJheU9mVmFsdWVzOiBQb3NzaWJsZVZhbHVlcyk6XG4gICAgUG9zc2libGVWYWx1ZXMge1xuICBhc3NlcnQoYXJyYXlPZlZhbHVlcy5sZW5ndGggPiAwLCAnYXJyYXlPZlZhbHVlcyBpcyBlbXB0eScpO1xuXG4gIGZvciAoY29uc3QgdmFsdWVzIG9mIGFycmF5T2ZWYWx1ZXMpIHtcbiAgICBhc3NlcnQoQXJyYXkuaXNBcnJheSh2YWx1ZXMpLCAnb25lIG9mIHRoZSB2YWx1ZXMgaXMgbm90IGFuIGFycmF5Jyk7XG4gICAgYXNzZXJ0KHZhbHVlcy5sZW5ndGggPiAwLCAnb25lIG9mIHRoZSB2YWx1ZXMgaXMgZW1wdHknKTtcbiAgfVxuXG4gIHJldHVybiBhcnJheU9mVmFsdWVzLnJlZHVjZSgocHJvZHVjdHMsIHZhbHVlcykgPT4ge1xuICAgIGlmIChwcm9kdWN0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB2YWx1ZXMubWFwKHZhbHVlID0+IFt2YWx1ZV0pO1xuICAgIH1cblxuICAgIHJldHVybiB2YWx1ZXNcbiAgICAgICAgLm1hcCh2YWx1ZSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHByb2R1Y3RzLm1hcCgocHJldlZhbHVlKSA9PiBbLi4ucHJldlZhbHVlLCB2YWx1ZV0pO1xuICAgICAgICB9KVxuICAgICAgICAucmVkdWNlKChmbGF0dGVuZWRQcm9kdWN0LCB1bmZsYXR0ZW5lZFByb2R1Y3QpID0+IHtcbiAgICAgICAgICByZXR1cm4gZmxhdHRlbmVkUHJvZHVjdC5jb25jYXQodW5mbGF0dGVuZWRQcm9kdWN0KTtcbiAgICAgICAgfSwgW10pO1xuICB9LCBbXSBhcyBQb3NzaWJsZVZhbHVlcyk7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Utilities related to persistent state in the backend.\n */\n/**\n * An ID to track `tf.SymbolicTensor`s and derived classes.\n * Required in different places in engine/topology.ts to identify unique\n * tensors.\n */\nlet _nextUniqueTensorId = 0;\nexport function getNextUniqueTensorId() {\n    return _nextUniqueTensorId++;\n}\nconst _uidPrefixes = {};\n/**\n * Provides a unique UID given a string prefix.\n *\n * @param prefix\n */\nexport function getUid(prefix = '') {\n    if (!(prefix in _uidPrefixes)) {\n        _uidPrefixes[prefix] = 0;\n    }\n    _uidPrefixes[prefix] += 1;\n    return prefix + _uidPrefixes[prefix].toString();\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhdGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvYmFja2VuZC9zdGF0ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUg7Ozs7R0FJRztBQUNILElBQUksbUJBQW1CLEdBQUcsQ0FBQyxDQUFDO0FBRTVCLE1BQU0sVUFBVSxxQkFBcUI7SUFDbkMsT0FBTyxtQkFBbUIsRUFBRSxDQUFDO0FBQy9CLENBQUM7QUFFRCxNQUFNLFlBQVksR0FBK0IsRUFBRSxDQUFDO0FBRXBEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsTUFBTSxDQUFDLE1BQU0sR0FBRyxFQUFFO0lBQ2hDLElBQUksQ0FBQyxDQUFDLE1BQU0sSUFBSSxZQUFZLENBQUMsRUFBRTtRQUM3QixZQUFZLENBQUMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0tBQzFCO0lBQ0QsWUFBWSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixPQUFPLE1BQU0sR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDbEQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogVXRpbGl0aWVzIHJlbGF0ZWQgdG8gcGVyc2lzdGVudCBzdGF0ZSBpbiB0aGUgYmFja2VuZC5cbiAqL1xuXG4vKipcbiAqIEFuIElEIHRvIHRyYWNrIGB0Zi5TeW1ib2xpY1RlbnNvcmBzIGFuZCBkZXJpdmVkIGNsYXNzZXMuXG4gKiBSZXF1aXJlZCBpbiBkaWZmZXJlbnQgcGxhY2VzIGluIGVuZ2luZS90b3BvbG9neS50cyB0byBpZGVudGlmeSB1bmlxdWVcbiAqIHRlbnNvcnMuXG4gKi9cbmxldCBfbmV4dFVuaXF1ZVRlbnNvcklkID0gMDtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE5leHRVbmlxdWVUZW5zb3JJZCgpOiBudW1iZXIge1xuICByZXR1cm4gX25leHRVbmlxdWVUZW5zb3JJZCsrO1xufVxuXG5jb25zdCBfdWlkUHJlZml4ZXM6IHtbcHJlZml4OiBzdHJpbmddOiBudW1iZXJ9ID0ge307XG5cbi8qKlxuICogUHJvdmlkZXMgYSB1bmlxdWUgVUlEIGdpdmVuIGEgc3RyaW5nIHByZWZpeC5cbiAqXG4gKiBAcGFyYW0gcHJlZml4XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRVaWQocHJlZml4ID0gJycpOiBzdHJpbmcge1xuICBpZiAoIShwcmVmaXggaW4gX3VpZFByZWZpeGVzKSkge1xuICAgIF91aWRQcmVmaXhlc1twcmVmaXhdID0gMDtcbiAgfVxuICBfdWlkUHJlZml4ZXNbcHJlZml4XSArPSAxO1xuICByZXR1cm4gcHJlZml4ICsgX3VpZFByZWZpeGVzW3ByZWZpeF0udG9TdHJpbmcoKTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nexport const VALID_DATA_FORMAT_VALUES = ['channelsFirst', 'channelsLast'];\nexport const VALID_INTERPOLATION_FORMAT_VALUES = ['nearest', 'bilinear'];\nexport const VALID_PADDING_MODE_VALUES = ['valid', 'same', 'causal'];\nexport const VALID_POOL_MODE_VALUES = ['max', 'avg'];\nexport const VALID_BIDIRECTIONAL_MERGE_MODES = ['sum', 'mul', 'concat', 'ave'];\nexport const VALID_SAMPLE_WEIGHT_MODES = ['temporal'];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2tlcmFzX2Zvcm1hdC9jb21tb24udHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFhSCxNQUFNLENBQUMsTUFBTSx3QkFBd0IsR0FBRyxDQUFDLGVBQWUsRUFBRSxjQUFjLENBQUMsQ0FBQztBQUcxRSxNQUFNLENBQUMsTUFBTSxpQ0FBaUMsR0FBRyxDQUFDLFNBQVMsRUFBRSxVQUFVLENBQUMsQ0FBQztBQU16RSxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLE9BQU8sRUFBRSxNQUFNLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFJckUsTUFBTSxDQUFDLE1BQU0sc0JBQXNCLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFJckQsTUFBTSxDQUFDLE1BQU0sK0JBQStCLEdBQUcsQ0FBQyxLQUFLLEVBQUUsS0FBSyxFQUFFLFFBQVEsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUkvRSxNQUFNLENBQUMsTUFBTSx5QkFBeUIsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLy8gVE9ETyhodWFuKTogYWRkIGxheWVyLXNwZWNpZmljIGlucHV0IHNoYXBlIHR5cGVzIChzZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMtbGF5ZXJzL3B1bGwvNDkyKVxuLyoqIEBkb2NhbGlhcyAobnVsbCB8IG51bWJlcilbXSAqL1xuZXhwb3J0IHR5cGUgU2hhcGUgPSBBcnJheTxudWxsIHwgbnVtYmVyPjtcblxuLy8gVGhlIHRmanMtY29yZSB2ZXJzaW9uIG9mIERhdGFUeXBlIG11c3Qgc3RheSBzeW5jZWQgd2l0aCB0aGlzLlxuZXhwb3J0IHR5cGUgRGF0YVR5cGUgPSAnZmxvYXQzMid8J2ludDMyJ3wnYm9vbCd8J2NvbXBsZXg2NCd8J3N0cmluZyc7XG5cbi8vIFRPRE8oc29lcmdlbCk6IE1vdmUgdGhlIENhbWVsQ2FzZSB2ZXJzaW9ucyBiYWNrIG91dCBvZiBrZXJhc19mb3JtYXRcbi8vIGUuZy4gdG8gc3JjL2NvbW1vbi50cy4gIE1heWJlIGV2ZW4gZHVwbGljYXRlICphbGwqIG9mIHRoZXNlIHRvIGJlIHBlZGFudGljP1xuLyoqIEBkb2NpbmxpbmUgKi9cbmV4cG9ydCB0eXBlIERhdGFGb3JtYXQgPSAnY2hhbm5lbHNGaXJzdCd8J2NoYW5uZWxzTGFzdCc7XG5leHBvcnQgY29uc3QgVkFMSURfREFUQV9GT1JNQVRfVkFMVUVTID0gWydjaGFubmVsc0ZpcnN0JywgJ2NoYW5uZWxzTGFzdCddO1xuXG5leHBvcnQgdHlwZSBJbnRlcnBvbGF0aW9uRm9ybWF0ID0gJ25lYXJlc3QnfCdiaWxpbmVhcic7XG5leHBvcnQgY29uc3QgVkFMSURfSU5URVJQT0xBVElPTl9GT1JNQVRfVkFMVUVTID0gWyduZWFyZXN0JywgJ2JpbGluZWFyJ107XG4vLyBUaGVzZSBjb25zdGFudHMgaGF2ZSBhIHNuYWtlIHZzLiBjYW1lbCBkaXN0aW5jdGlvbi5cbmV4cG9ydCB0eXBlIERhdGFGb3JtYXRTZXJpYWxpemF0aW9uID0gJ2NoYW5uZWxzX2ZpcnN0J3wnY2hhbm5lbHNfbGFzdCc7XG5cbi8qKiBAZG9jaW5saW5lICovXG5leHBvcnQgdHlwZSBQYWRkaW5nTW9kZSA9ICd2YWxpZCd8J3NhbWUnfCdjYXVzYWwnO1xuZXhwb3J0IGNvbnN0IFZBTElEX1BBRERJTkdfTU9ERV9WQUxVRVMgPSBbJ3ZhbGlkJywgJ3NhbWUnLCAnY2F1c2FsJ107XG5cbi8qKiBAZG9jaW5saW5lICovXG5leHBvcnQgdHlwZSBQb29sTW9kZSA9ICdtYXgnfCdhdmcnO1xuZXhwb3J0IGNvbnN0IFZBTElEX1BPT0xfTU9ERV9WQUxVRVMgPSBbJ21heCcsICdhdmcnXTtcblxuLyoqIEBkb2NpbmxpbmUgKi9cbmV4cG9ydCB0eXBlIEJpZGlyZWN0aW9uYWxNZXJnZU1vZGUgPSAnc3VtJ3wnbXVsJ3wnY29uY2F0J3wnYXZlJztcbmV4cG9ydCBjb25zdCBWQUxJRF9CSURJUkVDVElPTkFMX01FUkdFX01PREVTID0gWydzdW0nLCAnbXVsJywgJ2NvbmNhdCcsICdhdmUnXTtcblxuLyoqIEBkb2NpbmxpbmUgKi9cbmV4cG9ydCB0eXBlIFNhbXBsZVdlaWdodE1vZGUgPSAndGVtcG9yYWwnO1xuZXhwb3J0IGNvbnN0IFZBTElEX1NBTVBMRV9XRUlHSFRfTU9ERVMgPSBbJ3RlbXBvcmFsJ107XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Common functions for TensorFlow.js Layers.\n */\nimport { VALID_DATA_FORMAT_VALUES, VALID_INTERPOLATION_FORMAT_VALUES, VALID_PADDING_MODE_VALUES, VALID_POOL_MODE_VALUES } from './keras_format/common';\nimport { checkStringTypeUnionValue } from './utils/generic_utils';\n// A map from the requested scoped name of a Tensor to the number of Tensors\n// wanting that name so far.  This allows enforcing name uniqueness by appending\n// an incrementing index, e.g. scope/name, scope/name_1, scope/name_2, etc.\nconst nameMap = new Map();\nexport function checkDataFormat(value) {\n    checkStringTypeUnionValue(VALID_DATA_FORMAT_VALUES, 'DataFormat', value);\n}\nexport function checkInterpolationFormat(value) {\n    checkStringTypeUnionValue(VALID_INTERPOLATION_FORMAT_VALUES, 'InterpolationFormat', value);\n}\nexport function checkPaddingMode(value) {\n    checkStringTypeUnionValue(VALID_PADDING_MODE_VALUES, 'PaddingMode', value);\n}\nexport function checkPoolMode(value) {\n    checkStringTypeUnionValue(VALID_POOL_MODE_VALUES, 'PoolMode', value);\n}\nconst _nameScopeStack = [];\nconst _nameScopeDivider = '/';\n/**\n * Enter namescope, which can be nested.\n */\nexport function nameScope(name, fn) {\n    _nameScopeStack.push(name);\n    try {\n        const val = fn();\n        _nameScopeStack.pop();\n        return val;\n    }\n    catch (e) {\n        _nameScopeStack.pop();\n        throw e;\n    }\n}\n/**\n * Get the current namescope as a flat, concatenated string.\n */\nfunction currentNameScopePrefix() {\n    if (_nameScopeStack.length === 0) {\n        return '';\n    }\n    else {\n        return _nameScopeStack.join(_nameScopeDivider) + _nameScopeDivider;\n    }\n}\n/**\n * Get the name a Tensor (or Variable) would have if not uniqueified.\n * @param tensorName\n * @return Scoped name string.\n */\nexport function getScopedTensorName(tensorName) {\n    if (!isValidTensorName(tensorName)) {\n        throw new Error('Not a valid tensor name: \\'' + tensorName + '\\'');\n    }\n    return currentNameScopePrefix() + tensorName;\n}\n/**\n * Get unique names for Tensors and Variables.\n * @param scopedName The fully-qualified name of the Tensor, i.e. as produced by\n *  `getScopedTensorName()`.\n * @return A unique version of the given fully scoped name.\n *   If this is the first time that the scoped name is seen in this session,\n *   then the given `scopedName` is returned unaltered.  If the same name is\n *   seen again (producing a collision), an incrementing suffix is added to the\n *   end of the name, so it takes the form 'scope/name_1', 'scope/name_2', etc.\n */\nexport function getUniqueTensorName(scopedName) {\n    if (!isValidTensorName(scopedName)) {\n        throw new Error('Not a valid tensor name: \\'' + scopedName + '\\'');\n    }\n    if (!nameMap.has(scopedName)) {\n        nameMap.set(scopedName, 0);\n    }\n    const index = nameMap.get(scopedName);\n    nameMap.set(scopedName, nameMap.get(scopedName) + 1);\n    if (index > 0) {\n        const result = `${scopedName}_${index}`;\n        // Mark the composed name as used in case someone wants\n        // to call getUniqueTensorName(\"name_1\").\n        nameMap.set(result, 1);\n        return result;\n    }\n    else {\n        return scopedName;\n    }\n}\nconst tensorNameRegex = new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\\._\\/]*$/);\n/**\n * Determine whether a string is a valid tensor name.\n * @param name\n * @returns A Boolean indicating whether `name` is a valid tensor name.\n */\nexport function isValidTensorName(name) {\n    return !!name.match(tensorNameRegex);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2NvbW1vbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBQ0gsT0FBTyxFQUFDLHdCQUF3QixFQUFFLGlDQUFpQyxFQUFFLHlCQUF5QixFQUFFLHNCQUFzQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDckosT0FBTyxFQUFDLHlCQUF5QixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFaEUsNEVBQTRFO0FBQzVFLGdGQUFnRjtBQUNoRiwyRUFBMkU7QUFDM0UsTUFBTSxPQUFPLEdBQXdCLElBQUksR0FBRyxFQUFrQixDQUFDO0FBRS9ELE1BQU0sVUFBVSxlQUFlLENBQUMsS0FBYztJQUM1Qyx5QkFBeUIsQ0FBQyx3QkFBd0IsRUFBRSxZQUFZLEVBQUUsS0FBSyxDQUFDLENBQUM7QUFDM0UsQ0FBQztBQUVELE1BQU0sVUFBVSx3QkFBd0IsQ0FBQyxLQUFjO0lBQ3JELHlCQUF5QixDQUNyQixpQ0FBaUMsRUFBRSxxQkFBcUIsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUN2RSxDQUFDO0FBRUQsTUFBTSxVQUFVLGdCQUFnQixDQUFDLEtBQWM7SUFDN0MseUJBQXlCLENBQUMseUJBQXlCLEVBQUUsYUFBYSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzdFLENBQUM7QUFFRCxNQUFNLFVBQVUsYUFBYSxDQUFDLEtBQWM7SUFDMUMseUJBQXlCLENBQUMsc0JBQXNCLEVBQUUsVUFBVSxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQ3ZFLENBQUM7QUFFRCxNQUFNLGVBQWUsR0FBYSxFQUFFLENBQUM7QUFDckMsTUFBTSxpQkFBaUIsR0FBRyxHQUFHLENBQUM7QUFFOUI7O0dBRUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUFJLElBQVksRUFBRSxFQUFXO0lBQ3BELGVBQWUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDM0IsSUFBSTtRQUNGLE1BQU0sR0FBRyxHQUFNLEVBQUUsRUFBRSxDQUFDO1FBQ3BCLGVBQWUsQ0FBQyxHQUFHLEVBQUUsQ0FBQztRQUN0QixPQUFPLEdBQUcsQ0FBQztLQUNaO0lBQUMsT0FBTyxDQUFDLEVBQUU7UUFDVixlQUFlLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDdEIsTUFBTSxDQUFDLENBQUM7S0FDVDtBQUNILENBQUM7QUFFRDs7R0FFRztBQUNILFNBQVMsc0JBQXNCO0lBQzdCLElBQUksZUFBZSxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDaEMsT0FBTyxFQUFFLENBQUM7S0FDWDtTQUFNO1FBQ0wsT0FBTyxlQUFlLENBQUMsSUFBSSxDQUFDLGlCQUFpQixDQUFDLEdBQUcsaUJBQWlCLENBQUM7S0FDcEU7QUFDSCxDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxVQUFrQjtJQUNwRCxJQUFJLENBQUMsaUJBQWlCLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDbEMsTUFBTSxJQUFJLEtBQUssQ0FBQyw2QkFBNkIsR0FBRyxVQUFVLEdBQUcsSUFBSSxDQUFDLENBQUM7S0FDcEU7SUFDRCxPQUFPLHNCQUFzQixFQUFFLEdBQUcsVUFBVSxDQUFDO0FBQy9DLENBQUM7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsVUFBa0I7SUFDcEQsSUFBSSxDQUFDLGlCQUFpQixDQUFDLFVBQVUsQ0FBQyxFQUFFO1FBQ2xDLE1BQU0sSUFBSSxLQUFLLENBQUMsNkJBQTZCLEdBQUcsVUFBVSxHQUFHLElBQUksQ0FBQyxDQUFDO0tBQ3BFO0lBQ0QsSUFBSSxDQUFDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEVBQUU7UUFDNUIsT0FBTyxDQUFDLEdBQUcsQ0FBQyxVQUFVLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDNUI7SUFDRCxNQUFNLEtBQUssR0FBRyxPQUFPLENBQUMsR0FBRyxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3RDLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxFQUFFLE9BQU8sQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFFckQsSUFBSSxLQUFLLEdBQUcsQ0FBQyxFQUFFO1FBQ2IsTUFBTSxNQUFNLEdBQUcsR0FBRyxVQUFVLElBQUksS0FBSyxFQUFFLENBQUM7UUFDeEMsdURBQXVEO1FBQ3ZELHlDQUF5QztRQUN6QyxPQUFPLENBQUMsR0FBRyxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUMsQ0FBQztRQUN2QixPQUFPLE1BQU0sQ0FBQztLQUNmO1NBQU07UUFDTCxPQUFPLFVBQVUsQ0FBQztLQUNuQjtBQUNILENBQUM7QUFFRCxNQUFNLGVBQWUsR0FBRyxJQUFJLE1BQU0sQ0FBQyxpQ0FBaUMsQ0FBQyxDQUFDO0FBRXRFOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsaUJBQWlCLENBQUMsSUFBWTtJQUM1QyxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLGVBQWUsQ0FBQyxDQUFDO0FBQ3ZDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIENvbW1vbiBmdW5jdGlvbnMgZm9yIFRlbnNvckZsb3cuanMgTGF5ZXJzLlxuICovXG5pbXBvcnQge1ZBTElEX0RBVEFfRk9STUFUX1ZBTFVFUywgVkFMSURfSU5URVJQT0xBVElPTl9GT1JNQVRfVkFMVUVTLCBWQUxJRF9QQURESU5HX01PREVfVkFMVUVTLCBWQUxJRF9QT09MX01PREVfVkFMVUVTfSBmcm9tICcuL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuaW1wb3J0IHtjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlfSBmcm9tICcuL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuXG4vLyBBIG1hcCBmcm9tIHRoZSByZXF1ZXN0ZWQgc2NvcGVkIG5hbWUgb2YgYSBUZW5zb3IgdG8gdGhlIG51bWJlciBvZiBUZW5zb3JzXG4vLyB3YW50aW5nIHRoYXQgbmFtZSBzbyBmYXIuICBUaGlzIGFsbG93cyBlbmZvcmNpbmcgbmFtZSB1bmlxdWVuZXNzIGJ5IGFwcGVuZGluZ1xuLy8gYW4gaW5jcmVtZW50aW5nIGluZGV4LCBlLmcuIHNjb3BlL25hbWUsIHNjb3BlL25hbWVfMSwgc2NvcGUvbmFtZV8yLCBldGMuXG5jb25zdCBuYW1lTWFwOiBNYXA8c3RyaW5nLCBudW1iZXI+ID0gbmV3IE1hcDxzdHJpbmcsIG51bWJlcj4oKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRGF0YUZvcm1hdCh2YWx1ZT86IHN0cmluZyk6IHZvaWQge1xuICBjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0RBVEFfRk9STUFUX1ZBTFVFUywgJ0RhdGFGb3JtYXQnLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0ludGVycG9sYXRpb25Gb3JtYXQodmFsdWU/OiBzdHJpbmcpOiB2b2lkIHtcbiAgY2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZShcbiAgICAgIFZBTElEX0lOVEVSUE9MQVRJT05fRk9STUFUX1ZBTFVFUywgJ0ludGVycG9sYXRpb25Gb3JtYXQnLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1BhZGRpbmdNb2RlKHZhbHVlPzogc3RyaW5nKTogdm9pZCB7XG4gIGNoZWNrU3RyaW5nVHlwZVVuaW9uVmFsdWUoVkFMSURfUEFERElOR19NT0RFX1ZBTFVFUywgJ1BhZGRpbmdNb2RlJywgdmFsdWUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tQb29sTW9kZSh2YWx1ZT86IHN0cmluZyk6IHZvaWQge1xuICBjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX1BPT0xfTU9ERV9WQUxVRVMsICdQb29sTW9kZScsIHZhbHVlKTtcbn1cblxuY29uc3QgX25hbWVTY29wZVN0YWNrOiBzdHJpbmdbXSA9IFtdO1xuY29uc3QgX25hbWVTY29wZURpdmlkZXIgPSAnLyc7XG5cbi8qKlxuICogRW50ZXIgbmFtZXNjb3BlLCB3aGljaCBjYW4gYmUgbmVzdGVkLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbmFtZVNjb3BlPFQ+KG5hbWU6IHN0cmluZywgZm46ICgpID0+IFQpOiBUIHtcbiAgX25hbWVTY29wZVN0YWNrLnB1c2gobmFtZSk7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsOiBUID0gZm4oKTtcbiAgICBfbmFtZVNjb3BlU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHZhbDtcbiAgfSBjYXRjaCAoZSkge1xuICAgIF9uYW1lU2NvcGVTdGFjay5wb3AoKTtcbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBjdXJyZW50IG5hbWVzY29wZSBhcyBhIGZsYXQsIGNvbmNhdGVuYXRlZCBzdHJpbmcuXG4gKi9cbmZ1bmN0aW9uIGN1cnJlbnROYW1lU2NvcGVQcmVmaXgoKTogc3RyaW5nIHtcbiAgaWYgKF9uYW1lU2NvcGVTdGFjay5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gJyc7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIF9uYW1lU2NvcGVTdGFjay5qb2luKF9uYW1lU2NvcGVEaXZpZGVyKSArIF9uYW1lU2NvcGVEaXZpZGVyO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBuYW1lIGEgVGVuc29yIChvciBWYXJpYWJsZSkgd291bGQgaGF2ZSBpZiBub3QgdW5pcXVlaWZpZWQuXG4gKiBAcGFyYW0gdGVuc29yTmFtZVxuICogQHJldHVybiBTY29wZWQgbmFtZSBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRTY29wZWRUZW5zb3JOYW1lKHRlbnNvck5hbWU6IHN0cmluZyk6IHN0cmluZyB7XG4gIGlmICghaXNWYWxpZFRlbnNvck5hbWUodGVuc29yTmFtZSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBhIHZhbGlkIHRlbnNvciBuYW1lOiBcXCcnICsgdGVuc29yTmFtZSArICdcXCcnKTtcbiAgfVxuICByZXR1cm4gY3VycmVudE5hbWVTY29wZVByZWZpeCgpICsgdGVuc29yTmFtZTtcbn1cblxuLyoqXG4gKiBHZXQgdW5pcXVlIG5hbWVzIGZvciBUZW5zb3JzIGFuZCBWYXJpYWJsZXMuXG4gKiBAcGFyYW0gc2NvcGVkTmFtZSBUaGUgZnVsbHktcXVhbGlmaWVkIG5hbWUgb2YgdGhlIFRlbnNvciwgaS5lLiBhcyBwcm9kdWNlZCBieVxuICogIGBnZXRTY29wZWRUZW5zb3JOYW1lKClgLlxuICogQHJldHVybiBBIHVuaXF1ZSB2ZXJzaW9uIG9mIHRoZSBnaXZlbiBmdWxseSBzY29wZWQgbmFtZS5cbiAqICAgSWYgdGhpcyBpcyB0aGUgZmlyc3QgdGltZSB0aGF0IHRoZSBzY29wZWQgbmFtZSBpcyBzZWVuIGluIHRoaXMgc2Vzc2lvbixcbiAqICAgdGhlbiB0aGUgZ2l2ZW4gYHNjb3BlZE5hbWVgIGlzIHJldHVybmVkIHVuYWx0ZXJlZC4gIElmIHRoZSBzYW1lIG5hbWUgaXNcbiAqICAgc2VlbiBhZ2FpbiAocHJvZHVjaW5nIGEgY29sbGlzaW9uKSwgYW4gaW5jcmVtZW50aW5nIHN1ZmZpeCBpcyBhZGRlZCB0byB0aGVcbiAqICAgZW5kIG9mIHRoZSBuYW1lLCBzbyBpdCB0YWtlcyB0aGUgZm9ybSAnc2NvcGUvbmFtZV8xJywgJ3Njb3BlL25hbWVfMicsIGV0Yy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldFVuaXF1ZVRlbnNvck5hbWUoc2NvcGVkTmFtZTogc3RyaW5nKTogc3RyaW5nIHtcbiAgaWYgKCFpc1ZhbGlkVGVuc29yTmFtZShzY29wZWROYW1lKSkge1xuICAgIHRocm93IG5ldyBFcnJvcignTm90IGEgdmFsaWQgdGVuc29yIG5hbWU6IFxcJycgKyBzY29wZWROYW1lICsgJ1xcJycpO1xuICB9XG4gIGlmICghbmFtZU1hcC5oYXMoc2NvcGVkTmFtZSkpIHtcbiAgICBuYW1lTWFwLnNldChzY29wZWROYW1lLCAwKTtcbiAgfVxuICBjb25zdCBpbmRleCA9IG5hbWVNYXAuZ2V0KHNjb3BlZE5hbWUpO1xuICBuYW1lTWFwLnNldChzY29wZWROYW1lLCBuYW1lTWFwLmdldChzY29wZWROYW1lKSArIDEpO1xuXG4gIGlmIChpbmRleCA+IDApIHtcbiAgICBjb25zdCByZXN1bHQgPSBgJHtzY29wZWROYW1lfV8ke2luZGV4fWA7XG4gICAgLy8gTWFyayB0aGUgY29tcG9zZWQgbmFtZSBhcyB1c2VkIGluIGNhc2Ugc29tZW9uZSB3YW50c1xuICAgIC8vIHRvIGNhbGwgZ2V0VW5pcXVlVGVuc29yTmFtZShcIm5hbWVfMVwiKS5cbiAgICBuYW1lTWFwLnNldChyZXN1bHQsIDEpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNjb3BlZE5hbWU7XG4gIH1cbn1cblxuY29uc3QgdGVuc29yTmFtZVJlZ2V4ID0gbmV3IFJlZ0V4cCgvXltBLVphLXowLTldWy1BLVphLXowLTlcXC5fXFwvXSokLyk7XG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgYSBzdHJpbmcgaXMgYSB2YWxpZCB0ZW5zb3IgbmFtZS5cbiAqIEBwYXJhbSBuYW1lXG4gKiBAcmV0dXJucyBBIEJvb2xlYW4gaW5kaWNhdGluZyB3aGV0aGVyIGBuYW1lYCBpcyBhIHZhbGlkIHRlbnNvciBuYW1lLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZFRlbnNvck5hbWUobmFtZTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiAhIW5hbWUubWF0Y2godGVuc29yTmFtZVJlZ2V4KTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Math utility functions.\n *\n * This file contains some frequently used math function that operates on\n * number[] or Float32Array and return a number. Many of these functions are\n * not-so-thick wrappers around TF.js Core functions. But they offer the\n * convenience of\n * 1) not having to convert the inputs into Tensors,\n * 2) not having to convert the returned Tensors to numbers.\n */\nimport { ValueError } from '../errors';\n/**\n * Determine if a number is an integer.\n */\nexport function isInteger(x) {\n    return x === parseInt(x.toString(), 10);\n}\n/**\n * Calculate the product of an array of numbers.\n * @param array The array to calculate the product over.\n * @param begin Beginning index, inclusive.\n * @param end Ending index, exclusive.\n * @return The product.\n */\nexport function arrayProd(array, begin, end) {\n    if (begin == null) {\n        begin = 0;\n    }\n    if (end == null) {\n        end = array.length;\n    }\n    let prod = 1;\n    for (let i = begin; i < end; ++i) {\n        prod *= array[i];\n    }\n    return prod;\n}\n/**\n * Compute minimum value.\n * @param array\n * @return minimum value.\n */\nexport function min(array) {\n    // same behavior as tf.min()\n    if (array.length === 0) {\n        return Number.NaN;\n    }\n    let min = Number.POSITIVE_INFINITY;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        if (value < min) {\n            min = value;\n        }\n    }\n    return min;\n}\n/**\n * Compute maximum value.\n * @param array\n * @return maximum value\n */\nexport function max(array) {\n    // same behavior as tf.max()\n    if (array.length === 0) {\n        return Number.NaN;\n    }\n    let max = Number.NEGATIVE_INFINITY;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        if (value > max) {\n            max = value;\n        }\n    }\n    return max;\n}\n/**\n * Compute sum of array.\n * @param array\n * @return The sum.\n */\nexport function sum(array) {\n    let sum = 0;\n    for (let i = 0; i < array.length; i++) {\n        const value = array[i];\n        sum += value;\n    }\n    return sum;\n}\n/**\n * Compute mean of array.\n * @param array\n * @return The mean.\n */\nexport function mean(array) {\n    return sum(array) / array.length;\n}\n/**\n * Compute variance of array.\n * @param array\n * @return The variance.\n */\nexport function variance(array) {\n    const meanValue = mean(array);\n    const demeaned = array.map((value) => value - meanValue);\n    let sumSquare = 0;\n    for (let i = 0; i < demeaned.length; i++) {\n        const value = demeaned[i];\n        sumSquare += value * value;\n    }\n    return sumSquare / array.length;\n}\n/**\n * Compute median of array.\n * @param array\n * @return The median value.\n */\nexport function median(array) {\n    const arraySorted = array.slice().sort((a, b) => a - b);\n    const lowIdx = Math.floor((arraySorted.length - 1) / 2);\n    const highIdx = Math.ceil((arraySorted.length - 1) / 2);\n    if (lowIdx === highIdx) {\n        return arraySorted[lowIdx];\n    }\n    return (arraySorted[lowIdx] + arraySorted[highIdx]) / 2;\n}\n/**\n * Generate an array of integers in [begin, end).\n * @param begin Beginning integer, inclusive.\n * @param end Ending integer, exclusive.\n * @returns Range array.\n * @throws ValueError, iff `end` < `begin`.\n */\nexport function range(begin, end) {\n    if (end < begin) {\n        throw new ValueError(`end (${end}) < begin (${begin}) is forbidden.`);\n    }\n    const out = [];\n    for (let i = begin; i < end; ++i) {\n        out.push(i);\n    }\n    return out;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWF0aF91dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy91dGlscy9tYXRoX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7Ozs7Ozs7OztHQVNHO0FBRUgsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUlyQzs7R0FFRztBQUNILE1BQU0sVUFBVSxTQUFTLENBQUMsQ0FBUztJQUNqQyxPQUFPLENBQUMsS0FBSyxRQUFRLENBQUMsQ0FBQyxDQUFDLFFBQVEsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQzFDLENBQUM7QUFFRDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsU0FBUyxDQUNyQixLQUEwQixFQUFFLEtBQWMsRUFBRSxHQUFZO0lBQzFELElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtRQUNqQixLQUFLLEdBQUcsQ0FBQyxDQUFDO0tBQ1g7SUFDRCxJQUFJLEdBQUcsSUFBSSxJQUFJLEVBQUU7UUFDZixHQUFHLEdBQUcsS0FBSyxDQUFDLE1BQU0sQ0FBQztLQUNwQjtJQUVELElBQUksSUFBSSxHQUFHLENBQUMsQ0FBQztJQUNiLEtBQUssSUFBSSxDQUFDLEdBQUcsS0FBSyxFQUFFLENBQUMsR0FBRyxHQUFHLEVBQUUsRUFBRSxDQUFDLEVBQUU7UUFDaEMsSUFBSSxJQUFJLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNsQjtJQUNELE9BQU8sSUFBSSxDQUFDO0FBQ2QsQ0FBQztBQUVEOzs7O0dBSUc7QUFDSCxNQUFNLFVBQVUsR0FBRyxDQUFDLEtBQTRCO0lBQzlDLDRCQUE0QjtJQUM1QixJQUFJLEtBQUssQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1FBQ3RCLE9BQU8sTUFBTSxDQUFDLEdBQUcsQ0FBQztLQUNuQjtJQUNELElBQUksR0FBRyxHQUFHLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztJQUNu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TyxFQUFFO1FBQ3RCLE9BQU8sV0FBVyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQzVCO0lBQ0QsT0FBTyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUMsR0FBRyxXQUFXLENBQUMsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDMUQsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxLQUFLLENBQUMsS0FBYSxFQUFFLEdBQVc7SUFDOUMsSUFBSSxHQUFHLEdBQUcsS0FBSyxFQUFFO1FBQ2YsTUFBTSxJQUFJLFVBQVUsQ0FBQyxRQUFRLEdBQUcsY0FBYyxLQUFLLGlCQUFpQixDQUFDLENBQUM7S0FDdkU7SUFDRCxNQUFNLEdBQUcsR0FBYSxFQUFFLENBQUM7SUFDekIsS0FBSyxJQUFJLENBQUMsR0FBRyxLQUFLLEVBQUUsQ0FBQyxHQUFHLEdBQUcsRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNoQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ2I7SUFDRCxPQUFPLEdBQUcsQ0FBQztBQUNiLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIE1hdGggdXRpbGl0eSBmdW5jdGlvbnMuXG4gKlxuICogVGhpcyBmaWxlIGNvbnRhaW5zIHNvbWUgZnJlcXVlbnRseSB1c2VkIG1hdGggZnVuY3Rpb24gdGhhdCBvcGVyYXRlcyBvblxuICogbnVtYmVyW10gb3IgRmxvYXQzMkFycmF5IGFuZCByZXR1cm4gYSBudW1iZXIuIE1hbnkgb2YgdGhlc2UgZnVuY3Rpb25zIGFyZVxuICogbm90LXNvLXRoaWNrIHdyYXBwZXJzIGFyb3VuZCBURi5qcyBDb3JlIGZ1bmN0aW9ucy4gQnV0IHRoZXkgb2ZmZXIgdGhlXG4gKiBjb252ZW5pZW5jZSBvZlxuICogMSkgbm90IGhhdmluZyB0byBjb252ZXJ0IHRoZSBpbnB1dHMgaW50byBUZW5zb3JzLFxuICogMikgbm90IGhhdmluZyB0byBjb252ZXJ0IHRoZSByZXR1cm5lZCBUZW5zb3JzIHRvIG51bWJlcnMuXG4gKi9cblxuaW1wb3J0IHtWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuXG5leHBvcnQgdHlwZSBBcnJheVR5cGVzID0gVWludDhBcnJheXxJbnQzMkFycmF5fEZsb2F0MzJBcnJheTtcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSBudW1iZXIgaXMgYW4gaW50ZWdlci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzSW50ZWdlcih4OiBudW1iZXIpOiBib29sZWFuIHtcbiAgcmV0dXJuIHggPT09IHBhcnNlSW50KHgudG9TdHJpbmcoKSwgMTApO1xufVxuXG4vKipcbiAqIENhbGN1bGF0ZSB0aGUgcHJvZHVjdCBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuICogQHBhcmFtIGFycmF5IFRoZSBhcnJheSB0byBjYWxjdWxhdGUgdGhlIHByb2R1Y3Qgb3Zlci5cbiAqIEBwYXJhbSBiZWdpbiBCZWdpbm5pbmcgaW5kZXgsIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSBlbmQgRW5kaW5nIGluZGV4LCBleGNsdXNpdmUuXG4gKiBAcmV0dXJuIFRoZSBwcm9kdWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXJyYXlQcm9kKFxuICAgIGFycmF5OiBudW1iZXJbXXxBcnJheVR5cGVzLCBiZWdpbj86IG51bWJlciwgZW5kPzogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKGJlZ2luID09IG51bGwpIHtcbiAgICBiZWdpbiA9IDA7XG4gIH1cbiAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgZW5kID0gYXJyYXkubGVuZ3RoO1xuICB9XG5cbiAgbGV0IHByb2QgPSAxO1xuICBmb3IgKGxldCBpID0gYmVnaW47IGkgPCBlbmQ7ICsraSkge1xuICAgIHByb2QgKj0gYXJyYXlbaV07XG4gIH1cbiAgcmV0dXJuIHByb2Q7XG59XG5cbi8qKlxuICogQ29tcHV0ZSBtaW5pbXVtIHZhbHVlLlxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJuIG1pbmltdW0gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW4oYXJyYXk6IG51bWJlcltdfEZsb2F0MzJBcnJheSk6IG51bWJlciB7XG4gIC8vIHNhbWUgYmVoYXZpb3IgYXMgdGYubWluKClcbiAgaWYgKGFycmF5Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBOdW1iZXIuTmFOO1xuICB9XG4gIGxldCBtaW4gPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCB2YWx1ZSA9IGFycmF5W2ldO1xuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgbWluID0gdmFsdWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBtaW47XG59XG5cbi8qKlxuICogQ29tcHV0ZSBtYXhpbXVtIHZhbHVlLlxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJuIG1heGltdW0gdmFsdWVcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1heChhcnJheTogbnVtYmVyW118RmxvYXQzMkFycmF5KTogbnVtYmVyIHtcbiAgLy8gc2FtZSBiZWhhdmlvciBhcyB0Zi5tYXgoKVxuICBpZiAoYXJyYXkubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIE51bWJlci5OYU47XG4gIH1cbiAgbGV0IG1heCA9IE51bWJlci5ORUdBVElWRV9JTkZJTklUWTtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG4gICAgaWYgKHZhbHVlID4gbWF4KSB7XG4gICAgICBtYXggPSB2YWx1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG1heDtcbn1cblxuLyoqXG4gKiBDb21wdXRlIHN1bSBvZiBhcnJheS5cbiAqIEBwYXJhbSBhcnJheVxuICogQHJldHVybiBUaGUgc3VtLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3VtKGFycmF5OiBudW1iZXJbXXxGbG9hdDMyQXJyYXkpOiBudW1iZXIge1xuICBsZXQgc3VtID0gMDtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IHZhbHVlID0gYXJyYXlbaV07XG4gICAgc3VtICs9IHZhbHVlO1xuICB9XG4gIHJldHVybiBzdW07XG59XG5cbi8qKlxuICogQ29tcHV0ZSBtZWFuIG9mIGFycmF5LlxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJuIFRoZSBtZWFuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWVhbihhcnJheTogbnVtYmVyW118RmxvYXQzMkFycmF5KTogbnVtYmVyIHtcbiAgcmV0dXJuIHN1bShhcnJheSkgLyBhcnJheS5sZW5ndGg7XG59XG5cbi8qKlxuICogQ29tcHV0ZSB2YXJpYW5jZSBvZiBhcnJheS5cbiAqIEBwYXJhbSBhcnJheVxuICogQHJldHVybiBUaGUgdmFyaWFuY2UuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB2YXJpYW5jZShhcnJheTogbnVtYmVyW118RmxvYXQzMkFycmF5KTogbnVtYmVyIHtcbiAgY29uc3QgbWVhblZhbHVlID0gbWVhbihhcnJheSk7XG4gIGNvbnN0IGRlbWVhbmVkID0gYXJyYXkubWFwKCh2YWx1ZTogbnVtYmVyKSA9PiB2YWx1ZSAtIG1lYW5WYWx1ZSk7XG4gIGxldCBzdW1TcXVhcmUgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGRlbWVhbmVkLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdmFsdWUgPSBkZW1lYW5lZFtpXTtcbiAgICBzdW1TcXVhcmUgKz0gdmFsdWUgKiB2YWx1ZTtcbiAgfVxuICByZXR1cm4gc3VtU3F1YXJlIC8gYXJyYXkubGVuZ3RoO1xufVxuXG4vKipcbiAqIENvbXB1dGUgbWVkaWFuIG9mIGFycmF5LlxuICogQHBhcmFtIGFycmF5XG4gKiBAcmV0dXJuIFRoZSBtZWRpYW4gdmFsdWUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtZWRpYW4oYXJyYXk6IG51bWJlcltdfEZsb2F0MzJBcnJheSk6IG51bWJlciB7XG4gIGNvbnN0IGFycmF5U29ydGVkID0gYXJyYXkuc2xpY2UoKS5zb3J0KChhLCBiKSA9PiBhIC0gYik7XG4gIGNvbnN0IGxvd0lkeCA9IE1hdGguZmxvb3IoKGFycmF5U29ydGVkLmxlbmd0aCAtIDEpIC8gMik7XG4gIGNvbnN0IGhpZ2hJZHggPSBNYXRoLmNlaWwoKGFycmF5U29ydGVkLmxlbmd0aCAtIDEpIC8gMik7XG4gIGlmIChsb3dJZHggPT09IGhpZ2hJZHgpIHtcbiAgICByZXR1cm4gYXJyYXlTb3J0ZWRbbG93SWR4XTtcbiAgfVxuICByZXR1cm4gKGFycmF5U29ydGVkW2xvd0lkeF0gKyBhcnJheVNvcnRlZFtoaWdoSWR4XSkgLyAyO1xufVxuXG4vKipcbiAqIEdlbmVyYXRlIGFuIGFycmF5IG9mIGludGVnZXJzIGluIFtiZWdpbiwgZW5kKS5cbiAqIEBwYXJhbSBiZWdpbiBCZWdpbm5pbmcgaW50ZWdlciwgaW5jbHVzaXZlLlxuICogQHBhcmFtIGVuZCBFbmRpbmcgaW50ZWdlciwgZXhjbHVzaXZlLlxuICogQHJldHVybnMgUmFuZ2UgYXJyYXkuXG4gKiBAdGhyb3dzIFZhbHVlRXJyb3IsIGlmZiBgZW5kYCA8IGBiZWdpbmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5nZShiZWdpbjogbnVtYmVyLCBlbmQ6IG51bWJlcik6IG51bWJlcltdIHtcbiAgaWYgKGVuZCA8IGJlZ2luKSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYGVuZCAoJHtlbmR9KSA8IGJlZ2luICgke2JlZ2lufSkgaXMgZm9yYmlkZGVuLmApO1xuICB9XG4gIGNvbnN0IG91dDogbnVtYmVyW10gPSBbXTtcbiAgZm9yIChsZXQgaSA9IGJlZ2luOyBpIDwgZW5kOyArK2kpIHtcbiAgICBvdXQucHVzaChpKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { backend } from '@tensorflow/tfjs-core';\nlet _epsilon;\n/**\n * Returns the value of the fuzz factor used in numeric expressions.\n */\nexport function epsilon() {\n    if (_epsilon == null) {\n        _epsilon = backend().epsilon();\n    }\n    return _epsilon;\n}\n/**\n * Sets the value of the fuzz factor used in numeric expressions.\n * @param e New value of epsilon.\n */\nexport function setEpsilon(e) {\n    _epsilon = e;\n}\n/**\n * Returns the default image data format convention.\n */\nexport function imageDataFormat() {\n    return 'channelsLast';\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tbW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2JhY2tlbmQvY29tbW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRzlDLElBQUksUUFBZ0IsQ0FBQztBQUVyQjs7R0FFRztBQUNILE1BQU0sVUFBVSxPQUFPO0lBQ3JCLElBQUksUUFBUSxJQUFJLElBQUksRUFBRTtRQUNwQixRQUFRLEdBQUcsT0FBTyxFQUFFLENBQUMsT0FBTyxFQUFFLENBQUM7S0FDaEM7SUFDRCxPQUFPLFFBQVEsQ0FBQztBQUNsQixDQUFDO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxVQUFVLFVBQVUsQ0FBQyxDQUFTO0lBQ2xDLFFBQVEsR0FBRyxDQUFDLENBQUM7QUFDZixDQUFDO0FBRUQ7O0dBRUc7QUFDSCxNQUFNLFVBQVUsZUFBZTtJQUM3QixPQUFPLGNBQWMsQ0FBQztBQUN4QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtiYWNrZW5kfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtEYXRhRm9ybWF0fSBmcm9tICcuLi9rZXJhc19mb3JtYXQvY29tbW9uJztcblxubGV0IF9lcHNpbG9uOiBudW1iZXI7XG5cbi8qKlxuICogUmV0dXJucyB0aGUgdmFsdWUgb2YgdGhlIGZ1enogZmFjdG9yIHVzZWQgaW4gbnVtZXJpYyBleHByZXNzaW9ucy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVwc2lsb24oKSB7XG4gIGlmIChfZXBzaWxvbiA9PSBudWxsKSB7XG4gICAgX2Vwc2lsb24gPSBiYWNrZW5kKCkuZXBzaWxvbigpO1xuICB9XG4gIHJldHVybiBfZXBzaWxvbjtcbn1cblxuLyoqXG4gKiBTZXRzIHRoZSB2YWx1ZSBvZiB0aGUgZnV6eiBmYWN0b3IgdXNlZCBpbiBudW1lcmljIGV4cHJlc3Npb25zLlxuICogQHBhcmFtIGUgTmV3IHZhbHVlIG9mIGVwc2lsb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzZXRFcHNpbG9uKGU6IG51bWJlcikge1xuICBfZXBzaWxvbiA9IGU7XG59XG5cbi8qKlxuICogUmV0dXJucyB0aGUgZGVmYXVsdCBpbWFnZSBkYXRhIGZvcm1hdCBjb252ZW50aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW1hZ2VEYXRhRm9ybWF0KCk6IERhdGFGb3JtYXQge1xuICByZXR1cm4gJ2NoYW5uZWxzTGFzdCc7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * deeplearn.js backend.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { onesLike as coreOnesLike, scalar, tensor1d, tidy, where, zerosLike as coreZerosLike } from '@tensorflow/tfjs-core';\nimport { checkDataFormat } from '../common';\nimport { NotImplementedError, ValueError } from '../errors';\nimport * as math_utils from '../utils/math_utils';\nimport { imageDataFormat } from './common';\n// tslint:enable\n/* Setting and getting backend from deeplearn.js. */\n// Default deeplearn.js backend is WebGL (GPU).\nlet backend = 'webgl';\nexport function setBackend(requestedBackend) {\n    tfc.setBackend(requestedBackend);\n    backend = requestedBackend;\n}\nexport function getBackend() {\n    return backend;\n}\n/**\n * Indicates whether the backend is operating symbolically.\n *\n * This function will be used to determine how to interpret user code. If\n * it returns true, calls to the backend construct a symbolic graph; if\n * it returns false, calls to the backend execute immediately.\n */\nexport function isBackendSymbolic() {\n    return false;\n}\n/**\n * Get the number of elements in a Tensor.\n * @param x The Tensor.\n * @return Number of elements in `x`.\n */\nexport function countParams(x) {\n    const shape = x.shape;\n    if (shape.length > 0) {\n        return shape.reduce((a, b) => a * b);\n    }\n    else {\n        // Scalar.\n        return 1;\n    }\n}\n/**\n * Casts a tensor to a different dtype and returns it.\n * @param x Input tensor.\n * @param dtype String: 'float32'|'int32'|'bool'.\n * @returns Tensor of the specified `dtype`.\n */\nexport function cast(x, dtype) {\n    return tfc.cast(x, dtype);\n}\n/**\n * Adds a 1-sized dimension at index \"axis\".\n * @param x Input tensor.\n * @param axis Position where to add the new axis.\n * @returns Result of the dimension expansion.\n */\nexport function expandDims(x, axis = -1) {\n    const outShape = x.shape.slice();\n    if (axis < 0) {\n        axis = outShape.length + axis + 1;\n    }\n    outShape.splice(axis, 0, 1);\n    return tfc.reshape(x, outShape);\n}\n/**\n * Repeats a 2D tensor.\n *\n * If `x` has shape `[samples, dim]` and `n` is 2, for example, the output\n * will have shape `[samples, 2, dim]`.\n *\n * @param x Input tensor.\n * @param n Integer, number of times to repeat.\n * @returns The result of the repeat operation.\n * @throws ValueError: If input tensor is not 2D.\n */\nexport function repeat(x, n) {\n    return tidy(() => {\n        if (x.shape.length !== 2) {\n            throw new ValueError(`repeat() expects a rank-2 tensor, but received a ` +\n                `rank-${x.shape.length} tensor.`);\n        }\n        const y = expandDims(x, 1);\n        return tile(y, [1, n, 1]);\n    });\n}\n/**\n * Flatten a Tensor into 1D.\n * @param x Input tensor.\n * @return The result of the flattening `x`.\n */\nexport function flatten(x) {\n    const newShape = [math_utils.arrayProd(x.shape)];\n    return tfc.reshape(x, newShape);\n}\n/**\n * Turn a nD tensor into a 2D tensor with same 0th dimension.\n * In other words, it flattens each data samples of a batch.\n *\n * @param x The tensor to flatten. The rank of this tensor is required to be 2\n *   or higher.\n * @return The result of the flattening.\n */\nexport function batchFlatten(x) {\n    if (x.rank <= 1) {\n        throw new ValueError(`batchFlatten requires a minimum rank of 2. Got rank: ${x.rank}.`);\n    }\n    const newShape = [x.shape[0], math_utils.arrayProd(x.shape, 1)];\n    return tfc.reshape(x, newShape);\n}\n/**\n * Do slicing along the first axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size size of the slice along the first axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nexport function sliceAlongFirstAxis(array, start, size) {\n    return tidy(() => {\n        switch (array.rank) {\n            case 1:\n                return tfc.slice1d(array, start, size);\n            case 2:\n                return tfc.slice2d(array, [start, 0], [size, array.shape[1]]);\n            case 3:\n                return tfc.slice3d(array, [start, 0, 0], [size, array.shape[1], array.shape[2]]);\n            case 4:\n                return tfc.slice4d(array, [start, 0, 0, 0], [size, array.shape[1], array.shape[2], array.shape[3]]);\n            case 5:\n                return tfc.slice(array, [start, 0, 0, 0, 0], [\n                    size, array.shape[1], array.shape[2], array.shape[3], array.shape[4]\n                ]);\n            case 6:\n                return tfc.slice(array, [start, 0, 0, 0, 0, 0], [\n                    size, array.shape[1], array.shape[2], array.shape[3], array.shape[4],\n                    array.shape[5]\n                ]);\n            default:\n                throw new ValueError(`sliceAlongFirstAxis() received an unsupported tensor rank: ` +\n                    `${array.rank}`);\n        }\n    });\n}\n/**\n * Do slicing along the last axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size size of the slice along the last axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nexport function sliceAlongLastAxis(array, start, size) {\n    return tidy(() => {\n        switch (array.rank) {\n            case 1:\n                return tfc.slice1d(array, start, size);\n            case 2:\n                return tfc.slice2d(array, [0, start], [array.shape[0], size]);\n            case 3:\n                return tfc.slice3d(array, [0, 0, start], [array.shape[0], array.shape[1], size]);\n            case 4:\n                return tfc.slice4d(array, [0, 0, 0, start], [array.shape[0], array.shape[1], array.shape[2], size]);\n            default:\n                throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ` +\n                    `${array.rank}`);\n        }\n    });\n}\n/**\n * Do slicing along the sepcified axis.\n * @param array input `tf.Tensor`.\n * @param start starting index, inclusive.\n * @param size of the slice along the chosen axis.\n * @param choose an axis.\n * @returns result of the slicing.\n * @throws ValueError: If `array` is of an unsupported subtype of `tf.Tensor`.\n */\nexport function sliceAlongAxis(array, start, size, axis) {\n    return tidy(() => {\n        switch (array.rank) {\n            case 1:\n                return tfc.slice1d(array, start, size);\n            case 2:\n                switch (axis) {\n                    case 1:\n                        return sliceAlongFirstAxis(array, start, size);\n                    case 2:\n                        return sliceAlongLastAxis(array, start, size);\n                    default:\n                        throw new ValueError(`The axis is not within the rank of the tensor ` +\n                            `${axis}`);\n                }\n            case 3:\n                switch (axis) {\n                    case 1:\n                        return sliceAlongFirstAxis(array, start, size);\n                    case 2:\n                        return tfc.slice3d(array, [0, start, 0], [array.shape[0], size, array.shape[2]]);\n                    case 3:\n                        return sliceAlongLastAxis(array, start, size);\n                    default:\n                        throw new ValueError(`The axis is not within the rank of the tensor ` +\n                            `${axis}`);\n                }\n            case 4:\n                switch (axis) {\n                    case 1:\n                        return sliceAlongFirstAxis(array, start, size);\n                    case 2:\n                        return tfc.slice4d(array, [0, start, 0, 0], [array.shape[0], size, array.shape[2], array.shape[3]]);\n                    case 3:\n                        return tfc.slice4d(array, [0, 0, start, 0], [array.shape[0], array.shape[1], size, array.shape[3]]);\n                    case 4:\n                        return sliceAlongLastAxis(array, start, size);\n                    default:\n                        throw new ValueError(`The axis is not within the rank of the tensor ` +\n                            `${axis}`);\n                }\n            default:\n                throw new ValueError(`sliceAlongLastAxis() received an unsupported tensor rank: ` +\n                    `${array.rank}`);\n        }\n    });\n}\n/**\n * Concatenates a list of tensors alongside the specified axis.\n * @param tensors `Array` of tensors to concatenate.\n * @param axis Concatenation axis.\n * @returns The result of the concatenation.\n */\nexport function concatenate(tensors, axis = -1) {\n    let rank;\n    if (axis < 0) {\n        rank = tensors[0].rank;\n        if (rank !== 0) {\n            axis = rank;\n        }\n        else {\n            axis = 0;\n        }\n    }\n    if (axis === tensors[0].rank) {\n        // Porting Note: This is necessary because tfc.concat() requires axis to be\n        //   in the interval [-rank, rank).\n        axis = -1;\n    }\n    // Porting Note: Sparse concat is not supported yet.\n    return tfc.concat(tensors, axis);\n}\n/**\n * Concatenate two arrays along the first dimension.\n * @param a The 1st `tf.Tensor` to concatenate.\n * @param b The 2nd `tf.Tensor` to concatenate.\n * @returns Result of the concatenation.\n * @throws ValueError: If `a` is of an unsupported subtype of `tf.Tensor`.\n */\nexport function concatAlongFirstAxis(a, b) {\n    switch (a.rank) {\n        case 1:\n            return tfc.concat1d([a, b]);\n        case 2:\n            return tfc.concat2d([a, b], 0);\n        case 3:\n            return tfc.concat3d([a, b], 0);\n        case 4:\n            return tfc.concat4d([a, b], 0);\n        default:\n            throw new ValueError(`concatAlongFirstAxis() received an unsupported ` +\n                `tensor rank: ${a.rank}`);\n    }\n}\n/**\n * Creates a tensor by tiling `x` by `n`.\n * @param x A tensor.\n * @param n An Array of integers or a single integer. If an Array, the length\n *   must be the same as the number of dimensions in `x`. If a single integer,\n *   it will be treated as an Array of length 1.\n */\nexport function tile(x, n) {\n    if (!Array.isArray(n)) {\n        n = [n];\n    }\n    if (x.rank !== n.length) {\n        throw new ValueError(`The length of input n (${n.length}) does not match ` +\n            `the number of dimensions in input x (${x.rank})`);\n    }\n    return tfc.tile(x, n);\n}\n/* Creation of random tensors. */\n/**\n * Get a tensor with normal distribution of values.\n *\n * @param shape Shape of the tensor.\n * @param mean mean value of the normal distribution.\n * @param stddev standard deviation of the normal distribution.\n * @param dtype\n * @param seed\n * @return The normal tensor.\n */\nexport function randomNormal(shape, mean = 0.0, stddev = 1.0, dtype, seed) {\n    return tfc.randomNormal(shape, mean, stddev, dtype, seed);\n}\n/* Linear Algebra */\n/**\n * Multiply two tensors and returns the result as a tensor.\n *\n * For 2D tensors, this is equivalent to matrix multiplication (matMul).\n * For tensors of higher ranks, it follows the Theano behavior,\n * (e.g. `(2, 3) * (4, 3, 5) -> (2, 4, 5)`).  From the Theano documentation:\n *\n * For N dimensions it is a sum product over the last axis of x and the\n * second-to-last of y:\n *\n * @param a A tensor of at least rank 2.\n * @param b A tensor of at least rank 2.\n * @param activation (optional) A string identifying the activation\n *   function.\n * @return Result of the dot operation.\n */\nexport function dot(a, b, activation, bias) {\n    if ((a.rank < 2) || (b.rank < 2)) {\n        throw new NotImplementedError(`dot requires both inputs to be rank >= 2` +\n            ` but got x shape = ${a.shape} and y shape = ${b.shape}`);\n    }\n    if (b.rank >= 3) {\n        const xLastDim = a.shape.slice(-1)[0];\n        const ySecondLastDim = b.shape.slice(-2)[0];\n        if (xLastDim !== ySecondLastDim) {\n            throw new NotImplementedError(`If rank y >= 3, then the second last dim` +\n                ` of y must equal the last dim of x but got x shape = ${a.shape} and ` +\n                ` y shape = ${b.shape}`);\n        }\n    }\n    // Handle basic 2D x 2D case.\n    if ((a.rank === 2) && (b.rank === 2)) {\n        const transposeA = false;\n        const transposeB = false;\n        // tfc.fused.matMul only fuses certain activation functions. Unsupported\n        // activation functions are treated as 'linear' activations, which is\n        // equivalent to a no-op.\n        return tfc.fused.matMul({\n            a,\n            b: b,\n            transposeA,\n            transposeB,\n            bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,\n            activation\n        });\n    }\n    else {\n        // Reshape x into the analogous 2D Tensor.\n        const aFirstDims = a.shape.slice(); // Holds all but the last dim of x.\n        const aLastDim = aFirstDims.pop();\n        a = tfc.reshape(a, [-1, aLastDim]);\n        // Reshape y into the analogous 2D Tensor, and keep track of the\n        // required dimensions to reproduce the output shape.\n        const bShape = b.shape.slice();\n        const bLastDim = bShape.pop();\n        const ySecondLastDim = bShape.pop();\n        const yOtherDims = [...bShape, bLastDim];\n        // permutation should be like [r-2, 0, 1, 2, ... r-4, r-3, r-1]\n        // where r is the rank of y.\n        const perm = Array.from({ length: b.rank }, (_, i) => {\n            if (i === 0) {\n                return b.rank - 2;\n            }\n            else if (i <= b.rank - 2) {\n                return i - 1;\n            }\n            return i;\n        });\n        b = tfc.reshape(tfc.transpose(b, perm), [ySecondLastDim, -1]);\n        // Multiply x and y as 2D Tensors, and then reshape back to original.\n        const outputShape = [...aFirstDims, ...yOtherDims];\n        const transposeA = false;\n        const transposeB = false;\n        return tfc.reshape(tfc.fused.matMul({\n            a,\n            b,\n            transposeA,\n            transposeB,\n            bias: bias ? reshapeBias(a.rank, bias, imageDataFormat()) : null,\n            activation\n        }), outputShape);\n    }\n}\n/**\n * Compute the sign Tensor of an input Tensor.\n *\n * Elements of the input `tf.Tensor` that are === 0 are mapped to 0.\n * Elements of the input `tf.Tensor` that are > 0 are mapped to 1.\n * Elements of the input `tf.Tensor` that are < 0 are mapped to -1.\n *\n * @param x Input `tf.Tensor`.\n * @return The sign `tf.Tensor`.\n */\nexport function sign(x) {\n    // TODO(cais): Move to the core.\n    return tidy(() => {\n        const zerosLikeX = coreZerosLike(x);\n        const onesLikeX = coreOnesLike(x);\n        return where(tfc.equal(x, zerosLikeX), zerosLikeX, where(tfc.greater(x, coreZerosLike(x)), onesLikeX, tfc.mul(-1, onesLikeX)));\n    });\n}\n/**\n * Computes the one-hot representation of an integer tensor.\n * @param indices nD integer tensor of shape\n *   `(batch_size, dim1, dim2, ... dim(n-1))`\n * @param numClasses Integer, number of classes to consider.\n * @returns (n + 1)D one hot representation of the input\n *   with shape `(batch_size, dim1, dim2, ... dim(n-1), num_classes)`\n */\nexport function oneHot(indices, numClasses) {\n    return tidy(() => {\n        if (indices.rank !== 1) {\n            throw new Error('Only 1D one-hot tensors are supported in the ' +\n                'deeplearn backend, at present.');\n        }\n        indices = tfc.cast(indices, 'int32');\n        return tfc.cast(tfc.oneHot(indices, numClasses), 'float32');\n    });\n}\n/* Elementary math functions. */\n/**\n * Retrieves the elements of indices `indices` in the tensor `reference`.\n * @param reference A tensor.\n * @param indices An integer tensor of indices or an `Array` of integers.\n * @param axis Axis along which to perform the gather operation.\n * @returns The result of the gathering as a tensor.\n */\nexport function gather(reference, indices, axis) {\n    return tidy(() => {\n        if (Array.isArray(indices)) {\n            indices = tensor1d(indices, 'int32');\n        }\n        else {\n            indices = tfc.cast(indices, 'int32');\n        }\n        return tfc.gather(reference, indices, axis);\n    });\n}\n/**\n * Element-wise square.\n * @param x Input tensor.\n * @return element-wise x^2\n */\nexport function square(x) {\n    return tfc.mul(x, x);\n}\n/**\n * Element-wise exponentiation.\n *\n * Porting Note: In PyKeras, `a` (the exponent) is a Python integer, which\n *   takes advatnage of the backend's (e.g., TensorFlow's) automatic\n * conversion to tensor. Here we allow `a` to be either a number or a tensor.\n *\n * @param x The base tensor.\n * @param a The exponent, tensor or number. If a number, it is rounded to the\n *   nearest integer and converted to a tensor.\n * @returns A tensor of the same shape as `x`.\n */\nexport function pow(x, a) {\n    return tidy(() => {\n        if (typeof (a) === 'number') {\n            a = scalar(Math.round(a), 'int32');\n        }\n        if (a.dtype !== 'int32') {\n            throw new NotImplementedError(`Non-int32 dtype (${a.dtype}) is not supported by pow() yet`);\n        }\n        return tfc.pow(x, a);\n    });\n}\n/**\n * Reshapes bias tensor according to rank of x.\n */\nfunction reshapeBias(xRank, bias, dataFormat) {\n    const biasShape = bias.shape;\n    if (bias.rank !== 1 && bias.rank !== xRank) {\n        throw new ValueError(`Unexpected bias dimensions: ${bias.rank}` +\n            `; expected it to be 1 or ${xRank}`);\n    }\n    if (xRank === 5) {\n        if (dataFormat === 'channelsFirst') {\n            if (biasShape.length === 1) {\n                return tfc.reshape(bias, [1, biasShape[0], 1, 1, 1]);\n            }\n            else {\n                return tfc.reshape(bias, [1, biasShape[3], biasShape[0], biasShape[1], biasShape[2]]);\n            }\n        }\n        else if (dataFormat === 'channelsLast') {\n            if (biasShape.length === 1) {\n                return tfc.reshape(bias, [1, 1, 1, 1, biasShape[0]]);\n            }\n            else {\n                return tfc.reshape(bias, [1].concat(biasShape));\n            }\n        }\n    }\n    else if (xRank === 4) {\n        if (dataFormat === 'channelsFirst') {\n            if (biasShape.length === 1) {\n                return tfc.reshape(bias, [1, biasShape[0], 1, 1]);\n            }\n            else {\n                return tfc.reshape(bias, [1, biasShape[2], biasShape[0], biasShape[1]]);\n            }\n        }\n        else if (dataFormat === 'channelsLast') {\n            if (biasShape.length === 1) {\n                return tfc.reshape(bias, [1, 1, 1, biasShape[0]]);\n            }\n            else {\n                return tfc.reshape(bias, [1].concat(biasShape));\n            }\n        }\n    }\n    else if (xRank === 3) {\n        if (dataFormat === 'channelsFirst') {\n            if (biasShape.length === 1) {\n                return tfc.reshape(bias, [1, biasShape[0], 1]);\n            }\n            else {\n                return tfc.reshape(bias, [1, biasShape[1], biasShape[0]]);\n            }\n        }\n        else if (dataFormat === 'channelsLast') {\n            if (biasShape.length === 1) {\n                return tfc.reshape(bias, [1, 1, biasShape[0]]);\n            }\n            else {\n                return tfc.reshape(bias, [1].concat(biasShape));\n            }\n        }\n    }\n    else if (xRank < 3) {\n        return bias;\n    }\n    throw new ValueError(`Unsupported input rank by biasAdd: ${bias.rank}`);\n}\n/* Neural-network operations. */\n/**\n * Add a bias to a tensor.\n *\n * @param x The tensor to add the bias to.\n * @param bias The bias to add to `x`. Must be 1D or the same rank as `x`.\n * @return Result of the bias adding.\n * @throws ValueError: If the rank of `bias` is incorrect.\n */\nexport function biasAdd(x, bias, dataFormat) {\n    return tidy(() => {\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        checkDataFormat(dataFormat);\n        return tfc.add(x, reshapeBias(x.rank, bias, dataFormat));\n    });\n}\n/**\n * Exponential linear unit (ELU).\n * @param x A tensor or variable to compute the activation function for.\n * @param alpha: A scalar, a scaling factor for the negative section.\n * @return Output of the ELU operation.\n */\nexport function elu(x, alpha = 1) {\n    // TODO(cais): Add support for alpha values other than 1.\n    if (alpha !== 1) {\n        throw new NotImplementedError(`Support for alpha values other than 1 (${alpha}) is not implemented ` +\n            `yet.`);\n    }\n    return tfc.elu(x);\n}\n/**\n * Softsign of a tensor.\n *\n * Defined as x / (abs(x) + 1), element-wise.\n *\n * @param x: Input.\n * @returns Output.\n */\nexport function softsign(x) {\n    return tidy(() => tfc.div(x, tfc.add(tfc.abs(x), 1)));\n}\n/**\n * Sets entries in `x` to zero at random, while scaling the entire tensor.\n *\n * @param x input tensor.\n * @param level fraction of the entries in the tensor that will be set to 0.\n * @param noiseShape shape of randomly generated keep/drop flags, must be\n *   broadcastable to the shape of `x`. Optional.\n * @param seed random seed to ensure determinism. Optional.\n * @returns Result of the dropout operation.\n */\nexport function dropout(x, level, noiseShape, seed) {\n    return tidy(() => tfc.dropout(x, level, noiseShape, seed));\n}\n/**\n * Element-wise, segment-wise linear approximation of sigmoid.\n *\n * Returns `0.` if `x < -2.5`, `1.` if `x > 2.5`.\n * In `-2.5 <= x <= 2.5`, returns `0.2 * x + 0.5`.\n *\n * @param x Input tensor.\n * @returns Output tensor.\n */\nexport function hardSigmoid(x) {\n    return tidy(() => {\n        const y = tfc.add(.5, tfc.mul(.2, x));\n        return tfc.clipByValue(y, 0, 1);\n    });\n}\n/**\n * Invoke `x` in the training phase, and `alt` otherwise.\n *\n * Porting Note: We do not create placeholder tensors for the `training`\n * boolean flag here, because there is no such thing in the TF.js imperative\n * backend.\n *\n * @param x The function to invoke iff `training` is `true`.\n * @param alt The function to invoke iff `training` is `false`.\n * @param training Boolean flag for whether training phase is active.\n * @returns The return value of `x()` if `training` is `true`, or the return\n *   value of `alt()` if `training` is `false`.\n */\nexport function inTrainPhase(x, alt, training = false) {\n    return training ? x() : alt();\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGZqc19iYWNrZW5kLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2JhY2tlbmQvdGZqc19iYWNrZW5kLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxRQUFRLElBQUksWUFBWSxFQUFFLE1BQU0sRUFBb0IsUUFBUSxFQUEwQyxJQUFJLEVBQUUsS0FBSyxFQUFFLFNBQVMsSUFBSSxhQUFhLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUNwTCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQzFDLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFHMUQsT0FBTyxLQUFLLFVBQVUsTUFBTSxxQkFBcUIsQ0FBQztBQUVsRCxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBRXpDLGdCQUFnQjtBQUVoQixvREFBb0Q7QUFFcEQsK0NBQStDO0FBQy9DLElBQUksT0FBTyxHQUFrQixPQUFPLENBQUM7QUFFckMsTUFBTSxVQUFVLFVBQVUsQ0FBQyxnQkFBK0I7SUFDeEQsR0FBRyxDQUFDLFVBQVUsQ0FBQyxnQkFBZ0IsQ0FBQyxDQUFDO0lBQ2pDLE9BQU8sR0FBRyxnQkFBZ0IsQ0FBQztBQUM3QixDQUFDO0FBRUQsTUFBTSxVQUFVLFVBQVU7SUFDeEIsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQztBQUVEOzs7Ozs7R0FNRztBQUNILE1BQU0sVUFBVSxpQkFBaUI7SUFDL0IsT0FBTyxLQUFLLENBQUM7QUFDZixDQUFDO0FBRUQ7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQUMsQ0FBVztJQUNyQyxNQUFNLEtBQUssR0FBRyxDQUFDLENBQUMsS0FBSyxDQUFDO0lBQ3RCLElB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R0FBRyxLQUFLO0lBQ3hFLE9BQU8sUUFBUSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDaEMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogZGVlcGxlYXJuLmpzIGJhY2tlbmQuXG4gKi9cblxuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge29uZXNMaWtlIGFzIGNvcmVPbmVzTGlrZSwgc2NhbGFyLCBUZW5zb3IsIFRlbnNvcjFELCB0ZW5zb3IxZCwgVGVuc29yMkQsIFRlbnNvcjNELCBUZW5zb3I0RCwgVGVuc29yNUQsIHRpZHksIHdoZXJlLCB6ZXJvc0xpa2UgYXMgY29yZVplcm9zTGlrZX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7Y2hlY2tEYXRhRm9ybWF0fSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtEYXRhRm9ybWF0LCBTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge0hhc1NoYXBlfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyBtYXRoX3V0aWxzIGZyb20gJy4uL3V0aWxzL21hdGhfdXRpbHMnO1xuXG5pbXBvcnQge2ltYWdlRGF0YUZvcm1hdH0gZnJvbSAnLi9jb21tb24nO1xuXG4vLyB0c2xpbnQ6ZW5hYmxlXG5cbi8qIFNldHRpbmcgYW5kIGdldHRpbmcgYmFja2VuZCBmcm9tIGRlZXBsZWFybi5qcy4gKi9cblxuLy8gRGVmYXVsdCBkZWVwbGVhcm4uanMgYmFja2VuZCBpcyBXZWJHTCAoR1BVKS5cbmxldCBiYWNrZW5kOiAnY3B1J3wnd2ViZ2wnID0gJ3dlYmdsJztcblxuZXhwb3J0IGZ1bmN0aW9uIHNldEJhY2tlbmQocmVxdWVzdGVkQmFja2VuZDogJ2NwdSd8J3dlYmdsJykge1xuICB0ZmMuc2V0QmFja2VuZChyZXF1ZXN0ZWRCYWNrZW5kKTtcbiAgYmFja2VuZCA9IHJlcXVlc3RlZEJhY2tlbmQ7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRCYWNrZW5kKCk6ICdjcHUnfCd3ZWJnbCcge1xuICByZXR1cm4gYmFja2VuZDtcbn1cblxuLyoqXG4gKiBJbmRpY2F0ZXMgd2hldGhlciB0aGUgYmFja2VuZCBpcyBvcGVyYXRpbmcgc3ltYm9saWNhbGx5LlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSBob3cgdG8gaW50ZXJwcmV0IHVzZXIgY29kZS4gSWZcbiAqIGl0IHJldHVybnMgdHJ1ZSwgY2FsbHMgdG8gdGhlIGJhY2tlbmQgY29uc3RydWN0IGEgc3ltYm9saWMgZ3JhcGg7IGlmXG4gKiBpdCByZXR1cm5zIGZhbHNlLCBjYWxscyB0byB0aGUgYmFja2VuZCBleGVjdXRlIGltbWVkaWF0ZWx5LlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNCYWNrZW5kU3ltYm9saWMoKTogYm9vbGVhbiB7XG4gIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhIFRlbnNvci5cbiAqIEBwYXJhbSB4IFRoZSBUZW5zb3IuXG4gKiBAcmV0dXJuIE51bWJlciBvZiBlbGVtZW50cyBpbiBgeGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb3VudFBhcmFtcyh4OiBIYXNTaGFwZSk6IG51bWJlciB7XG4gIGNvbnN0IHNoYXBlID0geC5zaGFwZTtcbiAgaWYgKHNoYXBlLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gc2hhcGUucmVkdWNlKChhOiBudW1iZXIsIGI6IG51bWJlcikgPT4gYSAqIGIpO1xuICB9IGVsc2Uge1xuICAgIC8vIFNjYWxhci5cbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG4vKipcbiAqIENhc3RzIGEgdGVuc29yIHRvIGEgZGlmZmVyZW50IGR0eXBlIGFuZCByZXR1cm5zIGl0LlxuICogQHBhcmFtIHggSW5wdXQgdGVuc29yLlxuICogQHBhcmFtIGR0eXBlIFN0cmluZzogJ2Zsb2F0MzInfCdpbnQzMid8J2Jvb2wnLlxuICogQHJldHVybnMgVGVuc29yIG9mIHRoZSBzcGVjaWZpZWQgYGR0eXBlYC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNhc3QoeDogVGVuc29yLCBkdHlwZTogdGZjLkRhdGFUeXBlKTogVGVuc29yIHtcbiAgcmV0dXJuIHRmYy5jYXN0KHgsIGR0eXBlKTtcbn1cblxuLyoqXG4gKiBBZGRzIGEgMS1zaXplZCBkaW1lbnNpb24gYXQgaW5kZXggXCJheGlzXCIuXG4gKiBAcGFyYW0geCBJbnB1dCB0ZW5zb3IuXG4gKiBAcGFyYW0gYXhpcyBQb3NpdGlvbiB3aGVyZSB0byBhZGQgdGhlIG5ldyBheGlzLlxuICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSBkaW1lbnNpb24gZXhwYW5zaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZXhwYW5kRGltcyh4OiBUZW5zb3IsIGF4aXMgPSAtMSk6IFRlbnNvciB7XG4gIGNvbnN0IG91dFNoYXBlID0geC5zaGFwZS5zbGljZSgpO1xuICBpZiAoYXhpcyA8IDApIHtcbiAgICBheGlzID0gb3V0U2hhcGUubGVuZ3RoICsgYXhpcyArIDE7XG4gIH1cbiAgb3V0U2hhcGUuc3BsaWNlKGF4aXMsIDAsIDEpO1xuICByZXR1cm4gdGZjLnJlc2hhcGUoeCwgb3V0U2hhcGUpO1xufVxuXG4vKipcbiAqIFJlcGVhdHMgYSAyRCB0ZW5zb3IuXG4gKlxuICogSWYgYHhgIGhhcyBzaGFwZSBgW3NhbXBsZXMsIGRpbV1gIGFuZCBgbmAgaXMgMiwgZm9yIGV4YW1wbGUsIHRoZSBvdXRwdXRcbiAqIHdpbGwgaGF2ZSBzaGFwZSBgW3NhbXBsZXMsIDIsIGRpbV1gLlxuICpcbiAqIEBwYXJhbSB4IElucHV0IHRlbnNvci5cbiAqIEBwYXJhbSBuIEludGVnZXIsIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQuXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSByZXBlYXQgb3BlcmF0aW9uLlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBJZiBpbnB1dCB0ZW5zb3IgaXMgbm90IDJELlxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVwZWF0KHg6IFRlbnNvciwgbjogbnVtYmVyKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIGlmICh4LnNoYXBlLmxlbmd0aCAhPT0gMikge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYHJlcGVhdCgpIGV4cGVjdHMgYSByYW5rLTIgdGVuc29yLCBidXQgcmVjZWl2ZWQgYSBgICtcbiAgICAgICAgICBgcmFuay0ke3guc2hhcGUubGVuZ3RofSB0ZW5zb3IuYCk7XG4gICAgfVxuICAgIGNvbnN0IHkgPSBleHBhbmREaW1zKHgsIDEpO1xuICAgIHJldHVybiB0aWxlKHksIFsxLCBuLCAxXSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEZsYXR0ZW4gYSBUZW5zb3IgaW50byAxRC5cbiAqIEBwYXJhbSB4IElucHV0IHRlbnNvci5cbiAqIEByZXR1cm4gVGhlIHJlc3VsdCBvZiB0aGUgZmxhdHRlbmluZyBgeGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBmbGF0dGVuKHg6IFRlbnNvcik6IFRlbnNvciB7XG4gIGNvbnN0IG5ld1NoYXBlID0gW21hdGhfdXRpbHMuYXJyYXlQcm9kKHguc2hhcGUpXTtcbiAgcmV0dXJuIHRmYy5yZXNoYXBlKHgsIG5ld1NoYXBlKTtcbn1cblxuLyoqXG4gKiBUdXJuIGEgbkQgdGVuc29yIGludG8gYSAyRCB0ZW5zb3Igd2l0aCBzYW1lIDB0aCBkaW1lbnNpb24uXG4gKiBJbiBvdGhlciB3b3JkcywgaXQgZmxhdHRlbnMgZWFjaCBkYXRhIHNhbXBsZXMgb2YgYSBiYXRjaC5cbiAqXG4gKiBAcGFyYW0geCBUaGUgdGVuc29yIHRvIGZsYXR0ZW4uIFRoZSByYW5rIG9mIHRoaXMgdGVuc29yIGlzIHJlcXVpcmVkIHRvIGJlIDJcbiAqICAgb3IgaGlnaGVyLlxuICogQHJldHVybiBUaGUgcmVzdWx0IG9mIHRoZSBmbGF0dGVuaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmF0Y2hGbGF0dGVuKHg6IFRlbnNvcik6IFRlbnNvciB7XG4gIGlmICh4LnJhbmsgPD0gMSkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICBgYmF0Y2hGbGF0dGVuIHJlcXVpcmVzIGEgbWluaW11bSByYW5rIG9mIDIuIEdvdCByYW5rOiAke3gucmFua30uYCk7XG4gIH1cbiAgY29uc3QgbmV3U2hhcGUgPSBbeC5zaGFwZVswXSwgbWF0aF91dGlscy5hcnJheVByb2QoeC5zaGFwZSwgMSldO1xuICByZXR1cm4gdGZjLnJlc2hhcGUoeCwgbmV3U2hhcGUpO1xufVxuXG4vKipcbiAqIERvIHNsaWNpbmcgYWxvbmcgdGhlIGZpcnN0IGF4aXMuXG4gKiBAcGFyYW0gYXJyYXkgaW5wdXQgYHRmLlRlbnNvcmAuXG4gKiBAcGFyYW0gc3RhcnQgc3RhcnRpbmcgaW5kZXgsIGluY2x1c2l2ZS5cbiAqIEBwYXJhbSBzaXplIHNpemUgb2YgdGhlIHNsaWNlIGFsb25nIHRoZSBmaXJzdCBheGlzLlxuICogQHJldHVybnMgcmVzdWx0IG9mIHRoZSBzbGljaW5nLlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBJZiBgYXJyYXlgIGlzIG9mIGFuIHVuc3VwcG9ydGVkIHN1YnR5cGUgb2YgYHRmLlRlbnNvcmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzbGljZUFsb25nRmlyc3RBeGlzKFxuICAgIGFycmF5OiBUZW5zb3IsIHN0YXJ0OiBudW1iZXIsIHNpemU6IG51bWJlcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBzd2l0Y2ggKGFycmF5LnJhbmspIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRmYy5zbGljZTFkKGFycmF5IGFzIFRlbnNvcjFELCBzdGFydCwgc2l6ZSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0ZmMuc2xpY2UyZChcbiAgICAgICAgICAgIGFycmF5IGFzIFRlbnNvcjJELCBbc3RhcnQsIDBdLCBbc2l6ZSwgYXJyYXkuc2hhcGVbMV1dKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRmYy5zbGljZTNkKFxuICAgICAgICAgICAgYXJyYXkgYXMgVGVuc29yM0QsIFtzdGFydCwgMCwgMF0sXG4gICAgICAgICAgICBbc2l6ZSwgYXJyYXkuc2hhcGVbMV0sIGFycmF5LnNoYXBlWzJdXSk7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0ZmMuc2xpY2U0ZChcbiAgICAgICAgICAgIGFycmF5IGFzIFRlbnNvcjRELCBbc3RhcnQsIDAsIDAsIDBdLFxuICAgICAgICAgICAgW3NpemUsIGFycmF5LnNoYXBlWzFdLCBhcnJheS5zaGFwZVsyXSwgYXJyYXkuc2hhcGVbM11dKTtcbiAgICAgIGNhc2UgNTpcbiAgICAgICAgcmV0dXJuIHRmYy5zbGljZShhcnJheSBhcyBUZW5zb3I1RCwgW3N0YXJ0LCAwLCAwLCAwLCAwXSwgW1xuICAgICAgICAgIHNpemUsIGFycmF5LnNoYXBlWzFdLCBhcnJheS5zaGFwZVsyXSwgYXJyYXkuc2hhcGVbM10sIGFycmF5LnNoYXBlWzRdXG4gICAgICAgIF0pO1xuICAgICAgY2FzZSA2OlxuICAgICAgICByZXR1cm4gdGZjLnNsaWNlKGFycmF5LCBbc3RhcnQsIDAsIDAsIDAsIDAsIDBdLCBbXG4gICAgICAgICAgc2l6ZSwgYXJyYXkuc2hhcGVbMV0sIGFycmF5LnNoYXBlWzJdLCBhcnJheS5zaGFwZVszXSwgYXJyYXkuc2hhcGVbNF0sXG4gICAgICAgICAgYXJyYXkuc2hhcGVbNV1cbiAgICAgICAgXSk7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBzbGljZUFsb25nRmlyc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgdGVuc29yIHJhbms6IGAgK1xuICAgICAgICAgICAgYCR7YXJyYXkucmFua31gKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIERvIHNsaWNpbmcgYWxvbmcgdGhlIGxhc3QgYXhpcy5cbiAqIEBwYXJhbSBhcnJheSBpbnB1dCBgdGYuVGVuc29yYC5cbiAqIEBwYXJhbSBzdGFydCBzdGFydGluZyBpbmRleCwgaW5jbHVzaXZlLlxuICogQHBhcmFtIHNpemUgc2l6ZSBvZiB0aGUgc2xpY2UgYWxvbmcgdGhlIGxhc3QgYXhpcy5cbiAqIEByZXR1cm5zIHJlc3VsdCBvZiB0aGUgc2xpY2luZy5cbiAqIEB0aHJvd3MgVmFsdWVFcnJvcjogSWYgYGFycmF5YCBpcyBvZiBhbiB1bnN1cHBvcnRlZCBzdWJ0eXBlIG9mIGB0Zi5UZW5zb3JgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VBbG9uZ0xhc3RBeGlzKFxuICAgIGFycmF5OiBUZW5zb3IsIHN0YXJ0OiBudW1iZXIsIHNpemU6IG51bWJlcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBzd2l0Y2ggKGFycmF5LnJhbmspIHtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIHRmYy5zbGljZTFkKGFycmF5IGFzIFRlbnNvcjFELCBzdGFydCwgc2l6ZSk7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIHJldHVybiB0ZmMuc2xpY2UyZChcbiAgICAgICAgICAgIGFycmF5IGFzIFRlbnNvcjJELCBbMCwgc3RhcnRdLCBbYXJyYXkuc2hhcGVbMF0sIHNpemVdKTtcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgcmV0dXJuIHRmYy5zbGljZTNkKFxuICAgICAgICAgICAgYXJyYXkgYXMgVGVuc29yM0QsIFswLCAwLCBzdGFydF0sXG4gICAgICAgICAgICBbYXJyYXkuc2hhcGVbMF0sIGFycmF5LnNoYXBlWzFdLCBzaXplXSk7XG4gICAgICBjYXNlIDQ6XG4gICAgICAgIHJldHVybiB0ZmMuc2xpY2U0ZChcbiAgICAgICAgICAgIGFycmF5IGFzIFRlbnNvcjRELCBbMCwgMCwgMCwgc3RhcnRdLFxuICAgICAgICAgICAgW2FycmF5LnNoYXBlWzBdLCBhcnJheS5zaGFwZVsxXSwgYXJyYXkuc2hhcGVbMl0sIHNpemVdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYHNsaWNlQWxvbmdMYXN0QXhpcygpIHJlY2VpdmVkIGFuIHVuc3VwcG9ydGVkIHRlbnNvciByYW5rOiBgICtcbiAgICAgICAgICAgIGAke2FycmF5LnJhbmt9YCk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBEbyBzbGljaW5nIGFsb25nIHRoZSBzZXBjaWZpZWQgYXhpcy5cbiAqIEBwYXJhbSBhcnJheSBpbnB1dCBgdGYuVGVuc29yYC5cbiAqIEBwYXJhbSBzdGFydCBzdGFydGluZyBpbmRleCwgaW5jbHVzaXZlLlxuICogQHBhcmFtIHNpemUgb2YgdGhlIHNsaWNlIGFsb25nIHRoZSBjaG9zZW4gYXhpcy5cbiAqIEBwYXJhbSBjaG9vc2UgYW4gYXhpcy5cbiAqIEByZXR1cm5zIHJlc3VsdCBvZiB0aGUgc2xpY2luZy5cbiAqIEB0aHJvd3MgVmFsdWVFcnJvcjogSWYgYGFycmF5YCBpcyBvZiBhbiB1bnN1cHBvcnRlZCBzdWJ0eXBlIG9mIGB0Zi5UZW5zb3JgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VBbG9uZ0F4aXMoXG4gICAgYXJyYXk6IFRlbnNvciwgc3RhcnQ6IG51bWJlciwgc2l6ZTogbnVtYmVyLCBheGlzOiBudW1iZXIpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgc3dpdGNoIChhcnJheS5yYW5rKSB7XG4gICAgICBjYXNlIDE6XG4gICAgICAgIHJldHVybiB0ZmMuc2xpY2UxZChhcnJheSBhcyBUZW5zb3IxRCwgc3RhcnQsIHNpemUpO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBzd2l0Y2ggKGF4aXMpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheSwgc3RhcnQsIHNpemUpO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBzbGljZUFsb25nTGFzdEF4aXMoYXJyYXksIHN0YXJ0LCBzaXplKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgICAgYFRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBgICtcbiAgICAgICAgICAgICAgICBgJHtheGlzfWApO1xuICAgICAgICB9XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHN3aXRjaCAoYXhpcykge1xuICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBzbGljZUFsb25nRmlyc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgcmV0dXJuIHRmYy5zbGljZTNkKFxuICAgICAgICAgICAgICAgIGFycmF5IGFzIFRlbnNvcjNELCBbMCwgc3RhcnQsIDBdLFxuICAgICAgICAgICAgICAgIFthcnJheS5zaGFwZVswXSwgc2l6ZSwgYXJyYXkuc2hhcGVbMl1dKTtcbiAgICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gc2xpY2VBbG9uZ0xhc3RBeGlzKGFycmF5LCBzdGFydCwgc2l6ZSk7XG4gICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICAgIGBUaGUgYXhpcyBpcyBub3Qgd2l0aGluIHRoZSByYW5rIG9mIHRoZSB0ZW5zb3IgYCArXG4gICAgICAgICAgICAgICAgYCR7YXhpc31gKTtcbiAgICAgICAgfVxuICAgICAgY2FzZSA0OlxuICAgICAgICBzd2l0Y2ggKGF4aXMpIHtcbiAgICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheSwgc3RhcnQsIHNpemUpO1xuICAgICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2U0ZChcbiAgICAgICAgICAgICAgICBhcnJheSBhcyBUZW5zb3I0RCwgWzAsIHN0YXJ0LCAwLCAwXSxcbiAgICAgICAgICAgICAgICBbYXJyYXkuc2hhcGVbMF0sIHNpemUsIGFycmF5LnNoYXBlWzJdLCBhcnJheS5zaGFwZVszXV0pO1xuICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0ZmMuc2xpY2U0ZChcbiAgICAgICAgICAgICAgICBhcnJheSBhcyBUZW5zb3I0RCwgWzAsIDAsIHN0YXJ0LCAwXSxcbiAgICAgICAgICAgICAgICBbYXJyYXkuc2hhcGVbMF0sIGFycmF5LnNoYXBlWzFdLCBzaXplLCBhcnJheS5zaGFwZVszXV0pO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIHJldHVybiBzbGljZUFsb25nTGFzdEF4aXMoYXJyYXksIHN0YXJ0LCBzaXplKTtcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgICAgYFRoZSBheGlzIGlzIG5vdCB3aXRoaW4gdGhlIHJhbmsgb2YgdGhlIHRlbnNvciBgICtcbiAgICAgICAgICAgICAgICBgJHtheGlzfWApO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBzbGljZUFsb25nTGFzdEF4aXMoKSByZWNlaXZlZCBhbiB1bnN1cHBvcnRlZCB0ZW5zb3IgcmFuazogYCArXG4gICAgICAgICAgICBgJHthcnJheS5yYW5rfWApO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGVzIGEgbGlzdCBvZiB0ZW5zb3JzIGFsb25nc2lkZSB0aGUgc3BlY2lmaWVkIGF4aXMuXG4gKiBAcGFyYW0gdGVuc29ycyBgQXJyYXlgIG9mIHRlbnNvcnMgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcGFyYW0gYXhpcyBDb25jYXRlbmF0aW9uIGF4aXMuXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSBjb25jYXRlbmF0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0ZW5hdGUodGVuc29yczogVGVuc29yW10sIGF4aXMgPSAtMSk6IFRlbnNvciB7XG4gIGxldCByYW5rOiBudW1iZXI7XG4gIGlmIChheGlzIDwgMCkge1xuICAgIHJhbmsgPSB0ZW5zb3JzWzBdLnJhbms7XG4gICAgaWYgKHJhbmsgIT09IDApIHtcbiAgICAgIGF4aXMgPSByYW5rO1xuICAgIH0gZWxzZSB7XG4gICAgICBheGlzID0gMDtcbiAgICB9XG4gIH1cbiAgaWYgKGF4aXMgPT09IHRlbnNvcnNbMF0ucmFuaykge1xuICAgIC8vIFBvcnRpbmcgTm90ZTogVGhpcyBpcyBuZWNlc3NhcnkgYmVjYXVzZSB0ZmMuY29uY2F0KCkgcmVxdWlyZXMgYXhpcyB0byBiZVxuICAgIC8vICAgaW4gdGhlIGludGVydmFsIFstcmFuaywgcmFuaykuXG4gICAgYXhpcyA9IC0xO1xuICB9XG4gIC8vIFBvcnRpbmcgTm90ZTogU3BhcnNlIGNvbmNhdCBpcyBub3Qgc3VwcG9ydGVkIHlldC5cbiAgcmV0dXJuIHRmYy5jb25jYXQodGVuc29ycywgYXhpcyk7XG59XG5cbi8qKlxuICogQ29uY2F0ZW5hdGUgdHdvIGFycmF5cyBhbG9uZyB0aGUgZmlyc3QgZGltZW5zaW9uLlxuICogQHBhcmFtIGEgVGhlIDFzdCBgdGYuVGVuc29yYCB0byBjb25jYXRlbmF0ZS5cbiAqIEBwYXJhbSBiIFRoZSAybmQgYHRmLlRlbnNvcmAgdG8gY29uY2F0ZW5hdGUuXG4gKiBAcmV0dXJucyBSZXN1bHQgb2YgdGhlIGNvbmNhdGVuYXRpb24uXG4gKiBAdGhyb3dzIFZhbHVlRXJyb3I6IElmIGBhYCBpcyBvZiBhbiB1bnN1cHBvcnRlZCBzdWJ0eXBlIG9mIGB0Zi5UZW5zb3JgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0QWxvbmdGaXJzdEF4aXMoYTogVGVuc29yLCBiOiBUZW5zb3IpOiBUZW5zb3Ige1xuICBzd2l0Y2ggKGEucmFuaykge1xuICAgIGNhc2UgMTpcbiAgICAgIHJldHVybiB0ZmMuY29uY2F0MWQoW2EgYXMgVGVuc29yMUQsIGIgYXMgVGVuc29yMURdKTtcbiAgICBjYXNlIDI6XG4gICAgICByZXR1cm4gdGZjLmNvbmNhdDJkKFthIGFzIFRlbnNvcjJELCBiIGFzIFRlbnNvcjJEXSwgMCk7XG4gICAgY2FzZSAzOlxuICAgICAgcmV0dXJuIHRmYy5jb25jYXQzZChbYSBhcyBUZW5zb3IzRCwgYiBhcyBUZW5zb3IzRF0sIDApO1xuICAgIGNhc2UgNDpcbiAgICAgIHJldHVybiB0ZmMuY29uY2F0NGQoW2EgYXMgVGVuc29yNEQsIGIgYXMgVGVuc29yNERdLCAwKTtcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYGNvbmNhdEFsb25nRmlyc3RBeGlzKCkgcmVjZWl2ZWQgYW4gdW5zdXBwb3J0ZWQgYCArXG4gICAgICAgICAgYHRlbnNvciByYW5rOiAke2EucmFua31gKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSB0ZW5zb3IgYnkgdGlsaW5nIGB4YCBieSBgbmAuXG4gKiBAcGFyYW0geCBBIHRlbnNvci5cbiAqIEBwYXJhbSBuIEFuIEFycmF5IG9mIGludGVnZXJzIG9yIGEgc2luZ2xlIGludGVnZXIuIElmIGFuIEFycmF5LCB0aGUgbGVuZ3RoXG4gKiAgIG11c3QgYmUgdGhlIHNhbWUgYXMgdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIGB4YC4gSWYgYSBzaW5nbGUgaW50ZWdlcixcbiAqICAgaXQgd2lsbCBiZSB0cmVhdGVkIGFzIGFuIEFycmF5IG9mIGxlbmd0aCAxLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGlsZSh4OiBUZW5zb3IsIG46IG51bWJlcnxudW1iZXJbXSk6IFRlbnNvciB7XG4gIGlmICghQXJyYXkuaXNBcnJheShuKSkge1xuICAgIG4gPSBbbl07XG4gIH1cbiAgaWYgKHgucmFuayAhPT0gbi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgYFRoZSBsZW5ndGggb2YgaW5wdXQgbiAoJHtuLmxlbmd0aH0pIGRvZXMgbm90IG1hdGNoIGAgK1xuICAgICAgICBgdGhlIG51bWJlciBvZiBkaW1lbnNpb25zIGluIGlucHV0IHggKCR7eC5yYW5rfSlgKTtcbiAgfVxuICByZXR1cm4gdGZjLnRpbGUoeCwgbik7XG59XG5cbi8qIENyZWF0aW9uIG9mIHJhbmRvbSB0ZW5zb3JzLiAqL1xuXG4vKipcbiAqIEdldCBhIHRlbnNvciB3aXRoIG5vcm1hbCBkaXN0cmlidXRpb24gb2YgdmFsdWVzLlxuICpcbiAqIEBwYXJhbSBzaGFwZSBTaGFwZSBvZiB0aGUgdGVuc29yLlxuICogQHBhcmFtIG1lYW4gbWVhbiB2YWx1ZSBvZiB0aGUgbm9ybWFsIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSBzdGRkZXYgc3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSBub3JtYWwgZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIGR0eXBlXG4gKiBAcGFyYW0gc2VlZFxuICogQHJldHVybiBUaGUgbm9ybWFsIHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbU5vcm1hbChcbiAgICBzaGFwZTogU2hhcGUsIG1lYW4gPSAwLjAsIHN0ZGRldiA9IDEuMCwgZHR5cGU/OiAnZmxvYXQzMid8J2ludDMyJyxcbiAgICBzZWVkPzogbnVtYmVyKTogVGVuc29yIHtcbiAgcmV0dXJuIHRmYy5yYW5kb21Ob3JtYWwoc2hhcGUsIG1lYW4sIHN0ZGRldiwgZHR5cGUsIHNlZWQpO1xufVxuXG4vKiBMaW5lYXIgQWxnZWJyYSAqL1xuXG4vKipcbiAqIE11bHRpcGx5IHR3byB0ZW5zb3JzIGFuZCByZXR1cm5zIHRoZSByZXN1bHQgYXMgYSB0ZW5zb3IuXG4gKlxuICogRm9yIDJEIHRlbnNvcnMsIHRoaXMgaXMgZXF1aXZhbGVudCB0byBtYXRyaXggbXVsdGlwbGljYXRpb24gKG1hdE11bCkuXG4gKiBGb3IgdGVuc29ycyBvZiBoaWdoZXIgcmFua3MsIGl0IGZvbGxvd3MgdGhlIFRoZWFubyBiZWhhdmlvcixcbiAqIChlLmcuIGAoMiwgMykgKiAoNCwgMywgNSkgLT4gKDIsIDQsIDUpYCkuICBGcm9tIHRoZSBUaGVhbm8gZG9jdW1lbnRhdGlvbjpcbiAqXG4gKiBGb3IgTiBkaW1lbnNpb25zIGl0IGlzIGEgc3VtIHByb2R1Y3Qgb3ZlciB0aGUgbGFzdCBheGlzIG9mIHggYW5kIHRoZVxuICogc2Vjb25kLXRvLWxhc3Qgb2YgeTpcbiAqXG4gKiBAcGFyYW0gYSBBIHRlbnNvciBvZiBhdCBsZWFzdCByYW5rIDIuXG4gKiBAcGFyYW0gYiBBIHRlbnNvciBvZiBhdCBsZWFzdCByYW5rIDIuXG4gKiBAcGFyYW0gYWN0aXZhdGlvbiAob3B0aW9uYWwpIEEgc3RyaW5nIGlkZW50aWZ5aW5nIHRoZSBhY3RpdmF0aW9uXG4gKiAgIGZ1bmN0aW9uLlxuICogQHJldHVybiBSZXN1bHQgb2YgdGhlIGRvdCBvcGVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkb3QoXG4gICAgYTogVGVuc29yLCBiOiBUZW5zb3IsIGFjdGl2YXRpb24/OiB0ZmMuZnVzZWQuQWN0aXZhdGlvbixcbiAgICBiaWFzPzogVGVuc29yKTogVGVuc29yIHtcbiAgaWYgKChhLnJhbmsgPCAyKSB8fCAoYi5yYW5rIDwgMikpIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgYGRvdCByZXF1aXJlcyBib3RoIGlucHV0cyB0byBiZSByYW5rID49IDJgICtcbiAgICAgICAgYCBidXQgZ290IHggc2hhcGUgPSAke2Euc2hhcGV9IGFuZCB5IHNoYXBlID0gJHtiLnNoYXBlfWApO1xuICB9XG4gIGlmIChiLnJhbmsgPj0gMykge1xuICAgIGNvbnN0IHhMYXN0RGltID0gYS5zaGFwZS5zbGljZSgtMSlbMF07XG4gICAgY29uc3QgeVNlY29uZExhc3REaW0gPSBiLnNoYXBlLnNsaWNlKC0yKVswXTtcbiAgICBpZiAoeExhc3REaW0gIT09IHlTZWNvbmRMYXN0RGltKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICBgSWYgcmFuayB5ID49IDMsIHRoZW4gdGhlIHNlY29uZCBsYXN0IGRpbWAgK1xuICAgICAgICAgIGAgb2YgeSBtdXN0IGVxdWFsIHRoZSBsYXN0IGRpbSBvZiB4IGJ1dCBnb3QgeCBzaGFwZSA9ICR7XG4gICAgICAgICAgICAgIGEuc2hhcGV9IGFuZCBgICtcbiAgICAgICAgICBgIHkgc2hhcGUgPSAke2Iuc2hhcGV9YCk7XG4gICAgfVxuICB9XG4gIC8vIEhhbmRsZSBiYXNpYyAyRCB4IDJEIGNhc2UuXG4gIGlmICgoYS5yYW5rID09PSAyKSAmJiAoYi5yYW5rID09PSAyKSkge1xuICAgIGNvbnN0IHRyYW5zcG9zZUEgPSBmYWxzZTtcbiAgICBjb25zdCB0cmFuc3Bvc2VCID0gZmFsc2U7XG4gICAgLy8gdGZjLmZ1c2VkLm1hdE11bCBvbmx5IGZ1c2VzIGNlcnRhaW4gYWN0aXZhdGlvbiBmdW5jdGlvbnMuIFVuc3VwcG9ydGVkXG4gICAgLy8gYWN0aXZhdGlvbiBmdW5jdGlvbnMgYXJlIHRyZWF0ZWQgYXMgJ2xpbmVhcicgYWN0aXZhdGlvbnMsIHdoaWNoIGlzXG4gICAgLy8gZXF1aXZhbGVudCB0byBhIG5vLW9wLlxuICAgIHJldHVybiB0ZmMuZnVzZWQubWF0TXVsKHtcbiAgICAgIGEsXG4gICAgICBiOiBiIGFzIFRlbnNvcjJELFxuICAgICAgdHJhbnNwb3NlQSxcbiAgICAgIHRyYW5zcG9zZUIsXG4gICAgICBiaWFzOiBiaWFzID8gcmVzaGFwZUJpYXMoYS5yYW5rLCBiaWFzLCBpbWFnZURhdGFGb3JtYXQoKSkgOiBudWxsLFxuICAgICAgYWN0aXZhdGlvblxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIC8vIFJlc2hhcGUgeCBpbnRvIHRoZSBhbmFsb2dvdXMgMkQgVGVuc29yLlxuICAgIGNvbnN0IGFGaXJzdERpbXMgPSBhLnNoYXBlLnNsaWNlKCk7ICAvLyBIb2xkcyBhbGwgYnV0IHRoZSBsYXN0IGRpbSBvZiB4LlxuICAgIGNvbnN0IGFMYXN0RGltID0gYUZpcnN0RGltcy5wb3AoKTtcbiAgICBhID0gdGZjLnJlc2hhcGUoYSwgWy0xLCBhTGFzdERpbV0pO1xuXG4gICAgLy8gUmVzaGFwZSB5IGludG8gdGhlIGFuYWxvZ291cyAyRCBUZW5zb3IsIGFuZCBrZWVwIHRyYWNrIG9mIHRoZVxuICAgIC8vIHJlcXVpcmVkIGRpbWVuc2lvbnMgdG8gcmVwcm9kdWNlIHRoZSBvdXRwdXQgc2hhcGUuXG4gICAgY29uc3QgYlNoYXBlID0gYi5zaGFwZS5zbGljZSgpO1xuICAgIGNvbnN0IGJMYXN0RGltID0gYlNoYXBlLnBvcCgpO1xuICAgIGNvbnN0IHlTZWNvbmRMYXN0RGltID0gYlNoYXBlLnBvcCgpO1xuICAgIGNvbnN0IHlPdGhlckRpbXMgPSBbLi4uYlNoYXBlLCBiTGFzdERpbV07XG4gICAgLy8gcGVybXV0YXRpb24gc2hvdWxkIGJlIGxpa2UgW3ItMiwgMCwgMSwgMiwgLi4uIHItNCwgci0zLCByLTFdXG4gICAgLy8gd2hlcmUgciBpcyB0aGUgcmFuayBvZiB5LlxuICAgIGNvbnN0IHBlcm0gPSBBcnJheS5mcm9tKHtsZW5ndGg6IGIucmFua30sIChfLCBpKSA9PiB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICByZXR1cm4gYi5yYW5rIC0gMjtcbiAgICAgIH0gZWxzZSBpZiAoaSA8PSBiLnJhbmsgLSAyKSB7XG4gICAgICAgIHJldHVybiBpIC0gMTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpO1xuICAgIH0pO1xuICAgIGIgPSB0ZmMucmVzaGFwZSh0ZmMudHJhbnNwb3NlKGIsIHBlcm0pLCBbeVNlY29uZExhc3REaW0sIC0xXSk7XG5cbiAgICAvLyBNdWx0aXBseSB4IGFuZCB5IGFzIDJEIFRlbnNvcnMsIGFuZCB0aGVuIHJlc2hhcGUgYmFjayB0byBvcmlnaW5hbC5cbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IFsuLi5hRmlyc3REaW1zLCAuLi55T3RoZXJEaW1zXTtcbiAgICBjb25zdCB0cmFuc3Bvc2VBID0gZmFsc2U7XG4gICAgY29uc3QgdHJhbnNwb3NlQiA9IGZhbHNlO1xuICAgIHJldHVybiB0ZmMucmVzaGFwZShcbiAgICAgICAgdGZjLmZ1c2VkLm1hdE11bCh7XG4gICAgICAgICAgYSxcbiAgICAgICAgICBiLFxuICAgICAgICAgIHRyYW5zcG9zZUEsXG4gICAgICAgICAgdHJhbnNwb3NlQixcbiAgICAgICAgICBiaWFzOiBiaWFzID8gcmVzaGFwZUJpYXMoYS5yYW5rLCBiaWFzLCBpbWFnZURhdGFGb3JtYXQoKSkgOiBudWxsLFxuICAgICAgICAgIGFjdGl2YXRpb25cbiAgICAgICAgfSksXG4gICAgICAgIG91dHB1dFNoYXBlKTtcbiAgfVxufVxuXG4vKipcbiAqIENvbXB1dGUgdGhlIHNpZ24gVGVuc29yIG9mIGFuIGlucHV0IFRlbnNvci5cbiAqXG4gKiBFbGVtZW50cyBvZiB0aGUgaW5wdXQgYHRmLlRlbnNvcmAgdGhhdCBhcmUgPT09IDAgYXJlIG1hcHBlZCB0byAwLlxuICogRWxlbWVudHMgb2YgdGhlIGlucHV0IGB0Zi5UZW5zb3JgIHRoYXQgYXJlID4gMCBhcmUgbWFwcGVkIHRvIDEuXG4gKiBFbGVtZW50cyBvZiB0aGUgaW5wdXQgYHRmLlRlbnNvcmAgdGhhdCBhcmUgPCAwIGFyZSBtYXBwZWQgdG8gLTEuXG4gKlxuICogQHBhcmFtIHggSW5wdXQgYHRmLlRlbnNvcmAuXG4gKiBAcmV0dXJuIFRoZSBzaWduIGB0Zi5UZW5zb3JgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2lnbih4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAvLyBUT0RPKGNhaXMpOiBNb3ZlIHRvIHRoZSBjb3JlLlxuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgemVyb3NMaWtlWCA9IGNvcmVaZXJvc0xpa2UoeCk7XG4gICAgY29uc3Qgb25lc0xpa2VYID0gY29yZU9uZXNMaWtlKHgpO1xuICAgIHJldHVybiB3aGVyZShcbiAgICAgICAgdGZjLmVxdWFsKHgsIHplcm9zTGlrZVgpLCB6ZXJvc0xpa2VYLFxuICAgICAgICB3aGVyZShcbiAgICAgICAgICAgIHRmYy5ncmVhdGVyKHgsIGNvcmVaZXJvc0xpa2UoeCkpLCBvbmVzTGlrZVgsXG4gICAgICAgICAgICB0ZmMubXVsKC0xLCBvbmVzTGlrZVgpKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBvbmUtaG90IHJlcHJlc2VudGF0aW9uIG9mIGFuIGludGVnZXIgdGVuc29yLlxuICogQHBhcmFtIGluZGljZXMgbkQgaW50ZWdlciB0ZW5zb3Igb2Ygc2hhcGVcbiAqICAgYChiYXRjaF9zaXplLCBkaW0xLCBkaW0yLCAuLi4gZGltKG4tMSkpYFxuICogQHBhcmFtIG51bUNsYXNzZXMgSW50ZWdlciwgbnVtYmVyIG9mIGNsYXNzZXMgdG8gY29uc2lkZXIuXG4gKiBAcmV0dXJucyAobiArIDEpRCBvbmUgaG90IHJlcHJlc2VudGF0aW9uIG9mIHRoZSBpbnB1dFxuICogICB3aXRoIHNoYXBlIGAoYmF0Y2hfc2l6ZSwgZGltMSwgZGltMiwgLi4uIGRpbShuLTEpLCBudW1fY2xhc3NlcylgXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmVIb3QoaW5kaWNlczogVGVuc29yLCBudW1DbGFzc2VzOiBudW1iZXIpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKGluZGljZXMucmFuayAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdPbmx5IDFEIG9uZS1ob3QgdGVuc29ycyBhcmUgc3VwcG9ydGVkIGluIHRoZSAnICtcbiAgICAgICAgICAnZGVlcGxlYXJuIGJhY2tlbmQsIGF0IHByZXNlbnQuJyk7XG4gICAgfVxuICAgIGluZGljZXMgPSB0ZmMuY2FzdChpbmRpY2VzLCAnaW50MzInKTtcbiAgICByZXR1cm4gdGZjLmNhc3QodGZjLm9uZUhvdChpbmRpY2VzIGFzIFRlbnNvcjFELCBudW1DbGFzc2VzKSwgJ2Zsb2F0MzInKTtcbiAgfSk7XG59XG5cbi8qIEVsZW1lbnRhcnkgbWF0aCBmdW5jdGlvbnMuICovXG5cbi8qKlxuICogUmV0cmlldmVzIHRoZSBlbGVtZW50cyBvZiBpbmRpY2VzIGBpbmRpY2VzYCBpbiB0aGUgdGVuc29yIGByZWZlcmVuY2VgLlxuICogQHBhcmFtIHJlZmVyZW5jZSBBIHRlbnNvci5cbiAqIEBwYXJhbSBpbmRpY2VzIEFuIGludGVnZXIgdGVuc29yIG9mIGluZGljZXMgb3IgYW4gYEFycmF5YCBvZiBpbnRlZ2Vycy5cbiAqIEBwYXJhbSBheGlzIEF4aXMgYWxvbmcgd2hpY2ggdG8gcGVyZm9ybSB0aGUgZ2F0aGVyIG9wZXJhdGlvbi5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIGdhdGhlcmluZyBhcyBhIHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdhdGhlcihcbiAgICByZWZlcmVuY2U6IFRlbnNvciwgaW5kaWNlczogbnVtYmVyW118VGVuc29yMUQsIGF4aXM/OiBudW1iZXIpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoaW5kaWNlcykpIHtcbiAgICAgIGluZGljZXMgPSB0ZW5zb3IxZChpbmRpY2VzLCAnaW50MzInKTtcbiAgICB9IGVsc2Uge1xuICAgICAgaW5kaWNlcyA9IHRmYy5jYXN0KGluZGljZXMsICdpbnQzMicpO1xuICAgIH1cbiAgICByZXR1cm4gdGZjLmdhdGhlcihyZWZlcmVuY2UsIGluZGljZXMsIGF4aXMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBFbGVtZW50LXdpc2Ugc3F1YXJlLlxuICogQHBhcmFtIHggSW5wdXQgdGVuc29yLlxuICogQHJldHVybiBlbGVtZW50LXdpc2UgeF4yXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmUoeDogVGVuc29yKTogVGVuc29yIHtcbiAgcmV0dXJuIHRmYy5tdWwoeCwgeCk7XG59XG5cbi8qKlxuICogRWxlbWVudC13aXNlIGV4cG9uZW50aWF0aW9uLlxuICpcbiAqIFBvcnRpbmcgTm90ZTogSW4gUHlLZXJhcywgYGFgICh0aGUgZXhwb25lbnQpIGlzIGEgUHl0aG9uIGludGVnZXIsIHdoaWNoXG4gKiAgIHRha2VzIGFkdmF0bmFnZSBvZiB0aGUgYmFja2VuZCdzIChlLmcuLCBUZW5zb3JGbG93J3MpIGF1dG9tYXRpY1xuICogY29udmVyc2lvbiB0byB0ZW5zb3IuIEhlcmUgd2UgYWxsb3cgYGFgIHRvIGJlIGVpdGhlciBhIG51bWJlciBvciBhIHRlbnNvci5cbiAqXG4gKiBAcGFyYW0geCBUaGUgYmFzZSB0ZW5zb3IuXG4gKiBAcGFyYW0gYSBUaGUgZXhwb25lbnQsIHRlbnNvciBvciBudW1iZXIuIElmIGEgbnVtYmVyLCBpdCBpcyByb3VuZGVkIHRvIHRoZVxuICogICBuZWFyZXN0IGludGVnZXIgYW5kIGNvbnZlcnRlZCB0byBhIHRlbnNvci5cbiAqIEByZXR1cm5zIEEgdGVuc29yIG9mIHRoZSBzYW1lIHNoYXBlIGFzIGB4YC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHBvdyh4OiBUZW5zb3IsIGE6IFRlbnNvcnxudW1iZXIpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKHR5cGVvZiAoYSkgPT09ICdudW1iZXInKSB7XG4gICAgICBhID0gc2NhbGFyKE1hdGgucm91bmQoYSksICdpbnQzMicpO1xuICAgIH1cbiAgICBpZiAoYS5kdHlwZSAhPT0gJ2ludDMyJykge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgYE5vbi1pbnQzMiBkdHlwZSAoJHthLmR0eXBlfSkgaXMgbm90IHN1cHBvcnRlZCBieSBwb3coKSB5ZXRgKTtcbiAgICB9XG4gICAgcmV0dXJuIHRmYy5wb3coeCwgYSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIFJlc2hhcGVzIGJpYXMgdGVuc29yIGFjY29yZGluZyB0byByYW5rIG9mIHguXG4gKi9cbmZ1bmN0aW9uIHJlc2hhcGVCaWFzKHhSYW5rOiBudW1iZXIsIGJpYXM6IFRlbnNvciwgZGF0YUZvcm1hdDogc3RyaW5nKSB7XG4gIGNvbnN0IGJpYXNTaGFwZSA9IGJpYXMuc2hhcGU7XG5cbiAgaWYgKGJpYXMucmFuayAhPT0gMSAmJiBiaWFzLnJhbmsgIT09IHhSYW5rKSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgIGBVbmV4cGVjdGVkIGJpYXMgZGltZW5zaW9uczogJHtiaWFzLnJhbmt9YCArXG4gICAgICAgIGA7IGV4cGVjdGVkIGl0IHRvIGJlIDEgb3IgJHt4UmFua31gKTtcbiAgfVxuXG4gIGlmICh4UmFuayA9PT0gNSkge1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgIGlmIChiaWFzU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0ZmMucmVzaGFwZShiaWFzLCBbMSwgYmlhc1NoYXBlWzBdLCAxLCAxLCAxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGZjLnJlc2hhcGUoXG4gICAgICAgICAgICBiaWFzLCBbMSwgYmlhc1NoYXBlWzNdLCBiaWFzU2hhcGVbMF0sIGJpYXNTaGFwZVsxXSwgYmlhc1NoYXBlWzJdXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgaWYgKGJpYXNTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRmYy5yZXNoYXBlKGJpYXMsIFsxLCAxLCAxLCAxLCBiaWFzU2hhcGVbMF1dKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZmMucmVzaGFwZShiaWFzLCBbMV0uY29uY2F0KGJpYXNTaGFwZSkpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmICh4UmFuayA9PT0gNCkge1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgIGlmIChiaWFzU2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiB0ZmMucmVzaGFwZShiaWFzLCBbMSwgYmlhc1NoYXBlWzBdLCAxLCAxXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGZjLnJlc2hhcGUoYmlhcywgWzEsIGJpYXNTaGFwZVsyXSwgYmlhc1NoYXBlWzBdLCBiaWFzU2hhcGVbMV1dKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICBpZiAoYmlhc1NoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGZjLnJlc2hhcGUoYmlhcywgWzEsIDEsIDEsIGJpYXNTaGFwZVswXV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRmYy5yZXNoYXBlKGJpYXMsIFsxXS5jb25jYXQoYmlhc1NoYXBlKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHhSYW5rID09PSAzKSB7XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgaWYgKGJpYXNTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgcmV0dXJuIHRmYy5yZXNoYXBlKGJpYXMsIFsxLCBiaWFzU2hhcGVbMF0sIDFdKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0ZmMucmVzaGFwZShiaWFzLCBbMSwgYmlhc1NoYXBlWzFdLCBiaWFzU2hhcGVbMF1dKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICBpZiAoYmlhc1NoYXBlLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZXR1cm4gdGZjLnJlc2hhcGUoYmlhcywgWzEsIDEsIGJpYXNTaGFwZVswXV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRmYy5yZXNoYXBlKGJpYXMsIFsxXS5jb25jYXQoYmlhc1NoYXBlKSk7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2UgaWYgKHhSYW5rIDwgMykge1xuICAgIHJldHVybiBiaWFzO1xuICB9XG4gIHRocm93IG5ldyBWYWx1ZUVycm9yKGBVbnN1cHBvcnRlZCBpbnB1dCByYW5rIGJ5IGJpYXNBZGQ6ICR7Ymlhcy5yYW5rfWApO1xufVxuXG4vKiBOZXVyYWwtbmV0d29yayBvcGVyYXRpb25zLiAqL1xuXG4vKipcbiAqIEFkZCBhIGJpYXMgdG8gYSB0ZW5zb3IuXG4gKlxuICogQHBhcmFtIHggVGhlIHRlbnNvciB0byBhZGQgdGhlIGJpYXMgdG8uXG4gKiBAcGFyYW0gYmlhcyBUaGUgYmlhcyB0byBhZGQgdG8gYHhgLiBNdXN0IGJlIDFEIG9yIHRoZSBzYW1lIHJhbmsgYXMgYHhgLlxuICogQHJldHVybiBSZXN1bHQgb2YgdGhlIGJpYXMgYWRkaW5nLlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBJZiB0aGUgcmFuayBvZiBgYmlhc2AgaXMgaW5jb3JyZWN0LlxuICovXG5leHBvcnQgZnVuY3Rpb24gYmlhc0FkZChcbiAgICB4OiBUZW5zb3IsIGJpYXM6IFRlbnNvciwgZGF0YUZvcm1hdD86IERhdGFGb3JtYXQpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKGRhdGFGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgZGF0YUZvcm1hdCA9IGltYWdlRGF0YUZvcm1hdCgpO1xuICAgIH1cbiAgICBjaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG5cbiAgICByZXR1cm4gdGZjLmFkZCh4LCByZXNoYXBlQmlhcyh4LnJhbmssIGJpYXMsIGRhdGFGb3JtYXQpKTtcbiAgfSk7XG59XG5cbi8qKlxuICogRXhwb25lbnRpYWwgbGluZWFyIHVuaXQgKEVMVSkuXG4gKiBAcGFyYW0geCBBIHRlbnNvciBvciB2YXJpYWJsZSB0byBjb21wdXRlIHRoZSBhY3RpdmF0aW9uIGZ1bmN0aW9uIGZvci5cbiAqIEBwYXJhbSBhbHBoYTogQSBzY2FsYXIsIGEgc2NhbGluZyBmYWN0b3IgZm9yIHRoZSBuZWdhdGl2ZSBzZWN0aW9uLlxuICogQHJldHVybiBPdXRwdXQgb2YgdGhlIEVMVSBvcGVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBlbHUoeDogVGVuc29yLCBhbHBoYSA9IDEpOiBUZW5zb3Ige1xuICAvLyBUT0RPKGNhaXMpOiBBZGQgc3VwcG9ydCBmb3IgYWxwaGEgdmFsdWVzIG90aGVyIHRoYW4gMS5cbiAgaWYgKGFscGhhICE9PSAxKSB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgIGBTdXBwb3J0IGZvciBhbHBoYSB2YWx1ZXMgb3RoZXIgdGhhbiAxICgke2FscGhhfSkgaXMgbm90IGltcGxlbWVudGVkIGAgK1xuICAgICAgICBgeWV0LmApO1xuICB9XG4gIHJldHVybiB0ZmMuZWx1KHgpO1xufVxuXG4vKipcbiAqIFNvZnRzaWduIG9mIGEgdGVuc29yLlxuICpcbiAqIERlZmluZWQgYXMgeCAvIChhYnMoeCkgKyAxKSwgZWxlbWVudC13aXNlLlxuICpcbiAqIEBwYXJhbSB4OiBJbnB1dC5cbiAqIEByZXR1cm5zIE91dHB1dC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNvZnRzaWduKHg6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHRmYy5kaXYoeCwgdGZjLmFkZCh0ZmMuYWJzKHgpLCAxKSkpO1xufVxuXG4vKipcbiAqIFNldHMgZW50cmllcyBpbiBgeGAgdG8gemVybyBhdCByYW5kb20sIHdoaWxlIHNjYWxpbmcgdGhlIGVudGlyZSB0ZW5zb3IuXG4gKlxuICogQHBhcmFtIHggaW5wdXQgdGVuc29yLlxuICogQHBhcmFtIGxldmVsIGZyYWN0aW9uIG9mIHRoZSBlbnRyaWVzIGluIHRoZSB0ZW5zb3IgdGhhdCB3aWxsIGJlIHNldCB0byAwLlxuICogQHBhcmFtIG5vaXNlU2hhcGUgc2hhcGUgb2YgcmFuZG9tbHkgZ2VuZXJhdGVkIGtlZXAvZHJvcCBmbGFncywgbXVzdCBiZVxuICogICBicm9hZGNhc3RhYmxlIHRvIHRoZSBzaGFwZSBvZiBgeGAuIE9wdGlvbmFsLlxuICogQHBhcmFtIHNlZWQgcmFuZG9tIHNlZWQgdG8gZW5zdXJlIGRldGVybWluaXNtLiBPcHRpb25hbC5cbiAqIEByZXR1cm5zIFJlc3VsdCBvZiB0aGUgZHJvcG91dCBvcGVyYXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkcm9wb3V0KFxuICAgIHg6IFRlbnNvciwgbGV2ZWw6IG51bWJlciwgbm9pc2VTaGFwZT86IG51bWJlcltdLCBzZWVkPzogbnVtYmVyKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4gdGZjLmRyb3BvdXQoeCwgbGV2ZWwsIG5vaXNlU2hhcGUsIHNlZWQpKTtcbn1cblxuLyoqXG4gKiBFbGVtZW50LXdpc2UsIHNlZ21lbnQtd2lzZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBvZiBzaWdtb2lkLlxuICpcbiAqIFJldHVybnMgYDAuYCBpZiBgeCA8IC0yLjVgLCBgMS5gIGlmIGB4ID4gMi41YC5cbiAqIEluIGAtMi41IDw9IHggPD0gMi41YCwgcmV0dXJucyBgMC4yICogeCArIDAuNWAuXG4gKlxuICogQHBhcmFtIHggSW5wdXQgdGVuc29yLlxuICogQHJldHVybnMgT3V0cHV0IHRlbnNvci5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGhhcmRTaWdtb2lkKHg6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCB5ID0gdGZjLmFkZCguNSwgdGZjLm11bCguMiwgeCkpO1xuICAgIHJldHVybiB0ZmMuY2xpcEJ5VmFsdWUoeSwgMCwgMSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIEludm9rZSBgeGAgaW4gdGhlIHRyYWluaW5nIHBoYXNlLCBhbmQgYGFsdGAgb3RoZXJ3aXNlLlxuICpcbiAqIFBvcnRpbmcgTm90ZTogV2UgZG8gbm90IGNyZWF0ZSBwbGFjZWhvbGRlciB0ZW5zb3JzIGZvciB0aGUgYHRyYWluaW5nYFxuICogYm9vbGVhbiBmbGFnIGhlcmUsIGJlY2F1c2UgdGhlcmUgaXMgbm8gc3VjaCB0aGluZyBpbiB0aGUgVEYuanMgaW1wZXJhdGl2ZVxuICogYmFja2VuZC5cbiAqXG4gKiBAcGFyYW0geCBUaGUgZnVuY3Rpb24gdG8gaW52b2tlIGlmZiBgdHJhaW5pbmdgIGlzIGB0cnVlYC5cbiAqIEBwYXJhbSBhbHQgVGhlIGZ1bmN0aW9uIHRvIGludm9rZSBpZmYgYHRyYWluaW5nYCBpcyBgZmFsc2VgLlxuICogQHBhcmFtIHRyYWluaW5nIEJvb2xlYW4gZmxhZyBmb3Igd2hldGhlciB0cmFpbmluZyBwaGFzZSBpcyBhY3RpdmUuXG4gKiBAcmV0dXJucyBUaGUgcmV0dXJuIHZhbHVlIG9mIGB4KClgIGlmIGB0cmFpbmluZ2AgaXMgYHRydWVgLCBvciB0aGUgcmV0dXJuXG4gKiAgIHZhbHVlIG9mIGBhbHQoKWAgaWYgYHRyYWluaW5nYCBpcyBgZmFsc2VgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaW5UcmFpblBoYXNlPFQ+KHg6ICgpID0+IFQsIGFsdDogKCkgPT4gVCwgdHJhaW5pbmcgPSBmYWxzZSk6IFQge1xuICByZXR1cm4gdHJhaW5pbmcgPyB4KCkgOiBhbHQoKTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nexport const VALID_FAN_MODE_VALUES = ['fanIn', 'fanOut', 'fanAvg'];\nexport const VALID_DISTRIBUTION_VALUES = ['normal', 'uniform', 'truncatedNormal'];\n// We can't easily extract a string[] from the string union type, but we can\n// recapitulate the list, enforcing at compile time that the values are valid\n// and that we have the right number of them.\n/**\n * A string array of valid Initializer class names.\n *\n * This is guaranteed to match the `InitializerClassName` union type.\n */\nexport const initializerClassNames = [\n    'Zeros', 'Ones', 'Constant', 'RandomNormal', 'RandomUniform',\n    'TruncatedNormal', 'VarianceScaling', 'Orthogonal', 'Identity'\n];\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdGlhbGl6ZXJfY29uZmlnLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2tlcmFzX2Zvcm1hdC9pbml0aWFsaXplcl9jb25maWcudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFRSCxNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBRyxDQUFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFPbkUsTUFBTSxDQUFDLE1BQU0seUJBQXlCLEdBQ2xDLENBQUMsUUFBUSxFQUFFLFNBQVMsRUFBRSxpQkFBaUIsQ0FBQyxDQUFDO0FBNEU3Qyw0RUFBNEU7QUFDNUUsNkVBQTZFO0FBQzdFLDZDQUE2QztBQUU3Qzs7OztHQUlHO0FBQ0gsTUFBTSxDQUFDLE1BQU0scUJBQXFCLEdBQTJCO0lBQzNELE9BQU8sRUFBRSxNQUFNLEVBQUUsVUFBVSxFQUFFLGNBQWMsRUFBRSxlQUFlO0lBQzVELGlCQUFpQixFQUFFLGlCQUFpQixFQUFFLFlBQVksRUFBRSxVQUFVO0NBQy9ELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge0Jhc2VTZXJpYWxpemF0aW9ufSBmcm9tICcuL3R5cGVzJztcblxuLy8gVE9ETyhzb2VyZ2VsKTogTW92ZSB0aGUgQ2FtZWxDYXNlIHZlcnNpb25zIGJhY2sgb3V0IG9mIGtlcmFzX2Zvcm1hdFxuLy8gZS5nLiB0byBzcmMvY29tbW9uLnRzLiAgTWF5YmUgZXZlbiBkdXBsaWNhdGUgKmFsbCogb2YgdGhlc2UgdG8gYmUgcGVkYW50aWM/XG4vKiogQGRvY2lubGluZSAqL1xuZXhwb3J0IHR5cGUgRmFuTW9kZSA9ICdmYW5Jbid8J2Zhbk91dCd8J2ZhbkF2Zyc7XG5leHBvcnQgY29uc3QgVkFMSURfRkFOX01PREVfVkFMVUVTID0gWydmYW5JbicsICdmYW5PdXQnLCAnZmFuQXZnJ107XG5cbi8vIFRoZXNlIGNvbnN0YW50cyBoYXZlIGEgc25ha2UgdnMuIGNhbWVsIGRpc3RpbmN0aW9uLlxuZXhwb3J0IHR5cGUgRmFuTW9kZVNlcmlhbGl6YXRpb24gPSAnZmFuX2luJ3wnZmFuX291dCd8J2Zhbl9hdmcnO1xuXG4vKiogQGRvY2lubGluZSAqL1xuZXhwb3J0IHR5cGUgRGlzdHJpYnV0aW9uID0gJ25vcm1hbCd8J3VuaWZvcm0nfCd0cnVuY2F0ZWROb3JtYWwnO1xuZXhwb3J0IGNvbnN0IFZBTElEX0RJU1RSSUJVVElPTl9WQUxVRVMgPVxuICAgIFsnbm9ybWFsJywgJ3VuaWZvcm0nLCAndHJ1bmNhdGVkTm9ybWFsJ107XG4vLyBUaGVzZSBjb25zdGFudHMgaGF2ZSBhIHNuYWtlIHZzLiBjYW1lbCBkaXN0aW5jdGlvbi5cbmV4cG9ydCB0eXBlIERpc3RyaWJ1dGlvblNlcmlhbGl6YXRpb24gPSAnbm9ybWFsJ3wndW5pZm9ybSd8J3RydW5jYXRlZF9ub3JtYWwnO1xuXG5leHBvcnQgdHlwZSBaZXJvc1NlcmlhbGl6YXRpb24gPSBCYXNlU2VyaWFsaXphdGlvbjwnWmVyb3MnLCB7fT47XG5cbmV4cG9ydCB0eXBlIE9uZXNTZXJpYWxpemF0aW9uID0gQmFzZVNlcmlhbGl6YXRpb248J09uZXMnLCB7fT47XG5cbmV4cG9ydCB0eXBlIENvbnN0YW50Q29uZmlnID0ge1xuICB2YWx1ZTogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgQ29uc3RhbnRTZXJpYWxpemF0aW9uID1cbiAgICBCYXNlU2VyaWFsaXphdGlvbjwnQ29uc3RhbnQnLCBDb25zdGFudENvbmZpZz47XG5cbmV4cG9ydCB0eXBlIFJhbmRvbU5vcm1hbENvbmZpZyA9IHtcbiAgbWVhbj86IG51bWJlcjtcbiAgc3RkZGV2PzogbnVtYmVyO1xuICBzZWVkPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgUmFuZG9tTm9ybWFsU2VyaWFsaXphdGlvbiA9XG4gICAgQmFzZVNlcmlhbGl6YXRpb248J1JhbmRvbU5vcm1hbCcsIFJhbmRvbU5vcm1hbENvbmZpZz47XG5cbmV4cG9ydCB0eXBlIFJhbmRvbVVuaWZvcm1Db25maWcgPSB7XG4gIG1pbnZhbD86IG51bWJlcjtcbiAgbWF4dmFsPzogbnVtYmVyO1xuICBzZWVkPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgUmFuZG9tVW5pZm9ybVNlcmlhbGl6YXRpb24gPVxuICAgIEJhc2VTZXJpYWxpemF0aW9uPCdSYW5kb21Vbmlmb3JtJywgUmFuZG9tVW5pZm9ybUNvbmZpZz47XG5cbmV4cG9ydCB0eXBlIFRydW5jYXRlZE5vcm1hbENvbmZpZyA9IHtcbiAgbWVhbj86IG51bWJlcjtcbiAgc3RkZGV2PzogbnVtYmVyO1xuICBzZWVkPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgVHJ1bmNhdGVkTm9ybWFsU2VyaWFsaXphdGlvbiA9XG4gICAgQmFzZVNlcmlhbGl6YXRpb248J1RydW5jYXRlZE5vcm1hbCcsIFRydW5jYXRlZE5vcm1hbENvbmZpZz47XG5cbmV4cG9ydCB0eXBlIFZhcmlhbmNlU2NhbGluZ0NvbmZpZyA9IHtcbiAgc2NhbGU/OiBudW1iZXI7XG5cbiAgbW9kZT86IEZhbk1vZGVTZXJpYWxpemF0aW9uO1xuICBkaXN0cmlidXRpb24/OiBEaXN0cmlidXRpb25TZXJpYWxpemF0aW9uO1xuICBzZWVkPzogbnVtYmVyO1xufTtcblxuZXhwb3J0IHR5cGUgVmFyaWFuY2VTY2FsaW5nU2VyaWFsaXphdGlvbiA9XG4gICAgQmFzZVNlcmlhbGl6YXRpb248J1ZhcmlhbmNlU2NhbGluZycsIFZhcmlhbmNlU2NhbGluZ0NvbmZpZz47XG5cbmV4cG9ydCB0eXBlIE9ydGhvZ29uYWxDb25maWcgPSB7XG4gIHNlZWQ/OiBudW1iZXI7XG4gIGdhaW4/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBPcnRob2dvbmFsU2VyaWFsaXphdGlvbiA9XG4gICAgQmFzZVNlcmlhbGl6YXRpb248J09ydGhvZ29uYWwnLCBPcnRob2dvbmFsQ29uZmlnPjtcblxuZXhwb3J0IHR5cGUgSWRlbnRpdHlDb25maWcgPSB7XG4gIGdhaW4/OiBudW1iZXI7XG59O1xuXG5leHBvcnQgdHlwZSBJZGVudGl0eVNlcmlhbGl6YXRpb24gPVxuICAgIEJhc2VTZXJpYWxpemF0aW9uPCdJZGVudGl0eScsIElkZW50aXR5Q29uZmlnPjtcblxuLy8gVXBkYXRlIGluaXRpYWxpemVyQ2xhc3NOYW1lcyBiZWxvdyBpbiBjb25jZXJ0IHdpdGggdGhpcy5cbmV4cG9ydCB0eXBlIEluaXRpYWxpemVyU2VyaWFsaXphdGlvbiA9IFplcm9zU2VyaWFsaXphdGlvbnxPbmVzU2VyaWFsaXphdGlvbnxcbiAgICBDb25zdGFudFNlcmlhbGl6YXRpb258UmFuZG9tVW5pZm9ybVNlcmlhbGl6YXRpb258UmFuZG9tTm9ybWFsU2VyaWFsaXphdGlvbnxcbiAgICBUcnVuY2F0ZWROb3JtYWxTZXJpYWxpemF0aW9ufElkZW50aXR5U2VyaWFsaXphdGlvbnxcbiAgICBWYXJpYW5jZVNjYWxpbmdTZXJpYWxpemF0aW9ufE9ydGhvZ29uYWxTZXJpYWxpemF0aW9uO1xuXG5leHBvcnQgdHlwZSBJbml0aWFsaXplckNsYXNzTmFtZSA9IEluaXRpYWxpemVyU2VyaWFsaXphdGlvblsnY2xhc3NfbmFtZSddO1xuXG4vLyBXZSBjYW4ndCBlYXNpbHkgZXh0cmFjdCBhIHN0cmluZ1tdIGZyb20gdGhlIHN0cmluZyB1bmlvbiB0eXBlLCBidXQgd2UgY2FuXG4vLyByZWNhcGl0dWxhdGUgdGhlIGxpc3QsIGVuZm9yY2luZyBhdCBjb21waWxlIHRpbWUgdGhhdCB0aGUgdmFsdWVzIGFyZSB2YWxpZFxuLy8gYW5kIHRoYXQgd2UgaGF2ZSB0aGUgcmlnaHQgbnVtYmVyIG9mIHRoZW0uXG5cbi8qKlxuICogQSBzdHJpbmcgYXJyYXkgb2YgdmFsaWQgSW5pdGlhbGl6ZXIgY2xhc3MgbmFtZXMuXG4gKlxuICogVGhpcyBpcyBndWFyYW50ZWVkIHRvIG1hdGNoIHRoZSBgSW5pdGlhbGl6ZXJDbGFzc05hbWVgIHVuaW9uIHR5cGUuXG4gKi9cbmV4cG9ydCBjb25zdCBpbml0aWFsaXplckNsYXNzTmFtZXM6IEluaXRpYWxpemVyQ2xhc3NOYW1lW10gPSBbXG4gICdaZXJvcycsICdPbmVzJywgJ0NvbnN0YW50JywgJ1JhbmRvbU5vcm1hbCcsICdSYW5kb21Vbmlmb3JtJyxcbiAgJ1RydW5jYXRlZE5vcm1hbCcsICdWYXJpYW5jZVNjYWxpbmcnLCAnT3J0aG9nb25hbCcsICdJZGVudGl0eSdcbl07XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { eye, linalg, mul, ones, randomUniform, scalar, serialization, tidy, transpose, truncatedNormal, zeros } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { checkDataFormat } from './common';\nimport { NotImplementedError, ValueError } from './errors';\nimport { VALID_DISTRIBUTION_VALUES, VALID_FAN_MODE_VALUES } from './keras_format/initializer_config';\nimport { checkStringTypeUnionValue, deserializeKerasObject, serializeKerasObject } from './utils/generic_utils';\nimport { arrayProd } from './utils/math_utils';\nexport function checkFanMode(value) {\n    checkStringTypeUnionValue(VALID_FAN_MODE_VALUES, 'FanMode', value);\n}\nexport function checkDistribution(value) {\n    checkStringTypeUnionValue(VALID_DISTRIBUTION_VALUES, 'Distribution', value);\n}\n/**\n * Initializer base class.\n *\n * @doc {\n *   heading: 'Initializers', subheading: 'Classes', namespace: 'initializers'}\n */\nexport class Initializer extends serialization.Serializable {\n    fromConfigUsesCustomObjects() {\n        return false;\n    }\n    getConfig() {\n        return {};\n    }\n}\nexport class Zeros extends Initializer {\n    apply(shape, dtype) {\n        return zeros(shape, dtype);\n    }\n}\n/** @nocollapse */\nZeros.className = 'Zeros';\nserialization.registerClass(Zeros);\nexport class Ones extends Initializer {\n    apply(shape, dtype) {\n        return ones(shape, dtype);\n    }\n}\n/** @nocollapse */\nOnes.className = 'Ones';\nserialization.registerClass(Ones);\nexport class Constant extends Initializer {\n    constructor(args) {\n        super();\n        if (typeof args !== 'object') {\n            throw new ValueError(`Expected argument of type ConstantConfig but got ${args}`);\n        }\n        if (args.value === undefined) {\n            throw new ValueError(`config must have value set but got ${args}`);\n        }\n        this.value = args.value;\n    }\n    apply(shape, dtype) {\n        return tidy(() => mul(scalar(this.value), ones(shape, dtype)));\n    }\n    getConfig() {\n        return {\n            value: this.value,\n        };\n    }\n}\n/** @nocollapse */\nConstant.className = 'Constant';\nserialization.registerClass(Constant);\nexport class RandomUniform extends Initializer {\n    constructor(args) {\n        super();\n        this.DEFAULT_MINVAL = -0.05;\n        this.DEFAULT_MAXVAL = 0.05;\n        this.minval = args.minval || this.DEFAULT_MINVAL;\n        this.maxval = args.maxval || this.DEFAULT_MAXVAL;\n        this.seed = args.seed;\n    }\n    apply(shape, dtype) {\n        return randomUniform(shape, this.minval, this.maxval, dtype);\n    }\n    getConfig() {\n        return { minval: this.minval, maxval: this.maxval, seed: this.seed };\n    }\n}\n/** @nocollapse */\nRandomUniform.className = 'RandomUniform';\nserialization.registerClass(RandomUniform);\nexport class RandomNormal extends Initializer {\n    constructor(args) {\n        super();\n        this.DEFAULT_MEAN = 0.;\n        this.DEFAULT_STDDEV = 0.05;\n        this.mean = args.mean || this.DEFAULT_MEAN;\n        this.stddev = args.stddev || this.DEFAULT_STDDEV;\n        this.seed = args.seed;\n    }\n    apply(shape, dtype) {\n        dtype = dtype || 'float32';\n        if (dtype !== 'float32' && dtype !== 'int32') {\n            throw new NotImplementedError(`randomNormal does not support dType ${dtype}.`);\n        }\n        return K.randomNormal(shape, this.mean, this.stddev, dtype, this.seed);\n    }\n    getConfig() {\n        return { mean: this.mean, stddev: this.stddev, seed: this.seed };\n    }\n}\n/** @nocollapse */\nRandomNormal.className = 'RandomNormal';\nserialization.registerClass(RandomNormal);\nexport class TruncatedNormal extends Initializer {\n    constructor(args) {\n        super();\n        this.DEFAULT_MEAN = 0.;\n        this.DEFAULT_STDDEV = 0.05;\n        this.mean = args.mean || this.DEFAULT_MEAN;\n        this.stddev = args.stddev || this.DEFAULT_STDDEV;\n        this.seed = args.seed;\n    }\n    apply(shape, dtype) {\n        dtype = dtype || 'float32';\n        if (dtype !== 'float32' && dtype !== 'int32') {\n            throw new NotImplementedError(`truncatedNormal does not support dType ${dtype}.`);\n        }\n        return truncatedNormal(shape, this.mean, this.stddev, dtype, this.seed);\n    }\n    getConfig() {\n        return { mean: this.mean, stddev: this.stddev, seed: this.seed };\n    }\n}\n/** @nocollapse */\nTruncatedNormal.className = 'TruncatedNormal';\nserialization.registerClass(TruncatedNormal);\nexport class Identity extends Initializer {\n    constructor(args) {\n        super();\n        this.gain = args.gain != null ? args.gain : 1.0;\n    }\n    apply(shape, dtype) {\n        return tidy(() => {\n            if (shape.length !== 2 || shape[0] !== shape[1]) {\n                throw new ValueError('Identity matrix initializer can only be used for' +\n                    ' 2D square matrices.');\n            }\n            else {\n                return mul(this.gain, eye(shape[0]));\n            }\n        });\n    }\n    getConfig() {\n        return { gain: this.gain };\n    }\n}\n/** @nocollapse */\nIdentity.className = 'Identity';\nserialization.registerClass(Identity);\n/**\n * Computes the number of input and output units for a weight shape.\n * @param shape Shape of weight.\n * @param dataFormat data format to use for convolution kernels.\n *   Note that all kernels in Keras are standardized on the\n *   CHANNEL_LAST ordering (even when inputs are set to CHANNEL_FIRST).\n * @return An length-2 array: fanIn, fanOut.\n */\nfunction computeFans(shape, dataFormat = 'channelsLast') {\n    let fanIn;\n    let fanOut;\n    checkDataFormat(dataFormat);\n    if (shape.length === 2) {\n        fanIn = shape[0];\n        fanOut = shape[1];\n    }\n    else if ([3, 4, 5].indexOf(shape.length) !== -1) {\n        if (dataFormat === 'channelsFirst') {\n            const receptiveFieldSize = arrayProd(shape, 2);\n            fanIn = shape[1] * receptiveFieldSize;\n            fanOut = shape[0] * receptiveFieldSize;\n        }\n        else if (dataFormat === 'channelsLast') {\n            const receptiveFieldSize = arrayProd(shape, 0, shape.length - 2);\n            fanIn = shape[shape.length - 2] * receptiveFieldSize;\n            fanOut = shape[shape.length - 1] * receptiveFieldSize;\n        }\n    }\n    else {\n        const shapeProd = arrayProd(shape);\n        fanIn = Math.sqrt(shapeProd);\n        fanOut = Math.sqrt(shapeProd);\n    }\n    return [fanIn, fanOut];\n}\nexport class VarianceScaling extends Initializer {\n    /**\n     * Constructor of VarianceScaling.\n     * @throws ValueError for invalid value in scale.\n     */\n    constructor(args) {\n        super();\n        if (args.scale < 0.0) {\n            throw new ValueError(`scale must be a positive float. Got: ${args.scale}`);\n        }\n        this.scale = args.scale == null ? 1.0 : args.scale;\n        this.mode = args.mode == null ? 'fanIn' : args.mode;\n        checkFanMode(this.mode);\n        this.distribution =\n            args.distribution == null ? 'normal' : args.distribution;\n        checkDistribution(this.distribution);\n        this.seed = args.seed;\n    }\n    apply(shape, dtype) {\n        const fans = computeFans(shape);\n        const fanIn = fans[0];\n        const fanOut = fans[1];\n        let scale = this.scale;\n        if (this.mode === 'fanIn') {\n            scale /= Math.max(1, fanIn);\n        }\n        else if (this.mode === 'fanOut') {\n            scale /= Math.max(1, fanOut);\n        }\n        else {\n            scale /= Math.max(1, (fanIn + fanOut) / 2);\n        }\n        if (this.distribution === 'normal') {\n            const stddev = Math.sqrt(scale);\n            dtype = dtype || 'float32';\n            if (dtype !== 'float32' && dtype !== 'int32') {\n                throw new NotImplementedError(`${this.getClassName()} does not support dType ${dtype}.`);\n            }\n            return truncatedNormal(shape, 0, stddev, dtype, this.seed);\n        }\n        else {\n            const limit = Math.sqrt(3 * scale);\n            return randomUniform(shape, -limit, limit, dtype);\n        }\n    }\n    getConfig() {\n        return {\n            scale: this.scale,\n            mode: this.mode,\n            distribution: this.distribution,\n            seed: this.seed\n        };\n    }\n}\n/** @nocollapse */\nVarianceScaling.className = 'VarianceScaling';\nserialization.registerClass(VarianceScaling);\nexport class GlorotUniform extends VarianceScaling {\n    /**\n     * Constructor of GlorotUniform\n     * @param scale\n     * @param mode\n     * @param distribution\n     * @param seed\n     */\n    constructor(args) {\n        super({\n            scale: 1.0,\n            mode: 'fanAvg',\n            distribution: 'uniform',\n            seed: args == null ? null : args.seed\n        });\n    }\n    getClassName() {\n        // In Python Keras, GlorotUniform is not a class, but a helper method\n        // that creates a VarianceScaling object. Use 'VarianceScaling' as\n        // class name to be compatible with that.\n        return VarianceScaling.className;\n    }\n}\n/** @nocollapse */\nGlorotUniform.className = 'GlorotUniform';\nserialization.registerClass(GlorotUniform);\nexport class GlorotNormal extends VarianceScaling {\n    /**\n     * Constructor of GlorotNormal.\n     * @param scale\n     * @param mode\n     * @param distribution\n     * @param seed\n     */\n    constructor(args) {\n        super({\n            scale: 1.0,\n            mode: 'fanAvg',\n            distribution: 'normal',\n            seed: args == null ? null : args.seed\n        });\n    }\n    getClassName() {\n        // In Python Keras, GlorotNormal is not a class, but a helper method\n        // that creates a VarianceScaling object. Use 'VarianceScaling' as\n        // class name to be compatible with that.\n        return VarianceScaling.className;\n    }\n}\n/** @nocollapse */\nGlorotNormal.className = 'GlorotNormal';\nserialization.registerClass(GlorotNormal);\nexport class HeNormal extends VarianceScaling {\n    constructor(args) {\n        super({\n            scale: 2.0,\n            mode: 'fanIn',\n            distribution: 'normal',\n            seed: args == null ? null : args.seed\n        });\n    }\n    getClassName() {\n        // In Python Keras, HeNormal is not a class, but a helper method\n        // that creates a VarianceScaling object. Use 'VarianceScaling' as\n        // class name to be compatible with that.\n        return VarianceScaling.className;\n    }\n}\n/** @nocollapse */\nHeNormal.className = 'HeNormal';\nserialization.registerClass(HeNormal);\nexport class HeUniform extends VarianceScaling {\n    constructor(args) {\n        super({\n            scale: 2.0,\n            mode: 'fanIn',\n            distribution: 'uniform',\n            seed: args == null ? null : args.seed\n        });\n    }\n    getClassName() {\n        // In Python Keras, HeUniform is not a class, but a helper method\n        // that creates a VarianceScaling object. Use 'VarianceScaling' as\n        // class name to be compatible with that.\n        return VarianceScaling.className;\n    }\n}\n/** @nocollapse */\nHeUniform.className = 'HeUniform';\nserialization.registerClass(HeUniform);\nexport class LeCunNormal extends VarianceScaling {\n    constructor(args) {\n        super({\n            scale: 1.0,\n            mode: 'fanIn',\n            distribution: 'normal',\n            seed: args == null ? null : args.seed\n        });\n    }\n    getClassName() {\n        // In Python Keras, LeCunNormal is not a class, but a helper method\n        // that creates a VarianceScaling object. Use 'VarianceScaling' as\n        // class name to be compatible with that.\n        return VarianceScaling.className;\n    }\n}\n/** @nocollapse */\nLeCunNormal.className = 'LeCunNormal';\nserialization.registerClass(LeCunNormal);\nexport class LeCunUniform extends VarianceScaling {\n    constructor(args) {\n        super({\n            scale: 1.0,\n            mode: 'fanIn',\n            distribution: 'uniform',\n            seed: args == null ? null : args.seed\n        });\n    }\n    getClassName() {\n        // In Python Keras, LeCunUniform is not a class, but a helper method\n        // that creates a VarianceScaling object. Use 'VarianceScaling' as\n        // class name to be compatible with that.\n        return VarianceScaling.className;\n    }\n}\n/** @nocollapse */\nLeCunUniform.className = 'LeCunNormal';\nserialization.registerClass(LeCunUniform);\nexport class Orthogonal extends Initializer {\n    constructor(args) {\n        super();\n        this.DEFAULT_GAIN = 1;\n        this.gain = args.gain == null ? this.DEFAULT_GAIN : args.gain;\n        this.seed = args.seed;\n        if (this.seed != null) {\n            throw new NotImplementedError('Random seed is not implemented for Orthogonal Initializer yet.');\n        }\n    }\n    apply(shape, dtype) {\n        return tidy(() => {\n            if (shape.length < 2) {\n                throw new NotImplementedError('Shape must be at least 2D.');\n            }\n            if (shape[0] * shape[1] > 2000) {\n                console.warn(`Orthogonal initializer is being called on a matrix with more ` +\n                    `than 2000 (${shape[0] * shape[1]}) elements: ` +\n                    `Slowness may result.`);\n            }\n            // TODO(cais): Add seed support.\n            const normalizedShape = shape[0] > shape[1] ? [shape[1], shape[0]] : shape;\n            const a = K.randomNormal(normalizedShape, 0, 1, 'float32');\n            let q = linalg.gramSchmidt(a);\n            if (shape[0] > shape[1]) {\n                q = transpose(q);\n            }\n            return mul(this.gain, q);\n        });\n    }\n    getConfig() {\n        return {\n            gain: this.gain,\n            seed: this.seed,\n        };\n    }\n}\n/** @nocollapse */\nOrthogonal.className = 'Orthogonal';\nserialization.registerClass(Orthogonal);\n// Maps the JavaScript-like identifier keys to the corresponding registry\n// symbols.\nexport const INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {\n    'constant': 'Constant',\n    'glorotNormal': 'GlorotNormal',\n    'glorotUniform': 'GlorotUniform',\n    'heNormal': 'HeNormal',\n    'heUniform': 'HeUniform',\n    'identity': 'Identity',\n    'leCunNormal': 'LeCunNormal',\n    'leCunUniform': 'LeCunUniform',\n    'ones': 'Ones',\n    'orthogonal': 'Orthogonal',\n    'randomNormal': 'RandomNormal',\n    'randomUniform': 'RandomUniform',\n    'truncatedNormal': 'TruncatedNormal',\n    'varianceScaling': 'VarianceScaling',\n    'zeros': 'Zeros'\n};\nfunction deserializeInitializer(config, customObjects = {}) {\n    return deserializeKerasObject(config, serialization.SerializationMap.getMap().classNameMap, customObjects, 'initializer');\n}\nexport function serializeInitializer(initializer) {\n    return serializeKerasObject(initializer);\n}\nexport function getInitializer(identifier) {\n    if (typeof identifier === 'string') {\n        const className = identifier in INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?\n            INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :\n            identifier;\n        /* We have four 'helper' classes for common initializers that\n        all get serialized as 'VarianceScaling' and shouldn't go through\n        the deserializeInitializer pathway. */\n        if (className === 'GlorotNormal') {\n            return new GlorotNormal();\n        }\n        else if (className === 'GlorotUniform') {\n            return new GlorotUniform();\n        }\n        else if (className === 'HeNormal') {\n            return new HeNormal();\n        }\n        else if (className === 'HeUniform') {\n            return new HeUniform();\n        }\n        else if (className === 'LeCunNormal') {\n            return new LeCunNormal();\n        }\n        else if (className === 'LeCunUniform') {\n            return new LeCunUniform();\n        }\n        else {\n            const config = {};\n            config['className'] = className;\n            config['config'] = {};\n            return deserializeInitializer(config);\n        }\n    }\n    else if (identifier instanceof Initializer) {\n        return identifier;\n    }\n    else {\n        return deserializeInitializer(identifier);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5pdGlhbGl6ZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2luaXRpYWxpemVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILE9BQU8sRUFBVyxHQUFHLEVBQUUsTUFBTSxFQUFFLEdBQUcsRUFBRSxJQUFJLEVBQUUsYUFBYSxFQUFFLE1BQU0sRUFBRSxhQUFhLEVBQW9CLElBQUksRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLEtBQUssRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRXhLLE9BQU8sS0FBSyxDQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDNUMsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUN6QyxPQUFPLEVBQUMsbUJBQW1CLEVBQUUsVUFBVSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBRXpELE9BQU8sRUFBd0IseUJBQXlCLEVBQUUscUJBQXFCLEVBQUMsTUFBTSxtQ0FBbUMsQ0FBQztBQUMxSCxPQUFPLEVBQUMseUJBQXlCLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUM5RyxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFFN0MsTUFBTSxVQUFVLFlBQVksQ0FBQyxLQUFjO0lBQ3pDLHlCQUF5QixDQUFDLHFCQUFxQixFQUFFLFNBQVMsRUFBRSxLQUFLLENBQUMsQ0FBQztBQUNyRSxDQUFDO0FBRUQsTUFBTSxVQUFVLGlCQUFpQixDQUFDLEtBQWM7SUFDOUMseUJBQXlCLENBQUMseUJBQXlCLEVBQUUsY0FBYyxFQUFFLEtBQUssQ0FBQyxDQUFDO0FBQzlFLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sT0FBZ0IsV0FBWSxTQUFRLGFBQWEsQ0FBQyxZQUFZO0lBQzNELDJCQUEyQjtRQUNoQyxPQUFPLEtBQUssQ0FBQztJQUNmLENBQUM7SUFTRCxT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Q3hELFVBQVUsQ0FBQztRQUNmOzs4Q0FFc0M7UUFDdEMsSUFBSSxTQUFTLEtBQUssY0FBYyxFQUFFO1lBQ2hDLE9BQU8sSUFBSSxZQUFZLEVBQUUsQ0FBQztTQUMzQjthQUFNLElBQUksU0FBUyxLQUFLLGVBQWUsRUFBRTtZQUN4QyxPQUFPLElBQUksYUFBYSxFQUFFLENBQUM7U0FDNUI7YUFBTSxJQUFJLFNBQVMsS0FBSyxVQUFVLEVBQUU7WUFDbkMsT0FBTyxJQUFJLFFBQVEsRUFBRSxDQUFDO1NBQ3ZCO2FBQU0sSUFBSSxTQUFTLEtBQUssV0FBVyxFQUFFO1lBQ3BDLE9BQU8sSUFBSSxTQUFTLEVBQUUsQ0FBQztTQUN4QjthQUFNLElBQUksU0FBUyxLQUFLLGFBQWEsRUFBRTtZQUN0QyxPQUFPLElBQUksV0FBVyxFQUFFLENBQUM7U0FDMUI7YUFBTSxJQUFJLFNBQVMsS0FBSyxjQUFjLEVBQUU7WUFDdkMsT0FBTyxJQUFJLFlBQVksRUFBRSxDQUFDO1NBQzNCO2FBQU07WUFDTCxNQUFNLE1BQU0sR0FBNkIsRUFBRSxDQUFDO1lBQzVDLE1BQU0sQ0FBQyxXQUFXLENBQUMsR0FBRyxTQUFTLENBQUM7WUFDaEMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxHQUFHLEVBQUUsQ0FBQztZQUN0QixPQUFPLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDO1NBQ3ZDO0tBQ0Y7U0FBTSxJQUFJLFVBQVUsWUFBWSxXQUFXLEVBQUU7UUFDNUMsT0FBTyxVQUFVLENBQUM7S0FDbkI7U0FBTTtRQUNMLE9BQU8sc0JBQXNCLENBQUMsVUFBVSxDQUFDLENBQUM7S0FDM0M7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtEYXRhVHlwZSwgZXllLCBsaW5hbGcsIG11bCwgb25lcywgcmFuZG9tVW5pZm9ybSwgc2NhbGFyLCBzZXJpYWxpemF0aW9uLCBUZW5zb3IsIFRlbnNvcjJELCB0aWR5LCB0cmFuc3Bvc2UsIHRydW5jYXRlZE5vcm1hbCwgemVyb3N9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCAqIGFzIEsgZnJvbSAnLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge2NoZWNrRGF0YUZvcm1hdH0gZnJvbSAnLi9jb21tb24nO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge0RhdGFGb3JtYXQsIFNoYXBlfSBmcm9tICcuL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuaW1wb3J0IHtEaXN0cmlidXRpb24sIEZhbk1vZGUsIFZBTElEX0RJU1RSSUJVVElPTl9WQUxVRVMsIFZBTElEX0ZBTl9NT0RFX1ZBTFVFU30gZnJvbSAnLi9rZXJhc19mb3JtYXQvaW5pdGlhbGl6ZXJfY29uZmlnJztcbmltcG9ydCB7Y2hlY2tTdHJpbmdUeXBlVW5pb25WYWx1ZSwgZGVzZXJpYWxpemVLZXJhc09iamVjdCwgc2VyaWFsaXplS2VyYXNPYmplY3R9IGZyb20gJy4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQge2FycmF5UHJvZH0gZnJvbSAnLi91dGlscy9tYXRoX3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGNoZWNrRmFuTW9kZSh2YWx1ZT86IHN0cmluZyk6IHZvaWQge1xuICBjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0ZBTl9NT0RFX1ZBTFVFUywgJ0Zhbk1vZGUnLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0Rpc3RyaWJ1dGlvbih2YWx1ZT86IHN0cmluZyk6IHZvaWQge1xuICBjaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFZBTElEX0RJU1RSSUJVVElPTl9WQUxVRVMsICdEaXN0cmlidXRpb24nLCB2YWx1ZSk7XG59XG5cbi8qKlxuICogSW5pdGlhbGl6ZXIgYmFzZSBjbGFzcy5cbiAqXG4gKiBAZG9jIHtcbiAqICAgaGVhZGluZzogJ0luaXRpYWxpemVycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgbmFtZXNwYWNlOiAnaW5pdGlhbGl6ZXJzJ31cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIEluaXRpYWxpemVyIGV4dGVuZHMgc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUge1xuICBwdWJsaWMgZnJvbUNvbmZpZ1VzZXNDdXN0b21PYmplY3RzKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvKipcbiAgICogR2VuZXJhdGUgYW4gaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHNoYXBlXG4gICAqIEBwYXJhbSBkdHlwZVxuICAgKiBAcmV0dXJuIFRoZSBpbml0IHZhbHVlLlxuICAgKi9cbiAgYWJzdHJhY3QgYXBwbHkoc2hhcGU6IFNoYXBlLCBkdHlwZT86IERhdGFUeXBlKTogVGVuc29yO1xuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgWmVyb3MgZXh0ZW5kcyBJbml0aWFsaXplciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ1plcm9zJztcblxuICBhcHBseShzaGFwZTogU2hhcGUsIGR0eXBlPzogRGF0YVR5cGUpOiBUZW5zb3Ige1xuICAgIHJldHVybiB6ZXJvcyhzaGFwZSwgZHR5cGUpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoWmVyb3MpO1xuXG5leHBvcnQgY2xhc3MgT25lcyBleHRlbmRzIEluaXRpYWxpemVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnT25lcyc7XG5cbiAgYXBwbHkoc2hhcGU6IFNoYXBlLCBkdHlwZT86IERhdGFUeXBlKTogVGVuc29yIHtcbiAgICByZXR1cm4gb25lcyhzaGFwZSwgZHR5cGUpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoT25lcyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ29uc3RhbnRBcmdzIHtcbiAgLyoqIFRoZSB2YWx1ZSBmb3IgZWFjaCBlbGVtZW50IGluIHRoZSB2YXJpYWJsZS4gKi9cbiAgdmFsdWU6IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIENvbnN0YW50IGV4dGVuZHMgSW5pdGlhbGl6ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdDb25zdGFudCc7XG4gIHByaXZhdGUgdmFsdWU6IG51bWJlcjtcbiAgY29uc3RydWN0b3IoYXJnczogQ29uc3RhbnRBcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICBpZiAodHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgYXJndW1lbnQgb2YgdHlwZSBDb25zdGFudENvbmZpZyBidXQgZ290ICR7YXJnc31gKTtcbiAgICB9XG4gICAgaWYgKGFyZ3MudmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYGNvbmZpZyBtdXN0IGhhdmUgdmFsdWUgc2V0IGJ1dCBnb3QgJHthcmdzfWApO1xuICAgIH1cbiAgICB0aGlzLnZhbHVlID0gYXJncy52YWx1ZTtcbiAgfVxuXG4gIGFwcGx5KHNoYXBlOiBTaGFwZSwgZHR5cGU/OiBEYXRhVHlwZSk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4gbXVsKHNjYWxhcih0aGlzLnZhbHVlKSwgb25lcyhzaGFwZSwgZHR5cGUpKSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IHRoaXMudmFsdWUsXG4gICAgfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnN0YW50KTtcblxuZXhwb3J0IGludGVyZmFjZSBSYW5kb21Vbmlmb3JtQXJncyB7XG4gIC8qKiBMb3dlciBib3VuZCBvZiB0aGUgcmFuZ2Ugb2YgcmFuZG9tIHZhbHVlcyB0byBnZW5lcmF0ZS4gKi9cbiAgbWludmFsPzogbnVtYmVyO1xuICAvKiogVXBwZXIgYm91bmQgb2YgdGhlIHJhbmdlIG9mIHJhbmRvbSB2YWx1ZXMgdG8gZ2VuZXJhdGUuICovXG4gIG1heHZhbD86IG51bWJlcjtcbiAgLyoqIFVzZWQgdG8gc2VlZCB0aGUgcmFuZG9tIGdlbmVyYXRvci4gKi9cbiAgc2VlZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFJhbmRvbVVuaWZvcm0gZXh0ZW5kcyBJbml0aWFsaXplciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ1JhbmRvbVVuaWZvcm0nO1xuICByZWFkb25seSBERUZBVUxUX01JTlZBTCA9IC0wLjA1O1xuICByZWFkb25seSBERUZBVUxUX01BWFZBTCA9IDAuMDU7XG4gIHByaXZhdGUgbWludmFsOiBudW1iZXI7XG4gIHByaXZhdGUgbWF4dmFsOiBudW1iZXI7XG4gIHByaXZhdGUgc2VlZDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFJhbmRvbVVuaWZvcm1BcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1pbnZhbCA9IGFyZ3MubWludmFsIHx8IHRoaXMuREVGQVVMVF9NSU5WQUw7XG4gICAgdGhpcy5tYXh2YWwgPSBhcmdzLm1heHZhbCB8fCB0aGlzLkRFRkFVTFRfTUFYVkFMO1xuICAgIHRoaXMuc2VlZCA9IGFyZ3Muc2VlZDtcbiAgfVxuXG4gIGFwcGx5KHNoYXBlOiBTaGFwZSwgZHR5cGU/OiBEYXRhVHlwZSk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHJhbmRvbVVuaWZvcm0oc2hhcGUsIHRoaXMubWludmFsLCB0aGlzLm1heHZhbCwgZHR5cGUpO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgcmV0dXJuIHttaW52YWw6IHRoaXMubWludmFsLCBtYXh2YWw6IHRoaXMubWF4dmFsLCBzZWVkOiB0aGlzLnNlZWR9O1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmFuZG9tVW5pZm9ybSk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUmFuZG9tTm9ybWFsQXJncyB7XG4gIC8qKiBNZWFuIG9mIHRoZSByYW5kb20gdmFsdWVzIHRvIGdlbmVyYXRlLiAqL1xuICBtZWFuPzogbnVtYmVyO1xuICAvKiogU3RhbmRhcmQgZGV2aWF0aW9uIG9mIHRoZSByYW5kb20gdmFsdWVzIHRvIGdlbmVyYXRlLiAqL1xuICBzdGRkZXY/OiBudW1iZXI7XG4gIC8qKiBVc2VkIHRvIHNlZWQgdGhlIHJhbmRvbSBnZW5lcmF0b3IuICovXG4gIHNlZWQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBSYW5kb21Ob3JtYWwgZXh0ZW5kcyBJbml0aWFsaXplciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ1JhbmRvbU5vcm1hbCc7XG4gIHJlYWRvbmx5IERFRkFVTFRfTUVBTiA9IDAuO1xuICByZWFkb25seSBERUZBVUxUX1NURERFViA9IDAuMDU7XG4gIHByaXZhdGUgbWVhbjogbnVtYmVyO1xuICBwcml2YXRlIHN0ZGRldjogbnVtYmVyO1xuICBwcml2YXRlIHNlZWQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBSYW5kb21Ob3JtYWxBcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1lYW4gPSBhcmdzLm1lYW4gfHwgdGhpcy5ERUZBVUxUX01FQU47XG4gICAgdGhpcy5zdGRkZXYgPSBhcmdzLnN0ZGRldiB8fCB0aGlzLkRFRkFVTFRfU1REREVWO1xuICAgIHRoaXMuc2VlZCA9IGFyZ3Muc2VlZDtcbiAgfVxuXG4gIGFwcGx5KHNoYXBlOiBTaGFwZSwgZHR5cGU/OiBEYXRhVHlwZSk6IFRlbnNvciB7XG4gICAgZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gICAgaWYgKGR0eXBlICE9PSAnZmxvYXQzMicgJiYgZHR5cGUgIT09ICdpbnQzMicpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgIGByYW5kb21Ob3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSAke2R0eXBlfS5gKTtcbiAgICB9XG5cbiAgICByZXR1cm4gSy5yYW5kb21Ob3JtYWwoc2hhcGUsIHRoaXMubWVhbiwgdGhpcy5zdGRkZXYsIGR0eXBlLCB0aGlzLnNlZWQpO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgcmV0dXJuIHttZWFuOiB0aGlzLm1lYW4sIHN0ZGRldjogdGhpcy5zdGRkZXYsIHNlZWQ6IHRoaXMuc2VlZH07XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSYW5kb21Ob3JtYWwpO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRydW5jYXRlZE5vcm1hbEFyZ3Mge1xuICAvKiogTWVhbiBvZiB0aGUgcmFuZG9tIHZhbHVlcyB0byBnZW5lcmF0ZS4gKi9cbiAgbWVhbj86IG51bWJlcjtcbiAgLyoqIFN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgcmFuZG9tIHZhbHVlcyB0byBnZW5lcmF0ZS4gKi9cbiAgc3RkZGV2PzogbnVtYmVyO1xuICAvKiogVXNlZCB0byBzZWVkIHRoZSByYW5kb20gZ2VuZXJhdG9yLiAqL1xuICBzZWVkPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgVHJ1bmNhdGVkTm9ybWFsIGV4dGVuZHMgSW5pdGlhbGl6ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdUcnVuY2F0ZWROb3JtYWwnO1xuXG4gIHJlYWRvbmx5IERFRkFVTFRfTUVBTiA9IDAuO1xuICByZWFkb25seSBERUZBVUxUX1NURERFViA9IDAuMDU7XG4gIHByaXZhdGUgbWVhbjogbnVtYmVyO1xuICBwcml2YXRlIHN0ZGRldjogbnVtYmVyO1xuICBwcml2YXRlIHNlZWQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBUcnVuY2F0ZWROb3JtYWxBcmdzKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLm1lYW4gPSBhcmdzLm1lYW4gfHwgdGhpcy5ERUZBVUxUX01FQU47XG4gICAgdGhpcy5zdGRkZXYgPSBhcmdzLnN0ZGRldiB8fCB0aGlzLkRFRkFVTFRfU1REREVWO1xuICAgIHRoaXMuc2VlZCA9IGFyZ3Muc2VlZDtcbiAgfVxuXG4gIGFwcGx5KHNoYXBlOiBTaGFwZSwgZHR5cGU/OiBEYXRhVHlwZSk6IFRlbnNvciB7XG4gICAgZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gICAgaWYgKGR0eXBlICE9PSAnZmxvYXQzMicgJiYgZHR5cGUgIT09ICdpbnQzMicpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgIGB0cnVuY2F0ZWROb3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSAke2R0eXBlfS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRydW5jYXRlZE5vcm1hbChzaGFwZSwgdGhpcy5tZWFuLCB0aGlzLnN0ZGRldiwgZHR5cGUsIHRoaXMuc2VlZCk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICByZXR1cm4ge21lYW46IHRoaXMubWVhbiwgc3RkZGV2OiB0aGlzLnN0ZGRldiwgc2VlZDogdGhpcy5zZWVkfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFRydW5jYXRlZE5vcm1hbCk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSWRlbnRpdHlBcmdzIHtcbiAgLyoqXG4gICAqIE11bHRpcGxpY2F0aXZlIGZhY3RvciB0byBhcHBseSB0byB0aGUgaWRlbnRpdHkgbWF0cml4LlxuICAgKi9cbiAgZ2Fpbj86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIElkZW50aXR5IGV4dGVuZHMgSW5pdGlhbGl6ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdJZGVudGl0eSc7XG4gIHByaXZhdGUgZ2FpbjogbnVtYmVyO1xuICBjb25zdHJ1Y3RvcihhcmdzOiBJZGVudGl0eUFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZ2FpbiA9IGFyZ3MuZ2FpbiAhPSBudWxsID8gYXJncy5nYWluIDogMS4wO1xuICB9XG5cbiAgYXBwbHkoc2hhcGU6IFNoYXBlLCBkdHlwZT86IERhdGFUeXBlKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpZiAoc2hhcGUubGVuZ3RoICE9PSAyIHx8IHNoYXBlWzBdICE9PSBzaGFwZVsxXSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICdJZGVudGl0eSBtYXRyaXggaW5pdGlhbGl6ZXIgY2FuIG9ubHkgYmUgdXNlZCBmb3InICtcbiAgICAgICAgICAgICcgMkQgc3F1YXJlIG1hdHJpY2VzLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG11bCh0aGlzLmdhaW4sIGV5ZShzaGFwZVswXSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgcmV0dXJuIHtnYWluOiB0aGlzLmdhaW59O1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSWRlbnRpdHkpO1xuXG4vKipcbiAqIENvbXB1dGVzIHRoZSBudW1iZXIgb2YgaW5wdXQgYW5kIG91dHB1dCB1bml0cyBmb3IgYSB3ZWlnaHQgc2hhcGUuXG4gKiBAcGFyYW0gc2hhcGUgU2hhcGUgb2Ygd2VpZ2h0LlxuICogQHBhcmFtIGRhdGFGb3JtYXQgZGF0YSBmb3JtYXQgdG8gdXNlIGZvciBjb252b2x1dGlvbiBrZXJuZWxzLlxuICogICBOb3RlIHRoYXQgYWxsIGtlcm5lbHMgaW4gS2VyYXMgYXJlIHN0YW5kYXJkaXplZCBvbiB0aGVcbiAqICAgQ0hBTk5FTF9MQVNUIG9yZGVyaW5nIChldmVuIHdoZW4gaW5wdXRzIGFyZSBzZXQgdG8gQ0hBTk5FTF9GSVJTVCkuXG4gKiBAcmV0dXJuIEFuIGxlbmd0aC0yIGFycmF5OiBmYW5JbiwgZmFuT3V0LlxuICovXG5mdW5jdGlvbiBjb21wdXRlRmFucyhcbiAgICBzaGFwZTogU2hhcGUsIGRhdGFGb3JtYXQ6IERhdGFGb3JtYXQgPSAnY2hhbm5lbHNMYXN0Jyk6IG51bWJlcltdIHtcbiAgbGV0IGZhbkluOiBudW1iZXI7XG4gIGxldCBmYW5PdXQ6IG51bWJlcjtcbiAgY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICBpZiAoc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgZmFuSW4gPSBzaGFwZVswXTtcbiAgICBmYW5PdXQgPSBzaGFwZVsxXTtcbiAgfSBlbHNlIGlmIChbMywgNCwgNV0uaW5kZXhPZihzaGFwZS5sZW5ndGgpICE9PSAtMSkge1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgIGNvbnN0IHJlY2VwdGl2ZUZpZWxkU2l6ZSA9IGFycmF5UHJvZChzaGFwZSwgMik7XG4gICAgICBmYW5JbiA9IHNoYXBlWzFdICogcmVjZXB0aXZlRmllbGRTaXplO1xuICAgICAgZmFuT3V0ID0gc2hhcGVbMF0gKiByZWNlcHRpdmVGaWVsZFNpemU7XG4gICAgfSBlbHNlIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgY29uc3QgcmVjZXB0aXZlRmllbGRTaXplID0gYXJyYXlQcm9kKHNoYXBlLCAwLCBzaGFwZS5sZW5ndGggLSAyKTtcbiAgICAgIGZhbkluID0gc2hhcGVbc2hhcGUubGVuZ3RoIC0gMl0gKiByZWNlcHRpdmVGaWVsZFNpemU7XG4gICAgICBmYW5PdXQgPSBzaGFwZVtzaGFwZS5sZW5ndGggLSAxXSAqIHJlY2VwdGl2ZUZpZWxkU2l6ZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgc2hhcGVQcm9kID0gYXJyYXlQcm9kKHNoYXBlKTtcbiAgICBmYW5JbiA9IE1hdGguc3FydChzaGFwZVByb2QpO1xuICAgIGZhbk91dCA9IE1hdGguc3FydChzaGFwZVByb2QpO1xuICB9XG5cbiAgcmV0dXJuIFtmYW5JbiwgZmFuT3V0XTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBWYXJpYW5jZVNjYWxpbmdBcmdzIHtcbiAgLyoqIFNjYWxpbmcgZmFjdG9yIChwb3NpdGl2ZSBmbG9hdCkuICovXG4gIHNjYWxlPzogbnVtYmVyO1xuXG4gIC8qKiBGYW5uaW5nIG1vZGUgZm9yIGlucHV0cyBhbmQgb3V0cHV0cy4gKi9cbiAgbW9kZT86IEZhbk1vZGU7XG5cbiAgLyoqIFByb2JhYmlsaXN0aWMgZGlzdHJpYnV0aW9uIG9mIHRoZSB2YWx1ZXMuICovXG4gIGRpc3RyaWJ1dGlvbj86IERpc3RyaWJ1dGlvbjtcblxuICAvKiogUmFuZG9tIG51bWJlciBnZW5lcmF0b3Igc2VlZC4gKi9cbiAgc2VlZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFZhcmlhbmNlU2NhbGluZyBleHRlbmRzIEluaXRpYWxpemVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnVmFyaWFuY2VTY2FsaW5nJztcbiAgcHJpdmF0ZSBzY2FsZTogbnVtYmVyO1xuICBwcml2YXRlIG1vZGU6IEZhbk1vZGU7XG4gIHByaXZhdGUgZGlzdHJpYnV0aW9uOiBEaXN0cmlidXRpb247XG4gIHByaXZhdGUgc2VlZDogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBvZiBWYXJpYW5jZVNjYWxpbmcuXG4gICAqIEB0aHJvd3MgVmFsdWVFcnJvciBmb3IgaW52YWxpZCB2YWx1ZSBpbiBzY2FsZS5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFZhcmlhbmNlU2NhbGluZ0FyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIGlmIChhcmdzLnNjYWxlIDwgMC4wKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgc2NhbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGZsb2F0LiBHb3Q6ICR7YXJncy5zY2FsZX1gKTtcbiAgICB9XG4gICAgdGhpcy5zY2FsZSA9IGFyZ3Muc2NhbGUgPT0gbnVsbCA/IDEuMCA6IGFyZ3Muc2NhbGU7XG4gICAgdGhpcy5tb2RlID0gYXJncy5tb2RlID09IG51bGwgPyAnZmFuSW4nIDogYXJncy5tb2RlO1xuICAgIGNoZWNrRmFuTW9kZSh0aGlzLm1vZGUpO1xuICAgIHRoaXMuZGlzdHJpYnV0aW9uID1cbiAgICAgICAgYXJncy5kaXN0cmlidXRpb24gPT0gbnVsbCA/ICdub3JtYWwnIDogYXJncy5kaXN0cmlidXRpb247XG4gICAgY2hlY2tEaXN0cmlidXRpb24odGhpcy5kaXN0cmlidXRpb24pO1xuICAgIHRoaXMuc2VlZCA9IGFyZ3Muc2VlZDtcbiAgfVxuXG4gIGFwcGx5KHNoYXBlOiBTaGFwZSwgZHR5cGU/OiBEYXRhVHlwZSk6IFRlbnNvciB7XG4gICAgY29uc3QgZmFucyA9IGNvbXB1dGVGYW5zKHNoYXBlKTtcbiAgICBjb25zdCBmYW5JbiA9IGZhbnNbMF07XG4gICAgY29uc3QgZmFuT3V0ID0gZmFuc1sxXTtcbiAgICBsZXQgc2NhbGUgPSB0aGlzLnNjYWxlO1xuICAgIGlmICh0aGlzLm1vZGUgPT09ICdmYW5JbicpIHtcbiAgICAgIHNjYWxlIC89IE1hdGgubWF4KDEsIGZhbkluKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMubW9kZSA9PT0gJ2Zhbk91dCcpIHtcbiAgICAgIHNjYWxlIC89IE1hdGgubWF4KDEsIGZhbk91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNjYWxlIC89IE1hdGgubWF4KDEsIChmYW5JbiArIGZhbk91dCkgLyAyKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5kaXN0cmlidXRpb24gPT09ICdub3JtYWwnKSB7XG4gICAgICBjb25zdCBzdGRkZXYgPSBNYXRoLnNxcnQoc2NhbGUpO1xuICAgICAgZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gICAgICBpZiAoZHR5cGUgIT09ICdmbG9hdDMyJyAmJiBkdHlwZSAhPT0gJ2ludDMyJykge1xuICAgICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAgIGAke3RoaXMuZ2V0Q2xhc3NOYW1lKCl9IGRvZXMgbm90IHN1cHBvcnQgZFR5cGUgJHtkdHlwZX0uYCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1bmNhdGVkTm9ybWFsKHNoYXBlLCAwLCBzdGRkZXYsIGR0eXBlLCB0aGlzLnNlZWQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsaW1pdCA9IE1hdGguc3FydCgzICogc2NhbGUpO1xuICAgICAgcmV0dXJuIHJhbmRvbVVuaWZvcm0oc2hhcGUsIC1saW1pdCwgbGltaXQsIGR0eXBlKTtcbiAgICB9XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICBtb2RlOiB0aGlzLm1vZGUsXG4gICAgICBkaXN0cmlidXRpb246IHRoaXMuZGlzdHJpYnV0aW9uLFxuICAgICAgc2VlZDogdGhpcy5zZWVkXG4gICAgfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFZhcmlhbmNlU2NhbGluZyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgU2VlZE9ubHlJbml0aWFsaXplckFyZ3Mge1xuICAvKiogUmFuZG9tIG51bWJlciBnZW5lcmF0b3Igc2VlZC4gKi9cbiAgc2VlZD86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEdsb3JvdFVuaWZvcm0gZXh0ZW5kcyBWYXJpYW5jZVNjYWxpbmcge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdHbG9yb3RVbmlmb3JtJztcblxuICAvKipcbiAgICogQ29uc3RydWN0b3Igb2YgR2xvcm90VW5pZm9ybVxuICAgKiBAcGFyYW0gc2NhbGVcbiAgICogQHBhcmFtIG1vZGVcbiAgICogQHBhcmFtIGRpc3RyaWJ1dGlvblxuICAgKiBAcGFyYW0gc2VlZFxuICAgKi9cbiAgY29uc3RydWN0b3IoYXJncz86IFNlZWRPbmx5SW5pdGlhbGl6ZXJBcmdzKSB7XG4gICAgc3VwZXIoe1xuICAgICAgc2NhbGU6IDEuMCxcbiAgICAgIG1vZGU6ICdmYW5BdmcnLFxuICAgICAgZGlzdHJpYnV0aW9uOiAndW5pZm9ybScsXG4gICAgICBzZWVkOiBhcmdzID09IG51bGwgPyBudWxsIDogYXJncy5zZWVkXG4gICAgfSk7XG4gIH1cblxuICBnZXRDbGFzc05hbWUoKTogc3RyaW5nIHtcbiAgICAvLyBJbiBQeXRob24gS2VyYXMsIEdsb3JvdFVuaWZvcm0gaXMgbm90IGEgY2xhc3MsIGJ1dCBhIGhlbHBlciBtZXRob2RcbiAgICAvLyB0aGF0IGNyZWF0ZXMgYSBWYXJpYW5jZVNjYWxpbmcgb2JqZWN0LiBVc2UgJ1ZhcmlhbmNlU2NhbGluZycgYXNcbiAgICAvLyBjbGFzcyBuYW1lIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGF0LlxuICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvcm90VW5pZm9ybSk7XG5cbmV4cG9ydCBjbGFzcyBHbG9yb3ROb3JtYWwgZXh0ZW5kcyBWYXJpYW5jZVNjYWxpbmcge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdHbG9yb3ROb3JtYWwnO1xuXG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBvZiBHbG9yb3ROb3JtYWwuXG4gICAqIEBwYXJhbSBzY2FsZVxuICAgKiBAcGFyYW0gbW9kZVxuICAgKiBAcGFyYW0gZGlzdHJpYnV0aW9uXG4gICAqIEBwYXJhbSBzZWVkXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhcmdzPzogU2VlZE9ubHlJbml0aWFsaXplckFyZ3MpIHtcbiAgICBzdXBlcih7XG4gICAgICBzY2FsZTogMS4wLFxuICAgICAgbW9kZTogJ2ZhbkF2ZycsXG4gICAgICBkaXN0cmlidXRpb246ICdub3JtYWwnLFxuICAgICAgc2VlZDogYXJncyA9PSBudWxsID8gbnVsbCA6IGFyZ3Muc2VlZFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q2xhc3NOYW1lKCk6IHN0cmluZyB7XG4gICAgLy8gSW4gUHl0aG9uIEtlcmFzLCBHbG9yb3ROb3JtYWwgaXMgbm90IGEgY2xhc3MsIGJ1dCBhIGhlbHBlciBtZXRob2RcbiAgICAvLyB0aGF0IGNyZWF0ZXMgYSBWYXJpYW5jZVNjYWxpbmcgb2JqZWN0LiBVc2UgJ1ZhcmlhbmNlU2NhbGluZycgYXNcbiAgICAvLyBjbGFzcyBuYW1lIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGF0LlxuICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvcm90Tm9ybWFsKTtcblxuZXhwb3J0IGNsYXNzIEhlTm9ybWFsIGV4dGVuZHMgVmFyaWFuY2VTY2FsaW5nIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnSGVOb3JtYWwnO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBTZWVkT25seUluaXRpYWxpemVyQXJncykge1xuICAgIHN1cGVyKHtcbiAgICAgIHNjYWxlOiAyLjAsXG4gICAgICBtb2RlOiAnZmFuSW4nLFxuICAgICAgZGlzdHJpYnV0aW9uOiAnbm9ybWFsJyxcbiAgICAgIHNlZWQ6IGFyZ3MgPT0gbnVsbCA/IG51bGwgOiBhcmdzLnNlZWRcbiAgICB9KTtcbiAgfVxuXG4gIGdldENsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgIC8vIEluIFB5dGhvbiBLZXJhcywgSGVOb3JtYWwgaXMgbm90IGEgY2xhc3MsIGJ1dCBhIGhlbHBlciBtZXRob2RcbiAgICAvLyB0aGF0IGNyZWF0ZXMgYSBWYXJpYW5jZVNjYWxpbmcgb2JqZWN0LiBVc2UgJ1ZhcmlhbmNlU2NhbGluZycgYXNcbiAgICAvLyBjbGFzcyBuYW1lIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGF0LlxuICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSGVOb3JtYWwpO1xuXG5leHBvcnQgY2xhc3MgSGVVbmlmb3JtIGV4dGVuZHMgVmFyaWFuY2VTY2FsaW5nIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnSGVVbmlmb3JtJztcblxuICBjb25zdHJ1Y3RvcihhcmdzPzogU2VlZE9ubHlJbml0aWFsaXplckFyZ3MpIHtcbiAgICBzdXBlcih7XG4gICAgICBzY2FsZTogMi4wLFxuICAgICAgbW9kZTogJ2ZhbkluJyxcbiAgICAgIGRpc3RyaWJ1dGlvbjogJ3VuaWZvcm0nLFxuICAgICAgc2VlZDogYXJncyA9PSBudWxsID8gbnVsbCA6IGFyZ3Muc2VlZFxuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q2xhc3NOYW1lKCk6IHN0cmluZyB7XG4gICAgLy8gSW4gUHl0aG9uIEtlcmFzLCBIZVVuaWZvcm0gaXMgbm90IGEgY2xhc3MsIGJ1dCBhIGhlbHBlciBtZXRob2RcbiAgICAvLyB0aGF0IGNyZWF0ZXMgYSBWYXJpYW5jZVNjYWxpbmcgb2JqZWN0LiBVc2UgJ1ZhcmlhbmNlU2NhbGluZycgYXNcbiAgICAvLyBjbGFzcyBuYW1lIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGF0LlxuICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSGVVbmlmb3JtKTtcblxuZXhwb3J0IGNsYXNzIExlQ3VuTm9ybWFsIGV4dGVuZHMgVmFyaWFuY2VTY2FsaW5nIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTGVDdW5Ob3JtYWwnO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBTZWVkT25seUluaXRpYWxpemVyQXJncykge1xuICAgIHN1cGVyKHtcbiAgICAgIHNjYWxlOiAxLjAsXG4gICAgICBtb2RlOiAnZmFuSW4nLFxuICAgICAgZGlzdHJpYnV0aW9uOiAnbm9ybWFsJyxcbiAgICAgIHNlZWQ6IGFyZ3MgPT0gbnVsbCA/IG51bGwgOiBhcmdzLnNlZWRcbiAgICB9KTtcbiAgfVxuXG4gIGdldENsYXNzTmFtZSgpOiBzdHJpbmcge1xuICAgIC8vIEluIFB5dGhvbiBLZXJhcywgTGVDdW5Ob3JtYWwgaXMgbm90IGEgY2xhc3MsIGJ1dCBhIGhlbHBlciBtZXRob2RcbiAgICAvLyB0aGF0IGNyZWF0ZXMgYSBWYXJpYW5jZVNjYWxpbmcgb2JqZWN0LiBVc2UgJ1ZhcmlhbmNlU2NhbGluZycgYXNcbiAgICAvLyBjbGFzcyBuYW1lIHRvIGJlIGNvbXBhdGlibGUgd2l0aCB0aGF0LlxuICAgIHJldHVybiBWYXJpYW5jZVNjYWxpbmcuY2xhc3NOYW1lO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTGVDdW5Ob3JtYWwpO1xuXG5leHBvcnQgY2xhc3MgTGVDdW5Vbmlmb3JtIGV4dGVuZHMgVmFyaWFuY2VTY2FsaW5nIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTGVDdW5Ob3JtYWwnO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBTZWVkT25seUluaXRpYWxpemVyQXJncykge1xuICAgIHN1cGVyKHtcbiAgICAgIHNjYWxlOiAxLjAsXG4gICAgICBtb2RlOiAnZmFuSW4nLFxuICAgICAgZGlzdHJpYnV0aW9uOiAndW5pZm9ybScsXG4gICAgICBzZWVkOiBhcmdzID09IG51bGwgPyBudWxsIDogYXJncy5zZWVkXG4gICAgfSk7XG4gIH1cblxuICBnZXRDbGFzc05hbWUoKTogc3RyaW5nIHtcbiAgICAvLyBJbiBQeXRob24gS2VyYXMsIExlQ3VuVW5pZm9ybSBpcyBub3QgYSBjbGFzcywgYnV0IGEgaGVscGVyIG1ldGhvZFxuICAgIC8vIHRoYXQgY3JlYXRlcyBhIFZhcmlhbmNlU2NhbGluZyBvYmplY3QuIFVzZSAnVmFyaWFuY2VTY2FsaW5nJyBhc1xuICAgIC8vIGNsYXNzIG5hbWUgdG8gYmUgY29tcGF0aWJsZSB3aXRoIHRoYXQuXG4gICAgcmV0dXJuIFZhcmlhbmNlU2NhbGluZy5jbGFzc05hbWU7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMZUN1blVuaWZvcm0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIE9ydGhvZ29uYWxBcmdzIGV4dGVuZHMgU2VlZE9ubHlJbml0aWFsaXplckFyZ3Mge1xuICAvKipcbiAgICogTXVsdGlwbGljYXRpdmUgZmFjdG9yIHRvIGFwcGx5IHRvIHRoZSBvcnRob2dvbmFsIG1hdHJpeC4gRGVmYXVsdHMgdG8gMS5cbiAgICovXG4gIGdhaW4/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBPcnRob2dvbmFsIGV4dGVuZHMgSW5pdGlhbGl6ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdPcnRob2dvbmFsJztcbiAgcmVhZG9ubHkgREVGQVVMVF9HQUlOID0gMTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGdhaW46IG51bWJlcjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHNlZWQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihhcmdzPzogT3J0aG9nb25hbEFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuZ2FpbiA9IGFyZ3MuZ2FpbiA9PSBudWxsID8gdGhpcy5ERUZBVUxUX0dBSU4gOiBhcmdzLmdhaW47XG4gICAgdGhpcy5zZWVkID0gYXJncy5zZWVkO1xuXG4gICAgaWYgKHRoaXMuc2VlZCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAnUmFuZG9tIHNlZWQgaXMgbm90IGltcGxlbWVudGVkIGZvciBPcnRob2dvbmFsIEluaXRpYWxpemVyIHlldC4nKTtcbiAgICB9XG4gIH1cblxuICBhcHBseShzaGFwZTogU2hhcGUsIGR0eXBlPzogRGF0YVR5cGUpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlmIChzaGFwZS5sZW5ndGggPCAyKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdTaGFwZSBtdXN0IGJlIGF0IGxlYXN0IDJELicpO1xuICAgICAgfVxuICAgICAgaWYgKHNoYXBlWzBdICogc2hhcGVbMV0gPiAyMDAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIGBPcnRob2dvbmFsIGluaXRpYWxpemVyIGlzIGJlaW5nIGNhbGxlZCBvbiBhIG1hdHJpeCB3aXRoIG1vcmUgYCArXG4gICAgICAgICAgICBgdGhhbiAyMDAwICgke3NoYXBlWzBdICogc2hhcGVbMV19KSBlbGVtZW50czogYCArXG4gICAgICAgICAgICBgU2xvd25lc3MgbWF5IHJlc3VsdC5gKTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhjYWlzKTogQWRkIHNlZWQgc3VwcG9ydC5cbiAgICAgIGNvbnN0IG5vcm1hbGl6ZWRTaGFwZSA9XG4gICAgICAgICAgc2hhcGVbMF0gPiBzaGFwZVsxXSA/IFtzaGFwZVsxXSwgc2hhcGVbMF1dIDogc2hhcGU7XG4gICAgICBjb25zdCBhID0gSy5yYW5kb21Ob3JtYWwobm9ybWFsaXplZFNoYXBlLCAwLCAxLCAnZmxvYXQzMicpIGFzIFRlbnNvcjJEO1xuICAgICAgbGV0IHEgPSBsaW5hbGcuZ3JhbVNjaG1pZHQoYSkgYXMgVGVuc29yMkQ7XG4gICAgICBpZiAoc2hhcGVbMF0gPiBzaGFwZVsxXSkge1xuICAgICAgICBxID0gdHJhbnNwb3NlKHEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG11bCh0aGlzLmdhaW4sIHEpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGdhaW46IHRoaXMuZ2FpbixcbiAgICAgIHNlZWQ6IHRoaXMuc2VlZCxcbiAgICB9O1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoT3J0aG9nb25hbCk7XG5cbi8qKiBAZG9jaW5saW5lICovXG5leHBvcnQgdHlwZSBJbml0aWFsaXplcklkZW50aWZpZXIgPVxuICAgICdjb25zdGFudCd8J2dsb3JvdE5vcm1hbCd8J2dsb3JvdFVuaWZvcm0nfCdoZU5vcm1hbCd8J2hlVW5pZm9ybSd8J2lkZW50aXR5J3xcbiAgICAnbGVDdW5Ob3JtYWwnfCdsZUN1blVuaWZvcm0nfCdvbmVzJ3wnb3J0aG9nb25hbCd8J3JhbmRvbU5vcm1hbCd8XG4gICAgJ3JhbmRvbVVuaWZvcm0nfCd0cnVuY2F0ZWROb3JtYWwnfCd2YXJpYW5jZVNjYWxpbmcnfCd6ZXJvcyd8c3RyaW5nO1xuXG4vLyBNYXBzIHRoZSBKYXZhU2NyaXB0LWxpa2UgaWRlbnRpZmllciBrZXlzIHRvIHRoZSBjb3JyZXNwb25kaW5nIHJlZ2lzdHJ5XG4vLyBzeW1ib2xzLlxuZXhwb3J0IGNvbnN0IElOSVRJQUxJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUDpcbiAgICB7W2lkZW50aWZpZXIgaW4gSW5pdGlhbGl6ZXJJZGVudGlmaWVyXTogc3RyaW5nfSA9IHtcbiAgICAgICdjb25zdGFudCc6ICdDb25zdGFudCcsXG4gICAgICAnZ2xvcm90Tm9ybWFsJzogJ0dsb3JvdE5vcm1hbCcsXG4gICAgICAnZ2xvcm90VW5pZm9ybSc6ICdHbG9yb3RVbmlmb3JtJyxcbiAgICAgICdoZU5vcm1hbCc6ICdIZU5vcm1hbCcsXG4gICAgICAnaGVVbmlmb3JtJzogJ0hlVW5pZm9ybScsXG4gICAgICAnaWRlbnRpdHknOiAnSWRlbnRpdHknLFxuICAgICAgJ2xlQ3VuTm9ybWFsJzogJ0xlQ3VuTm9ybWFsJyxcbiAgICAgICdsZUN1blVuaWZvcm0nOiAnTGVDdW5Vbmlmb3JtJyxcbiAgICAgICdvbmVzJzogJ09uZXMnLFxuICAgICAgJ29ydGhvZ29uYWwnOiAnT3J0aG9nb25hbCcsXG4gICAgICAncmFuZG9tTm9ybWFsJzogJ1JhbmRvbU5vcm1hbCcsXG4gICAgICAncmFuZG9tVW5pZm9ybSc6ICdSYW5kb21Vbmlmb3JtJyxcbiAgICAgICd0cnVuY2F0ZWROb3JtYWwnOiAnVHJ1bmNhdGVkTm9ybWFsJyxcbiAgICAgICd2YXJpYW5jZVNjYWxpbmcnOiAnVmFyaWFuY2VTY2FsaW5nJyxcbiAgICAgICd6ZXJvcyc6ICdaZXJvcydcbiAgICB9O1xuXG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUluaXRpYWxpemVyKFxuICAgIGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0LFxuICAgIGN1c3RvbU9iamVjdHM6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt9KTogSW5pdGlhbGl6ZXIge1xuICByZXR1cm4gZGVzZXJpYWxpemVLZXJhc09iamVjdChcbiAgICAgIGNvbmZpZywgc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCxcbiAgICAgIGN1c3RvbU9iamVjdHMsICdpbml0aWFsaXplcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2VyaWFsaXplSW5pdGlhbGl6ZXIoaW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyKTpcbiAgICBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RWYWx1ZSB7XG4gIHJldHVybiBzZXJpYWxpemVLZXJhc09iamVjdChpbml0aWFsaXplcik7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRJbml0aWFsaXplcihpZGVudGlmaWVyOiBJbml0aWFsaXplcklkZW50aWZpZXJ8SW5pdGlhbGl6ZXJ8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0KTogSW5pdGlhbGl6ZXIge1xuICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gaWRlbnRpZmllciBpbiBJTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVAgP1xuICAgICAgICBJTklUSUFMSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVBbaWRlbnRpZmllcl0gOlxuICAgICAgICBpZGVudGlmaWVyO1xuICAgIC8qIFdlIGhhdmUgZm91ciAnaGVscGVyJyBjbGFzc2VzIGZvciBjb21tb24gaW5pdGlhbGl6ZXJzIHRoYXRcbiAgICBhbGwgZ2V0IHNlcmlhbGl6ZWQgYXMgJ1ZhcmlhbmNlU2NhbGluZycgYW5kIHNob3VsZG4ndCBnbyB0aHJvdWdoXG4gICAgdGhlIGRlc2VyaWFsaXplSW5pdGlhbGl6ZXIgcGF0aHdheS4gKi9cbiAgICBpZiAoY2xhc3NOYW1lID09PSAnR2xvcm90Tm9ybWFsJykge1xuICAgICAgcmV0dXJuIG5ldyBHbG9yb3ROb3JtYWwoKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gJ0dsb3JvdFVuaWZvcm0nKSB7XG4gICAgICByZXR1cm4gbmV3IEdsb3JvdFVuaWZvcm0oKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gJ0hlTm9ybWFsJykge1xuICAgICAgcmV0dXJuIG5ldyBIZU5vcm1hbCgpO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09PSAnSGVVbmlmb3JtJykge1xuICAgICAgcmV0dXJuIG5ldyBIZVVuaWZvcm0oKTtcbiAgICB9IGVsc2UgaWYgKGNsYXNzTmFtZSA9PT0gJ0xlQ3VuTm9ybWFsJykge1xuICAgICAgcmV0dXJuIG5ldyBMZUN1bk5vcm1hbCgpO1xuICAgIH0gZWxzZSBpZiAoY2xhc3NOYW1lID09PSAnTGVDdW5Vbmlmb3JtJykge1xuICAgICAgcmV0dXJuIG5ldyBMZUN1blVuaWZvcm0oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7fTtcbiAgICAgIGNvbmZpZ1snY2xhc3NOYW1lJ10gPSBjbGFzc05hbWU7XG4gICAgICBjb25maWdbJ2NvbmZpZyddID0ge307XG4gICAgICByZXR1cm4gZGVzZXJpYWxpemVJbml0aWFsaXplcihjb25maWcpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpZGVudGlmaWVyIGluc3RhbmNlb2YgSW5pdGlhbGl6ZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVJbml0aWFsaXplcihpZGVudGlmaWVyKTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { ValueError } from '../errors';\n// tslint:enable\n/**\n * Determine whether the input is an Array of Shapes.\n */\nexport function isArrayOfShapes(x) {\n    return Array.isArray(x) && Array.isArray(x[0]);\n}\n/**\n * Special case of normalizing shapes to lists.\n *\n * @param x A shape or list of shapes to normalize into a list of Shapes.\n * @return A list of Shapes.\n */\nexport function normalizeShapeList(x) {\n    if (x.length === 0) {\n        return [];\n    }\n    if (!Array.isArray(x[0])) {\n        return [x];\n    }\n    return x;\n}\n/**\n * Helper function to obtain exactly one Tensor.\n * @param xs: A single `tf.Tensor` or an `Array` of `tf.Tensor`s.\n * @return A single `tf.Tensor`. If `xs` is an `Array`, return the first one.\n * @throws ValueError: If `xs` is an `Array` and its length is not 1.\n */\nexport function getExactlyOneTensor(xs) {\n    let x;\n    if (Array.isArray(xs)) {\n        if (xs.length !== 1) {\n            throw new ValueError(`Expected Tensor length to be 1; got ${xs.length}`);\n        }\n        x = xs[0];\n    }\n    else {\n        x = xs;\n    }\n    return x;\n}\n/**\n * Helper function to obtain exactly on instance of Shape.\n *\n * @param shapes Input single `Shape` or Array of `Shape`s.\n * @returns If input is a single `Shape`, return it unchanged. If the input is\n *   an `Array` containing exactly one instance of `Shape`, return the instance.\n *   Otherwise, throw a `ValueError`.\n * @throws ValueError: If input is an `Array` of `Shape`s, and its length is not\n *   1.\n */\nexport function getExactlyOneShape(shapes) {\n    if (Array.isArray(shapes) && Array.isArray(shapes[0])) {\n        if (shapes.length === 1) {\n            shapes = shapes;\n            return shapes[0];\n        }\n        else {\n            throw new ValueError(`Expected exactly 1 Shape; got ${shapes.length}`);\n        }\n    }\n    else {\n        return shapes;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZXNfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvdXRpbHMvdHlwZXNfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFLSCxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBRXJDLGdCQUFnQjtBQUVoQjs7R0FFRztBQUNILE1BQU0sVUFBVSxlQUFlLENBQUMsQ0FBZ0I7SUFDOUMsT0FBTyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDakQsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsTUFBTSxVQUFVLGtCQUFrQixDQUFDLENBQWdCO0lBQ2pELElBQUksQ0FBQyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7UUFDbEIsT0FBTyxFQUFFLENBQUM7S0FDWDtJQUNELElBQUksQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQ3hCLE9BQU8sQ0FBQyxDQUFDLENBQVksQ0FBQztLQUN2QjtJQUNELE9BQU8sQ0FBWSxDQUFDO0FBQ3RCLENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxtQkFBbUIsQ0FBQyxFQUFtQjtJQUNyRCxJQUFJLENBQVMsQ0FBQztJQUNkLElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxFQUFFLENBQUMsRUFBRTtRQUNyQixJQUFJLEVBQUUsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ25CLE1BQU0sSUFBSSxVQUFVLENBQUMsdUNBQXVDLEVBQUUsQ0FBQyxNQUFNLEVBQUUsQ0FBQyxDQUFDO1NBQzFFO1FBQ0QsQ0FBQyxHQUFHLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQztLQUNYO1NBQU07UUFDTCxDQUFDLEdBQUcsRUFBRSxDQUFDO0tBQ1I7SUFDRCxPQUFPLENBQUMsQ0FBQztBQUNYLENBQUM7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQUMsTUFBcUI7SUFDdEQsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0sQ0FBQyxJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLEVBQUU7UUFDckQsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN2QixNQUFNLEdBQUcsTUFBaUIsQ0FBQztZQUMzQixPQUFPLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNsQjthQUFNO1lBQ0wsTUFBTSxJQUFJLFVBQVUsQ0FBQyxpQ0FBaUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxDQUFDLENBQUM7U0FDeEU7S0FDRjtTQUFNO1FBQ0wsT0FBTyxNQUFlLENBQUM7S0FDeEI7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyogT3JpZ2luYWwgc291cmNlOiB1dGlscy9nZW5lcmljX3V0aWxzLnB5ICovXG5cbmltcG9ydCB7VGVuc29yfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG4vLyB0c2xpbnQ6ZW5hYmxlXG5cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGlucHV0IGlzIGFuIEFycmF5IG9mIFNoYXBlcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGlzQXJyYXlPZlNoYXBlcyh4OiBTaGFwZXxTaGFwZVtdKTogYm9vbGVhbiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpICYmIEFycmF5LmlzQXJyYXkoeFswXSk7XG59XG5cbi8qKlxuICogU3BlY2lhbCBjYXNlIG9mIG5vcm1hbGl6aW5nIHNoYXBlcyB0byBsaXN0cy5cbiAqXG4gKiBAcGFyYW0geCBBIHNoYXBlIG9yIGxpc3Qgb2Ygc2hhcGVzIHRvIG5vcm1hbGl6ZSBpbnRvIGEgbGlzdCBvZiBTaGFwZXMuXG4gKiBAcmV0dXJuIEEgbGlzdCBvZiBTaGFwZXMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVTaGFwZUxpc3QoeDogU2hhcGV8U2hhcGVbXSk6IFNoYXBlW10ge1xuICBpZiAoeC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgaWYgKCFBcnJheS5pc0FycmF5KHhbMF0pKSB7XG4gICAgcmV0dXJuIFt4XSBhcyBTaGFwZVtdO1xuICB9XG4gIHJldHVybiB4IGFzIFNoYXBlW107XG59XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIG9idGFpbiBleGFjdGx5IG9uZSBUZW5zb3IuXG4gKiBAcGFyYW0geHM6IEEgc2luZ2xlIGB0Zi5UZW5zb3JgIG9yIGFuIGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzLlxuICogQHJldHVybiBBIHNpbmdsZSBgdGYuVGVuc29yYC4gSWYgYHhzYCBpcyBhbiBgQXJyYXlgLCByZXR1cm4gdGhlIGZpcnN0IG9uZS5cbiAqIEB0aHJvd3MgVmFsdWVFcnJvcjogSWYgYHhzYCBpcyBhbiBgQXJyYXlgIGFuZCBpdHMgbGVuZ3RoIGlzIG5vdCAxLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0RXhhY3RseU9uZVRlbnNvcih4czogVGVuc29yfFRlbnNvcltdKTogVGVuc29yIHtcbiAgbGV0IHg6IFRlbnNvcjtcbiAgaWYgKEFycmF5LmlzQXJyYXkoeHMpKSB7XG4gICAgaWYgKHhzLmxlbmd0aCAhPT0gMSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYEV4cGVjdGVkIFRlbnNvciBsZW5ndGggdG8gYmUgMTsgZ290ICR7eHMubGVuZ3RofWApO1xuICAgIH1cbiAgICB4ID0geHNbMF07XG4gIH0gZWxzZSB7XG4gICAgeCA9IHhzO1xuICB9XG4gIHJldHVybiB4O1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiB0byBvYnRhaW4gZXhhY3RseSBvbiBpbnN0YW5jZSBvZiBTaGFwZS5cbiAqXG4gKiBAcGFyYW0gc2hhcGVzIElucHV0IHNpbmdsZSBgU2hhcGVgIG9yIEFycmF5IG9mIGBTaGFwZWBzLlxuICogQHJldHVybnMgSWYgaW5wdXQgaXMgYSBzaW5nbGUgYFNoYXBlYCwgcmV0dXJuIGl0IHVuY2hhbmdlZC4gSWYgdGhlIGlucHV0IGlzXG4gKiAgIGFuIGBBcnJheWAgY29udGFpbmluZyBleGFjdGx5IG9uZSBpbnN0YW5jZSBvZiBgU2hhcGVgLCByZXR1cm4gdGhlIGluc3RhbmNlLlxuICogICBPdGhlcndpc2UsIHRocm93IGEgYFZhbHVlRXJyb3JgLlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBJZiBpbnB1dCBpcyBhbiBgQXJyYXlgIG9mIGBTaGFwZWBzLCBhbmQgaXRzIGxlbmd0aCBpcyBub3RcbiAqICAgMS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGdldEV4YWN0bHlPbmVTaGFwZShzaGFwZXM6IFNoYXBlfFNoYXBlW10pOiBTaGFwZSB7XG4gIGlmIChBcnJheS5pc0FycmF5KHNoYXBlcykgJiYgQXJyYXkuaXNBcnJheShzaGFwZXNbMF0pKSB7XG4gICAgaWYgKHNoYXBlcy5sZW5ndGggPT09IDEpIHtcbiAgICAgIHNoYXBlcyA9IHNoYXBlcyBhcyBTaGFwZVtdO1xuICAgICAgcmV0dXJuIHNoYXBlc1swXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYEV4cGVjdGVkIGV4YWN0bHkgMSBTaGFwZTsgZ290ICR7c2hhcGVzLmxlbmd0aH1gKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIHNoYXBlcyBhcyBTaGFwZTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Count the elements in an Array of LayerVariables.\n *\n * @param weights: The LayerVariables of which the constituent numbers are to\n *   be counted.\n * @returns A count of the elements in all the LayerVariables\n */\nexport function countParamsInWeights(weights) {\n    let count = 0;\n    for (const weight of weights) {\n        if (weight.shape.length === 0) {\n            count += 1;\n        }\n        else {\n            count += weight.shape.reduce((a, b) => a * b);\n        }\n    }\n    return count;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFyaWFibGVfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvdXRpbHMvdmFyaWFibGVfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFJSDs7Ozs7O0dBTUc7QUFDSCxNQUFNLFVBQVUsb0JBQW9CLENBQUMsT0FBd0I7SUFDM0QsSUFBSSxLQUFLLEdBQUcsQ0FBQyxDQUFDO0lBQ2QsS0FBSyxNQUFNLE1BQU0sSUFBSSxPQUFPLEVBQUU7UUFDNUIsSUFBSSxNQUFNLENBQUMsS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDN0IsS0FBSyxJQUFJLENBQUMsQ0FBQztTQUNaO2FBQU07WUFDTCxLQUFLLElBQUksTUFBTSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7U0FDL0M7S0FDRjtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7TGF5ZXJWYXJpYWJsZX0gZnJvbSAnLi4vdmFyaWFibGVzJztcblxuLyoqXG4gKiBDb3VudCB0aGUgZWxlbWVudHMgaW4gYW4gQXJyYXkgb2YgTGF5ZXJWYXJpYWJsZXMuXG4gKlxuICogQHBhcmFtIHdlaWdodHM6IFRoZSBMYXllclZhcmlhYmxlcyBvZiB3aGljaCB0aGUgY29uc3RpdHVlbnQgbnVtYmVycyBhcmUgdG9cbiAqICAgYmUgY291bnRlZC5cbiAqIEByZXR1cm5zIEEgY291bnQgb2YgdGhlIGVsZW1lbnRzIGluIGFsbCB0aGUgTGF5ZXJWYXJpYWJsZXNcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvdW50UGFyYW1zSW5XZWlnaHRzKHdlaWdodHM6IExheWVyVmFyaWFibGVbXSk6IG51bWJlciB7XG4gIGxldCBjb3VudCA9IDA7XG4gIGZvciAoY29uc3Qgd2VpZ2h0IG9mIHdlaWdodHMpIHtcbiAgICBpZiAod2VpZ2h0LnNoYXBlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY291bnQgKz0gd2VpZ2h0LnNoYXBlLnJlZHVjZSgoYSwgYikgPT4gYSAqIGIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { variableGrads } from '@tensorflow/tfjs-core';\nimport { getNextUniqueTensorId } from './backend/state';\nimport { getScopedTensorName, getUniqueTensorName } from './common';\nimport { NotImplementedError } from './errors';\nconst DEFAULT_VARIABLE_NAME_PREFIX = 'Variable';\n/**\n * A `tf.layers.LayerVariable` is similar to a `tf.Tensor` in that it has a\n * dtype and shape, but its value is mutable.  The value is itself represented\n * as a`tf.Tensor`, and can be read with the `read()` method and updated with\n * the `write()` method.\n */\nexport class LayerVariable {\n    /**\n     * Construct Variable from a `tf.Tensor`.\n     *\n     * If not explicitly named, the Variable will be given a name with the\n     * prefix 'Variable'. Variable names are unique. In the case of name\n     * collision, suffixies '_<num>' will be added to the name.\n     *\n     * @param val Initial value of the Variable.\n     * @param name Name of the variable. If `null` or `undefined` is provided, it\n     *   will default a name with the prefix 'Variable'.\n     * @param constraint Optional, projection function to be applied to the\n     * variable after optimize updates\n     * @throws ValueError if `name` is `null` or `undefined`.\n     */\n    constructor(val, dtype = 'float32', name = DEFAULT_VARIABLE_NAME_PREFIX, trainable = true, constraint = null) {\n        this.dtype = dtype == null ? 'float32' : dtype;\n        this.shape = val.shape;\n        this.id = getNextUniqueTensorId();\n        name = name == null ? DEFAULT_VARIABLE_NAME_PREFIX : name;\n        this.originalName = getScopedTensorName(name);\n        this.name = getUniqueTensorName(this.originalName);\n        this.trainable_ = trainable;\n        this.constraint = constraint;\n        this.val = tfc.variable(val, this.trainable_, this.name, this.dtype);\n    }\n    /**\n     * Get a snapshot of the Variable's value.\n     *\n     * The returned value is a snapshot of the Variable's value at the time of\n     * the invocation. Future mutations in the value of the tensor will only\n     * be reflected by future calls to this method.\n     */\n    read() {\n        this.assertNotDisposed();\n        return this.val;\n    }\n    /**\n     * Update the value of the Variable.\n     *\n     * @param newVal: The new value to update to. Must be consistent with the\n     *   dtype and shape of the Variable.\n     * @return This Variable.\n     */\n    write(newVal) {\n        // TODO(cais): Once  TF.js Core supports Tensor.dtype, check dtype match.\n        this.assertNotDisposed();\n        checkShapesMatch(this.val, newVal);\n        // Skip updating if this is the exact same tensor.\n        if (this.val.id !== newVal.id) {\n            this.val.assign(newVal);\n            if (this.constraint != null) {\n                this.val.assign(this.constraint.apply(this.val));\n            }\n        }\n        return this;\n    }\n    /**\n     * Dispose this LayersVariable instance from memory.\n     */\n    dispose() {\n        this.assertNotDisposed();\n        this.val.dispose();\n    }\n    assertNotDisposed() {\n        if (this.val.isDisposed) {\n            throw new Error(`LayersVariable ${this.name} is already disposed.`);\n        }\n    }\n    get trainable() {\n        return this.trainable_;\n    }\n    set trainable(trainable) {\n        this.trainable_ = trainable;\n        this.val.trainable = trainable;\n    }\n}\nfunction checkShapesMatch(x, y) {\n    if (x.shape.toString() !== y.shape.toString()) {\n        throw new Error('Shape mismatch: ' + JSON.stringify(x.shape) + ' vs. ' +\n            JSON.stringify(y.shape));\n    }\n}\n/**\n * Create a Variable.\n * @param x The initial value of the `Variable`.\n * @param dtype optional, the type of the variable.\n * @param name optional, the name of the variable, default provided by\n * Variable.\n * @param constraint optional, a constraint to be applied after every update.\n * @return The newly instantiated `Variable`.\n */\nexport function variable(x, dtype, name, constraint) {\n    return new LayerVariable(x, dtype, name, true, constraint);\n}\n/**\n * Instantiates an all-zeros Variable and returns it.\n *\n * @param shape Shape of the tensor.\n * @param dtype DType of the tensor.\n * @param name Name of the tensor.\n * @return An all-zero Variable.\n */\nexport function zerosVariable(shape, dtype, name) {\n    // TODO(cais): Implement logic for dtype.\n    return new LayerVariable(tfc.zeros(shape), dtype, name);\n}\n/**\n * Instantiates an all-zeros tensor of the same shape as another tensor.\n *\n * @param x The other tensor.\n * @param dtype DType of the tensor.\n * @param name Name of the tensor.\n * @return A newly instantiated Variable.\n */\nexport function zerosLike(x, dtype, name) {\n    return new LayerVariable(tfc.zerosLike(x), dtype, name);\n}\n/**\n * Instantiates an all-ones tensor and returns it.\n *\n * @param shape Shape of the tensor.\n * @param dtype DType of the tensor.\n * @param name Name of the tensor.\n * @return An all-ones Variable.\n */\nexport function onesVariable(shape, dtype, name) {\n    // TODO(cais): Implement logic for dtype.\n    const allocated = tfc.ones(shape);\n    return new LayerVariable(allocated, dtype, name);\n}\n/**\n * Instantiates an all-ones tensor of the same shape as another tensor.\n *\n * @param x The other tensor.\n * @param dtype DType of the tensor.\n * @param name Name of the tensor.\n * @return A newly instantiated Variable.\n */\nexport function onesLike(x, dtype, name) {\n    const allocated = tfc.onesLike(x);\n    return new LayerVariable(allocated, dtype, name);\n}\n/**\n * Instantiate an identity matrix and returns it, as a Variable\n *\n * @param size Number of rows/columns.\n * @param dtype Data type of returned Variable.\n * @param name Name of returned Variable.\n * @return A Variable, an identity matrix.\n */\nexport function eyeVariable(size, dtype, name) {\n    return new LayerVariable(tfc.eye(size), dtype, name);\n}\n/**\n * Get a Variable with uniform distribution of values.\n * @param shape Shape of the tensor.\n * @param minval Lower bound of the uniform distribution.\n * @param maxval Upper bound of the uniform distribution.\n * @param dtype\n * @param seed\n * @param name Optional name.\n * @return The uniform-random Variable.\n */\nexport function randomUniformVariable(shape, minval, maxval, dtype, seed, name = 'randomUniform') {\n    return new LayerVariable(tfc.randomUniform(shape, minval, maxval, dtype), dtype, name);\n}\n/**\n * Get a Variable with truncated-normal distribution of values.\n * @param shape Shape of the tensor.\n * @param mean mean value of the normal distribution.\n * @param stddev standard deviation of the normal distribution.\n * @param dtype\n * @param seed\n * @param name Optional name.\n * @return The truncated-normal-random Variable.\n */\nexport function truncatedNormalVariable(shape, mean = 0.0, stddev = 1.0, dtype, seed, name = 'truncatedNormal') {\n    // TODO(cais): Implement logic for dtype and seed once they are supported\n    // by deeplearn.js.\n    dtype = dtype || 'float32';\n    if (dtype !== 'float32' && dtype !== 'int32') {\n        throw new NotImplementedError(`randomNormal does not support dType ${dtype}.`);\n    }\n    return new LayerVariable(tfc.truncatedNormal(shape, mean, stddev, dtype, seed), dtype, name);\n}\n/**\n * Get a Variable with normal distribution of values.\n * @param shape Shape of the tensor.\n * @param mean mean value of the normal distribution.\n * @param stddev standard deviation of the normal distribution.\n * @param dtype\n * @param seed\n * @param name Optional name.\n * @return The truncated-normal-random Variable.\n */\nexport function randomNormalVariable(shape, mean = 0.0, stddev = 1.0, dtype, seed, name = 'randomNormal') {\n    dtype = dtype || 'float32';\n    if (dtype !== 'float32' && dtype !== 'int32') {\n        throw new NotImplementedError(`randomNormalVariable does not support dType ${dtype}.`);\n    }\n    return new LayerVariable(tfc.randomNormal(shape, mean, stddev, dtype, seed), dtype, name);\n}\n/**\n * Update the value of a Variable.\n * @param x The Variable to be updated.\n * @param xNew The new value to update to.\n * @return The Variable updated.\n */\nexport function update(x, xNew) {\n    return x.write(xNew);\n}\n/**\n * Update the value of a Variable by adding an increment.\n * @param x The Variable to be updated.\n * @param increment The incrment to add to `x`.\n * @return The Variable updated.\n */\nexport function updateAdd(x, increment) {\n    return x.write(tfc.add(x.read(), increment));\n}\n/**\n * Update the value of a Variable by subtracting a decrement.\n * @param x The Variable to be updated.\n * @param decrement The decrement to subtract from `x`.\n * @return The Variable updated.\n */\nexport function updateSub(x, decrement) {\n    return x.write(tfc.sub(x.read(), decrement));\n}\n/**\n * Get the values of an array of Variables.\n *\n * @param tensors An `Array` of `Variable`s to get the values of.\n * @return The values of the inputs, as an `Array` of`tf.Tensor`s.\n */\nexport function batchGetValue(xs) {\n    return xs.map(x => x.read());\n}\n/**\n * Update the value of multiple Variables at once.\n *\n * @param variablesAndValues An `Array`, each element is of type\n *   [Variable, Tensor]. The first item is the\n *   `Variable` of which the value is to be updated. The second item\n *   carries the new value.\n */\nexport function batchSetValue(variablesAndValues) {\n    variablesAndValues.forEach(variableAndValue => {\n        const variable = variableAndValue[0];\n        variable.write(variableAndValue[1]);\n    });\n}\n/**\n * Returns the gradients of `variables` w.r.t. the return value of `lossFn`.\n * @param lossFn A function which returns a Scalar to be used as the function\n *   value (i.e., numerator) for differentiation.\n * @param variables List of variables to be used as the independent variables\n *   (i.e., denominator) for differentiation.\n * @returns An Array of gradients tensors.\n */\nexport function gradients(lossFn, variables) {\n    // TODO(cais): The return type signature can be simplified if deeplearn makes\n    //   the corresponding type public.\n    const variableList = variables.map(variable => variable.read());\n    const valudAndGrads = variableGrads(lossFn, variableList);\n    return variables.map(variable => valudAndGrads.grads[variable.name]);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmFyaWFibGVzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL3ZhcmlhYmxlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILE9BQU8sS0FBSyxHQUFHLE1BQU0sdUJBQXVCLENBQUM7QUFDN0MsT0FBTyxFQUFtQixhQUFhLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV0RSxPQUFPLEVBQUMscUJBQXFCLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUN0RCxPQUFPLEVBQUMsbUJBQW1CLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFFbEUsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sVUFBVSxDQUFDO0FBSTdDLE1BQU0sNEJBQTRCLEdBQUcsVUFBVSxDQUFDO0FBRWhEOzs7OztHQUtHO0FBQ0gsTUFBTSxPQUFPLGFBQWE7SUFleEI7Ozs7Ozs7Ozs7Ozs7T0FhRztJQUNILFlBQ0ksR0FBVyxFQUFFLFFBQWtCLFNBQVMsRUFDeEMsSUFBSSxHQUFHLDRCQUE0QixFQUFFLFNBQVMsR0FBRyxJQUFJLEVBQ3JELGFBQXlCLElBQUk7UUFDL0IsSUFBSSxDQUFDLEtBQUssR0FBRyxLQUFLLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLEtBQUssQ0FBQztRQUMvQyxJQUFJLENBQUMsS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUM7UUFDdkIsSUFBSSxDQUFDLEVBQUUsR0FBRyxxQkFBcUIsRUFBRSxDQUFDO1FBRWxDLElBQUksR0FBRyxJQUFJLElBQUksSUFBSSxDQUFDLENBQUMsQ0FBQyw0QkFBNEIsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDO1FBQzFELElBQUksQ0FBQyxZQUFZLEdBQUcsbUJBQW1CLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUMsSUFBSSxDQUFDLElBQUksR0FBRyxtQkFBbUIsQ0FBQyxJ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Q3JCLE1BQXdCLEVBQUUsU0FBMEI7SUFDdEQsNkVBQTZFO0lBQzdFLG1DQUFtQztJQUNuQyxNQUFNLFlBQVksR0FDZCxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsUUFBUSxDQUFDLElBQUksRUFBa0IsQ0FBQyxDQUFDO0lBQy9ELE1BQU0sYUFBYSxHQUFHLGFBQWEsQ0FBQyxNQUFNLEVBQUUsWUFBWSxDQUFDLENBQUM7SUFDMUQsT0FBTyxTQUFTLENBQUMsR0FBRyxDQUFDLFFBQVEsQ0FBQyxFQUFFLENBQUMsYUFBYSxDQUFDLEtBQUssQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQztBQUN2RSxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0RhdGFUeXBlLCBUZW5zb3IsIHZhcmlhYmxlR3JhZHN9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7Z2V0TmV4dFVuaXF1ZVRlbnNvcklkfSBmcm9tICcuL2JhY2tlbmQvc3RhdGUnO1xuaW1wb3J0IHtnZXRTY29wZWRUZW5zb3JOYW1lLCBnZXRVbmlxdWVUZW5zb3JOYW1lfSBmcm9tICcuL2NvbW1vbic7XG5pbXBvcnQge0NvbnN0cmFpbnR9IGZyb20gJy4vY29uc3RyYWludHMnO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge1NoYXBlfSBmcm9tICcuL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuaW1wb3J0IHtIYXNTaGFwZX0gZnJvbSAnLi90eXBlcyc7XG5cbmNvbnN0IERFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVggPSAnVmFyaWFibGUnO1xuXG4vKipcbiAqIEEgYHRmLmxheWVycy5MYXllclZhcmlhYmxlYCBpcyBzaW1pbGFyIHRvIGEgYHRmLlRlbnNvcmAgaW4gdGhhdCBpdCBoYXMgYVxuICogZHR5cGUgYW5kIHNoYXBlLCBidXQgaXRzIHZhbHVlIGlzIG11dGFibGUuICBUaGUgdmFsdWUgaXMgaXRzZWxmIHJlcHJlc2VudGVkXG4gKiBhcyBhYHRmLlRlbnNvcmAsIGFuZCBjYW4gYmUgcmVhZCB3aXRoIHRoZSBgcmVhZCgpYCBtZXRob2QgYW5kIHVwZGF0ZWQgd2l0aFxuICogdGhlIGB3cml0ZSgpYCBtZXRob2QuXG4gKi9cbmV4cG9ydCBjbGFzcyBMYXllclZhcmlhYmxlIHtcbiAgcmVhZG9ubHkgZHR5cGU6IERhdGFUeXBlO1xuICByZWFkb25seSBzaGFwZTogU2hhcGU7XG5cbiAgcmVhZG9ubHkgaWQ6IG51bWJlcjtcbiAgLy8gVGhlIGZ1bGx5IHNjb3BlZCBuYW1lIG9mIHRoaXMgVmFyaWFibGUsIGluY2x1ZGluZyBhIHVuaXF1ZSBzdWZmaXggaWYgbmVlZGVkXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbiAgLy8gVGhlIG9yaWdpbmFsbHkgcmVxdWVzdGVkIGZ1bGx5IHNjb3BlZCBuYW1lIG9mIHRoaXMgVmFyaWFibGUsIG5vdCBpbmNsdWRpbmdcbiAgLy8gYW55IHVuaXF1ZSBzdWZmaXguICBUaGlzIG1heSBiZSBuZWVkZWQgd2hlbiByZXN0b3Jpbmcgd2VpZ2h0cyBiZWNhdXNlIHRoaXNcbiAgLy8gb3JpZ2luYWwgbmFtZSBpcyB1c2VkIGFzIGEga2V5LlxuICByZWFkb25seSBvcmlnaW5hbE5hbWU6IHN0cmluZztcbiAgcHJpdmF0ZSB0cmFpbmFibGVfOiBib29sZWFuO1xuXG4gIHByb3RlY3RlZCByZWFkb25seSB2YWw6IHRmYy5WYXJpYWJsZTtcbiAgcmVhZG9ubHkgY29uc3RyYWludDogQ29uc3RyYWludDtcbiAgLyoqXG4gICAqIENvbnN0cnVjdCBWYXJpYWJsZSBmcm9tIGEgYHRmLlRlbnNvcmAuXG4gICAqXG4gICAqIElmIG5vdCBleHBsaWNpdGx5IG5hbWVkLCB0aGUgVmFyaWFibGUgd2lsbCBiZSBnaXZlbiBhIG5hbWUgd2l0aCB0aGVcbiAgICogcHJlZml4ICdWYXJpYWJsZScuIFZhcmlhYmxlIG5hbWVzIGFyZSB1bmlxdWUuIEluIHRoZSBjYXNlIG9mIG5hbWVcbiAgICogY29sbGlzaW9uLCBzdWZmaXhpZXMgJ188bnVtPicgd2lsbCBiZSBhZGRlZCB0byB0aGUgbmFtZS5cbiAgICpcbiAgICogQHBhcmFtIHZhbCBJbml0aWFsIHZhbHVlIG9mIHRoZSBWYXJpYWJsZS5cbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdmFyaWFibGUuIElmIGBudWxsYCBvciBgdW5kZWZpbmVkYCBpcyBwcm92aWRlZCwgaXRcbiAgICogICB3aWxsIGRlZmF1bHQgYSBuYW1lIHdpdGggdGhlIHByZWZpeCAnVmFyaWFibGUnLlxuICAgKiBAcGFyYW0gY29uc3RyYWludCBPcHRpb25hbCwgcHJvamVjdGlvbiBmdW5jdGlvbiB0byBiZSBhcHBsaWVkIHRvIHRoZVxuICAgKiB2YXJpYWJsZSBhZnRlciBvcHRpbWl6ZSB1cGRhdGVzXG4gICAqIEB0aHJvd3MgVmFsdWVFcnJvciBpZiBgbmFtZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICB2YWw6IFRlbnNvciwgZHR5cGU6IERhdGFUeXBlID0gJ2Zsb2F0MzInLFxuICAgICAgbmFtZSA9IERFRkFVTFRfVkFSSUFCTEVfTkFNRV9QUkVGSVgsIHRyYWluYWJsZSA9IHRydWUsXG4gICAgICBjb25zdHJhaW50OiBDb25zdHJhaW50ID0gbnVsbCkge1xuICAgIHRoaXMuZHR5cGUgPSBkdHlwZSA9PSBudWxsID8gJ2Zsb2F0MzInIDogZHR5cGU7XG4gICAgdGhpcy5zaGFwZSA9IHZhbC5zaGFwZTtcbiAgICB0aGlzLmlkID0gZ2V0TmV4dFVuaXF1ZVRlbnNvcklkKCk7XG5cbiAgICBuYW1lID0gbmFtZSA9PSBudWxsID8gREVGQVVMVF9WQVJJQUJMRV9OQU1FX1BSRUZJWCA6IG5hbWU7XG4gICAgdGhpcy5vcmlnaW5hbE5hbWUgPSBnZXRTY29wZWRUZW5zb3JOYW1lKG5hbWUpO1xuICAgIHRoaXMubmFtZSA9IGdldFVuaXF1ZVRlbnNvck5hbWUodGhpcy5vcmlnaW5hbE5hbWUpO1xuXG4gICAgdGhpcy50cmFpbmFibGVfID0gdHJhaW5hYmxlO1xuICAgIHRoaXMuY29uc3RyYWludCA9IGNvbnN0cmFpbnQ7XG5cbiAgICB0aGlzLnZhbCA9IHRmYy52YXJpYWJsZSh2YWwsIHRoaXMudHJhaW5hYmxlXywgdGhpcy5uYW1lLCB0aGlzLmR0eXBlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgYSBzbmFwc2hvdCBvZiB0aGUgVmFyaWFibGUncyB2YWx1ZS5cbiAgICpcbiAgICogVGhlIHJldHVybmVkIHZhbHVlIGlzIGEgc25hcHNob3Qgb2YgdGhlIFZhcmlhYmxlJ3MgdmFsdWUgYXQgdGhlIHRpbWUgb2ZcbiAgICogdGhlIGludm9jYXRpb24uIEZ1dHVyZSBtdXRhdGlvbnMgaW4gdGhlIHZhbHVlIG9mIHRoZSB0ZW5zb3Igd2lsbCBvbmx5XG4gICAqIGJlIHJlZmxlY3RlZCBieSBmdXR1cmUgY2FsbHMgdG8gdGhpcyBtZXRob2QuXG4gICAqL1xuICByZWFkKCk6IFRlbnNvciB7XG4gICAgdGhpcy5hc3NlcnROb3REaXNwb3NlZCgpO1xuICAgIHJldHVybiB0aGlzLnZhbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVcGRhdGUgdGhlIHZhbHVlIG9mIHRoZSBWYXJpYWJsZS5cbiAgICpcbiAgICogQHBhcmFtIG5ld1ZhbDogVGhlIG5ldyB2YWx1ZSB0byB1cGRhdGUgdG8uIE11c3QgYmUgY29uc2lzdGVudCB3aXRoIHRoZVxuICAgKiAgIGR0eXBlIGFuZCBzaGFwZSBvZiB0aGUgVmFyaWFibGUuXG4gICAqIEByZXR1cm4gVGhpcyBWYXJpYWJsZS5cbiAgICovXG4gIHdyaXRlKG5ld1ZhbDogVGVuc29yKSB7XG4gICAgLy8gVE9ETyhjYWlzKTogT25jZSAgVEYuanMgQ29yZSBzdXBwb3J0cyBUZW5zb3IuZHR5cGUsIGNoZWNrIGR0eXBlIG1hdGNoLlxuICAgIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICBjaGVja1NoYXBlc01hdGNoKHRoaXMudmFsLCBuZXdWYWwpO1xuICAgIC8vIFNraXAgdXBkYXRpbmcgaWYgdGhpcyBpcyB0aGUgZXhhY3Qgc2FtZSB0ZW5zb3IuXG4gICAgaWYgKHRoaXMudmFsLmlkICE9PSBuZXdWYWwuaWQpIHtcbiAgICAgIHRoaXMudmFsLmFzc2lnbihuZXdWYWwpO1xuICAgICAgaWYgKHRoaXMuY29uc3RyYWludCAhPSBudWxsKSB7XG4gICAgICAgIHRoaXMudmFsLmFzc2lnbih0aGlzLmNvbnN0cmFpbnQuYXBwbHkodGhpcy52YWwpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvKipcbiAgICogRGlzcG9zZSB0aGlzIExheWVyc1ZhcmlhYmxlIGluc3RhbmNlIGZyb20gbWVtb3J5LlxuICAgKi9cbiAgZGlzcG9zZSgpOiB2b2lkIHtcbiAgICB0aGlzLmFzc2VydE5vdERpc3Bvc2VkKCk7XG4gICAgdGhpcy52YWwuZGlzcG9zZSgpO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzc2VydE5vdERpc3Bvc2VkKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLnZhbC5pc0Rpc3Bvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYExheWVyc1ZhcmlhYmxlICR7dGhpcy5uYW1lfSBpcyBhbHJlYWR5IGRpc3Bvc2VkLmApO1xuICAgIH1cbiAgfVxuXG4gIGdldCB0cmFpbmFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMudHJhaW5hYmxlXztcbiAgfVxuXG4gIHNldCB0cmFpbmFibGUodHJhaW5hYmxlOiBib29sZWFuKSB7XG4gICAgdGhpcy50cmFpbmFibGVfID0gdHJhaW5hYmxlO1xuICAgIHRoaXMudmFsLnRyYWluYWJsZSA9IHRyYWluYWJsZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1NoYXBlc01hdGNoKHg6IEhhc1NoYXBlLCB5OiBIYXNTaGFwZSk6IHZvaWQge1xuICBpZiAoeC5zaGFwZS50b1N0cmluZygpICE9PSB5LnNoYXBlLnRvU3RyaW5nKCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdTaGFwZSBtaXNtYXRjaDogJyArIEpTT04uc3RyaW5naWZ5KHguc2hhcGUpICsgJyB2cy4gJyArXG4gICAgICAgIEpTT04uc3RyaW5naWZ5KHkuc2hhcGUpKTtcbiAgfVxufVxuXG4vKipcbiAqIENyZWF0ZSBhIFZhcmlhYmxlLlxuICogQHBhcmFtIHggVGhlIGluaXRpYWwgdmFsdWUgb2YgdGhlIGBWYXJpYWJsZWAuXG4gKiBAcGFyYW0gZHR5cGUgb3B0aW9uYWwsIHRoZSB0eXBlIG9mIHRoZSB2YXJpYWJsZS5cbiAqIEBwYXJhbSBuYW1lIG9wdGlvbmFsLCB0aGUgbmFtZSBvZiB0aGUgdmFyaWFibGUsIGRlZmF1bHQgcHJvdmlkZWQgYnlcbiAqIFZhcmlhYmxlLlxuICogQHBhcmFtIGNvbnN0cmFpbnQgb3B0aW9uYWwsIGEgY29uc3RyYWludCB0byBiZSBhcHBsaWVkIGFmdGVyIGV2ZXJ5IHVwZGF0ZS5cbiAqIEByZXR1cm4gVGhlIG5ld2x5IGluc3RhbnRpYXRlZCBgVmFyaWFibGVgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdmFyaWFibGUoXG4gICAgeDogVGVuc29yLCBkdHlwZT86IERhdGFUeXBlLCBuYW1lPzogc3RyaW5nLFxuICAgIGNvbnN0cmFpbnQ/OiBDb25zdHJhaW50KTogTGF5ZXJWYXJpYWJsZSB7XG4gIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZSh4LCBkdHlwZSwgbmFtZSwgdHJ1ZSwgY29uc3RyYWludCk7XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGFuIGFsbC16ZXJvcyBWYXJpYWJsZSBhbmQgcmV0dXJucyBpdC5cbiAqXG4gKiBAcGFyYW0gc2hhcGUgU2hhcGUgb2YgdGhlIHRlbnNvci5cbiAqIEBwYXJhbSBkdHlwZSBEVHlwZSBvZiB0aGUgdGVuc29yLlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdGVuc29yLlxuICogQHJldHVybiBBbiBhbGwtemVybyBWYXJpYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9zVmFyaWFibGUoXG4gICAgc2hhcGU6IFNoYXBlLCBkdHlwZT86IERhdGFUeXBlLCBuYW1lPzogc3RyaW5nKTogTGF5ZXJWYXJpYWJsZSB7XG4gIC8vIFRPRE8oY2Fpcyk6IEltcGxlbWVudCBsb2dpYyBmb3IgZHR5cGUuXG4gIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZSh0ZmMuemVyb3Moc2hhcGUpLCBkdHlwZSwgbmFtZSk7XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGVzIGFuIGFsbC16ZXJvcyB0ZW5zb3Igb2YgdGhlIHNhbWUgc2hhcGUgYXMgYW5vdGhlciB0ZW5zb3IuXG4gKlxuICogQHBhcmFtIHggVGhlIG90aGVyIHRlbnNvci5cbiAqIEBwYXJhbSBkdHlwZSBEVHlwZSBvZiB0aGUgdGVuc29yLlxuICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgdGVuc29yLlxuICogQHJldHVybiBBIG5ld2x5IGluc3RhbnRpYXRlZCBWYXJpYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHplcm9zTGlrZShcbiAgICB4OiBUZW5zb3IsIGR0eXBlPzogRGF0YVR5cGUsIG5hbWU/OiBzdHJpbmcpOiBMYXllclZhcmlhYmxlIHtcbiAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKHRmYy56ZXJvc0xpa2UoeCksIGR0eXBlLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYW4gYWxsLW9uZXMgdGVuc29yIGFuZCByZXR1cm5zIGl0LlxuICpcbiAqIEBwYXJhbSBzaGFwZSBTaGFwZSBvZiB0aGUgdGVuc29yLlxuICogQHBhcmFtIGR0eXBlIERUeXBlIG9mIHRoZSB0ZW5zb3IuXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHRoZSB0ZW5zb3IuXG4gKiBAcmV0dXJuIEFuIGFsbC1vbmVzIFZhcmlhYmxlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gb25lc1ZhcmlhYmxlKFxuICAgIHNoYXBlOiBTaGFwZSwgZHR5cGU/OiBEYXRhVHlwZSwgbmFtZT86IHN0cmluZyk6IExheWVyVmFyaWFibGUge1xuICAvLyBUT0RPKGNhaXMpOiBJbXBsZW1lbnQgbG9naWMgZm9yIGR0eXBlLlxuICBjb25zdCBhbGxvY2F0ZWQgPSB0ZmMub25lcyhzaGFwZSk7XG4gIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZShhbGxvY2F0ZWQsIGR0eXBlLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBJbnN0YW50aWF0ZXMgYW4gYWxsLW9uZXMgdGVuc29yIG9mIHRoZSBzYW1lIHNoYXBlIGFzIGFub3RoZXIgdGVuc29yLlxuICpcbiAqIEBwYXJhbSB4IFRoZSBvdGhlciB0ZW5zb3IuXG4gKiBAcGFyYW0gZHR5cGUgRFR5cGUgb2YgdGhlIHRlbnNvci5cbiAqIEBwYXJhbSBuYW1lIE5hbWUgb2YgdGhlIHRlbnNvci5cbiAqIEByZXR1cm4gQSBuZXdseSBpbnN0YW50aWF0ZWQgVmFyaWFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBvbmVzTGlrZShcbiAgICB4OiBUZW5zb3IsIGR0eXBlPzogRGF0YVR5cGUsIG5hbWU/OiBzdHJpbmcpOiBMYXllclZhcmlhYmxlIHtcbiAgY29uc3QgYWxsb2NhdGVkID0gdGZjLm9uZXNMaWtlKHgpO1xuICByZXR1cm4gbmV3IExheWVyVmFyaWFibGUoYWxsb2NhdGVkLCBkdHlwZSwgbmFtZSk7XG59XG5cbi8qKlxuICogSW5zdGFudGlhdGUgYW4gaWRlbnRpdHkgbWF0cml4IGFuZCByZXR1cm5zIGl0LCBhcyBhIFZhcmlhYmxlXG4gKlxuICogQHBhcmFtIHNpemUgTnVtYmVyIG9mIHJvd3MvY29sdW1ucy5cbiAqIEBwYXJhbSBkdHlwZSBEYXRhIHR5cGUgb2YgcmV0dXJuZWQgVmFyaWFibGUuXG4gKiBAcGFyYW0gbmFtZSBOYW1lIG9mIHJldHVybmVkIFZhcmlhYmxlLlxuICogQHJldHVybiBBIFZhcmlhYmxlLCBhbiBpZGVudGl0eSBtYXRyaXguXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleWVWYXJpYWJsZShcbiAgICBzaXplOiBudW1iZXIsIGR0eXBlPzogRGF0YVR5cGUsIG5hbWU/OiBzdHJpbmcpOiBMYXllclZhcmlhYmxlIHtcbiAgcmV0dXJuIG5ldyBMYXllclZhcmlhYmxlKHRmYy5leWUoc2l6ZSksIGR0eXBlLCBuYW1lKTtcbn1cblxuLyoqXG4gKiBHZXQgYSBWYXJpYWJsZSB3aXRoIHVuaWZvcm0gZGlzdHJpYnV0aW9uIG9mIHZhbHVlcy5cbiAqIEBwYXJhbSBzaGFwZSBTaGFwZSBvZiB0aGUgdGVuc29yLlxuICogQHBhcmFtIG1pbnZhbCBMb3dlciBib3VuZCBvZiB0aGUgdW5pZm9ybSBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0gbWF4dmFsIFVwcGVyIGJvdW5kIG9mIHRoZSB1bmlmb3JtIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSBkdHlwZVxuICogQHBhcmFtIHNlZWRcbiAqIEBwYXJhbSBuYW1lIE9wdGlvbmFsIG5hbWUuXG4gKiBAcmV0dXJuIFRoZSB1bmlmb3JtLXJhbmRvbSBWYXJpYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJhbmRvbVVuaWZvcm1WYXJpYWJsZShcbiAgICBzaGFwZTogU2hhcGUsIG1pbnZhbDogbnVtYmVyLCBtYXh2YWw6IG51bWJlciwgZHR5cGU/OiBEYXRhVHlwZSxcbiAgICBzZWVkPzogbnVtYmVyLCBuYW1lID0gJ3JhbmRvbVVuaWZvcm0nKTogTGF5ZXJWYXJpYWJsZSB7XG4gIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZShcbiAgICAgIHRmYy5yYW5kb21Vbmlmb3JtKHNoYXBlLCBtaW52YWwsIG1heHZhbCwgZHR5cGUpLCBkdHlwZSwgbmFtZSk7XG59XG5cbi8qKlxuICogR2V0IGEgVmFyaWFibGUgd2l0aCB0cnVuY2F0ZWQtbm9ybWFsIGRpc3RyaWJ1dGlvbiBvZiB2YWx1ZXMuXG4gKiBAcGFyYW0gc2hhcGUgU2hhcGUgb2YgdGhlIHRlbnNvci5cbiAqIEBwYXJhbSBtZWFuIG1lYW4gdmFsdWUgb2YgdGhlIG5vcm1hbCBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0gc3RkZGV2IHN0YW5kYXJkIGRldmlhdGlvbiBvZiB0aGUgbm9ybWFsIGRpc3RyaWJ1dGlvbi5cbiAqIEBwYXJhbSBkdHlwZVxuICogQHBhcmFtIHNlZWRcbiAqIEBwYXJhbSBuYW1lIE9wdGlvbmFsIG5hbWUuXG4gKiBAcmV0dXJuIFRoZSB0cnVuY2F0ZWQtbm9ybWFsLXJhbmRvbSBWYXJpYWJsZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHRydW5jYXRlZE5vcm1hbFZhcmlhYmxlKFxuICAgIHNoYXBlOiBTaGFwZSwgbWVhbiA9IDAuMCwgc3RkZGV2ID0gMS4wLCBkdHlwZT86IERhdGFUeXBlLCBzZWVkPzogbnVtYmVyLFxuICAgIG5hbWUgPSAndHJ1bmNhdGVkTm9ybWFsJyk6IExheWVyVmFyaWFibGUge1xuICAvLyBUT0RPKGNhaXMpOiBJbXBsZW1lbnQgbG9naWMgZm9yIGR0eXBlIGFuZCBzZWVkIG9uY2UgdGhleSBhcmUgc3VwcG9ydGVkXG4gIC8vIGJ5IGRlZXBsZWFybi5qcy5cbiAgZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gIGlmIChkdHlwZSAhPT0gJ2Zsb2F0MzInICYmIGR0eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgIGByYW5kb21Ob3JtYWwgZG9lcyBub3Qgc3VwcG9ydCBkVHlwZSAke2R0eXBlfS5gKTtcbiAgfVxuICByZXR1cm4gbmV3IExheWVyVmFyaWFibGUoXG4gICAgICB0ZmMudHJ1bmNhdGVkTm9ybWFsKHNoYXBlLCBtZWFuLCBzdGRkZXYsIGR0eXBlLCBzZWVkKSwgZHR5cGUsIG5hbWUpO1xufVxuLyoqXG4gKiBHZXQgYSBWYXJpYWJsZSB3aXRoIG5vcm1hbCBkaXN0cmlidXRpb24gb2YgdmFsdWVzLlxuICogQHBhcmFtIHNoYXBlIFNoYXBlIG9mIHRoZSB0ZW5zb3IuXG4gKiBAcGFyYW0gbWVhbiBtZWFuIHZhbHVlIG9mIHRoZSBub3JtYWwgZGlzdHJpYnV0aW9uLlxuICogQHBhcmFtIHN0ZGRldiBzdGFuZGFyZCBkZXZpYXRpb24gb2YgdGhlIG5vcm1hbCBkaXN0cmlidXRpb24uXG4gKiBAcGFyYW0gZHR5cGVcbiAqIEBwYXJhbSBzZWVkXG4gKiBAcGFyYW0gbmFtZSBPcHRpb25hbCBuYW1lLlxuICogQHJldHVybiBUaGUgdHJ1bmNhdGVkLW5vcm1hbC1yYW5kb20gVmFyaWFibGUuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21Ob3JtYWxWYXJpYWJsZShcbiAgICBzaGFwZTogU2hhcGUsIG1lYW4gPSAwLjAsIHN0ZGRldiA9IDEuMCwgZHR5cGU/OiBEYXRhVHlwZSwgc2VlZD86IG51bWJlcixcbiAgICBuYW1lID0gJ3JhbmRvbU5vcm1hbCcpOiBMYXllclZhcmlhYmxlIHtcbiAgZHR5cGUgPSBkdHlwZSB8fCAnZmxvYXQzMic7XG4gIGlmIChkdHlwZSAhPT0gJ2Zsb2F0MzInICYmIGR0eXBlICE9PSAnaW50MzInKSB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgIGByYW5kb21Ob3JtYWxWYXJpYWJsZSBkb2VzIG5vdCBzdXBwb3J0IGRUeXBlICR7ZHR5cGV9LmApO1xuICB9XG4gIHJldHVybiBuZXcgTGF5ZXJWYXJpYWJsZShcbiAgICAgIHRmYy5yYW5kb21Ob3JtYWwoc2hhcGUsIG1lYW4sIHN0ZGRldiwgZHR5cGUsIHNlZWQpLCBkdHlwZSwgbmFtZSk7XG59XG5cbi8qKlxuICogVXBkYXRlIHRoZSB2YWx1ZSBvZiBhIFZhcmlhYmxlLlxuICogQHBhcmFtIHggVGhlIFZhcmlhYmxlIHRvIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0geE5ldyBUaGUgbmV3IHZhbHVlIHRvIHVwZGF0ZSB0by5cbiAqIEByZXR1cm4gVGhlIFZhcmlhYmxlIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGUoeDogTGF5ZXJWYXJpYWJsZSwgeE5ldzogVGVuc29yKTogTGF5ZXJWYXJpYWJsZSB7XG4gIHJldHVybiB4LndyaXRlKHhOZXcpO1xufVxuXG4vKipcbiAqIFVwZGF0ZSB0aGUgdmFsdWUgb2YgYSBWYXJpYWJsZSBieSBhZGRpbmcgYW4gaW5jcmVtZW50LlxuICogQHBhcmFtIHggVGhlIFZhcmlhYmxlIHRvIGJlIHVwZGF0ZWQuXG4gKiBAcGFyYW0gaW5jcmVtZW50IFRoZSBpbmNybWVudCB0byBhZGQgdG8gYHhgLlxuICogQHJldHVybiBUaGUgVmFyaWFibGUgdXBkYXRlZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHVwZGF0ZUFkZCh4OiBMYXllclZhcmlhYmxlLCBpbmNyZW1lbnQ6IFRlbnNvcik6IExheWVyVmFyaWFibGUge1xuICByZXR1cm4geC53cml0ZSh0ZmMuYWRkKHgucmVhZCgpLCBpbmNyZW1lbnQpKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHZhbHVlIG9mIGEgVmFyaWFibGUgYnkgc3VidHJhY3RpbmcgYSBkZWNyZW1lbnQuXG4gKiBAcGFyYW0geCBUaGUgVmFyaWFibGUgdG8gYmUgdXBkYXRlZC5cbiAqIEBwYXJhbSBkZWNyZW1lbnQgVGhlIGRlY3JlbWVudCB0byBzdWJ0cmFjdCBmcm9tIGB4YC5cbiAqIEByZXR1cm4gVGhlIFZhcmlhYmxlIHVwZGF0ZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVTdWIoeDogTGF5ZXJWYXJpYWJsZSwgZGVjcmVtZW50OiBUZW5zb3IpOiBMYXllclZhcmlhYmxlIHtcbiAgcmV0dXJuIHgud3JpdGUodGZjLnN1Yih4LnJlYWQoKSwgZGVjcmVtZW50KSk7XG59XG5cbi8qKlxuICogR2V0IHRoZSB2YWx1ZXMgb2YgYW4gYXJyYXkgb2YgVmFyaWFibGVzLlxuICpcbiAqIEBwYXJhbSB0ZW5zb3JzIEFuIGBBcnJheWAgb2YgYFZhcmlhYmxlYHMgdG8gZ2V0IHRoZSB2YWx1ZXMgb2YuXG4gKiBAcmV0dXJuIFRoZSB2YWx1ZXMgb2YgdGhlIGlucHV0cywgYXMgYW4gYEFycmF5YCBvZmB0Zi5UZW5zb3Jgcy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhdGNoR2V0VmFsdWUoeHM6IExheWVyVmFyaWFibGVbXSk6IFRlbnNvcltdIHtcbiAgcmV0dXJuIHhzLm1hcCh4ID0+IHgucmVhZCgpKTtcbn1cblxuLyoqXG4gKiBVcGRhdGUgdGhlIHZhbHVlIG9mIG11bHRpcGxlIFZhcmlhYmxlcyBhdCBvbmNlLlxuICpcbiAqIEBwYXJhbSB2YXJpYWJsZXNBbmRWYWx1ZXMgQW4gYEFycmF5YCwgZWFjaCBlbGVtZW50IGlzIG9mIHR5cGVcbiAqICAgW1ZhcmlhYmxlLCBUZW5zb3JdLiBUaGUgZmlyc3QgaXRlbSBpcyB0aGVcbiAqICAgYFZhcmlhYmxlYCBvZiB3aGljaCB0aGUgdmFsdWUgaXMgdG8gYmUgdXBkYXRlZC4gVGhlIHNlY29uZCBpdGVtXG4gKiAgIGNhcnJpZXMgdGhlIG5ldyB2YWx1ZS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhdGNoU2V0VmFsdWUoXG4gICAgdmFyaWFibGVzQW5kVmFsdWVzOiBBcnJheTxbTGF5ZXJWYXJpYWJsZSwgVGVuc29yXT4pOiB2b2lkIHtcbiAgdmFyaWFibGVzQW5kVmFsdWVzLmZvckVhY2godmFyaWFibGVBbmRWYWx1ZSA9PiB7XG4gICAgY29uc3QgdmFyaWFibGU6IExheWVyVmFyaWFibGUgPSB2YXJpYWJsZUFuZFZhbHVlWzBdO1xuICAgIHZhcmlhYmxlLndyaXRlKHZhcmlhYmxlQW5kVmFsdWVbMV0pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBncmFkaWVudHMgb2YgYHZhcmlhYmxlc2Agdy5yLnQuIHRoZSByZXR1cm4gdmFsdWUgb2YgYGxvc3NGbmAuXG4gKiBAcGFyYW0gbG9zc0ZuIEEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFNjYWxhciB0byBiZSB1c2VkIGFzIHRoZSBmdW5jdGlvblxuICogICB2YWx1ZSAoaS5lLiwgbnVtZXJhdG9yKSBmb3IgZGlmZmVyZW50aWF0aW9uLlxuICogQHBhcmFtIHZhcmlhYmxlcyBMaXN0IG9mIHZhcmlhYmxlcyB0byBiZSB1c2VkIGFzIHRoZSBpbmRlcGVuZGVudCB2YXJpYWJsZXNcbiAqICAgKGkuZS4sIGRlbm9taW5hdG9yKSBmb3IgZGlmZmVyZW50aWF0aW9uLlxuICogQHJldHVybnMgQW4gQXJyYXkgb2YgZ3JhZGllbnRzIHRlbnNvcnMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBncmFkaWVudHMoXG4gICAgbG9zc0ZuOiAoKSA9PiB0ZmMuU2NhbGFyLCB2YXJpYWJsZXM6IExheWVyVmFyaWFibGVbXSk6IFRlbnNvcltdIHtcbiAgLy8gVE9ETyhjYWlzKTogVGhlIHJldHVybiB0eXBlIHNpZ25hdHVyZSBjYW4gYmUgc2ltcGxpZmllZCBpZiBkZWVwbGVhcm4gbWFrZXNcbiAgLy8gICB0aGUgY29ycmVzcG9uZGluZyB0eXBlIHB1YmxpYy5cbiAgY29uc3QgdmFyaWFibGVMaXN0ID1cbiAgICAgIHZhcmlhYmxlcy5tYXAodmFyaWFibGUgPT4gdmFyaWFibGUucmVhZCgpIGFzIHRmYy5WYXJpYWJsZSk7XG4gIGNvbnN0IHZhbHVkQW5kR3JhZHMgPSB2YXJpYWJsZUdyYWRzKGxvc3NGbiwgdmFyaWFibGVMaXN0KTtcbiAgcmV0dXJuIHZhcmlhYmxlcy5tYXAodmFyaWFibGUgPT4gdmFsdWRBbmRHcmFkcy5ncmFkc1t2YXJpYWJsZS5uYW1lXSk7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/engine/topology.py */\nimport { serialization, tidy, util } from '@tensorflow/tfjs-core';\nimport { getNextUniqueTensorId, getUid } from '../backend/state';\nimport { getScopedTensorName, getUniqueTensorName, nameScope } from '../common';\nimport { AttributeError, NotImplementedError, RuntimeError, ValueError } from '../errors';\nimport { getInitializer } from '../initializers';\nimport * as generic_utils from '../utils/generic_utils';\nimport * as types_utils from '../utils/types_utils';\nimport * as variable_utils from '../utils/variable_utils';\nimport { batchGetValue, batchSetValue, LayerVariable } from '../variables';\n/**\n * Specifies the ndim, dtype and shape of every input to a layer.\n *\n * Every layer should expose (if appropriate) an `inputSpec` attribute:\n * a list of instances of InputSpec (one per input tensor).\n *\n * A null entry in a shape is compatible with any dimension,\n * a null shape is compatible with any shape.\n */\nexport class InputSpec {\n    constructor(args) {\n        this.dtype = args.dtype;\n        this.shape = args.shape;\n        /*\n          TODO(michaelterry): Could throw error if ndim and shape are both defined\n            (then backport).\n        */\n        if (args.shape != null) {\n            this.ndim = args.shape.length;\n        }\n        else {\n            this.ndim = args.ndim;\n        }\n        this.maxNDim = args.maxNDim;\n        this.minNDim = args.minNDim;\n        this.axes = args.axes || {};\n    }\n}\n/**\n * `tf.SymbolicTensor` is a placeholder for a Tensor without any concrete value.\n *\n * They are most often encountered when building a graph of `Layer`s for a\n * a `tf.LayersModel` and the input data's shape, but not values are known.\n *\n * @doc {heading: 'Models', 'subheading': 'Classes'}\n */\nexport class SymbolicTensor {\n    /**\n     *\n     * @param dtype\n     * @param shape\n     * @param sourceLayer The Layer that produced this symbolic tensor.\n     * @param inputs The inputs passed to sourceLayer's __call__() method.\n     * @param nodeIndex\n     * @param tensorIndex\n     * @param callArgs The keyword arguments passed to the __call__() method.\n     * @param name\n     * @param outputTensorIndex The index of this tensor in the list of outputs\n     *   returned by apply().\n     */\n    constructor(dtype, shape, sourceLayer, inputs, callArgs, name, outputTensorIndex) {\n        this.dtype = dtype;\n        this.shape = shape;\n        this.sourceLayer = sourceLayer;\n        this.inputs = inputs;\n        this.callArgs = callArgs;\n        this.outputTensorIndex = outputTensorIndex;\n        this.id = getNextUniqueTensorId();\n        if (name != null) {\n            this.originalName = getScopedTensorName(name);\n            this.name = getUniqueTensorName(this.originalName);\n        }\n        this.rank = shape.length;\n    }\n}\nlet _nextNodeID = 0;\n/**\n * A `Node` describes the connectivity between two layers.\n *\n * Each time a layer is connected to some new input,\n * a node is added to `layer.inboundNodes`.\n *\n * Each time the output of a layer is used by another layer,\n * a node is added to `layer.outboundNodes`.\n *\n * `nodeIndices` and `tensorIndices` are basically fine-grained coordinates\n * describing the origin of the `inputTensors`, verifying the following:\n *\n * `inputTensors[i] ==\n * inboundLayers[i].inboundNodes[nodeIndices[i]].outputTensors[\n *   tensorIndices[i]]`\n *\n * A node from layer A to layer B is added to:\n *     A.outboundNodes\n *     B.inboundNodes\n */\nexport class Node {\n    constructor(args, \n    // TODO(michaelterry): Define actual type for this.\n    callArgs) {\n        this.callArgs = callArgs;\n        this.id = _nextNodeID++;\n        /*\n          Layer instance (NOT a list).\n          this is the layer that takes a list of input tensors\n          and turns them into a list of output tensors.\n          the current node will be added to\n          the inboundNodes of outboundLayer.\n        */\n        this.outboundLayer = args.outboundLayer;\n        /*\n            The following 3 properties describe where\n            the input tensors come from: which layers,\n            and for each layer, which node and which\n            tensor output of each node.\n        */\n        // List of layer instances.\n        this.inboundLayers = args.inboundLayers;\n        // List of integers, 1:1 mapping with inboundLayers.\n        this.nodeIndices = args.nodeIndices;\n        // List of integers, 1:1 mapping with inboundLayers.\n        this.tensorIndices = args.tensorIndices;\n        /*\n            Following 2 properties:\n            tensor inputs and outputs of outboundLayer.\n        */\n        // List of tensors. 1:1 mapping with inboundLayers.\n        this.inputTensors = args.inputTensors;\n        // List of tensors, created by outboundLayer.call().\n        this.outputTensors = args.outputTensors;\n        /*\n            Following 2 properties: input and output masks.\n            List of tensors, 1:1 mapping with inputTensor.\n        */\n        this.inputMasks = args.inputMasks;\n        // List of tensors, created by outboundLayer.computeMask().\n        this.outputMasks = args.outputMasks;\n        // Following 2 properties: input and output shapes.\n        // List of shape tuples, shapes of inputTensors.\n        this.inputShapes = args.inputShapes;\n        // List of shape tuples, shapes of outputTensors.\n        this.outputShapes = args.outputShapes;\n        // Add nodes to all layers involved.\n        for (const layer of args.inboundLayers) {\n            if (layer != null) {\n                layer.outboundNodes.push(this);\n            }\n        }\n        args.outboundLayer.inboundNodes.push(this);\n    }\n    getConfig() {\n        const inboundNames = [];\n        for (const layer of this.inboundLayers) {\n            if (layer != null) {\n                inboundNames.push(layer.name);\n            }\n            else {\n                inboundNames.push(null);\n            }\n        }\n        return {\n            outboundLayer: this.outboundLayer ? this.outboundLayer.name : null,\n            inboundLayers: inboundNames,\n            nodeIndices: this.nodeIndices,\n            tensorIndices: this.tensorIndices\n        };\n    }\n}\nlet _nextLayerID = 0;\n/**\n * A layer is a grouping of operations and weights that can be composed to\n * create a `tf.LayersModel`.\n *\n * Layers are constructed by using the functions under the\n * [tf.layers](#Layers-Basic) namespace.\n *\n * @doc {heading: 'Layers', subheading: 'Classes', namespace: 'layers'}\n */\nexport class Layer extends serialization.Serializable {\n    constructor(args = {}) {\n        super();\n        this._callHook = null;\n        this._addedWeightNames = [];\n        // Porting Notes: PyKeras does not have this property in this base Layer\n        //   class. Instead lets Layer subclass set it dynamically and checks the\n        //   value with `hasattr`. In tfjs-layers, we let this be a member of this\n        //   base class.\n        this._stateful = false;\n        this.id = _nextLayerID++;\n        this.activityRegularizer = null;\n        this.inputSpec = null;\n        this.supportsMasking = false;\n        // These properties will be set upon call of this.build()\n        this._trainableWeights = [];\n        this._nonTrainableWeights = [];\n        this._losses = [];\n        this._updates = [];\n        this._built = false;\n        /*\n          These lists will be filled via successive calls\n          to this.addInboundNode().\n         */\n        this.inboundNodes = [];\n        this.outboundNodes = [];\n        let name = args.name;\n        if (!name) {\n            const prefix = this.getClassName();\n            name = generic_utils.toSnakeCase(prefix) + '_' + getUid(prefix);\n        }\n        this.name = name;\n        this.trainable_ = args.trainable == null ? true : args.trainable;\n        if (args.inputShape != null || args.batchInputShape != null) {\n            /*\n              In this case we will later create an input layer\n              to insert before the current layer\n             */\n            let batchInputShape;\n            if (args.batchInputShape != null) {\n                batchInputShape = args.batchInputShape;\n            }\n            else if (args.inputShape != null) {\n                let batchSize = null;\n                if (args.batchSize != null) {\n                    batchSize = args.batchSize;\n                }\n                batchInputShape = [batchSize].concat(args.inputShape);\n            }\n            this.batchInputShape = batchInputShape;\n            // Set dtype.\n            let dtype = args.dtype;\n            if (dtype == null) {\n                dtype = args.inputDType;\n            }\n            if (dtype == null) {\n                dtype = 'float32';\n            }\n            this.dtype = dtype;\n        }\n        if (args.weights != null) {\n            this.initialWeights = args.weights;\n        }\n        else {\n            this.initialWeights = null;\n        }\n        // The value of `_refCount` is initialized to null. When the layer is used\n        // in a symbolic way for the first time, it will be set to 1.\n        this._refCount = null;\n        this.fastWeightInitDuringBuild = false;\n    }\n    /**\n     * Converts a layer and its index to a unique (immutable type) name.\n     * This function is used internally with `this.containerNodes`.\n     * @param layer The layer.\n     * @param nodeIndex The layer's position (e.g. via enumerate) in a list of\n     *   nodes.\n     *\n     * @returns The unique name.\n     */\n    static nodeKey(layer, nodeIndex) {\n        return layer.name + '_ib-' + nodeIndex.toString();\n    }\n    /**\n     * Returns this.inboundNode at index nodeIndex.\n     *\n     * Porting note: This is a replacement for _get_node_attribute_at_index()\n     * @param nodeIndex\n     * @param attrName The name of the attribute related to request for this node.\n     */\n    getNodeAtIndex(nodeIndex, attrName) {\n        if (this.inboundNodes.length === 0) {\n            throw new RuntimeError('The layer has never been called ' +\n                `and thus has no defined ${attrName}.`);\n        }\n        if (this.inboundNodes.length <= nodeIndex) {\n            throw new ValueError(`Asked to get ${attrName} at node ${nodeIndex}, ` +\n                `but the layer has only ${this.inboundNodes.length} inbound nodes.`);\n        }\n        return this.inboundNodes[nodeIndex];\n    }\n    /**\n     * Retrieves the input tensor(s) of a layer at a given node.\n     *\n     * @param nodeIndex Integer, index of the node from which to retrieve the\n     *   attribute. E.g. `nodeIndex=0` will correspond to the first time the layer\n     *   was called.\n     *\n     * @return A tensor (or list of tensors if the layer has multiple inputs).\n     */\n    getInputAt(nodeIndex) {\n        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'input').inputTensors);\n    }\n    /**\n     * Retrieves the output tensor(s) of a layer at a given node.\n     *\n     * @param nodeIndex Integer, index of the node from which to retrieve the\n     *   attribute. E.g. `nodeIndex=0` will correspond to the first time the layer\n     *   was called.\n     *\n     * @return A tensor (or list of tensors if the layer has multiple outputs).\n     */\n    getOutputAt(nodeIndex) {\n        return generic_utils.singletonOrArray(this.getNodeAtIndex(nodeIndex, 'output').outputTensors);\n    }\n    // Properties\n    /**\n     * Retrieves the input tensor(s) of a layer.\n     *\n     * Only applicable if the layer has exactly one inbound node,\n     * i.e. if it is connected to one incoming layer.\n     *\n     * @return Input tensor or list of input tensors.\n     *\n     * @exception AttributeError if the layer is connected to more than one\n     *   incoming layers.\n     */\n    get input() {\n        if (this.inboundNodes.length > 1) {\n            throw new AttributeError(`Layer ${this.name}` +\n                ' has multiple inbound nodes, ' +\n                'hence the notion of \"layer input\" ' +\n                'is ill-defined. ' +\n                'Use `getInputAt(nodeIndex)` instead.');\n        }\n        else if (this.inboundNodes.length === 0) {\n            throw new AttributeError(`Layer ${this.name}` +\n                ' is not connected, no input to return.');\n        }\n        return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'input').inputTensors);\n    }\n    /**\n     * Retrieves the output tensor(s) of a layer.\n     *\n     * Only applicable if the layer has exactly one inbound node,\n     * i.e. if it is connected to one incoming layer.\n     *\n     * @return Output tensor or list of output tensors.\n     *\n     * @exception AttributeError if the layer is connected to more than one\n     *   incoming layers.\n     */\n    get output() {\n        if (this.inboundNodes.length === 0) {\n            throw new AttributeError(`Layer ${this.name}` +\n                ' has no inbound nodes.');\n        }\n        if (this.inboundNodes.length > 1) {\n            throw new AttributeError(`Layer ${this.name}` +\n                ' has multiple inbound nodes, ' +\n                'hence the notion of \"layer output\" ' +\n                'is ill-defined. ' +\n                'Use `getOutputAt(nodeIndex)` instead.');\n        }\n        return generic_utils.singletonOrArray(this.getNodeAtIndex(0, 'output').outputTensors);\n    }\n    get losses() {\n        return this._losses;\n    }\n    /**\n     * Retrieves the Layer's current loss values.\n     *\n     * Used for regularizers during training.\n     */\n    calculateLosses() {\n        // Porting Node: This is an augmentation to Layer.loss in PyKeras.\n        //   In PyKeras, Layer.loss returns symbolic tensors. Here a concrete\n        //   Tensor (specifically Scalar) values are returned. This is due to the\n        //   imperative backend.\n        return this.losses.map(lossFn => lossFn());\n    }\n    get updates() {\n        return this._updates;\n    }\n    get built() {\n        return this._built;\n    }\n    set built(built) {\n        this._built = built;\n    }\n    get trainable() {\n        return this.trainable_;\n    }\n    set trainable(trainable) {\n        this._trainableWeights.forEach(w => w.trainable = trainable);\n        this.trainable_ = trainable;\n    }\n    get trainableWeights() {\n        if (this.trainable_) {\n            return this._trainableWeights.filter(w => w.trainable);\n        }\n        else {\n            return [];\n        }\n    }\n    set trainableWeights(weights) {\n        this._trainableWeights = weights;\n    }\n    get nonTrainableWeights() {\n        if (this.trainable) {\n            return this._trainableWeights.filter(w => !w.trainable)\n                .concat(this._nonTrainableWeights);\n        }\n        else {\n            return this._trainableWeights.concat(this._nonTrainableWeights);\n        }\n    }\n    set nonTrainableWeights(weights) {\n        this._nonTrainableWeights = weights;\n    }\n    /**\n     * The concatenation of the lists trainableWeights and nonTrainableWeights\n     * (in this order).\n     */\n    get weights() {\n        return this.trainableWeights.concat(this.nonTrainableWeights);\n    }\n    get stateful() {\n        return this._stateful;\n    }\n    /**\n     * Reset the states of the layer.\n     *\n     * This method of the base Layer class is essentially a no-op.\n     * Subclasses that are stateful (e.g., stateful RNNs) should override this\n     * method.\n     */\n    resetStates() {\n        if (!this.stateful) {\n            throw new Error('Cannot call the resetStates() method of a non-stateful Layer ' +\n                'object.');\n        }\n    }\n    /**\n     * Checks compatibility between the layer and provided inputs.\n     *\n     * This checks that the tensor(s) `input`\n     * verify the input assumptions of the layer\n     * (if any). If not, exceptions are raised.\n     *\n     * @param inputs Input tensor or list of input tensors.\n     *\n     * @exception ValueError in case of mismatch between\n     *   the provided inputs and the expectations of the layer.\n     */\n    assertInputCompatibility(inputs) {\n        inputs = generic_utils.toList(inputs);\n        if (this.inputSpec == null || this.inputSpec.length === 0) {\n            return;\n        }\n        const inputSpec = generic_utils.toList(this.inputSpec);\n        if (inputs.length !== inputSpec.length) {\n            throw new ValueError(`Layer ${this.name} expects ${inputSpec.length} inputs, ` +\n                `but it received ${inputs.length} input tensors. ` +\n                `Input received: ${inputs}`);\n        }\n        for (let inputIndex = 0; inputIndex < inputs.length; inputIndex++) {\n            const x = inputs[inputIndex];\n            const spec = inputSpec[inputIndex];\n            if (spec == null) {\n                continue;\n            }\n            // Check ndim.\n            const ndim = x.rank;\n            if (spec.ndim != null) {\n                if (ndim !== spec.ndim) {\n                    throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}: ` +\n                        `expected ndim=${spec.ndim}, found ndim=${ndim}`);\n                }\n            }\n            if (spec.maxNDim != null) {\n                if (ndim > spec.maxNDim) {\n                    throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}` +\n                        `: expected max_ndim=${spec.maxNDim}, found ndim=${ndim}`);\n                }\n            }\n            if (spec.minNDim != null) {\n                if (ndim < spec.minNDim) {\n                    throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name}` +\n                        `: expected min_ndim=${spec.minNDim}, found ndim=${ndim}.`);\n                }\n            }\n            // Check dtype.\n            if (spec.dtype != null) {\n                if (x.dtype !== spec.dtype) {\n                    throw new ValueError(`Input ${inputIndex} is incompatible with layer ${this.name} ` +\n                        `: expected dtype=${spec.dtype}, found dtype=${x.dtype}.`);\n                }\n            }\n            // Check specific shape axes.\n            if (spec.axes) {\n                const xShape = x.shape;\n                for (const key in spec.axes) {\n                    const axis = Number(key);\n                    const value = spec.axes[key];\n                    // Perform Python-style slicing in case axis < 0;\n                    // TODO(cais): Use https://github.com/alvivi/typescript-underscore to\n                    // ensure type safety through Underscore calls.\n                    const xShapeAtAxis = axis >= 0 ? xShape[axis] : xShape[xShape.length + axis];\n                    if (value != null && [value, null].indexOf(xShapeAtAxis) === -1) {\n                        throw new ValueError(`Input ${inputIndex} is incompatible with layer ` +\n                            `${this.name}: expected axis ${axis} of input shape to ` +\n                            `have value ${value} but got shape ${xShape}.`);\n                    }\n                }\n            }\n            // Check shape.\n            if (spec.shape != null) {\n                for (let i = 0; i < spec.shape.length; ++i) {\n                    const specDim = spec.shape[i];\n                    const dim = x.shape[i];\n                    if (specDim != null && dim != null) {\n                        if (specDim !== dim) {\n                            throw new ValueError(`Input ${inputIndex} is incompatible with layer ` +\n                                `${this.name}: expected shape=${spec.shape}, ` +\n                                `found shape=${x.shape}.`);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    /**\n     * This is where the layer's logic lives.\n     *\n     * @param inputs Input tensor, or list/tuple of input tensors.\n     * @param kwargs Additional keyword arguments.\n     *\n     * @return A tensor or list/tuple of tensors.\n     */\n    call(inputs, kwargs) {\n        return inputs;\n    }\n    invokeCallHook(inputs, kwargs) {\n        if (this._callHook != null) {\n            this._callHook(inputs, kwargs);\n        }\n    }\n    /**\n     * Set call hook.\n     * This is currently used for testing only.\n     * @param callHook\n     */\n    setCallHook(callHook) {\n        this._callHook = callHook;\n    }\n    /**\n     * Clear call hook.\n     * This is currently used for testing only.\n     */\n    clearCallHook() {\n        this._callHook = null;\n    }\n    /**\n     * Builds or executes a `Layer's logic.\n     *\n     * When called with `tf.Tensor`(s), execute the `Layer`s computation and\n     * return Tensor(s). For example:\n     *\n     * ```js\n     * const denseLayer = tf.layers.dense({\n     *   units: 1,\n     *   kernelInitializer: 'zeros',\n     *   useBias: false\n     * });\n     *\n     * // Invoke the layer's apply() method with a `tf.Tensor` (with concrete\n     * // numeric values).\n     * const input = tf.ones([2, 2]);\n     * const output = denseLayer.apply(input);\n     *\n     * // The output's value is expected to be [[0], [0]], due to the fact that\n     * // the dense layer has a kernel initialized to all-zeros and does not have\n     * // a bias.\n     * output.print();\n     * ```\n     *\n     * When called with `tf.SymbolicTensor`(s), this will prepare the layer for\n     * future execution.  This entails internal book-keeping on shapes of\n     * expected Tensors, wiring layers together, and initializing weights.\n     *\n     * Calling `apply` with `tf.SymbolicTensor`s are typically used during the\n     * building of non-`tf.Sequential` models. For example:\n     *\n     * ```js\n     * const flattenLayer = tf.layers.flatten();\n     * const denseLayer = tf.layers.dense({units: 1});\n     *\n     * // Use tf.layers.input() to obtain a SymbolicTensor as input to apply().\n     * const input = tf.input({shape: [2, 2]});\n     * const output1 = flattenLayer.apply(input);\n     *\n     * // output1.shape is [null, 4]. The first dimension is the undetermined\n     * // batch size. The second dimension comes from flattening the [2, 2]\n     * // shape.\n     * console.log(JSON.stringify(output1.shape));\n     *\n     * // The output SymbolicTensor of the flatten layer can be used to call\n     * // the apply() of the dense layer:\n     * const output2 = denseLayer.apply(output1);\n     *\n     * // output2.shape is [null, 1]. The first dimension is the undetermined\n     * // batch size. The second dimension matches the number of units of the\n     * // dense layer.\n     * console.log(JSON.stringify(output2.shape));\n     *\n     * // The input and output and be used to construct a model that consists\n     * // of the flatten and dense layers.\n     * const model = tf.model({inputs: input, outputs: output2});\n     * ```\n     *\n     * @param inputs a `tf.Tensor` or `tf.SymbolicTensor` or an Array of them.\n     * @param kwargs Additional keyword arguments to be passed to `call()`.\n     *\n     * @return Output of the layer's `call` method.\n     *\n     * @exception ValueError error in case the layer is missing shape information\n     *   for its `build` call.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    // Porting Note: This is a replacement for __call__() in Python.\n    apply(inputs, kwargs) {\n        kwargs = kwargs || {};\n        this.assertNotDisposed();\n        // Ensure inputs are all the same type.\n        const inputsList = generic_utils.toList(inputs);\n        let allAreSymbolic = true;\n        for (const input of inputsList) {\n            if (!(input instanceof SymbolicTensor)) {\n                allAreSymbolic = false;\n                break;\n            }\n        }\n        let noneAreSymbolic = true;\n        for (const input of inputsList) {\n            if (input instanceof SymbolicTensor) {\n                noneAreSymbolic = false;\n                break;\n            }\n        }\n        if (allAreSymbolic === noneAreSymbolic) {\n            throw new ValueError('Arguments to apply() must be all ' +\n                'SymbolicTensors or all Tensors');\n        }\n        // TODO(michaelterry): nameScope() may not be necessary.\n        return nameScope(this.name, () => {\n            // Handle laying building (weight creating, input spec locking).\n            if (!this.built) {\n                /*\n                  Throw exceptions in case the input is not compatible\n                  with the inputSpec specified in the layer constructor.\n                 */\n                this.assertInputCompatibility(inputs);\n                // Collect input shapes to build layer.\n                const inputShapes = [];\n                for (const xElem of generic_utils.toList(inputs)) {\n                    inputShapes.push(xElem.shape);\n                }\n                this.build(generic_utils.singletonOrArray(inputShapes));\n                this.built = true;\n                // Load weights that were specified at layer instantiation.\n                if (this.initialWeights) {\n                    this.setWeights(this.initialWeights);\n                }\n                if (this._refCount === null && noneAreSymbolic) {\n                    // The first use of this layer is a non-symbolic call, set ref count\n                    // to 1 so the Layer can be properly disposed if its dispose() method\n                    // is called.\n                    this._refCount = 1;\n                }\n            }\n            /*\n              Throw exceptions in case the input is not compatible\n              with the inputSpec set at build time.\n            */\n            this.assertInputCompatibility(inputs);\n            // Handle mask propagation.\n            // TODO(michaelterry): Mask propagation not currently implemented.\n            // Actually call the layer, collecting output(s), mask(s), and shape(s).\n            if (noneAreSymbolic) {\n                let output = this.call(inputs, kwargs);\n                // TODO(michaelterry): Compute the outputMask\n                // If the layer returns tensors from its inputs, unmodified,\n                // we copy them to avoid loss of tensor metadata.\n                const outputList = generic_utils.toList(output);\n                const outputListCopy = [];\n                // TODO(michaelterry): This copying may not be necessary given our eager\n                // backend.\n                for (let x of outputList) {\n                    if (inputsList.indexOf(x) !== -1) {\n                        x = x.clone();\n                    }\n                    outputListCopy.push(x);\n                }\n                output = generic_utils.singletonOrArray(outputListCopy);\n                if (this.activityRegularizer != null) {\n                    throw new NotImplementedError('Layer invocation in the presence of activity ' +\n                        'regularizer(s) is not supported yet.');\n                }\n                // TODO(michaelterry): Call addInboundNode()?\n                return output;\n            }\n            else {\n                const inputShape = collectInputShape(inputs);\n                const outputShape = this.computeOutputShape(inputShape);\n                let output;\n                const outputDType = guessOutputDType(inputs);\n                this.warnOnIncompatibleInputShape(Array.isArray(inputs) ? inputShape[0] :\n                    inputShape);\n                if (outputShape != null && outputShape.length > 0 &&\n                    Array.isArray(outputShape[0])) {\n                    // We have multiple output shapes. Create multiple output tensors.\n                    output = outputShape\n                        .map((shape, index) => new SymbolicTensor(outputDType, shape, this, generic_utils.toList(inputs), kwargs, this.name, index));\n                }\n                else {\n                    output = new SymbolicTensor(outputDType, outputShape, this, generic_utils.toList(inputs), kwargs, this.name);\n                }\n                /*\n                  Add an inbound node to the layer, so that it keeps track\n                  of the call and of all new variables created during the call.\n                  This also updates the layer history of the output tensor(s).\n                  If the input tensor(s) had no previous history,\n                  this does nothing.\n                */\n                this.addInboundNode(inputs, output, null, null, inputShape, outputShape, kwargs);\n                this._refCount++;\n                if (this.activityRegularizer != null) {\n                    throw new NotImplementedError('Layer invocation in the presence of activity ' +\n                        'regularizer(s) is not supported yet.');\n                }\n                return output;\n            }\n        });\n    }\n    /**\n     * Check compatibility between input shape and this layer's batchInputShape.\n     *\n     * Print warning if any incompatibility is found.\n     *\n     * @param inputShape Input shape to be checked.\n     */\n    warnOnIncompatibleInputShape(inputShape) {\n        if (this.batchInputShape == null) {\n            return;\n        }\n        else if (inputShape.length !== this.batchInputShape.length) {\n            console.warn(`The rank of the input tensor provided (shape: ` +\n                `${JSON.stringify(inputShape)}) does not match that of the ` +\n                `batchInputShape (${JSON.stringify(this.batchInputShape)}) ` +\n                `of the layer ${this.name}`);\n        }\n        else {\n            let dimMismatch = false;\n            this.batchInputShape.forEach((dimension, i) => {\n                if (dimension != null && inputShape[i] != null &&\n                    inputShape[i] !== dimension) {\n                    dimMismatch = true;\n                }\n            });\n            if (dimMismatch) {\n                console.warn(`The shape of the input tensor ` +\n                    `(${JSON.stringify(inputShape)}) does not ` +\n                    `match the expectation of layer ${this.name}: ` +\n                    `${JSON.stringify(this.batchInputShape)}`);\n            }\n        }\n    }\n    /**\n     * Retrieves the output shape(s) of a layer.\n     *\n     * Only applicable if the layer has only one inbound node, or if all inbound\n     * nodes have the same output shape.\n     *\n     * @returns Output shape or shapes.\n     * @throws AttributeError: if the layer is connected to more than one incoming\n     *   nodes.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    get outputShape() {\n        if (this.inboundNodes == null || this.inboundNodes.length === 0) {\n            throw new AttributeError(`The layer ${this.name} has never been called and thus has no ` +\n                `defined output shape.`);\n        }\n        const allOutputShapes = [];\n        for (const node of this.inboundNodes) {\n            const shapeString = JSON.stringify(node.outputShapes);\n            if (allOutputShapes.indexOf(shapeString) === -1) {\n                allOutputShapes.push(shapeString);\n            }\n        }\n        if (allOutputShapes.length === 1) {\n            const outputShapes = this.inboundNodes[0].outputShapes;\n            if (Array.isArray(outputShapes) && Array.isArray(outputShapes[0]) &&\n                outputShapes.length === 1) {\n                return outputShapes[0];\n            }\n            else {\n                return outputShapes;\n            }\n        }\n        else {\n            throw new AttributeError(`The layer ${this.name} has multiple inbound nodes with different ` +\n                `output shapes. Hence the notion of \"output shape\" is ill-defined ` +\n                `for the layer.`);\n            // TODO(cais): Implement getOutputShapeAt().\n        }\n    }\n    /**\n     * Counts the total number of numbers (e.g., float32, int32) in the\n     * weights.\n     *\n     * @returns An integer count.\n     * @throws RuntimeError: If the layer is not built yet (in which case its\n     *   weights are not defined yet.)\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    countParams() {\n        if (!this.built) {\n            throw new RuntimeError(`You tried to call countParams() on ${this.name}, ` +\n                `but the layer is not built yet. Build it first by calling ` +\n                `build(batchInputShape).`);\n        }\n        return variable_utils.countParamsInWeights(this.weights);\n    }\n    /**\n     * Creates the layer weights.\n     *\n     * Must be implemented on all layers that have weights.\n     *\n     * Called when apply() is called to construct the weights.\n     *\n     * @param inputShape A `Shape` or array of `Shape` (unused).\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    build(inputShape) {\n        this.built = true;\n    }\n    /**\n     * Returns the current values of the weights of the layer.\n     *\n     * @param trainableOnly Whether to get the values of only trainable weights.\n     * @returns Weight values as an `Array` of `tf.Tensor`s.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    getWeights(trainableOnly = false) {\n        return batchGetValue(trainableOnly ? this.trainableWeights : this.weights);\n    }\n    /**\n     * Sets the weights of the layer, from Tensors.\n     *\n     * @param weights a list of Tensors. The number of arrays and their shape\n     *   must match number of the dimensions of the weights of the layer (i.e.\n     *   it should match the output of `getWeights`).\n     *\n     * @exception ValueError If the provided weights list does not match the\n     *   layer's specifications.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    setWeights(weights) {\n        tidy(() => {\n            const params = this.weights;\n            if (params.length !== weights.length) {\n                // TODO(cais): Restore the following and use `providedWeights`, instead\n                // of `weights` in the error message, once the deeplearn.js bug is\n                // fixed: https://github.com/PAIR-code/deeplearnjs/issues/498 const\n                // providedWeights = JSON.stringify(weights).slice(0, 50);\n                throw new ValueError(`You called setWeights(weights) on layer \"${this.name}\" ` +\n                    `with a weight list of length ${weights.length}, ` +\n                    `but the layer was expecting ${params.length} weights. ` +\n                    `Provided weights: ${weights}...`);\n            }\n            if (params.length === 0) {\n                return;\n            }\n            const weightValueTuples = [];\n            const paramValues = batchGetValue(params);\n            for (let i = 0; i < paramValues.length; ++i) {\n                const pv = paramValues[i];\n                const p = params[i];\n                const w = weights[i];\n                if (!util.arraysEqual(pv.shape, w.shape)) {\n                    throw new ValueError(`Layer weight shape ${pv.shape} ` +\n                        `not compatible with provided weight shape ${w.shape}`);\n                }\n                weightValueTuples.push([p, w]);\n            }\n            batchSetValue(weightValueTuples);\n        });\n    }\n    /**\n     * Adds a weight variable to the layer.\n     *\n     * @param name Name of the new weight variable.\n     * @param shape The shape of the weight.\n     * @param dtype The dtype of the weight.\n     * @param initializer An initializer instance.\n     * @param regularizer A regularizer instance.\n     * @param trainable Whether the weight should be trained via backprop or not\n     *   (assuming that the layer itself is also trainable).\n     * @param constraint An optional trainable.\n     * @return The created weight variable.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    addWeight(name, shape, dtype, initializer, regularizer, trainable, constraint, getInitializerFunc) {\n        // Reject duplicate weight names.\n        if (this._addedWeightNames.indexOf(name) !== -1) {\n            throw new ValueError(`Duplicate weight name ${name} for layer ${this.name}`);\n        }\n        this._addedWeightNames.push(name);\n        if (dtype == null) {\n            dtype = 'float32';\n        }\n        if (this.fastWeightInitDuringBuild) {\n            initializer = getInitializerFunc != null ? getInitializerFunc() :\n                getInitializer('zeros');\n        }\n        const initValue = initializer.apply(shape, dtype);\n        const weight = new LayerVariable(initValue, dtype, name, trainable, constraint);\n        initValue.dispose();\n        // Request backend not to dispose the weights of the model on scope() exit.\n        if (regularizer != null) {\n            this.addLoss(() => regularizer.apply(weight.read()));\n        }\n        if (trainable == null) {\n            trainable = true;\n        }\n        if (trainable) {\n            this._trainableWeights.push(weight);\n        }\n        else {\n            this._nonTrainableWeights.push(weight);\n        }\n        return weight;\n    }\n    /**\n     * Set the fast-weight-initialization flag.\n     *\n     * In cases where the initialized weight values will be immediately\n     * overwritten by loaded weight values during model loading, setting\n     * the flag to `true` saves unnecessary calls to potentially expensive\n     * initializers and speeds up the loading process.\n     *\n     * @param value Target value of the flag.\n     */\n    setFastWeightInitDuringBuild(value) {\n        this.fastWeightInitDuringBuild = value;\n    }\n    /**\n     * Add losses to the layer.\n     *\n     * The loss may potentionally be conditional on some inputs tensors,\n     * for instance activity losses are conditional on the layer's inputs.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    addLoss(losses) {\n        if (losses == null || Array.isArray(losses) && losses.length === 0) {\n            return;\n        }\n        // Update this.losses\n        losses = generic_utils.toList(losses);\n        if (this._losses !== undefined && this._losses !== null) {\n            this.losses.push(...losses);\n        }\n    }\n    /**\n     * Computes the output shape of the layer.\n     *\n     * Assumes that the layer will be built to match that input shape provided.\n     *\n     * @param inputShape A shape (tuple of integers) or a list of shape tuples\n     *   (one per output tensor of the layer). Shape tuples can include null for\n     *   free dimensions, instead of an integer.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    /**\n     * Computes an output mask tensor.\n     *\n     * @param inputs Tensor or list of tensors.\n     * @param mask Tensor or list of tensors.\n     *\n     * @return null or a tensor (or list of tensors, one per output tensor of the\n     * layer).\n     */\n    computeMask(inputs, mask) {\n        if (!this.supportsMasking) {\n            if (mask != null) {\n                if (Array.isArray(mask)) {\n                    mask.forEach(maskElement => {\n                        if (maskElement != null) {\n                            throw new TypeError(`Layer ${this.name} does not support masking, ` +\n                                'but was passed an inputMask.');\n                        }\n                    });\n                }\n                else {\n                    throw new TypeError(`Layer ${this.name} does not support masking, ` +\n                        'but was passed an inputMask.');\n                }\n            }\n            // masking not explicitly supported: return null as mask\n            return null;\n        }\n        // if masking is explictly supported, by default\n        // carry over the input mask\n        return mask;\n    }\n    /**\n     * Internal method to create an inbound node for the layer.\n     *\n     * @param inputTensors List of input tensors.\n     * @param outputTensors List of output tensors.\n     * @param inputMasks List of input masks (a mask can be a tensor, or null).\n     * @param outputMasks List of output masks (a mask can be a tensor, or null).\n     * @param inputShapes List of input shape tuples.\n     * @param outputShapes List of output shape tuples.\n     * @param kwargs Dictionary of keyword arguments that were passed to the\n     *   `call` method of the layer at the call that created the node.\n     */\n    addInboundNode(inputTensors, outputTensors, inputMasks, outputMasks, inputShapes, outputShapes, kwargs = null) {\n        const inputTensorList = generic_utils.toList(inputTensors);\n        outputTensors = generic_utils.toList(outputTensors);\n        inputMasks = generic_utils.toList(inputMasks);\n        outputMasks = generic_utils.toList(outputMasks);\n        inputShapes = types_utils.normalizeShapeList(inputShapes);\n        outputShapes = types_utils.normalizeShapeList(outputShapes);\n        // Collect input tensor(s) coordinates.\n        const inboundLayers = [];\n        const nodeIndices = [];\n        const tensorIndices = [];\n        for (const x of inputTensorList) {\n            /*\n             * TODO(michaelterry): Keras adds this value to tensors; it's not\n             * clear whether we'll use this or not.\n             */\n            inboundLayers.push(x.sourceLayer);\n            nodeIndices.push(x.nodeIndex);\n            tensorIndices.push(x.tensorIndex);\n        }\n        // Create node, add it to inbound nodes.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new Node({\n            outboundLayer: this,\n            inboundLayers,\n            nodeIndices,\n            tensorIndices,\n            inputTensors: inputTensorList,\n            outputTensors,\n            inputMasks,\n            outputMasks,\n            inputShapes,\n            outputShapes\n        }, kwargs);\n        // Update tensor history\n        for (let i = 0; i < outputTensors.length; i++) {\n            // TODO(michaelterry: _uses_learning_phase not tracked.\n            outputTensors[i].sourceLayer = this;\n            outputTensors[i].nodeIndex = this.inboundNodes.length - 1;\n            outputTensors[i].tensorIndex = i;\n        }\n    }\n    /**\n     * Returns the config of the layer.\n     *\n     * A layer config is a TS dictionary (serializable)\n     * containing the configuration of a layer.\n     * The same layer can be reinstantiated later\n     * (without its trained weights) from this configuration.\n     *\n     * The config of a layer does not include connectivity\n     * information, nor the layer class name.  These are handled\n     * by 'Container' (one layer of abstraction above).\n     *\n     * Porting Note: The TS dictionary follows TS naming standrds for\n     * keys, and uses tfjs-layers type-safe Enums.  Serialization methods\n     * should use a helper function to convert to the pythonic storage\n     * standard. (see serialization_utils.convertTsToPythonic)\n     *\n     * @returns TS dictionary of configuration.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    getConfig() {\n        const config = { name: this.name, trainable: this.trainable };\n        if (this.batchInputShape != null) {\n            config['batchInputShape'] = this.batchInputShape;\n        }\n        if (this.dtype != null) {\n            config['dtype'] = this.dtype;\n        }\n        return config;\n    }\n    /**\n     * Dispose the weight variables that this Layer instance holds.\n     *\n     * @returns {number} Number of disposed variables.\n     */\n    disposeWeights() {\n        this.weights.forEach(weight => weight.dispose());\n        return this.weights.length;\n    }\n    assertNotDisposed() {\n        if (this._refCount === 0) {\n            throw new Error(`Layer '${this.name}' is already disposed.`);\n        }\n    }\n    /**\n     * Attempt to dispose layer's weights.\n     *\n     * This method decrease the reference count of the Layer object by 1.\n     *\n     * A Layer is reference-counted. Its reference count is incremented by 1\n     * the first item its `apply()` method is called and when it becomes a part\n     * of a new `Node` (through calling the `apply()`) method on a\n     * `tf.SymbolicTensor`).\n     *\n     * If the reference count of a Layer becomes 0, all the weights will be\n     * disposed and the underlying memory (e.g., the textures allocated in WebGL)\n     * will be freed.\n     *\n     * Note: If the reference count is greater than 0 after the decrement, the\n     * weights of the Layer will *not* be disposed.\n     *\n     * After a Layer is disposed, it cannot be used in calls such as `apply()`,\n     * `getWeights()` or `setWeights()` anymore.\n     *\n     * @returns A DisposeResult Object with the following fields:\n     *   - refCountAfterDispose: The reference count of the Container after this\n     *     `dispose()` call.\n     *   - numDisposedVariables: Number of `tf.Variable`s (i.e., weights) disposed\n     *     during this `dispose()` call.\n     * @throws {Error} If the layer is not built yet, or if the layer has already\n     *   been disposed.\n     *\n     * @doc {heading: 'Models', 'subheading': 'Classes'}\n     */\n    dispose() {\n        if (!this.built) {\n            throw new Error(`Cannot dispose Layer ${this.name} because it has not been ` +\n                `built yet.`);\n        }\n        if (this._refCount === null) {\n            throw new Error(`Cannot dispose Layer ${this.name} because it has not been used ` +\n                `yet.`);\n        }\n        this.assertNotDisposed();\n        let numDisposedVariables = 0;\n        if (--this._refCount === 0) {\n            numDisposedVariables = this.disposeWeights();\n        }\n        return { refCountAfterDispose: this._refCount, numDisposedVariables };\n    }\n}\n/**\n * Collects the input shape(s) of a list of `tf.Tensor`s or\n * `tf.SymbolicTensor`s.\n *\n * TODO(michaelterry): Update PyKeras docs (backport).\n *\n * @param inputTensors List of input tensors (or single input tensor).\n *\n * @return List of shape tuples (or single tuple), one tuple per input.\n */\nfunction collectInputShape(inputTensors) {\n    inputTensors =\n        generic_utils.toList(inputTensors);\n    const shapes = [];\n    for (const x of inputTensors) {\n        shapes.push(x.shape);\n    }\n    return generic_utils.singletonOrArray(shapes);\n}\n/**\n * Guesses output dtype based on inputs.\n *\n * At present, just returns 'float32' for any input.\n *\n * @param inputTensors List of input tensors (or single input tensor).\n *\n * @return The guessed DType. At present, always returns 'float32'.\n */\nfunction guessOutputDType(inputTensors) {\n    return 'float32';\n}\n/**\n * Returns the list of input tensors necessary to compute `tensor`.\n *\n * Output will always be a list of tensors (potentially with 1 element).\n *\n * @param tensor The tensor to start from.\n * @param layer Origin layer of the tensor.\n * @param nodeIndex Origin node index of the tensor.\n *\n * @return Array of input tensors.\n */\nexport function getSourceInputs(tensor, layer, nodeIndex) {\n    if (layer == null || (nodeIndex != null && nodeIndex > 0)) {\n        layer = tensor.sourceLayer;\n        nodeIndex = tensor.nodeIndex;\n    }\n    if (layer.inboundNodes.length === 0) {\n        return [tensor];\n    }\n    else {\n        const node = layer.inboundNodes[nodeIndex];\n        if (node.inboundLayers.length === 0) {\n            return node.inputTensors;\n        }\n        else {\n            const sourceTensors = [];\n            for (let i = 0; i < node.inboundLayers.length; i++) {\n                const x = node.inputTensors[i];\n                const layer = node.inboundLayers[i];\n                const nodeIndex = node.nodeIndices[i];\n                const previousSources = getSourceInputs(x, layer, nodeIndex);\n                // Avoid input redundancy.\n                for (const x of previousSources) {\n                    if (sourceTensors.indexOf(x) === -1) {\n                        sourceTensors.push(x);\n                    }\n                }\n            }\n            return sourceTensors;\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidG9wb2xvZ3kuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvZW5naW5lL3RvcG9sb2d5LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsK0NBQStDO0FBRS9DLE9BQU8sRUFBbUIsYUFBYSxFQUFVLElBQUksRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRixPQUFPLEVBQUMscUJBQXFCLEVBQUUsTUFBTSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDL0QsT0FBTyxFQUFDLG1CQUFtQixFQUFFLG1CQUFtQixFQUFFLFNBQVMsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUU5RSxPQUFPLEVBQUMsY0FBYyxFQUFFLG1CQUFtQixFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDeEYsT0FBTyxFQUFDLGNBQWMsRUFBYyxNQUFNLGlCQUFpQixDQUFDO0FBSTVELE9BQU8sS0FBSyxhQUFhLE1BQU0sd0JBQXdCLENBQUM7QUFDeEQsT0FBTyxLQUFLLFdBQVcsTUFBTSxzQkFBc0IsQ0FBQztBQUNwRCxPQUFPLEtBQUssY0FBYyxNQUFNLHlCQUF5QixDQUFDO0FBQzFELE9BQU8sRUFBQyxhQUFhLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBQyxNQUFNLGNBQWMsQ0FBQztBQXVCekU7Ozs7Ozs7O0dBUUc7QUFDSCxNQUFNLE9BQU8sU0FBUztJQWNwQixZQUFZLElBQW1CO1FBQzdCLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDLEtBQUssQ0FBQztRQUN4QixJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUM7UUFDeEI7OztVQUdFO1FBQ0YsSUFBSSxJQUFJLENBQUMsS0FBSyxJQUFJLElBQUksRUFBRTtZQUN0QixJQUFJLENBQUMsSUFBSSxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFD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LEVBQUU7WUFDbkMsT0FBTyxJQUFJLENBQUMsWUFBWSxDQUFDO1NBQzFCO2FBQU07WUFDTCxNQUFNLGFBQWEsR0FBcUIsRUFBRSxDQUFDO1lBQzNDLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxDQUFDLEVBQUUsRUFBRTtnQkFDbEQsTUFBTSxDQUFDLEdBQUcsSUFBSSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDL0IsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLGFBQWEsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDcEMsTUFBTSxTQUFTLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQztnQkFDdEMsTUFBTSxlQUFlLEdBQUcsZUFBZSxDQUFDLENBQUMsRUFBRSxLQUFLLEVBQUUsU0FBUyxDQUFDLENBQUM7Z0JBQzdELDBCQUEwQjtnQkFDMUIsS0FBSyxNQUFNLENBQUMsSUFBSSxlQUFlLEVBQUU7b0JBQy9CLElBQUksYUFBYSxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsS0FBSyxDQUFDLENBQUMsRUFBRTt3QkFDbkMsYUFBYSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztxQkFDdkI7aUJBQ0Y7YUFDRjtZQUNELE9BQU8sYUFBYSxDQUFDO1NBQ3RCO0tBQ0Y7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyogT3JpZ2luYWwgc291cmNlOiBrZXJhcy9lbmdpbmUvdG9wb2xvZ3kucHkgKi9cblxuaW1wb3J0IHtEYXRhVHlwZSwgU2NhbGFyLCBzZXJpYWxpemF0aW9uLCBUZW5zb3IsIHRpZHksIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7Z2V0TmV4dFVuaXF1ZVRlbnNvcklkLCBnZXRVaWR9IGZyb20gJy4uL2JhY2tlbmQvc3RhdGUnO1xuaW1wb3J0IHtnZXRTY29wZWRUZW5zb3JOYW1lLCBnZXRVbmlxdWVUZW5zb3JOYW1lLCBuYW1lU2NvcGV9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge0NvbnN0cmFpbnR9IGZyb20gJy4uL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7QXR0cmlidXRlRXJyb3IsIE5vdEltcGxlbWVudGVkRXJyb3IsIFJ1bnRpbWVFcnJvciwgVmFsdWVFcnJvcn0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7Z2V0SW5pdGlhbGl6ZXIsIEluaXRpYWxpemVyfSBmcm9tICcuLi9pbml0aWFsaXplcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge1JlZ3VsYXJpemVyfSBmcm9tICcuLi9yZWd1bGFyaXplcnMnO1xuaW1wb3J0IHtLd2FyZ3MsIFJlZ3VsYXJpemVyRm59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQgKiBhcyB0eXBlc191dGlscyBmcm9tICcuLi91dGlscy90eXBlc191dGlscyc7XG5pbXBvcnQgKiBhcyB2YXJpYWJsZV91dGlscyBmcm9tICcuLi91dGlscy92YXJpYWJsZV91dGlscyc7XG5pbXBvcnQge2JhdGNoR2V0VmFsdWUsIGJhdGNoU2V0VmFsdWUsIExheWVyVmFyaWFibGV9IGZyb20gJy4uL3ZhcmlhYmxlcyc7XG5cbi8vIFRPRE8obWljaGFlbHRlcnJ5KTogVGhpcyBpcyBhIHN0dWIgdW50aWwgaXQncyBkZWZpbmVkLlxuZXhwb3J0IHR5cGUgT3AgPSAoeDogTGF5ZXJWYXJpYWJsZSkgPT4gTGF5ZXJWYXJpYWJsZTtcblxuLyoqXG4gKiBDb25zdHJ1Y3RvciBhcmd1bWVudHMgZm9yIElucHV0U3BlYy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dFNwZWNBcmdzIHtcbiAgLyoqIEV4cGVjdGVkIGRhdGF0eXBlIG9mIHRoZSBpbnB1dC4gKi9cbiAgZHR5cGU/OiBEYXRhVHlwZTtcbiAgLyoqIEV4cGVjdGVkIHNoYXBlIG9mIHRoZSBpbnB1dCAobWF5IGluY2x1ZGUgbnVsbCBmb3IgdW5jaGVja2VkIGF4ZXMpLiAqL1xuICBzaGFwZT86IFNoYXBlO1xuICAvKiogRXhwZWN0ZWQgcmFuayBvZiB0aGUgaW5wdXQuICovXG4gIG5kaW0/OiBudW1iZXI7XG4gIC8qKiBNYXhpbXVtIHJhbmsgb2YgdGhlIGlucHV0LiAqL1xuICBtYXhORGltPzogbnVtYmVyO1xuICAvKiogTWluaW11bSByYW5rIG9mIHRoZSBpbnB1dC4gKi9cbiAgbWluTkRpbT86IG51bWJlcjtcbiAgLyoqIERpY3Rpb25hcnkgbWFwcGluZyBpbnRlZ2VyIGF4ZXMgdG8gYSBzcGVjaWZpYyBkaW1lbnNpb24gdmFsdWUuICovXG4gIGF4ZXM/OiB7W2F4aXM6IG51bWJlcl06IG51bWJlcn07XG59XG5cbi8qKlxuICogU3BlY2lmaWVzIHRoZSBuZGltLCBkdHlwZSBhbmQgc2hhcGUgb2YgZXZlcnkgaW5wdXQgdG8gYSBsYXllci5cbiAqXG4gKiBFdmVyeSBsYXllciBzaG91bGQgZXhwb3NlIChpZiBhcHByb3ByaWF0ZSkgYW4gYGlucHV0U3BlY2AgYXR0cmlidXRlOlxuICogYSBsaXN0IG9mIGluc3RhbmNlcyBvZiBJbnB1dFNwZWMgKG9uZSBwZXIgaW5wdXQgdGVuc29yKS5cbiAqXG4gKiBBIG51bGwgZW50cnkgaW4gYSBzaGFwZSBpcyBjb21wYXRpYmxlIHdpdGggYW55IGRpbWVuc2lvbixcbiAqIGEgbnVsbCBzaGFwZSBpcyBjb21wYXRpYmxlIHdpdGggYW55IHNoYXBlLlxuICovXG5leHBvcnQgY2xhc3MgSW5wdXRTcGVjIHtcbiAgLyoqIEV4cGVjdGVkIGRhdGF0eXBlIG9mIHRoZSBpbnB1dC4gKi9cbiAgZHR5cGU/OiBEYXRhVHlwZTtcbiAgLyoqIEV4cGVjdGVkIHNoYXBlIG9mIHRoZSBpbnB1dCAobWF5IGluY2x1ZGUgbnVsbCBmb3IgdW5jaGVja2VkIGF4ZXMpLiAqL1xuICBzaGFwZT86IFNoYXBlO1xuICAvKiogRXhwZWN0ZWQgcmFuayBvZiB0aGUgaW5wdXQuICovXG4gIG5kaW0/OiBudW1iZXI7XG4gIC8qKiBNYXhpbXVtIHJhbmsgb2YgdGhlIGlucHV0LiAqL1xuICBtYXhORGltPzogbnVtYmVyO1xuICAvKiogTWluaW11bSByYW5rIG9mIHRoZSBpbnB1dC4gKi9cbiAgbWluTkRpbT86IG51bWJlcjtcbiAgLyoqIERpY3Rpb25hcnkgbWFwcGluZyBpbnRlZ2VyIGF4ZXMgdG8gYSBzcGVjaWZpYyBkaW1lbnNpb24gdmFsdWUuICovXG4gIGF4ZXM/OiB7W2F4aXM6IG51bWJlcl06IG51bWJlcn07XG5cbiAgY29uc3RydWN0b3IoYXJnczogSW5wdXRTcGVjQXJncykge1xuICAgIHRoaXMuZHR5cGUgPSBhcmdzLmR0eXBlO1xuICAgIHRoaXMuc2hhcGUgPSBhcmdzLnNoYXBlO1xuICAgIC8qXG4gICAgICBUT0RPKG1pY2hhZWx0ZXJyeSk6IENvdWxkIHRocm93IGVycm9yIGlmIG5kaW0gYW5kIHNoYXBlIGFyZSBib3RoIGRlZmluZWRcbiAgICAgICAgKHRoZW4gYmFja3BvcnQpLlxuICAgICovXG4gICAgaWYgKGFyZ3Muc2hhcGUgIT0gbnVsbCkge1xuICAgICAgdGhpcy5uZGltID0gYXJncy5zaGFwZS5sZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmRpbSA9IGFyZ3MubmRpbTtcbiAgICB9XG4gICAgdGhpcy5tYXhORGltID0gYXJncy5tYXhORGltO1xuICAgIHRoaXMubWluTkRpbSA9IGFyZ3MubWluTkRpbTtcbiAgICB0aGlzLmF4ZXMgPSBhcmdzLmF4ZXMgfHwge307XG4gIH1cbn1cblxuLyoqXG4gKiBgdGYuU3ltYm9saWNUZW5zb3JgIGlzIGEgcGxhY2Vob2xkZXIgZm9yIGEgVGVuc29yIHdpdGhvdXQgYW55IGNvbmNyZXRlIHZhbHVlLlxuICpcbiAqIFRoZXkgYXJlIG1vc3Qgb2Z0ZW4gZW5jb3VudGVyZWQgd2hlbiBidWlsZGluZyBhIGdyYXBoIG9mIGBMYXllcmBzIGZvciBhXG4gKiBhIGB0Zi5MYXllcnNNb2RlbGAgYW5kIHRoZSBpbnB1dCBkYXRhJ3Mgc2hhcGUsIGJ1dCBub3QgdmFsdWVzIGFyZSBrbm93bi5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgJ3N1YmhlYWRpbmcnOiAnQ2xhc3Nlcyd9XG4gKi9cbmV4cG9ydCBjbGFzcyBTeW1ib2xpY1RlbnNvciB7XG4gIC8qIEEgdW5pcXVlIElEIGZvciB0aGUgdGVuc29yIHRvIGJlIGFibGUgdG8gZGlmZmVyZW50aWF0ZSB0ZW5zb3JzLiAqL1xuICByZWFkb25seSBpZDogbnVtYmVyO1xuICAvLyBUaGUgZnVsbHkgc2NvcGVkIG5hbWUgb2YgdGhpcyBWYXJpYWJsZSwgaW5jbHVkaW5nIGEgdW5pcXVlIHN1ZmZpeCBpZiBuZWVkZWRcbiAgcmVhZG9ubHkgbmFtZTogc3RyaW5nO1xuICAvLyBUaGUgb3JpZ2luYWxseSByZXF1ZXN0ZWQgZnVsbHkgc2NvcGVkIG5hbWUgb2YgdGhpcyBWYXJpYWJsZSwgbm90IGluY2x1ZGluZ1xuICAvLyBhbnkgdW5pcXVlIHN1ZmZpeC4gIFRoaXMgbWF5IGJlIG5lZWRlZCB3aGVuIHJlc3RvcmluZyB3ZWlnaHRzIGJlY2F1c2UgdGhpc1xuICAvLyBvcmlnaW5hbCBuYW1lIGlzIHVzZWQgYXMgYSBrZXkuXG4gIHJlYWRvbmx5IG9yaWdpbmFsTmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFJhbmsvZGltZW5zaW9uYWxpdHkgb2YgdGhlIHRlbnNvci5cbiAgICovXG4gIHJlYWRvbmx5IHJhbms6IG51bWJlcjtcbiAgLyoqXG4gICAqIFJlcGxhY2VtZW50IGZvciBfa2VyYXNfaGlzdG9yeS5cbiAgICovXG4gIG5vZGVJbmRleDogbnVtYmVyO1xuICAvKipcbiAgICogUmVwbGFjZW1lbnQgZm9yIF9rZXJhc19oaXN0b3J5LlxuICAgKi9cbiAgdGVuc29ySW5kZXg6IG51bWJlcjtcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIGR0eXBlXG4gICAqIEBwYXJhbSBzaGFwZVxuICAgKiBAcGFyYW0gc291cmNlTGF5ZXIgVGhlIExheWVyIHRoYXQgcHJvZHVjZWQgdGhpcyBzeW1ib2xpYyB0ZW5zb3IuXG4gICAqIEBwYXJhbSBpbnB1dHMgVGhlIGlucHV0cyBwYXNzZWQgdG8gc291cmNlTGF5ZXIncyBfX2NhbGxfXygpIG1ldGhvZC5cbiAgICogQHBhcmFtIG5vZGVJbmRleFxuICAgKiBAcGFyYW0gdGVuc29ySW5kZXhcbiAgICogQHBhcmFtIGNhbGxBcmdzIFRoZSBrZXl3b3JkIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIF9fY2FsbF9fKCkgbWV0aG9kLlxuICAgKiBAcGFyYW0gbmFtZVxuICAgKiBAcGFyYW0gb3V0cHV0VGVuc29ySW5kZXggVGhlIGluZGV4IG9mIHRoaXMgdGVuc29yIGluIHRoZSBsaXN0IG9mIG91dHB1dHNcbiAgICogICByZXR1cm5lZCBieSBhcHBseSgpLlxuICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgICByZWFkb25seSBkdHlwZTogRGF0YVR5cGUsIHJlYWRvbmx5IHNoYXBlOiBTaGFwZSxcbiAgICAgIHB1YmxpYyBzb3VyY2VMYXllcjogTGF5ZXIsIHJlYWRvbmx5IGlucHV0czogU3ltYm9saWNUZW5zb3JbXSxcbiAgICAgIHJlYWRvbmx5IGNhbGxBcmdzOiBLd2FyZ3MsIG5hbWU/OiBzdHJpbmcsXG4gICAgICByZWFkb25seSBvdXRwdXRUZW5zb3JJbmRleD86IG51bWJlcikge1xuICAgIHRoaXMuaWQgPSBnZXROZXh0VW5pcXVlVGVuc29ySWQoKTtcbiAgICBpZiAobmFtZSAhPSBudWxsKSB7XG4gICAgICB0aGlzLm9yaWdpbmFsTmFtZSA9IGdldFNjb3BlZFRlbnNvck5hbWUobmFtZSk7XG4gICAgICB0aGlzLm5hbWUgPSBnZXRVbmlxdWVUZW5zb3JOYW1lKHRoaXMub3JpZ2luYWxOYW1lKTtcbiAgICB9XG4gICAgdGhpcy5yYW5rID0gc2hhcGUubGVuZ3RoO1xuICB9XG59XG5cbi8qKlxuICogQ29uc3RydWN0b3IgYXJndW1lbnRzIGZvciBOb2RlLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE5vZGVBcmdzIHtcbiAgLyoqXG4gICAqIFRoZSBsYXllciB0aGF0IHRha2VzIGBpbnB1dFRlbnNvcnNgIGFuZCB0dXJucyB0aGVtIGludG8gYG91dHB1dFRlbnNvcnNgLlxuICAgKiAodGhlIG5vZGUgZ2V0cyBjcmVhdGVkIHdoZW4gdGhlIGBjYWxsYCBtZXRob2Qgb2YgdGhlIGxheWVyIGlzIGNhbGxlZCkuXG4gICAqL1xuICBvdXRib3VuZExheWVyOiBMYXllcjtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBsYXllcnMsIHRoZSBzYW1lIGxlbmd0aCBhcyBgaW5wdXRUZW5zb3JzYCwgdGhlIGxheWVycyBmcm9tIHdoZXJlXG4gICAqIGBpbnB1dFRlbnNvcnNgIG9yaWdpbmF0ZS5cbiAgICovXG4gIGluYm91bmRMYXllcnM6IExheWVyW107XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgaW50ZWdlcnMsIHRoZSBzYW1lIGxlbmd0aCBhcyBgaW5ib3VuZExheWVyc2AuIGBub2RlSW5kaWNlc1tpXWAgaXNcbiAgICogdGhlIG9yaWdpbiBub2RlIG9mIGBpbnB1dFRlbnNvcnNbaV1gIChuZWNlc3Nhcnkgc2luY2UgZWFjaCBpbmJvdW5kIGxheWVyXG4gICAqIG1pZ2h0IGhhdmUgc2V2ZXJhbCBub2RlcywgZS5nLiBpZiB0aGUgbGF5ZXIgaXMgYmVpbmcgc2hhcmVkIHdpdGggYVxuICAgKiBkaWZmZXJlbnQgZGF0YSBzdHJlYW0pLlxuICAgKi9cbiAgbm9kZUluZGljZXM6IG51bWJlcltdO1xuICAvKipcbiAgICogQSBsaXN0IG9mIGludGVnZXJzLCB0aGUgc2FtZSBsZW5ndGggYXMgYGluYm91bmRMYXllcnNgLiBgdGVuc29ySW5kaWNlc1tpXWBcbiAgICogaXMgdGhlIGluZGV4IG9mIGBpbnB1dFRlbnNvcnNbaV1gIHdpdGhpbiB0aGUgb3V0cHV0IG9mIHRoZSBpbmJvdW5kIGxheWVyXG4gICAqIChuZWNlc3Nhcnkgc2luY2UgZWFjaCBpbmJvdW5kIGxheWVyIG1pZ2h0IGhhdmUgbXVsdGlwbGUgdGVuc29yIG91dHB1dHMsXG4gICAqIHdpdGggZWFjaCBvbmUgYmVpbmcgaW5kZXBlbmRlbnRseSBtYW5pcHVsYWJsZSkuXG4gICAqL1xuICB0ZW5zb3JJbmRpY2VzOiBudW1iZXJbXTtcbiAgLyoqIExpc3Qgb2YgaW5wdXQgdGVuc29ycy4gKi9cbiAgaW5wdXRUZW5zb3JzOiBTeW1ib2xpY1RlbnNvcltdO1xuICAvKiogTGlzdCBvZiBvdXRwdXQgdGVuc29ycy4gKi9cbiAgb3V0cHV0VGVuc29yczogU3ltYm9saWNUZW5zb3JbXTtcbiAgLyoqIExpc3Qgb2YgaW5wdXQgbWFza3MgKGEgbWFzayBjYW4gYmUgYSB0ZW5zb3IsIG9yIG51bGwpLiAqL1xuICBpbnB1dE1hc2tzOiBUZW5zb3JbXTtcbiAgLyoqIExpc3Qgb2Ygb3V0cHV0IG1hc2tzIChhIG1hc2sgY2FuIGJlIGEgdGVuc29yLCBvciBudWxsKS4gKi9cbiAgb3V0cHV0TWFza3M6IFRlbnNvcltdO1xuICAvKiogTGlzdCBvZiBpbnB1dCBzaGFwZSB0dXBsZXMuICovXG4gIGlucHV0U2hhcGVzOiBTaGFwZXxTaGFwZVtdO1xuICAvKiogTGlzdCBvZiBvdXRwdXQgc2hhcGUgdHVwbGVzLiAqL1xuICBvdXRwdXRTaGFwZXM6IFNoYXBlfFNoYXBlW107XG59XG5cbi8qKlxuICogVGhlIHR5cGUgb2YgdGhlIHJldHVybiB2YWx1ZSBvZiBMYXllci5kaXNwb3NlKCkgYW5kIENvbnRhaW5lci5kaXNwb3NlKCkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRGlzcG9zZVJlc3VsdCB7XG4gIC8qKlxuICAgKiBSZWZlcmVuY2UgY291bnQgYWZ0ZXIgdGhlIGRpc3Bvc2UgY2FsbC5cbiAgICovXG4gIHJlZkNvdW50QWZ0ZXJEaXNwb3NlOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE51bWJlciBvZiB2YXJpYWJsZXMgZGlzcG9zZSBpbiB0aGlzIGRpc3Bvc2UgY2FsbC5cbiAgICovXG4gIG51bURpc3Bvc2VkVmFyaWFibGVzOiBudW1iZXI7XG59XG5cbmxldCBfbmV4dE5vZGVJRCA9IDA7XG5cbi8qKlxuICogQSBgTm9kZWAgZGVzY3JpYmVzIHRoZSBjb25uZWN0aXZpdHkgYmV0d2VlbiB0d28gbGF5ZXJzLlxuICpcbiAqIEVhY2ggdGltZSBhIGxheWVyIGlzIGNvbm5lY3RlZCB0byBzb21lIG5ldyBpbnB1dCxcbiAqIGEgbm9kZSBpcyBhZGRlZCB0byBgbGF5ZXIuaW5ib3VuZE5vZGVzYC5cbiAqXG4gKiBFYWNoIHRpbWUgdGhlIG91dHB1dCBvZiBhIGxheWVyIGlzIHVzZWQgYnkgYW5vdGhlciBsYXllcixcbiAqIGEgbm9kZSBpcyBhZGRlZCB0byBgbGF5ZXIub3V0Ym91bmROb2Rlc2AuXG4gKlxuICogYG5vZGVJbmRpY2VzYCBhbmQgYHRlbnNvckluZGljZXNgIGFyZSBiYXNpY2FsbHkgZmluZS1ncmFpbmVkIGNvb3JkaW5hdGVzXG4gKiBkZXNjcmliaW5nIHRoZSBvcmlnaW4gb2YgdGhlIGBpbnB1dFRlbnNvcnNgLCB2ZXJpZnlpbmcgdGhlIGZvbGxvd2luZzpcbiAqXG4gKiBgaW5wdXRUZW5zb3JzW2ldID09XG4gKiBpbmJvdW5kTGF5ZXJzW2ldLmluYm91bmROb2Rlc1tub2RlSW5kaWNlc1tpXV0ub3V0cHV0VGVuc29yc1tcbiAqICAgdGVuc29ySW5kaWNlc1tpXV1gXG4gKlxuICogQSBub2RlIGZyb20gbGF5ZXIgQSB0byBsYXllciBCIGlzIGFkZGVkIHRvOlxuICogICAgIEEub3V0Ym91bmROb2Rlc1xuICogICAgIEIuaW5ib3VuZE5vZGVzXG4gKi9cbmV4cG9ydCBjbGFzcyBOb2RlIHtcbiAgLyoqXG4gICAqIFRoZSBsYXllciB0aGF0IHRha2VzIGBpbnB1dFRlbnNvcnNgIGFuZCB0dXJucyB0aGVtIGludG8gYG91dHB1dFRlbnNvcnNgXG4gICAqICh0aGUgbm9kZSBnZXRzIGNyZWF0ZWQgd2hlbiB0aGUgYGNhbGxgIG1ldGhvZCBvZiB0aGUgbGF5ZXIgaXMgY2FsbGVkKS5cbiAgICovXG4gIG91dGJvdW5kTGF5ZXI6IExheWVyO1xuICAvKipcbiAgICogQSBsaXN0IG9mIGxheWVycywgdGhlIHNhbWUgbGVuZ3RoIGFzIGBpbnB1dFRlbnNvcnNgLCB0aGUgbGF5ZXJzIGZyb20gd2hlcmVcbiAgICogYGlucHV0VGVuc29yc2Agb3JpZ2luYXRlLlxuICAgKi9cbiAgaW5ib3VuZExheWVyczogTGF5ZXJbXTtcbiAgLyoqXG4gICAqIEEgbGlzdCBvZiBpbnRlZ2VycywgdGhlIHNhbWUgbGVuZ3RoIGFzIGBpbmJvdW5kTGF5ZXJzYC4gYG5vZGVJbmRpY2VzW2ldYCBpc1xuICAgKiB0aGUgb3JpZ2luIG5vZGUgb2YgYGlucHV0VGVuc29yc1tpXWAgKG5lY2Vzc2FyeSBzaW5jZSBlYWNoIGluYm91bmQgbGF5ZXJcbiAgICogbWlnaHQgaGF2ZSBzZXZlcmFsIG5vZGVzLCBlLmcuIGlmIHRoZSBsYXllciBpcyBiZWluZyBzaGFyZWQgd2l0aCBhXG4gICAqIGRpZmZlcmVudCBkYXRhIHN0cmVhbSkuXG4gICAqL1xuICBub2RlSW5kaWNlczogbnVtYmVyW107XG4gIC8qKlxuICAgKiBBIGxpc3Qgb2YgaW50ZWdlcnMsIHRoZSBzYW1lIGxlbmd0aCBhcyBgaW5ib3VuZExheWVyc2AuIGB0ZW5zb3JJbmRpY2VzW2ldYFxuICAgKiBpcyB0aGUgaW5kZXggb2YgYGlucHV0VGVuc29yc1tpXWAgd2l0aGluIHRoZSBvdXRwdXQgb2YgdGhlIGluYm91bmQgbGF5ZXJcbiAgICogKG5lY2Vzc2FyeSBzaW5jZSBlYWNoIGluYm91bmQgbGF5ZXIgbWlnaHQgaGF2ZSBtdWx0aXBsZSB0ZW5zb3Igb3V0cHV0cyxcbiAgICogd2l0aCBlYWNoIG9uZSBiZWluZyBpbmRlcGVuZGVudGx5IG1hbmlwdWxhYmxlKS5cbiAgICovXG4gIHRlbnNvckluZGljZXM6IG51bWJlcltdO1xuICAvKiogTGlzdCBvZiBpbnB1dCB0ZW5zb3JzLiAqL1xuICBpbnB1dFRlbnNvcnM6IFN5bWJvbGljVGVuc29yW107XG4gIC8qKiBMaXN0IG9mIG91dHB1dCB0ZW5zb3JzLiAqL1xuICBvdXRwdXRUZW5zb3JzOiBTeW1ib2xpY1RlbnNvcltdO1xuICAvKiogTGlzdCBvZiBpbnB1dCBtYXNrcyAoYSBtYXNrIGNhbiBiZSBhIHRlbnNvciwgb3IgbnVsbCkuICovXG4gIGlucHV0TWFza3M6IFRlbnNvcltdO1xuICAvKiogTGlzdCBvZiBvdXRwdXQgbWFza3MgKGEgbWFzayBjYW4gYmUgYSB0ZW5zb3IsIG9yIG51bGwpLiAqL1xuICBvdXRwdXRNYXNrczogVGVuc29yW107XG4gIC8qKiBMaXN0IG9mIGlucHV0IHNoYXBlIHR1cGxlcy4gKi9cbiAgaW5wdXRTaGFwZXM6IFNoYXBlfFNoYXBlW107XG4gIC8qKiBMaXN0IG9mIG91dHB1dCBzaGFwZSB0dXBsZXMuICovXG4gIG91dHB1dFNoYXBlczogU2hhcGV8U2hhcGVbXTtcblxuICByZWFkb25seSBpZDogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgICAgYXJnczogTm9kZUFyZ3MsXG4gICAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IERlZmluZSBhY3R1YWwgdHlwZSBmb3IgdGhpcy5cbiAgICAgIHB1YmxpYyBjYWxsQXJncz86IEt3YXJncykge1xuICAgIHRoaXMuaWQgPSBfbmV4dE5vZGVJRCsrO1xuICAgIC8qXG4gICAgICBMYXllciBpbnN0YW5jZSAoTk9UIGEgbGlzdCkuXG4gICAgICB0aGlzIGlzIHRoZSBsYXllciB0aGF0IHRha2VzIGEgbGlzdCBvZiBpbnB1dCB0ZW5zb3JzXG4gICAgICBhbmQgdHVybnMgdGhlbSBpbnRvIGEgbGlzdCBvZiBvdXRwdXQgdGVuc29ycy5cbiAgICAgIHRoZSBjdXJyZW50IG5vZGUgd2lsbCBiZSBhZGRlZCB0b1xuICAgICAgdGhlIGluYm91bmROb2RlcyBvZiBvdXRib3VuZExheWVyLlxuICAgICovXG4gICAgdGhpcy5vdXRib3VuZExheWVyID0gYXJncy5vdXRib3VuZExheWVyO1xuXG4gICAgLypcbiAgICAgICAgVGhlIGZvbGxvd2luZyAzIHByb3BlcnRpZXMgZGVzY3JpYmUgd2hlcmVcbiAgICAgICAgdGhlIGlucHV0IHRlbnNvcnMgY29tZSBmcm9tOiB3aGljaCBsYXllcnMsXG4gICAgICAgIGFuZCBmb3IgZWFjaCBsYXllciwgd2hpY2ggbm9kZSBhbmQgd2hpY2hcbiAgICAgICAgdGVuc29yIG91dHB1dCBvZiBlYWNoIG5vZGUuXG4gICAgKi9cblxuICAgIC8vIExpc3Qgb2YgbGF5ZXIgaW5zdGFuY2VzLlxuICAgIHRoaXMuaW5ib3VuZExheWVycyA9IGFyZ3MuaW5ib3VuZExheWVycztcbiAgICAvLyBMaXN0IG9mIGludGVnZXJzLCAxOjEgbWFwcGluZyB3aXRoIGluYm91bmRMYXllcnMuXG4gICAgdGhpcy5ub2RlSW5kaWNlcyA9IGFyZ3Mubm9kZUluZGljZXM7XG4gICAgLy8gTGlzdCBvZiBpbnRlZ2VycywgMToxIG1hcHBpbmcgd2l0aCBpbmJvdW5kTGF5ZXJzLlxuICAgIHRoaXMudGVuc29ySW5kaWNlcyA9IGFyZ3MudGVuc29ySW5kaWNlcztcblxuICAgIC8qXG4gICAgICAgIEZvbGxvd2luZyAyIHByb3BlcnRpZXM6XG4gICAgICAgIHRlbnNvciBpbnB1dHMgYW5kIG91dHB1dHMgb2Ygb3V0Ym91bmRMYXllci5cbiAgICAqL1xuXG4gICAgLy8gTGlzdCBvZiB0ZW5zb3JzLiAxOjEgbWFwcGluZyB3aXRoIGluYm91bmRMYXllcnMuXG4gICAgdGhpcy5pbnB1dFRlbnNvcnMgPSBhcmdzLmlucHV0VGVuc29ycztcbiAgICAvLyBMaXN0IG9mIHRlbnNvcnMsIGNyZWF0ZWQgYnkgb3V0Ym91bmRMYXllci5jYWxsKCkuXG4gICAgdGhpcy5vdXRwdXRUZW5zb3JzID0gYXJncy5vdXRwdXRUZW5zb3JzO1xuXG4gICAgLypcbiAgICAgICAgRm9sbG93aW5nIDIgcHJvcGVydGllczogaW5wdXQgYW5kIG91dHB1dCBtYXNrcy5cbiAgICAgICAgTGlzdCBvZiB0ZW5zb3JzLCAxOjEgbWFwcGluZyB3aXRoIGlucHV0VGVuc29yLlxuICAgICovXG4gICAgdGhpcy5pbnB1dE1hc2tzID0gYXJncy5pbnB1dE1hc2tzO1xuICAgIC8vIExpc3Qgb2YgdGVuc29ycywgY3JlYXRlZCBieSBvdXRib3VuZExheWVyLmNvbXB1dGVNYXNrKCkuXG4gICAgdGhpcy5vdXRwdXRNYXNrcyA9IGFyZ3Mub3V0cHV0TWFza3M7XG5cbiAgICAvLyBGb2xsb3dpbmcgMiBwcm9wZXJ0aWVzOiBpbnB1dCBhbmQgb3V0cHV0IHNoYXBlcy5cblxuICAgIC8vIExpc3Qgb2Ygc2hhcGUgdHVwbGVzLCBzaGFwZXMgb2YgaW5wdXRUZW5zb3JzLlxuICAgIHRoaXMuaW5wdXRTaGFwZXMgPSBhcmdzLmlucHV0U2hhcGVzO1xuICAgIC8vIExpc3Qgb2Ygc2hhcGUgdHVwbGVzLCBzaGFwZXMgb2Ygb3V0cHV0VGVuc29ycy5cbiAgICB0aGlzLm91dHB1dFNoYXBlcyA9IGFyZ3Mub3V0cHV0U2hhcGVzO1xuXG4gICAgLy8gQWRkIG5vZGVzIHRvIGFsbCBsYXllcnMgaW52b2x2ZWQuXG4gICAgZm9yIChjb25zdCBsYXllciBvZiBhcmdzLmluYm91bmRMYXllcnMpIHtcbiAgICAgIGlmIChsYXllciAhPSBudWxsKSB7XG4gICAgICAgIGxheWVyLm91dGJvdW5kTm9kZXMucHVzaCh0aGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYXJncy5vdXRib3VuZExheWVyLmluYm91bmROb2Rlcy5wdXNoKHRoaXMpO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgaW5ib3VuZE5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5pbmJvdW5kTGF5ZXJzKSB7XG4gICAgICBpZiAobGF5ZXIgIT0gbnVsbCkge1xuICAgICAgICBpbmJvdW5kTmFtZXMucHVzaChsYXllci5uYW1lKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluYm91bmROYW1lcy5wdXNoKG51bGwpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgb3V0Ym91bmRMYXllcjogdGhpcy5vdXRib3VuZExheWVyID8gdGhpcy5vdXRib3VuZExheWVyLm5hbWUgOiBudWxsLFxuICAgICAgaW5ib3VuZExheWVyczogaW5ib3VuZE5hbWVzLFxuICAgICAgbm9kZUluZGljZXM6IHRoaXMubm9kZUluZGljZXMsXG4gICAgICB0ZW5zb3JJbmRpY2VzOiB0aGlzLnRlbnNvckluZGljZXNcbiAgICB9O1xuICB9XG59XG5cbi8qKiBDb25zdHJ1Y3RvciBhcmd1bWVudHMgZm9yIExheWVyLiAqL1xuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBJZiBkZWZpbmVkLCB3aWxsIGJlIHVzZWQgdG8gY3JlYXRlIGFuIGlucHV0IGxheWVyIHRvIGluc2VydCBiZWZvcmUgdGhpc1xuICAgKiBsYXllci4gSWYgYm90aCBgaW5wdXRTaGFwZWAgYW5kIGBiYXRjaElucHV0U2hhcGVgIGFyZSBkZWZpbmVkLFxuICAgKiBgYmF0Y2hJbnB1dFNoYXBlYCB3aWxsIGJlIHVzZWQuIFRoaXMgYXJndW1lbnQgaXMgb25seSBhcHBsaWNhYmxlIHRvIGlucHV0XG4gICAqIGxheWVycyAodGhlIGZpcnN0IGxheWVyIG9mIGEgbW9kZWwpLlxuICAgKi9cbiAgaW5wdXRTaGFwZT86IFNoYXBlO1xuICAvKipcbiAgICogSWYgZGVmaW5lZCwgd2lsbCBiZSB1c2VkIHRvIGNyZWF0ZSBhbiBpbnB1dCBsYXllciB0byBpbnNlcnQgYmVmb3JlIHRoaXNcbiAgICogbGF5ZXIuIElmIGJvdGggYGlucHV0U2hhcGVgIGFuZCBgYmF0Y2hJbnB1dFNoYXBlYCBhcmUgZGVmaW5lZCxcbiAgICogYGJhdGNoSW5wdXRTaGFwZWAgd2lsbCBiZSB1c2VkLiBUaGlzIGFyZ3VtZW50IGlzIG9ubHkgYXBwbGljYWJsZSB0byBpbnB1dFxuICAgKiBsYXllcnMgKHRoZSBmaXJzdCBsYXllciBvZiBhIG1vZGVsKS5cbiAgICovXG4gIGJhdGNoSW5wdXRTaGFwZT86IFNoYXBlO1xuICAvKipcbiAgICogSWYgYGlucHV0U2hhcGVgIGlzIHNwZWNpZmllZCBhbmQgYGJhdGNoSW5wdXRTaGFwZWAgaXMgKm5vdCogc3BlY2lmaWVkLFxuICAgKiBgYmF0Y2hTaXplYCBpcyB1c2VkIHRvIGNvbnN0cnVjdCB0aGUgYGJhdGNoSW5wdXRTaGFwZWA6IGBbYmF0Y2hTaXplLFxuICAgKiAuLi5pbnB1dFNoYXBlXWBcbiAgICovXG4gIGJhdGNoU2l6ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRoZSBkYXRhLXR5cGUgZm9yIHRoaXMgbGF5ZXIuIERlZmF1bHRzIHRvICdmbG9hdDMyJy5cbiAgICogVGhpcyBhcmd1bWVudCBpcyBvbmx5IGFwcGxpY2FibGUgdG8gaW5wdXQgbGF5ZXJzICh0aGUgZmlyc3QgbGF5ZXIgb2YgYVxuICAgKiBtb2RlbCkuXG4gICAqL1xuICBkdHlwZT86IERhdGFUeXBlO1xuICAvKiogTmFtZSBmb3IgdGhpcyBsYXllci4gKi9cbiAgbmFtZT86IHN0cmluZztcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHdlaWdodHMgb2YgdGhpcyBsYXllciBhcmUgdXBkYXRhYmxlIGJ5IGBmaXRgLlxuICAgKiBEZWZhdWx0cyB0byB0cnVlLlxuICAgKi9cbiAgdHJhaW5hYmxlPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIEluaXRpYWwgd2VpZ2h0IHZhbHVlcyBvZiB0aGUgbGF5ZXIuXG4gICAqL1xuICB3ZWlnaHRzPzogVGVuc29yW107XG4gIC8qKiBMZWdhY3kgc3VwcG9ydC4gRG8gbm90IHVzZSBmb3IgbmV3IGNvZGUuICovXG4gIGlucHV0RFR5cGU/OiBEYXRhVHlwZTtcbn1cblxuLy8gSWYgbmVjZXNzYXJ5LCBhZGQgYG91dHB1dGAgYXJndW1lbnRzIHRvIHRoZSBDYWxsSG9vayBmdW5jdGlvbi5cbi8vIFRoaXMgaXMgY3VycmVudGx5IHVzZWQgZm9yIHRlc3Rpbmcgb25seSwgYnV0IG1heSBiZSB1c2VkIGZvciBkZWJ1Z2dlci1yZWxhdGVkXG4vLyBwdXJwb3NlcyBpbiB0aGUgZnV0dXJlLlxuZXhwb3J0IHR5cGUgQ2FsbEhvb2sgPSAoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKSA9PiB2b2lkO1xuXG5sZXQgX25leHRMYXllcklEID0gMDtcblxuLyoqXG4gKiBBIGxheWVyIGlzIGEgZ3JvdXBpbmcgb2Ygb3BlcmF0aW9ucyBhbmQgd2VpZ2h0cyB0aGF0IGNhbiBiZSBjb21wb3NlZCB0b1xuICogY3JlYXRlIGEgYHRmLkxheWVyc01vZGVsYC5cbiAqXG4gKiBMYXllcnMgYXJlIGNvbnN0cnVjdGVkIGJ5IHVzaW5nIHRoZSBmdW5jdGlvbnMgdW5kZXIgdGhlXG4gKiBbdGYubGF5ZXJzXSgjTGF5ZXJzLUJhc2ljKSBuYW1lc3BhY2UuXG4gKlxuICogQGRvYyB7aGVhZGluZzogJ0xheWVycycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJywgbmFtZXNwYWNlOiAnbGF5ZXJzJ31cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIExheWVyIGV4dGVuZHMgc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUge1xuICAvKiogTmFtZSBmb3IgdGhpcyBsYXllci4gTXVzdCBiZSB1bmlxdWUgd2l0aGluIGEgbW9kZWwuICovXG4gIG5hbWU6IHN0cmluZztcbiAgLyoqXG4gICAqIExpc3Qgb2YgSW5wdXRTcGVjIGNsYXNzIGluc3RhbmNlcy5cbiAgICpcbiAgICogRWFjaCBlbnRyeSBkZXNjcmliZXMgb25lIHJlcXVpcmVkIGlucHV0OlxuICAgKiAtIG5kaW1cbiAgICogLSBkdHlwZVxuICAgKiBBIGxheWVyIHdpdGggYG5gIGlucHV0IHRlbnNvcnMgbXVzdCBoYXZlIGFuIGBpbnB1dFNwZWNgIG9mIGxlbmd0aCBgbmAuXG4gICAqL1xuICBpbnB1dFNwZWM6IElucHV0U3BlY1tdO1xuICBzdXBwb3J0c01hc2tpbmc6IGJvb2xlYW47XG4gIC8qKiBXaGV0aGVyIHRoZSBsYXllciB3ZWlnaHRzIHdpbGwgYmUgdXBkYXRlZCBkdXJpbmcgdHJhaW5pbmcuICovXG4gIHByb3RlY3RlZCB0cmFpbmFibGVfOiBib29sZWFuO1xuICBiYXRjaElucHV0U2hhcGU6IFNoYXBlO1xuICBkdHlwZTogRGF0YVR5cGU7XG4gIGluaXRpYWxXZWlnaHRzOiBUZW5zb3JbXTtcblxuICBpbmJvdW5kTm9kZXM6IE5vZGVbXTtcbiAgb3V0Ym91bmROb2RlczogTm9kZVtdO1xuXG4gIGFjdGl2aXR5UmVndWxhcml6ZXI6IFJlZ3VsYXJpemVyO1xuXG4gIHByb3RlY3RlZCBfdHJhaW5hYmxlV2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdO1xuICBwcml2YXRlIF9ub25UcmFpbmFibGVXZWlnaHRzOiBMYXllclZhcmlhYmxlW107XG4gIHByaXZhdGUgX2xvc3NlczogUmVndWxhcml6ZXJGbltdO1xuICAvLyBUT0RPKGNhaXMpOiBfdXBkYXRlcyBpcyBjdXJyZW50bHkgdW51c2VkLlxuICBwcml2YXRlIF91cGRhdGVzOiBUZW5zb3JbXTtcbiAgcHJpdmF0ZSBfYnVpbHQ6IGJvb2xlYW47XG4gIHByaXZhdGUgX2NhbGxIb29rOiBDYWxsSG9vayA9IG51bGw7XG5cbiAgcHJpdmF0ZSBfYWRkZWRXZWlnaHROYW1lczogc3RyaW5nW10gPSBbXTtcblxuICByZWFkb25seSBpZDogbnVtYmVyO1xuXG4gIC8vIFBvcnRpbmcgTm90ZXM6IFB5S2VyYXMgZG9lcyBub3QgaGF2ZSB0aGlzIHByb3BlcnR5IGluIHRoaXMgYmFzZSBMYXllclxuICAvLyAgIGNsYXNzLiBJbnN0ZWFkIGxldHMgTGF5ZXIgc3ViY2xhc3Mgc2V0IGl0IGR5bmFtaWNhbGx5IGFuZCBjaGVja3MgdGhlXG4gIC8vICAgdmFsdWUgd2l0aCBgaGFzYXR0cmAuIEluIHRmanMtbGF5ZXJzLCB3ZSBsZXQgdGhpcyBiZSBhIG1lbWJlciBvZiB0aGlzXG4gIC8vICAgYmFzZSBjbGFzcy5cbiAgcHJvdGVjdGVkIF9zdGF0ZWZ1bCA9IGZhbHNlO1xuXG4gIHByb3RlY3RlZCBfcmVmQ291bnQ6IG51bWJlcnxudWxsO1xuXG4gIC8vIEEgZmxhZyBmb3Igd2hldGhlciBmYXN0IChpLmUuLCBhbGwtemVybykgd2VpZ2h0IGluaXRpYWxpemF0aW9uIGlzIHRvXG4gIC8vIGJlIHVzZWQgZHVyaW5nIGBidWlsZCgpYCBjYWxsLiBUaGlzIHNwZWVkcyB1cCB3ZWlnaHQgaW5pdGlhbGl6YXRpb25cbiAgLy8gYnkgc2F2aW5nIHVubmVjZXNzYXJ5IGNhbGxzIHRvIGV4cGVuc2l2ZSBpbml0aWFsaXplcnMgaW4gY2FzZXMgd2hlcmVcbiAgLy8gdGhlIGluaXRpYWxpemVkIHZhbHVlcyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGxvYWRlZCB3ZWlnaHQgdmFsdWVzXG4gIC8vIGR1cmluZyBtb2RlbCBsb2FkaW5nLlxuICBwcml2YXRlIGZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoYXJnczogTGF5ZXJBcmdzID0ge30pIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuaWQgPSBfbmV4dExheWVySUQrKztcblxuICAgIHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciA9IG51bGw7XG5cbiAgICB0aGlzLmlucHV0U3BlYyA9IG51bGw7XG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSBmYWxzZTtcblxuICAgIC8vIFRoZXNlIHByb3BlcnRpZXMgd2lsbCBiZSBzZXQgdXBvbiBjYWxsIG9mIHRoaXMuYnVpbGQoKVxuICAgIHRoaXMuX3RyYWluYWJsZVdlaWdodHMgPSBbXTtcbiAgICB0aGlzLl9ub25UcmFpbmFibGVXZWlnaHRzID0gW107XG4gICAgdGhpcy5fbG9zc2VzID0gW107XG4gICAgdGhpcy5fdXBkYXRlcyA9IFtdO1xuICAgIHRoaXMuX2J1aWx0ID0gZmFsc2U7XG5cbiAgICAvKlxuICAgICAgVGhlc2UgbGlzdHMgd2lsbCBiZSBmaWxsZWQgdmlhIHN1Y2Nlc3NpdmUgY2FsbHNcbiAgICAgIHRvIHRoaXMuYWRkSW5ib3VuZE5vZGUoKS5cbiAgICAgKi9cbiAgICB0aGlzLmluYm91bmROb2RlcyA9IFtdO1xuICAgIHRoaXMub3V0Ym91bmROb2RlcyA9IFtdO1xuXG4gICAgbGV0IG5hbWUgPSBhcmdzLm5hbWU7XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmdldENsYXNzTmFtZSgpO1xuICAgICAgbmFtZSA9IGdlbmVyaWNfdXRpbHMudG9TbmFrZUNhc2UocHJlZml4KSArICdfJyArIGdldFVpZChwcmVmaXgpO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBuYW1lO1xuXG4gICAgdGhpcy50cmFpbmFibGVfID0gYXJncy50cmFpbmFibGUgPT0gbnVsbCA/IHRydWUgOiBhcmdzLnRyYWluYWJsZTtcblxuICAgIGlmIChhcmdzLmlucHV0U2hhcGUgIT0gbnVsbCB8fCBhcmdzLmJhdGNoSW5wdXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAvKlxuICAgICAgICBJbiB0aGlzIGNhc2Ugd2Ugd2lsbCBsYXRlciBjcmVhdGUgYW4gaW5wdXQgbGF5ZXJcbiAgICAgICAgdG8gaW5zZXJ0IGJlZm9yZSB0aGUgY3VycmVudCBsYXllclxuICAgICAgICovXG4gICAgICBsZXQgYmF0Y2hJbnB1dFNoYXBlOiBTaGFwZTtcbiAgICAgIGlmIChhcmdzLmJhdGNoSW5wdXRTaGFwZSAhPSBudWxsKSB7XG4gICAgICAgIGJhdGNoSW5wdXRTaGFwZSA9IGFyZ3MuYmF0Y2hJbnB1dFNoYXBlO1xuICAgICAgfSBlbHNlIGlmIChhcmdzLmlucHV0U2hhcGUgIT0gbnVsbCkge1xuICAgICAgICBsZXQgYmF0Y2hTaXplOiBudW1iZXIgPSBudWxsO1xuICAgICAgICBpZiAoYXJncy5iYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICAgIGJhdGNoU2l6ZSA9IGFyZ3MuYmF0Y2hTaXplO1xuICAgICAgICB9XG4gICAgICAgIGJhdGNoSW5wdXRTaGFwZSA9IFtiYXRjaFNpemVdLmNvbmNhdChhcmdzLmlucHV0U2hhcGUpO1xuICAgICAgfVxuICAgICAgdGhpcy5iYXRjaElucHV0U2hhcGUgPSBiYXRjaElucHV0U2hhcGU7XG5cbiAgICAgIC8vIFNldCBkdHlwZS5cbiAgICAgIGxldCBkdHlwZSA9IGFyZ3MuZHR5cGU7XG4gICAgICBpZiAoZHR5cGUgPT0gbnVsbCkge1xuICAgICAgICBkdHlwZSA9IGFyZ3MuaW5wdXREVHlwZTtcbiAgICAgIH1cbiAgICAgIGlmIChkdHlwZSA9PSBudWxsKSB7XG4gICAgICAgIGR0eXBlID0gJ2Zsb2F0MzInO1xuICAgICAgfVxuICAgICAgdGhpcy5kdHlwZSA9IGR0eXBlO1xuICAgIH1cblxuICAgIGlmIChhcmdzLndlaWdodHMgIT0gbnVsbCkge1xuICAgICAgdGhpcy5pbml0aWFsV2VpZ2h0cyA9IGFyZ3Mud2VpZ2h0cztcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5pbml0aWFsV2VpZ2h0cyA9IG51bGw7XG4gICAgfVxuXG4gICAgLy8gVGhlIHZhbHVlIG9mIGBfcmVmQ291bnRgIGlzIGluaXRpYWxpemVkIHRvIG51bGwuIFdoZW4gdGhlIGxheWVyIGlzIHVzZWRcbiAgICAvLyBpbiBhIHN5bWJvbGljIHdheSBmb3IgdGhlIGZpcnN0IHRpbWUsIGl0IHdpbGwgYmUgc2V0IHRvIDEuXG4gICAgdGhpcy5fcmVmQ291bnQgPSBudWxsO1xuXG4gICAgdGhpcy5mYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYSBsYXllciBhbmQgaXRzIGluZGV4IHRvIGEgdW5pcXVlIChpbW11dGFibGUgdHlwZSkgbmFtZS5cbiAgICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGludGVybmFsbHkgd2l0aCBgdGhpcy5jb250YWluZXJOb2Rlc2AuXG4gICAqIEBwYXJhbSBsYXllciBUaGUgbGF5ZXIuXG4gICAqIEBwYXJhbSBub2RlSW5kZXggVGhlIGxheWVyJ3MgcG9zaXRpb24gKGUuZy4gdmlhIGVudW1lcmF0ZSkgaW4gYSBsaXN0IG9mXG4gICAqICAgbm9kZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIFRoZSB1bmlxdWUgbmFtZS5cbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgbm9kZUtleShsYXllcjogTGF5ZXIsIG5vZGVJbmRleDogbnVtYmVyKSB7XG4gICAgcmV0dXJuIGxheWVyLm5hbWUgKyAnX2liLScgKyBub2RlSW5kZXgudG9TdHJpbmcoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoaXMuaW5ib3VuZE5vZGUgYXQgaW5kZXggbm9kZUluZGV4LlxuICAgKlxuICAgKiBQb3J0aW5nIG5vdGU6IFRoaXMgaXMgYSByZXBsYWNlbWVudCBmb3IgX2dldF9ub2RlX2F0dHJpYnV0ZV9hdF9pbmRleCgpXG4gICAqIEBwYXJhbSBub2RlSW5kZXhcbiAgICogQHBhcmFtIGF0dHJOYW1lIFRoZSBuYW1lIG9mIHRoZSBhdHRyaWJ1dGUgcmVsYXRlZCB0byByZXF1ZXN0IGZvciB0aGlzIG5vZGUuXG4gICAqL1xuICBwcml2YXRlIGdldE5vZGVBdEluZGV4KG5vZGVJbmRleDogbnVtYmVyLCBhdHRyTmFtZTogc3RyaW5nKTogTm9kZSB7XG4gICAgaWYgKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcbiAgICAgICAgICAnVGhlIGxheWVyIGhhcyBuZXZlciBiZWVuIGNhbGxlZCAnICtcbiAgICAgICAgICBgYW5kIHRodXMgaGFzIG5vIGRlZmluZWQgJHthdHRyTmFtZX0uYCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggPD0gbm9kZUluZGV4KSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgQXNrZWQgdG8gZ2V0ICR7YXR0ck5hbWV9IGF0IG5vZGUgJHtub2RlSW5kZXh9LCBgICtcbiAgICAgICAgICBgYnV0IHRoZSBsYXllciBoYXMgb25seSAke3RoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aH0gaW5ib3VuZCBub2Rlcy5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuaW5ib3VuZE5vZGVzW25vZGVJbmRleF07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmVzIHRoZSBpbnB1dCB0ZW5zb3Iocykgb2YgYSBsYXllciBhdCBhIGdpdmVuIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlSW5kZXggSW50ZWdlciwgaW5kZXggb2YgdGhlIG5vZGUgZnJvbSB3aGljaCB0byByZXRyaWV2ZSB0aGVcbiAgICogICBhdHRyaWJ1dGUuIEUuZy4gYG5vZGVJbmRleD0wYCB3aWxsIGNvcnJlc3BvbmQgdG8gdGhlIGZpcnN0IHRpbWUgdGhlIGxheWVyXG4gICAqICAgd2FzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybiBBIHRlbnNvciAob3IgbGlzdCBvZiB0ZW5zb3JzIGlmIHRoZSBsYXllciBoYXMgbXVsdGlwbGUgaW5wdXRzKS5cbiAgICovXG4gIGdldElucHV0QXQobm9kZUluZGV4OiBudW1iZXIpOiBTeW1ib2xpY1RlbnNvcnxTeW1ib2xpY1RlbnNvcltdIHtcbiAgICByZXR1cm4gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KFxuICAgICAgICB0aGlzLmdldE5vZGVBdEluZGV4KG5vZGVJbmRleCwgJ2lucHV0JykuaW5wdXRUZW5zb3JzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG91dHB1dCB0ZW5zb3Iocykgb2YgYSBsYXllciBhdCBhIGdpdmVuIG5vZGUuXG4gICAqXG4gICAqIEBwYXJhbSBub2RlSW5kZXggSW50ZWdlciwgaW5kZXggb2YgdGhlIG5vZGUgZnJvbSB3aGljaCB0byByZXRyaWV2ZSB0aGVcbiAgICogICBhdHRyaWJ1dGUuIEUuZy4gYG5vZGVJbmRleD0wYCB3aWxsIGNvcnJlc3BvbmQgdG8gdGhlIGZpcnN0IHRpbWUgdGhlIGxheWVyXG4gICAqICAgd2FzIGNhbGxlZC5cbiAgICpcbiAgICogQHJldHVybiBBIHRlbnNvciAob3IgbGlzdCBvZiB0ZW5zb3JzIGlmIHRoZSBsYXllciBoYXMgbXVsdGlwbGUgb3V0cHV0cykuXG4gICAqL1xuICBnZXRPdXRwdXRBdChub2RlSW5kZXg6IG51bWJlcik6IFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW10ge1xuICAgIHJldHVybiBnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkoXG4gICAgICAgIHRoaXMuZ2V0Tm9kZUF0SW5kZXgobm9kZUluZGV4LCAnb3V0cHV0Jykub3V0cHV0VGVuc29ycyk7XG4gIH1cblxuICAvLyBQcm9wZXJ0aWVzXG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgaW5wdXQgdGVuc29yKHMpIG9mIGEgbGF5ZXIuXG4gICAqXG4gICAqIE9ubHkgYXBwbGljYWJsZSBpZiB0aGUgbGF5ZXIgaGFzIGV4YWN0bHkgb25lIGluYm91bmQgbm9kZSxcbiAgICogaS5lLiBpZiBpdCBpcyBjb25uZWN0ZWQgdG8gb25lIGluY29taW5nIGxheWVyLlxuICAgKlxuICAgKiBAcmV0dXJuIElucHV0IHRlbnNvciBvciBsaXN0IG9mIGlucHV0IHRlbnNvcnMuXG4gICAqXG4gICAqIEBleGNlcHRpb24gQXR0cmlidXRlRXJyb3IgaWYgdGhlIGxheWVyIGlzIGNvbm5lY3RlZCB0byBtb3JlIHRoYW4gb25lXG4gICAqICAgaW5jb21pbmcgbGF5ZXJzLlxuICAgKi9cbiAgZ2V0IGlucHV0KCk6IFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW10ge1xuICAgIGlmICh0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXG4gICAgICAgICAgYExheWVyICR7dGhpcy5uYW1lfWAgK1xuICAgICAgICAgICcgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMsICcgK1xuICAgICAgICAgICdoZW5jZSB0aGUgbm90aW9uIG9mIFwibGF5ZXIgaW5wdXRcIiAnICtcbiAgICAgICAgICAnaXMgaWxsLWRlZmluZWQuICcgK1xuICAgICAgICAgICdVc2UgYGdldElucHV0QXQobm9kZUluZGV4KWAgaW5zdGVhZC4nKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuaW5ib3VuZE5vZGVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFxuICAgICAgICAgIGBMYXllciAke3RoaXMubmFtZX1gICtcbiAgICAgICAgICAnIGlzIG5vdCBjb25uZWN0ZWQsIG5vIGlucHV0IHRvIHJldHVybi4nKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShcbiAgICAgICAgdGhpcy5nZXROb2RlQXRJbmRleCgwLCAnaW5wdXQnKS5pbnB1dFRlbnNvcnMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgb3V0cHV0IHRlbnNvcihzKSBvZiBhIGxheWVyLlxuICAgKlxuICAgKiBPbmx5IGFwcGxpY2FibGUgaWYgdGhlIGxheWVyIGhhcyBleGFjdGx5IG9uZSBpbmJvdW5kIG5vZGUsXG4gICAqIGkuZS4gaWYgaXQgaXMgY29ubmVjdGVkIHRvIG9uZSBpbmNvbWluZyBsYXllci5cbiAgICpcbiAgICogQHJldHVybiBPdXRwdXQgdGVuc29yIG9yIGxpc3Qgb2Ygb3V0cHV0IHRlbnNvcnMuXG4gICAqXG4gICAqIEBleGNlcHRpb24gQXR0cmlidXRlRXJyb3IgaWYgdGhlIGxheWVyIGlzIGNvbm5lY3RlZCB0byBtb3JlIHRoYW4gb25lXG4gICAqICAgaW5jb21pbmcgbGF5ZXJzLlxuICAgKi9cbiAgZ2V0IG91dHB1dCgpOiBTeW1ib2xpY1RlbnNvcnxTeW1ib2xpY1RlbnNvcltdIHtcbiAgICBpZiAodGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXG4gICAgICAgICAgYExheWVyICR7dGhpcy5uYW1lfWAgK1xuICAgICAgICAgICcgaGFzIG5vIGluYm91bmQgbm9kZXMuJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICB0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXG4gICAgICAgICAgYExheWVyICR7dGhpcy5uYW1lfWAgK1xuICAgICAgICAgICcgaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMsICcgK1xuICAgICAgICAgICdoZW5jZSB0aGUgbm90aW9uIG9mIFwibGF5ZXIgb3V0cHV0XCIgJyArXG4gICAgICAgICAgJ2lzIGlsbC1kZWZpbmVkLiAnICtcbiAgICAgICAgICAnVXNlIGBnZXRPdXRwdXRBdChub2RlSW5kZXgpYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgICByZXR1cm4gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KFxuICAgICAgICB0aGlzLmdldE5vZGVBdEluZGV4KDAsICdvdXRwdXQnKS5vdXRwdXRUZW5zb3JzKTtcbiAgfVxuXG4gIGdldCBsb3NzZXMoKTogUmVndWxhcml6ZXJGbltdIHtcbiAgICByZXR1cm4gdGhpcy5fbG9zc2VzO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgTGF5ZXIncyBjdXJyZW50IGxvc3MgdmFsdWVzLlxuICAgKlxuICAgKiBVc2VkIGZvciByZWd1bGFyaXplcnMgZHVyaW5nIHRyYWluaW5nLlxuICAgKi9cbiAgY2FsY3VsYXRlTG9zc2VzKCk6IFNjYWxhcltdIHtcbiAgICAvLyBQb3J0aW5nIE5vZGU6IFRoaXMgaXMgYW4gYXVnbWVudGF0aW9uIHRvIExheWVyLmxvc3MgaW4gUHlLZXJhcy5cbiAgICAvLyAgIEluIFB5S2VyYXMsIExheWVyLmxvc3MgcmV0dXJucyBzeW1ib2xpYyB0ZW5zb3JzLiBIZXJlIGEgY29uY3JldGVcbiAgICAvLyAgIFRlbnNvciAoc3BlY2lmaWNhbGx5IFNjYWxhcikgdmFsdWVzIGFyZSByZXR1cm5lZC4gVGhpcyBpcyBkdWUgdG8gdGhlXG4gICAgLy8gICBpbXBlcmF0aXZlIGJhY2tlbmQuXG4gICAgcmV0dXJuIHRoaXMubG9zc2VzLm1hcChsb3NzRm4gPT4gbG9zc0ZuKCkpO1xuICB9XG5cbiAgZ2V0IHVwZGF0ZXMoKTogVGVuc29yW10ge1xuICAgIHJldHVybiB0aGlzLl91cGRhdGVzO1xuICB9XG5cbiAgZ2V0IGJ1aWx0KCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9idWlsdDtcbiAgfVxuXG4gIHNldCBidWlsdChidWlsdDogYm9vbGVhbikge1xuICAgIHRoaXMuX2J1aWx0ID0gYnVpbHQ7XG4gIH1cblxuICBnZXQgdHJhaW5hYmxlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRyYWluYWJsZV87XG4gIH1cblxuICBzZXQgdHJhaW5hYmxlKHRyYWluYWJsZTogYm9vbGVhbikge1xuICAgIHRoaXMuX3RyYWluYWJsZVdlaWdodHMuZm9yRWFjaCh3ID0+IHcudHJhaW5hYmxlID0gdHJhaW5hYmxlKTtcbiAgICB0aGlzLnRyYWluYWJsZV8gPSB0cmFpbmFibGU7XG4gIH1cblxuICBnZXQgdHJhaW5hYmxlV2VpZ2h0cygpOiBMYXllclZhcmlhYmxlW10ge1xuICAgIGlmICh0aGlzLnRyYWluYWJsZV8pIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFpbmFibGVXZWlnaHRzLmZpbHRlcih3ID0+IHcudHJhaW5hYmxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfVxuXG4gIHNldCB0cmFpbmFibGVXZWlnaHRzKHdlaWdodHM6IExheWVyVmFyaWFibGVbXSkge1xuICAgIHRoaXMuX3RyYWluYWJsZVdlaWdodHMgPSB3ZWlnaHRzO1xuICB9XG5cbiAgZ2V0IG5vblRyYWluYWJsZVdlaWdodHMoKTogTGF5ZXJWYXJpYWJsZVtdIHtcbiAgICBpZiAodGhpcy50cmFpbmFibGUpIHtcbiAgICAgIHJldHVybiB0aGlzLl90cmFpbmFibGVXZWlnaHRzLmZpbHRlcih3ID0+ICF3LnRyYWluYWJsZSlcbiAgICAgICAgICAuY29uY2F0KHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5jb25jYXQodGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cyk7XG4gICAgfVxuICB9XG5cbiAgc2V0IG5vblRyYWluYWJsZVdlaWdodHMod2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdKSB7XG4gICAgdGhpcy5fbm9uVHJhaW5hYmxlV2VpZ2h0cyA9IHdlaWdodHM7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlIGxpc3RzIHRyYWluYWJsZVdlaWdodHMgYW5kIG5vblRyYWluYWJsZVdlaWdodHNcbiAgICogKGluIHRoaXMgb3JkZXIpLlxuICAgKi9cbiAgZ2V0IHdlaWdodHMoKTogTGF5ZXJWYXJpYWJsZVtdIHtcbiAgICByZXR1cm4gdGhpcy50cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh0aGlzLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICB9XG5cbiAgZ2V0IHN0YXRlZnVsKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLl9zdGF0ZWZ1bDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc3RhdGVzIG9mIHRoZSBsYXllci5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgb2YgdGhlIGJhc2UgTGF5ZXIgY2xhc3MgaXMgZXNzZW50aWFsbHkgYSBuby1vcC5cbiAgICogU3ViY2xhc3NlcyB0aGF0IGFyZSBzdGF0ZWZ1bCAoZS5nLiwgc3RhdGVmdWwgUk5Ocykgc2hvdWxkIG92ZXJyaWRlIHRoaXNcbiAgICogbWV0aG9kLlxuICAgKi9cbiAgcmVzZXRTdGF0ZXMoKTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLnN0YXRlZnVsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBjYWxsIHRoZSByZXNldFN0YXRlcygpIG1ldGhvZCBvZiBhIG5vbi1zdGF0ZWZ1bCBMYXllciAnICtcbiAgICAgICAgICAnb2JqZWN0LicpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgY29tcGF0aWJpbGl0eSBiZXR3ZWVuIHRoZSBsYXllciBhbmQgcHJvdmlkZWQgaW5wdXRzLlxuICAgKlxuICAgKiBUaGlzIGNoZWNrcyB0aGF0IHRoZSB0ZW5zb3IocykgYGlucHV0YFxuICAgKiB2ZXJpZnkgdGhlIGlucHV0IGFzc3VtcHRpb25zIG9mIHRoZSBsYXllclxuICAgKiAoaWYgYW55KS4gSWYgbm90LCBleGNlcHRpb25zIGFyZSByYWlzZWQuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dHMgSW5wdXQgdGVuc29yIG9yIGxpc3Qgb2YgaW5wdXQgdGVuc29ycy5cbiAgICpcbiAgICogQGV4Y2VwdGlvbiBWYWx1ZUVycm9yIGluIGNhc2Ugb2YgbWlzbWF0Y2ggYmV0d2VlblxuICAgKiAgIHRoZSBwcm92aWRlZCBpbnB1dHMgYW5kIHRoZSBleHBlY3RhdGlvbnMgb2YgdGhlIGxheWVyLlxuICAgKi9cbiAgcHJvdGVjdGVkIGFzc2VydElucHV0Q29tcGF0aWJpbGl0eShpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcnxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBTeW1ib2xpY1RlbnNvcltdKTogdm9pZCB7XG4gICAgaW5wdXRzID0gZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRzKTtcbiAgICBpZiAodGhpcy5pbnB1dFNwZWMgPT0gbnVsbCB8fCB0aGlzLmlucHV0U3BlYy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRTcGVjID0gZ2VuZXJpY191dGlscy50b0xpc3QodGhpcy5pbnB1dFNwZWMpO1xuICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSBpbnB1dFNwZWMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgTGF5ZXIgJHt0aGlzLm5hbWV9IGV4cGVjdHMgJHtpbnB1dFNwZWMubGVuZ3RofSBpbnB1dHMsIGAgK1xuICAgICAgICAgIGBidXQgaXQgcmVjZWl2ZWQgJHtpbnB1dHMubGVuZ3RofSBpbnB1dCB0ZW5zb3JzLiBgICtcbiAgICAgICAgICBgSW5wdXQgcmVjZWl2ZWQ6ICR7aW5wdXRzfWApO1xuICAgIH1cbiAgICBmb3IgKGxldCBpbnB1dEluZGV4ID0gMDsgaW5wdXRJbmRleCA8IGlucHV0cy5sZW5ndGg7IGlucHV0SW5kZXgrKykge1xuICAgICAgY29uc3QgeCA9IGlucHV0c1tpbnB1dEluZGV4XTtcbiAgICAgIGNvbnN0IHNwZWM6IElucHV0U3BlYyA9IGlucHV0U3BlY1tpbnB1dEluZGV4XTtcbiAgICAgIGlmIChzcGVjID09IG51bGwpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIG5kaW0uXG4gICAgICBjb25zdCBuZGltID0geC5yYW5rO1xuICAgICAgaWYgKHNwZWMubmRpbSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZGltICE9PSBzcGVjLm5kaW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgYElucHV0ICR7aW5wdXRJbmRleH0gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9OiBgICtcbiAgICAgICAgICAgICAgYGV4cGVjdGVkIG5kaW09JHtzcGVjLm5kaW19LCBmb3VuZCBuZGltPSR7bmRpbX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHNwZWMubWF4TkRpbSAhPSBudWxsKSB7XG4gICAgICAgIGlmIChuZGltID4gc3BlYy5tYXhORGltKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgIGBJbnB1dCAke2lucHV0SW5kZXh9IGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyICR7dGhpcy5uYW1lfWAgK1xuICAgICAgICAgICAgICBgOiBleHBlY3RlZCBtYXhfbmRpbT0ke3NwZWMubWF4TkRpbX0sIGZvdW5kIG5kaW09JHtuZGltfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3BlYy5taW5ORGltICE9IG51bGwpIHtcbiAgICAgICAgaWYgKG5kaW0gPCBzcGVjLm1pbk5EaW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgYElucHV0ICR7aW5wdXRJbmRleH0gaXMgaW5jb21wYXRpYmxlIHdpdGggbGF5ZXIgJHt0aGlzLm5hbWV9YCArXG4gICAgICAgICAgICAgIGA6IGV4cGVjdGVkIG1pbl9uZGltPSR7c3BlYy5taW5ORGltfSwgZm91bmQgbmRpbT0ke25kaW19LmApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIENoZWNrIGR0eXBlLlxuICAgICAgaWYgKHNwZWMuZHR5cGUgIT0gbnVsbCkge1xuICAgICAgICBpZiAoeC5kdHlwZSAhPT0gc3BlYy5kdHlwZSkge1xuICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgSW5wdXQgJHtpbnB1dEluZGV4fSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX0gYCArXG4gICAgICAgICAgICAgIGA6IGV4cGVjdGVkIGR0eXBlPSR7c3BlYy5kdHlwZX0sIGZvdW5kIGR0eXBlPSR7eC5kdHlwZX0uYCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgc3BlY2lmaWMgc2hhcGUgYXhlcy5cbiAgICAgIGlmIChzcGVjLmF4ZXMpIHtcbiAgICAgICAgY29uc3QgeFNoYXBlID0geC5zaGFwZTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gc3BlYy5heGVzKSB7XG4gICAgICAgICAgY29uc3QgYXhpcyA9IE51bWJlcihrZXkpO1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3BlYy5heGVzW2tleV07XG4gICAgICAgICAgLy8gUGVyZm9ybSBQeXRob24tc3R5bGUgc2xpY2luZyBpbiBjYXNlIGF4aXMgPCAwO1xuICAgICAgICAgIC8vIFRPRE8oY2Fpcyk6IFVzZSBodHRwczovL2dpdGh1Yi5jb20vYWx2aXZpL3R5cGVzY3JpcHQtdW5kZXJzY29yZSB0b1xuICAgICAgICAgIC8vIGVuc3VyZSB0eXBlIHNhZmV0eSB0aHJvdWdoIFVuZGVyc2NvcmUgY2FsbHMuXG4gICAgICAgICAgY29uc3QgeFNoYXBlQXRBeGlzID1cbiAgICAgICAgICAgICAgYXhpcyA+PSAwID8geFNoYXBlW2F4aXNdIDogeFNoYXBlW3hTaGFwZS5sZW5ndGggKyBheGlzXTtcbiAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCAmJiBbdmFsdWUsIG51bGxdLmluZGV4T2YoeFNoYXBlQXRBeGlzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICAgIGBJbnB1dCAke2lucHV0SW5kZXh9IGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIGAgK1xuICAgICAgICAgICAgICAgIGAke3RoaXMubmFtZX06IGV4cGVjdGVkIGF4aXMgJHtheGlzfSBvZiBpbnB1dCBzaGFwZSB0byBgICtcbiAgICAgICAgICAgICAgICBgaGF2ZSB2YWx1ZSAke3ZhbHVlfSBidXQgZ290IHNoYXBlICR7eFNoYXBlfS5gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQ2hlY2sgc2hhcGUuXG4gICAgICBpZiAoc3BlYy5zaGFwZSAhPSBudWxsKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3BlYy5zaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IHNwZWNEaW0gPSBzcGVjLnNoYXBlW2ldO1xuICAgICAgICAgIGNvbnN0IGRpbSA9IHguc2hhcGVbaV07XG4gICAgICAgICAgaWYgKHNwZWNEaW0gIT0gbnVsbCAmJiBkaW0gIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHNwZWNEaW0gIT09IGRpbSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgICAgIGBJbnB1dCAke2lucHV0SW5kZXh9IGlzIGluY29tcGF0aWJsZSB3aXRoIGxheWVyIGAgK1xuICAgICAgICAgICAgICAgICAgYCR7dGhpcy5uYW1lfTogZXhwZWN0ZWQgc2hhcGU9JHtzcGVjLnNoYXBlfSwgYCArXG4gICAgICAgICAgICAgICAgICBgZm91bmQgc2hhcGU9JHt4LnNoYXBlfS5gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBpcyB3aGVyZSB0aGUgbGF5ZXIncyBsb2dpYyBsaXZlcy5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0cyBJbnB1dCB0ZW5zb3IsIG9yIGxpc3QvdHVwbGUgb2YgaW5wdXQgdGVuc29ycy5cbiAgICogQHBhcmFtIGt3YXJncyBBZGRpdGlvbmFsIGtleXdvcmQgYXJndW1lbnRzLlxuICAgKlxuICAgKiBAcmV0dXJuIEEgdGVuc29yIG9yIGxpc3QvdHVwbGUgb2YgdGVuc29ycy5cbiAgICovXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gaW5wdXRzO1xuICB9XG5cbiAgcHJvdGVjdGVkIGludm9rZUNhbGxIb29rKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncykge1xuICAgIGlmICh0aGlzLl9jYWxsSG9vayAhPSBudWxsKSB7XG4gICAgICB0aGlzLl9jYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFNldCBjYWxsIGhvb2suXG4gICAqIFRoaXMgaXMgY3VycmVudGx5IHVzZWQgZm9yIHRlc3Rpbmcgb25seS5cbiAgICogQHBhcmFtIGNhbGxIb29rXG4gICAqL1xuICBzZXRDYWxsSG9vayhjYWxsSG9vazogQ2FsbEhvb2spIHtcbiAgICB0aGlzLl9jYWxsSG9vayA9IGNhbGxIb29rO1xuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGNhbGwgaG9vay5cbiAgICogVGhpcyBpcyBjdXJyZW50bHkgdXNlZCBmb3IgdGVzdGluZyBvbmx5LlxuICAgKi9cbiAgY2xlYXJDYWxsSG9vaygpIHtcbiAgICB0aGlzLl9jYWxsSG9vayA9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQnVpbGRzIG9yIGV4ZWN1dGVzIGEgYExheWVyJ3MgbG9naWMuXG4gICAqXG4gICAqIFdoZW4gY2FsbGVkIHdpdGggYHRmLlRlbnNvcmAocyksIGV4ZWN1dGUgdGhlIGBMYXllcmBzIGNvbXB1dGF0aW9uIGFuZFxuICAgKiByZXR1cm4gVGVuc29yKHMpLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgZGVuc2VMYXllciA9IHRmLmxheWVycy5kZW5zZSh7XG4gICAqICAgdW5pdHM6IDEsXG4gICAqICAga2VybmVsSW5pdGlhbGl6ZXI6ICd6ZXJvcycsXG4gICAqICAgdXNlQmlhczogZmFsc2VcbiAgICogfSk7XG4gICAqXG4gICAqIC8vIEludm9rZSB0aGUgbGF5ZXIncyBhcHBseSgpIG1ldGhvZCB3aXRoIGEgYHRmLlRlbnNvcmAgKHdpdGggY29uY3JldGVcbiAgICogLy8gbnVtZXJpYyB2YWx1ZXMpLlxuICAgKiBjb25zdCBpbnB1dCA9IHRmLm9uZXMoWzIsIDJdKTtcbiAgICogY29uc3Qgb3V0cHV0ID0gZGVuc2VMYXllci5hcHBseShpbnB1dCk7XG4gICAqXG4gICAqIC8vIFRoZSBvdXRwdXQncyB2YWx1ZSBpcyBleHBlY3RlZCB0byBiZSBbWzBdLCBbMF1dLCBkdWUgdG8gdGhlIGZhY3QgdGhhdFxuICAgKiAvLyB0aGUgZGVuc2UgbGF5ZXIgaGFzIGEga2VybmVsIGluaXRpYWxpemVkIHRvIGFsbC16ZXJvcyBhbmQgZG9lcyBub3QgaGF2ZVxuICAgKiAvLyBhIGJpYXMuXG4gICAqIG91dHB1dC5wcmludCgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogV2hlbiBjYWxsZWQgd2l0aCBgdGYuU3ltYm9saWNUZW5zb3JgKHMpLCB0aGlzIHdpbGwgcHJlcGFyZSB0aGUgbGF5ZXIgZm9yXG4gICAqIGZ1dHVyZSBleGVjdXRpb24uICBUaGlzIGVudGFpbHMgaW50ZXJuYWwgYm9vay1rZWVwaW5nIG9uIHNoYXBlcyBvZlxuICAgKiBleHBlY3RlZCBUZW5zb3JzLCB3aXJpbmcgbGF5ZXJzIHRvZ2V0aGVyLCBhbmQgaW5pdGlhbGl6aW5nIHdlaWdodHMuXG4gICAqXG4gICAqIENhbGxpbmcgYGFwcGx5YCB3aXRoIGB0Zi5TeW1ib2xpY1RlbnNvcmBzIGFyZSB0eXBpY2FsbHkgdXNlZCBkdXJpbmcgdGhlXG4gICAqIGJ1aWxkaW5nIG9mIG5vbi1gdGYuU2VxdWVudGlhbGAgbW9kZWxzLiBGb3IgZXhhbXBsZTpcbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgZmxhdHRlbkxheWVyID0gdGYubGF5ZXJzLmZsYXR0ZW4oKTtcbiAgICogY29uc3QgZGVuc2VMYXllciA9IHRmLmxheWVycy5kZW5zZSh7dW5pdHM6IDF9KTtcbiAgICpcbiAgICogLy8gVXNlIHRmLmxheWVycy5pbnB1dCgpIHRvIG9idGFpbiBhIFN5bWJvbGljVGVuc29yIGFzIGlucHV0IHRvIGFwcGx5KCkuXG4gICAqIGNvbnN0IGlucHV0ID0gdGYuaW5wdXQoe3NoYXBlOiBbMiwgMl19KTtcbiAgICogY29uc3Qgb3V0cHV0MSA9IGZsYXR0ZW5MYXllci5hcHBseShpbnB1dCk7XG4gICAqXG4gICAqIC8vIG91dHB1dDEuc2hhcGUgaXMgW251bGwsIDRdLiBUaGUgZmlyc3QgZGltZW5zaW9uIGlzIHRoZSB1bmRldGVybWluZWRcbiAgICogLy8gYmF0Y2ggc2l6ZS4gVGhlIHNlY29uZCBkaW1lbnNpb24gY29tZXMgZnJvbSBmbGF0dGVuaW5nIHRoZSBbMiwgMl1cbiAgICogLy8gc2hhcGUuXG4gICAqIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KG91dHB1dDEuc2hhcGUpKTtcbiAgICpcbiAgICogLy8gVGhlIG91dHB1dCBTeW1ib2xpY1RlbnNvciBvZiB0aGUgZmxhdHRlbiBsYXllciBjYW4gYmUgdXNlZCB0byBjYWxsXG4gICAqIC8vIHRoZSBhcHBseSgpIG9mIHRoZSBkZW5zZSBsYXllcjpcbiAgICogY29uc3Qgb3V0cHV0MiA9IGRlbnNlTGF5ZXIuYXBwbHkob3V0cHV0MSk7XG4gICAqXG4gICAqIC8vIG91dHB1dDIuc2hhcGUgaXMgW251bGwsIDFdLiBUaGUgZmlyc3QgZGltZW5zaW9uIGlzIHRoZSB1bmRldGVybWluZWRcbiAgICogLy8gYmF0Y2ggc2l6ZS4gVGhlIHNlY29uZCBkaW1lbnNpb24gbWF0Y2hlcyB0aGUgbnVtYmVyIG9mIHVuaXRzIG9mIHRoZVxuICAgKiAvLyBkZW5zZSBsYXllci5cbiAgICogY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkob3V0cHV0Mi5zaGFwZSkpO1xuICAgKlxuICAgKiAvLyBUaGUgaW5wdXQgYW5kIG91dHB1dCBhbmQgYmUgdXNlZCB0byBjb25zdHJ1Y3QgYSBtb2RlbCB0aGF0IGNvbnNpc3RzXG4gICAqIC8vIG9mIHRoZSBmbGF0dGVuIGFuZCBkZW5zZSBsYXllcnMuXG4gICAqIGNvbnN0IG1vZGVsID0gdGYubW9kZWwoe2lucHV0czogaW5wdXQsIG91dHB1dHM6IG91dHB1dDJ9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dHMgYSBgdGYuVGVuc29yYCBvciBgdGYuU3ltYm9saWNUZW5zb3JgIG9yIGFuIEFycmF5IG9mIHRoZW0uXG4gICAqIEBwYXJhbSBrd2FyZ3MgQWRkaXRpb25hbCBrZXl3b3JkIGFyZ3VtZW50cyB0byBiZSBwYXNzZWQgdG8gYGNhbGwoKWAuXG4gICAqXG4gICAqIEByZXR1cm4gT3V0cHV0IG9mIHRoZSBsYXllcidzIGBjYWxsYCBtZXRob2QuXG4gICAqXG4gICAqIEBleGNlcHRpb24gVmFsdWVFcnJvciBlcnJvciBpbiBjYXNlIHRoZSBsYXllciBpcyBtaXNzaW5nIHNoYXBlIGluZm9ybWF0aW9uXG4gICAqICAgZm9yIGl0cyBgYnVpbGRgIGNhbGwuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCAnc3ViaGVhZGluZyc6ICdDbGFzc2VzJ31cbiAgICovXG4gIC8vIFBvcnRpbmcgTm90ZTogVGhpcyBpcyBhIHJlcGxhY2VtZW50IGZvciBfX2NhbGxfXygpIGluIFB5dGhvbi5cbiAgYXBwbHkoXG4gICAgICBpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcnxTeW1ib2xpY1RlbnNvcltdLFxuICAgICAga3dhcmdzPzogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdfFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW10ge1xuICAgIGt3YXJncyA9IGt3YXJncyB8fCB7fTtcblxuICAgIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTtcblxuICAgIC8vIEVuc3VyZSBpbnB1dHMgYXJlIGFsbCB0aGUgc2FtZSB0eXBlLlxuICAgIGNvbnN0IGlucHV0c0xpc3QgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpO1xuXG4gICAgbGV0IGFsbEFyZVN5bWJvbGljID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0c0xpc3QpIHtcbiAgICAgIGlmICghKGlucHV0IGluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3IpKSB7XG4gICAgICAgIGFsbEFyZVN5bWJvbGljID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBsZXQgbm9uZUFyZVN5bWJvbGljID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIGlucHV0c0xpc3QpIHtcbiAgICAgIGlmIChpbnB1dCBpbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yKSB7XG4gICAgICAgIG5vbmVBcmVTeW1ib2xpYyA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoYWxsQXJlU3ltYm9saWMgPT09IG5vbmVBcmVTeW1ib2xpYykge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ0FyZ3VtZW50cyB0byBhcHBseSgpIG11c3QgYmUgYWxsICcgK1xuICAgICAgICAgICdTeW1ib2xpY1RlbnNvcnMgb3IgYWxsIFRlbnNvcnMnKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IG5hbWVTY29wZSgpIG1heSBub3QgYmUgbmVjZXNzYXJ5LlxuICAgIHJldHVybiBuYW1lU2NvcGUodGhpcy5uYW1lLCAoKSA9PiB7XG4gICAgICAvLyBIYW5kbGUgbGF5aW5nIGJ1aWxkaW5nICh3ZWlnaHQgY3JlYXRpbmcsIGlucHV0IHNwZWMgbG9ja2luZykuXG4gICAgICBpZiAoIXRoaXMuYnVpbHQpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBUaHJvdyBleGNlcHRpb25zIGluIGNhc2UgdGhlIGlucHV0IGlzIG5vdCBjb21wYXRpYmxlXG4gICAgICAgICAgd2l0aCB0aGUgaW5wdXRTcGVjIHNwZWNpZmllZCBpbiB0aGUgbGF5ZXIgY29uc3RydWN0b3IuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmFzc2VydElucHV0Q29tcGF0aWJpbGl0eShpbnB1dHMpO1xuXG4gICAgICAgIC8vIENvbGxlY3QgaW5wdXQgc2hhcGVzIHRvIGJ1aWxkIGxheWVyLlxuICAgICAgICBjb25zdCBpbnB1dFNoYXBlczogU2hhcGVbXSA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHhFbGVtIG9mIGdlbmVyaWNfdXRpbHMudG9MaXN0KGlucHV0cykpIHtcbiAgICAgICAgICBpbnB1dFNoYXBlcy5wdXNoKHhFbGVtLnNoYXBlKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmJ1aWxkKGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShpbnB1dFNoYXBlcykpO1xuICAgICAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcblxuICAgICAgICAvLyBMb2FkIHdlaWdodHMgdGhhdCB3ZXJlIHNwZWNpZmllZCBhdCBsYXllciBpbnN0YW50aWF0aW9uLlxuICAgICAgICBpZiAodGhpcy5pbml0aWFsV2VpZ2h0cykge1xuICAgICAgICAgIHRoaXMuc2V0V2VpZ2h0cyh0aGlzLmluaXRpYWxXZWlnaHRzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gbnVsbCAmJiBub25lQXJlU3ltYm9saWMpIHtcbiAgICAgICAgICAvLyBUaGUgZmlyc3QgdXNlIG9mIHRoaXMgbGF5ZXIgaXMgYSBub24tc3ltYm9saWMgY2FsbCwgc2V0IHJlZiBjb3VudFxuICAgICAgICAgIC8vIHRvIDEgc28gdGhlIExheWVyIGNhbiBiZSBwcm9wZXJseSBkaXNwb3NlZCBpZiBpdHMgZGlzcG9zZSgpIG1ldGhvZFxuICAgICAgICAgIC8vIGlzIGNhbGxlZC5cbiAgICAgICAgICB0aGlzLl9yZWZDb3VudCA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLypcbiAgICAgICAgVGhyb3cgZXhjZXB0aW9ucyBpbiBjYXNlIHRoZSBpbnB1dCBpcyBub3QgY29tcGF0aWJsZVxuICAgICAgICB3aXRoIHRoZSBpbnB1dFNwZWMgc2V0IGF0IGJ1aWxkIHRpbWUuXG4gICAgICAqL1xuICAgICAgdGhpcy5hc3NlcnRJbnB1dENvbXBhdGliaWxpdHkoaW5wdXRzKTtcblxuICAgICAgLy8gSGFuZGxlIG1hc2sgcHJvcGFnYXRpb24uXG4gICAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IE1hc2sgcHJvcGFnYXRpb24gbm90IGN1cnJlbnRseSBpbXBsZW1lbnRlZC5cblxuICAgICAgLy8gQWN0dWFsbHkgY2FsbCB0aGUgbGF5ZXIsIGNvbGxlY3Rpbmcgb3V0cHV0KHMpLCBtYXNrKHMpLCBhbmQgc2hhcGUocykuXG4gICAgICBpZiAobm9uZUFyZVN5bWJvbGljKSB7XG4gICAgICAgIGxldCBvdXRwdXQgPSB0aGlzLmNhbGwoaW5wdXRzIGFzIFRlbnNvciB8IFRlbnNvcltdLCBrd2FyZ3MpO1xuICAgICAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IENvbXB1dGUgdGhlIG91dHB1dE1hc2tcblxuICAgICAgICAvLyBJZiB0aGUgbGF5ZXIgcmV0dXJucyB0ZW5zb3JzIGZyb20gaXRzIGlucHV0cywgdW5tb2RpZmllZCxcbiAgICAgICAgLy8gd2UgY29weSB0aGVtIHRvIGF2b2lkIGxvc3Mgb2YgdGVuc29yIG1ldGFkYXRhLlxuICAgICAgICBjb25zdCBvdXRwdXRMaXN0OiBUZW5zb3JbXSA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KG91dHB1dCk7XG4gICAgICAgIGNvbnN0IG91dHB1dExpc3RDb3B5OiBUZW5zb3JbXSA9IFtdO1xuICAgICAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IFRoaXMgY29weWluZyBtYXkgbm90IGJlIG5lY2Vzc2FyeSBnaXZlbiBvdXIgZWFnZXJcbiAgICAgICAgLy8gYmFja2VuZC5cbiAgICAgICAgZm9yIChsZXQgeCBvZiBvdXRwdXRMaXN0KSB7XG4gICAgICAgICAgaWYgKGlucHV0c0xpc3QuaW5kZXhPZih4KSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHggPSB4LmNsb25lKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG91dHB1dExpc3RDb3B5LnB1c2goeCk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0ID0gZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KG91dHB1dExpc3RDb3B5KTtcblxuICAgICAgICBpZiAodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAgICAgJ0xheWVyIGludm9jYXRpb24gaW4gdGhlIHByZXNlbmNlIG9mIGFjdGl2aXR5ICcgK1xuICAgICAgICAgICAgICAncmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IENhbGwgYWRkSW5ib3VuZE5vZGUoKT9cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBjb2xsZWN0SW5wdXRTaGFwZShpbnB1dHMpO1xuICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHRoaXMuY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGUpO1xuICAgICAgICBsZXQgb3V0cHV0OiBTeW1ib2xpY1RlbnNvcnxTeW1ib2xpY1RlbnNvcltdO1xuICAgICAgICBjb25zdCBvdXRwdXREVHlwZSA9IGd1ZXNzT3V0cHV0RFR5cGUoaW5wdXRzKTtcbiAgICAgICAgdGhpcy53YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlKFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShpbnB1dHMpID8gaW5wdXRTaGFwZVswXSBhcyBTaGFwZSA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFNoYXBlIGFzIFNoYXBlKTtcblxuICAgICAgICBpZiAob3V0cHV0U2hhcGUgIT0gbnVsbCAmJiBvdXRwdXRTaGFwZS5sZW5ndGggPiAwICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KG91dHB1dFNoYXBlWzBdKSkge1xuICAgICAgICAgIC8vIFdlIGhhdmUgbXVsdGlwbGUgb3V0cHV0IHNoYXBlcy4gQ3JlYXRlIG11bHRpcGxlIG91dHB1dCB0ZW5zb3JzLlxuICAgICAgICAgIG91dHB1dCA9IChvdXRwdXRTaGFwZSBhcyBTaGFwZVtdKVxuICAgICAgICAgICAgICAgICAgICAgICAubWFwKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgKHNoYXBlLCBpbmRleCkgPT4gbmV3IFN5bWJvbGljVGVuc29yKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dERUeXBlLCBzaGFwZSwgdGhpcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpLCBrd2FyZ3MsIHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmRleCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dCA9IG5ldyBTeW1ib2xpY1RlbnNvcihcbiAgICAgICAgICAgICAgb3V0cHV0RFR5cGUsIG91dHB1dFNoYXBlIGFzIFNoYXBlLCB0aGlzLFxuICAgICAgICAgICAgICBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpLCBrd2FyZ3MsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKlxuICAgICAgICAgIEFkZCBhbiBpbmJvdW5kIG5vZGUgdG8gdGhlIGxheWVyLCBzbyB0aGF0IGl0IGtlZXBzIHRyYWNrXG4gICAgICAgICAgb2YgdGhlIGNhbGwgYW5kIG9mIGFsbCBuZXcgdmFyaWFibGVzIGNyZWF0ZWQgZHVyaW5nIHRoZSBjYWxsLlxuICAgICAgICAgIFRoaXMgYWxzbyB1cGRhdGVzIHRoZSBsYXllciBoaXN0b3J5IG9mIHRoZSBvdXRwdXQgdGVuc29yKHMpLlxuICAgICAgICAgIElmIHRoZSBpbnB1dCB0ZW5zb3IocykgaGFkIG5vIHByZXZpb3VzIGhpc3RvcnksXG4gICAgICAgICAgdGhpcyBkb2VzIG5vdGhpbmcuXG4gICAgICAgICovXG4gICAgICAgIHRoaXMuYWRkSW5ib3VuZE5vZGUoXG4gICAgICAgICAgICBpbnB1dHMgYXMgU3ltYm9saWNUZW5zb3IgfCBTeW1ib2xpY1RlbnNvcltdLCBvdXRwdXQsIG51bGwsIG51bGwsXG4gICAgICAgICAgICBpbnB1dFNoYXBlLCBvdXRwdXRTaGFwZSwga3dhcmdzKTtcbiAgICAgICAgdGhpcy5fcmVmQ291bnQrKztcblxuICAgICAgICBpZiAodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyICE9IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAgICAgJ0xheWVyIGludm9jYXRpb24gaW4gdGhlIHByZXNlbmNlIG9mIGFjdGl2aXR5ICcgK1xuICAgICAgICAgICAgICAncmVndWxhcml6ZXIocykgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gb3V0cHV0O1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrIGNvbXBhdGliaWxpdHkgYmV0d2VlbiBpbnB1dCBzaGFwZSBhbmQgdGhpcyBsYXllcidzIGJhdGNoSW5wdXRTaGFwZS5cbiAgICpcbiAgICogUHJpbnQgd2FybmluZyBpZiBhbnkgaW5jb21wYXRpYmlsaXR5IGlzIGZvdW5kLlxuICAgKlxuICAgKiBAcGFyYW0gaW5wdXRTaGFwZSBJbnB1dCBzaGFwZSB0byBiZSBjaGVja2VkLlxuICAgKi9cbiAgcHJvdGVjdGVkIHdhcm5PbkluY29tcGF0aWJsZUlucHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGUpIHtcbiAgICBpZiAodGhpcy5iYXRjaElucHV0U2hhcGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH0gZWxzZSBpZiAoaW5wdXRTaGFwZS5sZW5ndGggIT09IHRoaXMuYmF0Y2hJbnB1dFNoYXBlLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgIGBUaGUgcmFuayBvZiB0aGUgaW5wdXQgdGVuc29yIHByb3ZpZGVkIChzaGFwZTogYCArXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSl9KSBkb2VzIG5vdCBtYXRjaCB0aGF0IG9mIHRoZSBgICtcbiAgICAgICAgICBgYmF0Y2hJbnB1dFNoYXBlICgke0pTT04uc3RyaW5naWZ5KHRoaXMuYmF0Y2hJbnB1dFNoYXBlKX0pIGAgK1xuICAgICAgICAgIGBvZiB0aGUgbGF5ZXIgJHt0aGlzLm5hbWV9YCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBkaW1NaXNtYXRjaCA9IGZhbHNlO1xuICAgICAgdGhpcy5iYXRjaElucHV0U2hhcGUuZm9yRWFjaCgoZGltZW5zaW9uLCBpKSA9PiB7XG4gICAgICAgIGlmIChkaW1lbnNpb24gIT0gbnVsbCAmJiBpbnB1dFNoYXBlW2ldICE9IG51bGwgJiZcbiAgICAgICAgICAgIGlucHV0U2hhcGVbaV0gIT09IGRpbWVuc2lvbikge1xuICAgICAgICAgIGRpbU1pc21hdGNoID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoZGltTWlzbWF0Y2gpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgYFRoZSBzaGFwZSBvZiB0aGUgaW5wdXQgdGVuc29yIGAgK1xuICAgICAgICAgICAgYCgke0pTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpfSkgZG9lcyBub3QgYCArXG4gICAgICAgICAgICBgbWF0Y2ggdGhlIGV4cGVjdGF0aW9uIG9mIGxheWVyICR7dGhpcy5uYW1lfTogYCArXG4gICAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmJhdGNoSW5wdXRTaGFwZSl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgb3V0cHV0IHNoYXBlKHMpIG9mIGEgbGF5ZXIuXG4gICAqXG4gICAqIE9ubHkgYXBwbGljYWJsZSBpZiB0aGUgbGF5ZXIgaGFzIG9ubHkgb25lIGluYm91bmQgbm9kZSwgb3IgaWYgYWxsIGluYm91bmRcbiAgICogbm9kZXMgaGF2ZSB0aGUgc2FtZSBvdXRwdXQgc2hhcGUuXG4gICAqXG4gICAqIEByZXR1cm5zIE91dHB1dCBzaGFwZSBvciBzaGFwZXMuXG4gICAqIEB0aHJvd3MgQXR0cmlidXRlRXJyb3I6IGlmIHRoZSBsYXllciBpcyBjb25uZWN0ZWQgdG8gbW9yZSB0aGFuIG9uZSBpbmNvbWluZ1xuICAgKiAgIG5vZGVzLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgJ3N1YmhlYWRpbmcnOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBnZXQgb3V0cHV0U2hhcGUoKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaWYgKHRoaXMuaW5ib3VuZE5vZGVzID09IG51bGwgfHwgdGhpcy5pbmJvdW5kTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXG4gICAgICAgICAgYFRoZSBsYXllciAke3RoaXMubmFtZX0gaGFzIG5ldmVyIGJlZW4gY2FsbGVkIGFuZCB0aHVzIGhhcyBubyBgICtcbiAgICAgICAgICBgZGVmaW5lZCBvdXRwdXQgc2hhcGUuYCk7XG4gICAgfVxuICAgIGNvbnN0IGFsbE91dHB1dFNoYXBlczogc3RyaW5nW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgdGhpcy5pbmJvdW5kTm9kZXMpIHtcbiAgICAgIGNvbnN0IHNoYXBlU3RyaW5nID0gSlNPTi5zdHJpbmdpZnkobm9kZS5vdXRwdXRTaGFwZXMpO1xuICAgICAgaWYgKGFsbE91dHB1dFNoYXBlcy5pbmRleE9mKHNoYXBlU3RyaW5nKSA9PT0gLTEpIHtcbiAgICAgICAgYWxsT3V0cHV0U2hhcGVzLnB1c2goc2hhcGVTdHJpbmcpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWxsT3V0cHV0U2hhcGVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGVzID0gdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0U2hhcGVzO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkob3V0cHV0U2hhcGVzKSAmJiBBcnJheS5pc0FycmF5KG91dHB1dFNoYXBlc1swXSkgJiZcbiAgICAgICAgICBvdXRwdXRTaGFwZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHJldHVybiAob3V0cHV0U2hhcGVzIGFzIFNoYXBlW10pWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG91dHB1dFNoYXBlcztcbiAgICAgIH1cblxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgQXR0cmlidXRlRXJyb3IoXG4gICAgICAgICAgYFRoZSBsYXllciAke3RoaXMubmFtZX0gaGFzIG11bHRpcGxlIGluYm91bmQgbm9kZXMgd2l0aCBkaWZmZXJlbnQgYCArXG4gICAgICAgICAgYG91dHB1dCBzaGFwZXMuIEhlbmNlIHRoZSBub3Rpb24gb2YgXCJvdXRwdXQgc2hhcGVcIiBpcyBpbGwtZGVmaW5lZCBgICtcbiAgICAgICAgICBgZm9yIHRoZSBsYXllci5gKTtcbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEltcGxlbWVudCBnZXRPdXRwdXRTaGFwZUF0KCkuXG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENvdW50cyB0aGUgdG90YWwgbnVtYmVyIG9mIG51bWJlcnMgKGUuZy4sIGZsb2F0MzIsIGludDMyKSBpbiB0aGVcbiAgICogd2VpZ2h0cy5cbiAgICpcbiAgICogQHJldHVybnMgQW4gaW50ZWdlciBjb3VudC5cbiAgICogQHRocm93cyBSdW50aW1lRXJyb3I6IElmIHRoZSBsYXllciBpcyBub3QgYnVpbHQgeWV0IChpbiB3aGljaCBjYXNlIGl0c1xuICAgKiAgIHdlaWdodHMgYXJlIG5vdCBkZWZpbmVkIHlldC4pXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCAnc3ViaGVhZGluZyc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGNvdW50UGFyYW1zKCk6IG51bWJlciB7XG4gICAgaWYgKCF0aGlzLmJ1aWx0KSB7XG4gICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFxuICAgICAgICAgIGBZb3UgdHJpZWQgdG8gY2FsbCBjb3VudFBhcmFtcygpIG9uICR7dGhpcy5uYW1lfSwgYCArXG4gICAgICAgICAgYGJ1dCB0aGUgbGF5ZXIgaXMgbm90IGJ1aWx0IHlldC4gQnVpbGQgaXQgZmlyc3QgYnkgY2FsbGluZyBgICtcbiAgICAgICAgICBgYnVpbGQoYmF0Y2hJbnB1dFNoYXBlKS5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHZhcmlhYmxlX3V0aWxzLmNvdW50UGFyYW1zSW5XZWlnaHRzKHRoaXMud2VpZ2h0cyk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyB0aGUgbGF5ZXIgd2VpZ2h0cy5cbiAgICpcbiAgICogTXVzdCBiZSBpbXBsZW1lbnRlZCBvbiBhbGwgbGF5ZXJzIHRoYXQgaGF2ZSB3ZWlnaHRzLlxuICAgKlxuICAgKiBDYWxsZWQgd2hlbiBhcHBseSgpIGlzIGNhbGxlZCB0byBjb25zdHJ1Y3QgdGhlIHdlaWdodHMuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlIEEgYFNoYXBlYCBvciBhcnJheSBvZiBgU2hhcGVgICh1bnVzZWQpLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgJ3N1YmhlYWRpbmcnOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBidWlsZChpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKSB7XG4gICAgdGhpcy5idWlsdCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY3VycmVudCB2YWx1ZXMgb2YgdGhlIHdlaWdodHMgb2YgdGhlIGxheWVyLlxuICAgKlxuICAgKiBAcGFyYW0gdHJhaW5hYmxlT25seSBXaGV0aGVyIHRvIGdldCB0aGUgdmFsdWVzIG9mIG9ubHkgdHJhaW5hYmxlIHdlaWdodHMuXG4gICAqIEByZXR1cm5zIFdlaWdodCB2YWx1ZXMgYXMgYW4gYEFycmF5YCBvZiBgdGYuVGVuc29yYHMuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCAnc3ViaGVhZGluZyc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGdldFdlaWdodHModHJhaW5hYmxlT25seSA9IGZhbHNlKTogVGVuc29yW10ge1xuICAgIHJldHVybiBiYXRjaEdldFZhbHVlKHRyYWluYWJsZU9ubHkgPyB0aGlzLnRyYWluYWJsZVdlaWdodHMgOiB0aGlzLndlaWdodHMpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdlaWdodHMgb2YgdGhlIGxheWVyLCBmcm9tIFRlbnNvcnMuXG4gICAqXG4gICAqIEBwYXJhbSB3ZWlnaHRzIGEgbGlzdCBvZiBUZW5zb3JzLiBUaGUgbnVtYmVyIG9mIGFycmF5cyBhbmQgdGhlaXIgc2hhcGVcbiAgICogICBtdXN0IG1hdGNoIG51bWJlciBvZiB0aGUgZGltZW5zaW9ucyBvZiB0aGUgd2VpZ2h0cyBvZiB0aGUgbGF5ZXIgKGkuZS5cbiAgICogICBpdCBzaG91bGQgbWF0Y2ggdGhlIG91dHB1dCBvZiBgZ2V0V2VpZ2h0c2ApLlxuICAgKlxuICAgKiBAZXhjZXB0aW9uIFZhbHVlRXJyb3IgSWYgdGhlIHByb3ZpZGVkIHdlaWdodHMgbGlzdCBkb2VzIG5vdCBtYXRjaCB0aGVcbiAgICogICBsYXllcidzIHNwZWNpZmljYXRpb25zLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgJ3N1YmhlYWRpbmcnOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBzZXRXZWlnaHRzKHdlaWdodHM6IFRlbnNvcltdKTogdm9pZCB7XG4gICAgdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBwYXJhbXMgPSB0aGlzLndlaWdodHM7XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCAhPT0gd2VpZ2h0cy5sZW5ndGgpIHtcbiAgICAgICAgLy8gVE9ETyhjYWlzKTogUmVzdG9yZSB0aGUgZm9sbG93aW5nIGFuZCB1c2UgYHByb3ZpZGVkV2VpZ2h0c2AsIGluc3RlYWRcbiAgICAgICAgLy8gb2YgYHdlaWdodHNgIGluIHRoZSBlcnJvciBtZXNzYWdlLCBvbmNlIHRoZSBkZWVwbGVhcm4uanMgYnVnIGlzXG4gICAgICAgIC8vIGZpeGVkOiBodHRwczovL2dpdGh1Yi5jb20vUEFJUi1jb2RlL2RlZXBsZWFybmpzL2lzc3Vlcy80OTggY29uc3RcbiAgICAgICAgLy8gcHJvdmlkZWRXZWlnaHRzID0gSlNPTi5zdHJpbmdpZnkod2VpZ2h0cykuc2xpY2UoMCwgNTApO1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBZb3UgY2FsbGVkIHNldFdlaWdodHMod2VpZ2h0cykgb24gbGF5ZXIgXCIke3RoaXMubmFtZX1cIiBgICtcbiAgICAgICAgICAgIGB3aXRoIGEgd2VpZ2h0IGxpc3Qgb2YgbGVuZ3RoICR7d2VpZ2h0cy5sZW5ndGh9LCBgICtcbiAgICAgICAgICAgIGBidXQgdGhlIGxheWVyIHdhcyBleHBlY3RpbmcgJHtwYXJhbXMubGVuZ3RofSB3ZWlnaHRzLiBgICtcbiAgICAgICAgICAgIGBQcm92aWRlZCB3ZWlnaHRzOiAke3dlaWdodHN9Li4uYCk7XG4gICAgICB9XG4gICAgICBpZiAocGFyYW1zLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB3ZWlnaHRWYWx1ZVR1cGxlczogQXJyYXk8W0xheWVyVmFyaWFibGUsIFRlbnNvcl0+ID0gW107XG4gICAgICBjb25zdCBwYXJhbVZhbHVlcyA9IGJhdGNoR2V0VmFsdWUocGFyYW1zKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYW1WYWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3QgcHYgPSBwYXJhbVZhbHVlc1tpXTtcbiAgICAgICAgY29uc3QgcCA9IHBhcmFtc1tpXTtcbiAgICAgICAgY29uc3QgdyA9IHdlaWdodHNbaV07XG4gICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChwdi5zaGFwZSwgdy5zaGFwZSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgYExheWVyIHdlaWdodCBzaGFwZSAke3B2LnNoYXBlfSBgICtcbiAgICAgICAgICAgICAgYG5vdCBjb21wYXRpYmxlIHdpdGggcHJvdmlkZWQgd2VpZ2h0IHNoYXBlICR7dy5zaGFwZX1gKTtcbiAgICAgICAgfVxuICAgICAgICB3ZWlnaHRWYWx1ZVR1cGxlcy5wdXNoKFtwLCB3XSk7XG4gICAgICB9XG4gICAgICBiYXRjaFNldFZhbHVlKHdlaWdodFZhbHVlVHVwbGVzKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBZGRzIGEgd2VpZ2h0IHZhcmlhYmxlIHRvIHRoZSBsYXllci5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiB0aGUgbmV3IHdlaWdodCB2YXJpYWJsZS5cbiAgICogQHBhcmFtIHNoYXBlIFRoZSBzaGFwZSBvZiB0aGUgd2VpZ2h0LlxuICAgKiBAcGFyYW0gZHR5cGUgVGhlIGR0eXBlIG9mIHRoZSB3ZWlnaHQuXG4gICAqIEBwYXJhbSBpbml0aWFsaXplciBBbiBpbml0aWFsaXplciBpbnN0YW5jZS5cbiAgICogQHBhcmFtIHJlZ3VsYXJpemVyIEEgcmVndWxhcml6ZXIgaW5zdGFuY2UuXG4gICAqIEBwYXJhbSB0cmFpbmFibGUgV2hldGhlciB0aGUgd2VpZ2h0IHNob3VsZCBiZSB0cmFpbmVkIHZpYSBiYWNrcHJvcCBvciBub3RcbiAgICogICAoYXNzdW1pbmcgdGhhdCB0aGUgbGF5ZXIgaXRzZWxmIGlzIGFsc28gdHJhaW5hYmxlKS5cbiAgICogQHBhcmFtIGNvbnN0cmFpbnQgQW4gb3B0aW9uYWwgdHJhaW5hYmxlLlxuICAgKiBAcmV0dXJuIFRoZSBjcmVhdGVkIHdlaWdodCB2YXJpYWJsZS5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsICdzdWJoZWFkaW5nJzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgcHJvdGVjdGVkIGFkZFdlaWdodChcbiAgICAgIG5hbWU6IHN0cmluZywgc2hhcGU6IFNoYXBlLCBkdHlwZT86IERhdGFUeXBlLCBpbml0aWFsaXplcj86IEluaXRpYWxpemVyLFxuICAgICAgcmVndWxhcml6ZXI/OiBSZWd1bGFyaXplciwgdHJhaW5hYmxlPzogYm9vbGVhbiwgY29uc3RyYWludD86IENvbnN0cmFpbnQsXG4gICAgICBnZXRJbml0aWFsaXplckZ1bmM/OiBGdW5jdGlvbik6IExheWVyVmFyaWFibGUge1xuICAgIC8vIFJlamVjdCBkdXBsaWNhdGUgd2VpZ2h0IG5hbWVzLlxuICAgIGlmICh0aGlzLl9hZGRlZFdlaWdodE5hbWVzLmluZGV4T2YobmFtZSkgIT09IC0xKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgRHVwbGljYXRlIHdlaWdodCBuYW1lICR7bmFtZX0gZm9yIGxheWVyICR7dGhpcy5uYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLl9hZGRlZFdlaWdodE5hbWVzLnB1c2gobmFtZSk7XG5cbiAgICBpZiAoZHR5cGUgPT0gbnVsbCkge1xuICAgICAgZHR5cGUgPSAnZmxvYXQzMic7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuZmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCkge1xuICAgICAgaW5pdGlhbGl6ZXIgPSBnZXRJbml0aWFsaXplckZ1bmMgIT0gbnVsbCA/IGdldEluaXRpYWxpemVyRnVuYygpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBnZXRJbml0aWFsaXplcignemVyb3MnKTtcbiAgICB9XG4gICAgY29uc3QgaW5pdFZhbHVlID0gaW5pdGlhbGl6ZXIuYXBwbHkoc2hhcGUsIGR0eXBlKTtcbiAgICBjb25zdCB3ZWlnaHQgPVxuICAgICAgICBuZXcgTGF5ZXJWYXJpYWJsZShpbml0VmFsdWUsIGR0eXBlLCBuYW1lLCB0cmFpbmFibGUsIGNvbnN0cmFpbnQpO1xuICAgIGluaXRWYWx1ZS5kaXNwb3NlKCk7XG4gICAgLy8gUmVxdWVzdCBiYWNrZW5kIG5vdCB0byBkaXNwb3NlIHRoZSB3ZWlnaHRzIG9mIHRoZSBtb2RlbCBvbiBzY29wZSgpIGV4aXQuXG4gICAgaWYgKHJlZ3VsYXJpemVyICE9IG51bGwpIHtcbiAgICAgIHRoaXMuYWRkTG9zcygoKSA9PiByZWd1bGFyaXplci5hcHBseSh3ZWlnaHQucmVhZCgpKSk7XG4gICAgfVxuICAgIGlmICh0cmFpbmFibGUgPT0gbnVsbCkge1xuICAgICAgdHJhaW5hYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHRyYWluYWJsZSkge1xuICAgICAgdGhpcy5fdHJhaW5hYmxlV2VpZ2h0cy5wdXNoKHdlaWdodCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuX25vblRyYWluYWJsZVdlaWdodHMucHVzaCh3ZWlnaHQpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0O1xuICB9XG5cbiAgLyoqXG4gICAqIFNldCB0aGUgZmFzdC13ZWlnaHQtaW5pdGlhbGl6YXRpb24gZmxhZy5cbiAgICpcbiAgICogSW4gY2FzZXMgd2hlcmUgdGhlIGluaXRpYWxpemVkIHdlaWdodCB2YWx1ZXMgd2lsbCBiZSBpbW1lZGlhdGVseVxuICAgKiBvdmVyd3JpdHRlbiBieSBsb2FkZWQgd2VpZ2h0IHZhbHVlcyBkdXJpbmcgbW9kZWwgbG9hZGluZywgc2V0dGluZ1xuICAgKiB0aGUgZmxhZyB0byBgdHJ1ZWAgc2F2ZXMgdW5uZWNlc3NhcnkgY2FsbHMgdG8gcG90ZW50aWFsbHkgZXhwZW5zaXZlXG4gICAqIGluaXRpYWxpemVycyBhbmQgc3BlZWRzIHVwIHRoZSBsb2FkaW5nIHByb2Nlc3MuXG4gICAqXG4gICAqIEBwYXJhbSB2YWx1ZSBUYXJnZXQgdmFsdWUgb2YgdGhlIGZsYWcuXG4gICAqL1xuICBzZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgdGhpcy5mYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkID0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkIGxvc3NlcyB0byB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIFRoZSBsb3NzIG1heSBwb3RlbnRpb25hbGx5IGJlIGNvbmRpdGlvbmFsIG9uIHNvbWUgaW5wdXRzIHRlbnNvcnMsXG4gICAqIGZvciBpbnN0YW5jZSBhY3Rpdml0eSBsb3NzZXMgYXJlIGNvbmRpdGlvbmFsIG9uIHRoZSBsYXllcidzIGlucHV0cy5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsICdzdWJoZWFkaW5nJzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgYWRkTG9zcyhsb3NzZXM6IFJlZ3VsYXJpemVyRm58UmVndWxhcml6ZXJGbltdKTogdm9pZCB7XG4gICAgaWYgKGxvc3NlcyA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkobG9zc2VzKSAmJiBsb3NzZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIFVwZGF0ZSB0aGlzLmxvc3Nlc1xuICAgIGxvc3NlcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KGxvc3Nlcyk7XG4gICAgaWYgKHRoaXMuX2xvc3NlcyAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2xvc3NlcyAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5sb3NzZXMucHVzaCguLi5sb3NzZXMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgb3V0cHV0IHNoYXBlIG9mIHRoZSBsYXllci5cbiAgICpcbiAgICogQXNzdW1lcyB0aGF0IHRoZSBsYXllciB3aWxsIGJlIGJ1aWx0IHRvIG1hdGNoIHRoYXQgaW5wdXQgc2hhcGUgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlIEEgc2hhcGUgKHR1cGxlIG9mIGludGVnZXJzKSBvciBhIGxpc3Qgb2Ygc2hhcGUgdHVwbGVzXG4gICAqICAgKG9uZSBwZXIgb3V0cHV0IHRlbnNvciBvZiB0aGUgbGF5ZXIpLiBTaGFwZSB0dXBsZXMgY2FuIGluY2x1ZGUgbnVsbCBmb3JcbiAgICogICBmcmVlIGRpbWVuc2lvbnMsIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsICdzdWJoZWFkaW5nJzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiBTaGFwZXxTaGFwZVtdIHtcbiAgICByZXR1cm4gaW5wdXRTaGFwZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhbiBvdXRwdXQgbWFzayB0ZW5zb3IuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dHMgVGVuc29yIG9yIGxpc3Qgb2YgdGVuc29ycy5cbiAgICogQHBhcmFtIG1hc2sgVGVuc29yIG9yIGxpc3Qgb2YgdGVuc29ycy5cbiAgICpcbiAgICogQHJldHVybiBudWxsIG9yIGEgdGVuc29yIChvciBsaXN0IG9mIHRlbnNvcnMsIG9uZSBwZXIgb3V0cHV0IHRlbnNvciBvZiB0aGVcbiAgICogbGF5ZXIpLlxuICAgKi9cbiAgY29tcHV0ZU1hc2soaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIG1hc2s/OiBUZW5zb3J8VGVuc29yW10pOiBUZW5zb3JcbiAgICAgIHxUZW5zb3JbXSB7XG4gICAgaWYgKCF0aGlzLnN1cHBvcnRzTWFza2luZykge1xuICAgICAgaWYgKG1hc2sgIT0gbnVsbCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXNrKSkge1xuICAgICAgICAgIG1hc2suZm9yRWFjaChtYXNrRWxlbWVudCA9PiB7XG4gICAgICAgICAgICBpZiAobWFza0VsZW1lbnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICAgICAgYExheWVyICR7dGhpcy5uYW1lfSBkb2VzIG5vdCBzdXBwb3J0IG1hc2tpbmcsIGAgK1xuICAgICAgICAgICAgICAgICAgJ2J1dCB3YXMgcGFzc2VkIGFuIGlucHV0TWFzay4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgICBgTGF5ZXIgJHt0aGlzLm5hbWV9IGRvZXMgbm90IHN1cHBvcnQgbWFza2luZywgYCArXG4gICAgICAgICAgICAgICdidXQgd2FzIHBhc3NlZCBhbiBpbnB1dE1hc2suJyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIG1hc2tpbmcgbm90IGV4cGxpY2l0bHkgc3VwcG9ydGVkOiByZXR1cm4gbnVsbCBhcyBtYXNrXG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgLy8gaWYgbWFza2luZyBpcyBleHBsaWN0bHkgc3VwcG9ydGVkLCBieSBkZWZhdWx0XG4gICAgLy8gY2Fycnkgb3ZlciB0aGUgaW5wdXQgbWFza1xuICAgIHJldHVybiBtYXNrO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsIG1ldGhvZCB0byBjcmVhdGUgYW4gaW5ib3VuZCBub2RlIGZvciB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dFRlbnNvcnMgTGlzdCBvZiBpbnB1dCB0ZW5zb3JzLlxuICAgKiBAcGFyYW0gb3V0cHV0VGVuc29ycyBMaXN0IG9mIG91dHB1dCB0ZW5zb3JzLlxuICAgKiBAcGFyYW0gaW5wdXRNYXNrcyBMaXN0IG9mIGlucHV0IG1hc2tzIChhIG1hc2sgY2FuIGJlIGEgdGVuc29yLCBvciBudWxsKS5cbiAgICogQHBhcmFtIG91dHB1dE1hc2tzIExpc3Qgb2Ygb3V0cHV0IG1hc2tzIChhIG1hc2sgY2FuIGJlIGEgdGVuc29yLCBvciBudWxsKS5cbiAgICogQHBhcmFtIGlucHV0U2hhcGVzIExpc3Qgb2YgaW5wdXQgc2hhcGUgdHVwbGVzLlxuICAgKiBAcGFyYW0gb3V0cHV0U2hhcGVzIExpc3Qgb2Ygb3V0cHV0IHNoYXBlIHR1cGxlcy5cbiAgICogQHBhcmFtIGt3YXJncyBEaWN0aW9uYXJ5IG9mIGtleXdvcmQgYXJndW1lbnRzIHRoYXQgd2VyZSBwYXNzZWQgdG8gdGhlXG4gICAqICAgYGNhbGxgIG1ldGhvZCBvZiB0aGUgbGF5ZXIgYXQgdGhlIGNhbGwgdGhhdCBjcmVhdGVkIHRoZSBub2RlLlxuICAgKi9cbiAgcHJpdmF0ZSBhZGRJbmJvdW5kTm9kZShcbiAgICAgIGlucHV0VGVuc29yczogU3ltYm9saWNUZW5zb3J8U3ltYm9saWNUZW5zb3JbXSxcbiAgICAgIG91dHB1dFRlbnNvcnM6IFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW10sXG4gICAgICBpbnB1dE1hc2tzOiBUZW5zb3J8VGVuc29yW10sIG91dHB1dE1hc2tzOiBUZW5zb3J8VGVuc29yW10sXG4gICAgICBpbnB1dFNoYXBlczogU2hhcGV8U2hhcGVbXSwgb3V0cHV0U2hhcGVzOiBTaGFwZXxTaGFwZVtdLFxuICAgICAga3dhcmdzOiB7fSA9IG51bGwpOiB2b2lkIHtcbiAgICBjb25zdCBpbnB1dFRlbnNvckxpc3Q6IFN5bWJvbGljVGVuc29yW10gPVxuICAgICAgICBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dFRlbnNvcnMpO1xuICAgIG91dHB1dFRlbnNvcnMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChvdXRwdXRUZW5zb3JzKTtcbiAgICBpbnB1dE1hc2tzID0gZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRNYXNrcyk7XG4gICAgb3V0cHV0TWFza3MgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChvdXRwdXRNYXNrcyk7XG4gICAgaW5wdXRTaGFwZXMgPSB0eXBlc191dGlscy5ub3JtYWxpemVTaGFwZUxpc3QoaW5wdXRTaGFwZXMpO1xuICAgIG91dHB1dFNoYXBlcyA9IHR5cGVzX3V0aWxzLm5vcm1hbGl6ZVNoYXBlTGlzdChvdXRwdXRTaGFwZXMpO1xuXG4gICAgLy8gQ29sbGVjdCBpbnB1dCB0ZW5zb3IocykgY29vcmRpbmF0ZXMuXG4gICAgY29uc3QgaW5ib3VuZExheWVyczogTGF5ZXJbXSA9IFtdO1xuICAgIGNvbnN0IG5vZGVJbmRpY2VzOiBudW1iZXJbXSA9IFtdO1xuICAgIGNvbnN0IHRlbnNvckluZGljZXM6IG51bWJlcltdID0gW107XG4gICAgZm9yIChjb25zdCB4IG9mIGlucHV0VGVuc29yTGlzdCkge1xuICAgICAgLypcbiAgICAgICAqIFRPRE8obWljaGFlbHRlcnJ5KTogS2VyYXMgYWRkcyB0aGlzIHZhbHVlIHRvIHRlbnNvcnM7IGl0J3Mgbm90XG4gICAgICAgKiBjbGVhciB3aGV0aGVyIHdlJ2xsIHVzZSB0aGlzIG9yIG5vdC5cbiAgICAgICAqL1xuICAgICAgaW5ib3VuZExheWVycy5wdXNoKHguc291cmNlTGF5ZXIpO1xuICAgICAgbm9kZUluZGljZXMucHVzaCh4Lm5vZGVJbmRleCk7XG4gICAgICB0ZW5zb3JJbmRpY2VzLnB1c2goeC50ZW5zb3JJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gQ3JlYXRlIG5vZGUsIGFkZCBpdCB0byBpbmJvdW5kIG5vZGVzLlxuICAgIC8vIChUaGlzIGNhbGwgaGFzIHNpZGUgZWZmZWN0cy4pXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgbmV3IE5vZGUoXG4gICAgICAgIHtcbiAgICAgICAgICBvdXRib3VuZExheWVyOiB0aGlzLFxuICAgICAgICAgIGluYm91bmRMYXllcnMsXG4gICAgICAgICAgbm9kZUluZGljZXMsXG4gICAgICAgICAgdGVuc29ySW5kaWNlcyxcbiAgICAgICAgICBpbnB1dFRlbnNvcnM6IGlucHV0VGVuc29yTGlzdCxcbiAgICAgICAgICBvdXRwdXRUZW5zb3JzLFxuICAgICAgICAgIGlucHV0TWFza3MsXG4gICAgICAgICAgb3V0cHV0TWFza3MsXG4gICAgICAgICAgaW5wdXRTaGFwZXMsXG4gICAgICAgICAgb3V0cHV0U2hhcGVzXG4gICAgICAgIH0sXG4gICAgICAgIGt3YXJncyk7XG5cbiAgICAvLyBVcGRhdGUgdGVuc29yIGhpc3RvcnlcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFRlbnNvcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5OiBfdXNlc19sZWFybmluZ19waGFzZSBub3QgdHJhY2tlZC5cbiAgICAgIG91dHB1dFRlbnNvcnNbaV0uc291cmNlTGF5ZXIgPSB0aGlzO1xuICAgICAgb3V0cHV0VGVuc29yc1tpXS5ub2RlSW5kZXggPSB0aGlzLmluYm91bmROb2Rlcy5sZW5ndGggLSAxO1xuICAgICAgb3V0cHV0VGVuc29yc1tpXS50ZW5zb3JJbmRleCA9IGk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGNvbmZpZyBvZiB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIEEgbGF5ZXIgY29uZmlnIGlzIGEgVFMgZGljdGlvbmFyeSAoc2VyaWFsaXphYmxlKVxuICAgKiBjb250YWluaW5nIHRoZSBjb25maWd1cmF0aW9uIG9mIGEgbGF5ZXIuXG4gICAqIFRoZSBzYW1lIGxheWVyIGNhbiBiZSByZWluc3RhbnRpYXRlZCBsYXRlclxuICAgKiAod2l0aG91dCBpdHMgdHJhaW5lZCB3ZWlnaHRzKSBmcm9tIHRoaXMgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogVGhlIGNvbmZpZyBvZiBhIGxheWVyIGRvZXMgbm90IGluY2x1ZGUgY29ubmVjdGl2aXR5XG4gICAqIGluZm9ybWF0aW9uLCBub3IgdGhlIGxheWVyIGNsYXNzIG5hbWUuICBUaGVzZSBhcmUgaGFuZGxlZFxuICAgKiBieSAnQ29udGFpbmVyJyAob25lIGxheWVyIG9mIGFic3RyYWN0aW9uIGFib3ZlKS5cbiAgICpcbiAgICogUG9ydGluZyBOb3RlOiBUaGUgVFMgZGljdGlvbmFyeSBmb2xsb3dzIFRTIG5hbWluZyBzdGFuZHJkcyBmb3JcbiAgICoga2V5cywgYW5kIHVzZXMgdGZqcy1sYXllcnMgdHlwZS1zYWZlIEVudW1zLiAgU2VyaWFsaXphdGlvbiBtZXRob2RzXG4gICAqIHNob3VsZCB1c2UgYSBoZWxwZXIgZnVuY3Rpb24gdG8gY29udmVydCB0byB0aGUgcHl0aG9uaWMgc3RvcmFnZVxuICAgKiBzdGFuZGFyZC4gKHNlZSBzZXJpYWxpemF0aW9uX3V0aWxzLmNvbnZlcnRUc1RvUHl0aG9uaWMpXG4gICAqXG4gICAqIEByZXR1cm5zIFRTIGRpY3Rpb25hcnkgb2YgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsICdzdWJoZWFkaW5nJzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnOlxuICAgICAgICBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7bmFtZTogdGhpcy5uYW1lLCB0cmFpbmFibGU6IHRoaXMudHJhaW5hYmxlfTtcbiAgICBpZiAodGhpcy5iYXRjaElucHV0U2hhcGUgIT0gbnVsbCkge1xuICAgICAgY29uZmlnWydiYXRjaElucHV0U2hhcGUnXSA9IHRoaXMuYmF0Y2hJbnB1dFNoYXBlO1xuICAgIH1cbiAgICBpZiAodGhpcy5kdHlwZSAhPSBudWxsKSB7XG4gICAgICBjb25maWdbJ2R0eXBlJ10gPSB0aGlzLmR0eXBlO1xuICAgIH1cbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIERpc3Bvc2UgdGhlIHdlaWdodCB2YXJpYWJsZXMgdGhhdCB0aGlzIExheWVyIGluc3RhbmNlIGhvbGRzLlxuICAgKlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBOdW1iZXIgb2YgZGlzcG9zZWQgdmFyaWFibGVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGRpc3Bvc2VXZWlnaHRzKCk6IG51bWJlciB7XG4gICAgdGhpcy53ZWlnaHRzLmZvckVhY2god2VpZ2h0ID0+IHdlaWdodC5kaXNwb3NlKCkpO1xuICAgIHJldHVybiB0aGlzLndlaWdodHMubGVuZ3RoO1xuICB9XG5cbiAgcHJvdGVjdGVkIGFzc2VydE5vdERpc3Bvc2VkKCkge1xuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBMYXllciAnJHt0aGlzLm5hbWV9JyBpcyBhbHJlYWR5IGRpc3Bvc2VkLmApO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBBdHRlbXB0IHRvIGRpc3Bvc2UgbGF5ZXIncyB3ZWlnaHRzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkZWNyZWFzZSB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoZSBMYXllciBvYmplY3QgYnkgMS5cbiAgICpcbiAgICogQSBMYXllciBpcyByZWZlcmVuY2UtY291bnRlZC4gSXRzIHJlZmVyZW5jZSBjb3VudCBpcyBpbmNyZW1lbnRlZCBieSAxXG4gICAqIHRoZSBmaXJzdCBpdGVtIGl0cyBgYXBwbHkoKWAgbWV0aG9kIGlzIGNhbGxlZCBhbmQgd2hlbiBpdCBiZWNvbWVzIGEgcGFydFxuICAgKiBvZiBhIG5ldyBgTm9kZWAgKHRocm91Z2ggY2FsbGluZyB0aGUgYGFwcGx5KClgKSBtZXRob2Qgb24gYVxuICAgKiBgdGYuU3ltYm9saWNUZW5zb3JgKS5cbiAgICpcbiAgICogSWYgdGhlIHJlZmVyZW5jZSBjb3VudCBvZiBhIExheWVyIGJlY29tZXMgMCwgYWxsIHRoZSB3ZWlnaHRzIHdpbGwgYmVcbiAgICogZGlzcG9zZWQgYW5kIHRoZSB1bmRlcmx5aW5nIG1lbW9yeSAoZS5nLiwgdGhlIHRleHR1cmVzIGFsbG9jYXRlZCBpbiBXZWJHTClcbiAgICogd2lsbCBiZSBmcmVlZC5cbiAgICpcbiAgICogTm90ZTogSWYgdGhlIHJlZmVyZW5jZSBjb3VudCBpcyBncmVhdGVyIHRoYW4gMCBhZnRlciB0aGUgZGVjcmVtZW50LCB0aGVcbiAgICogd2VpZ2h0cyBvZiB0aGUgTGF5ZXIgd2lsbCAqbm90KiBiZSBkaXNwb3NlZC5cbiAgICpcbiAgICogQWZ0ZXIgYSBMYXllciBpcyBkaXNwb3NlZCwgaXQgY2Fubm90IGJlIHVzZWQgaW4gY2FsbHMgc3VjaCBhcyBgYXBwbHkoKWAsXG4gICAqIGBnZXRXZWlnaHRzKClgIG9yIGBzZXRXZWlnaHRzKClgIGFueW1vcmUuXG4gICAqXG4gICAqIEByZXR1cm5zIEEgRGlzcG9zZVJlc3VsdCBPYmplY3Qgd2l0aCB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgICogICAtIHJlZkNvdW50QWZ0ZXJEaXNwb3NlOiBUaGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoZSBDb250YWluZXIgYWZ0ZXIgdGhpc1xuICAgKiAgICAgYGRpc3Bvc2UoKWAgY2FsbC5cbiAgICogICAtIG51bURpc3Bvc2VkVmFyaWFibGVzOiBOdW1iZXIgb2YgYHRmLlZhcmlhYmxlYHMgKGkuZS4sIHdlaWdodHMpIGRpc3Bvc2VkXG4gICAqICAgICBkdXJpbmcgdGhpcyBgZGlzcG9zZSgpYCBjYWxsLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxheWVyIGlzIG5vdCBidWlsdCB5ZXQsIG9yIGlmIHRoZSBsYXllciBoYXMgYWxyZWFkeVxuICAgKiAgIGJlZW4gZGlzcG9zZWQuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCAnc3ViaGVhZGluZyc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGRpc3Bvc2UoKTogRGlzcG9zZVJlc3VsdCB7XG4gICAgaWYgKCF0aGlzLmJ1aWx0KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYENhbm5vdCBkaXNwb3NlIExheWVyICR7dGhpcy5uYW1lfSBiZWNhdXNlIGl0IGhhcyBub3QgYmVlbiBgICtcbiAgICAgICAgICBgYnVpbHQgeWV0LmApO1xuICAgIH1cblxuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIGBDYW5ub3QgZGlzcG9zZSBMYXllciAke3RoaXMubmFtZX0gYmVjYXVzZSBpdCBoYXMgbm90IGJlZW4gdXNlZCBgICtcbiAgICAgICAgICBgeWV0LmApO1xuICAgIH1cblxuICAgIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTtcblxuICAgIGxldCBudW1EaXNwb3NlZFZhcmlhYmxlcyA9IDA7XG4gICAgaWYgKC0tdGhpcy5fcmVmQ291bnQgPT09IDApIHtcbiAgICAgIG51bURpc3Bvc2VkVmFyaWFibGVzID0gdGhpcy5kaXNwb3NlV2VpZ2h0cygpO1xuICAgIH1cblxuICAgIHJldHVybiB7cmVmQ291bnRBZnRlckRpc3Bvc2U6IHRoaXMuX3JlZkNvdW50LCBudW1EaXNwb3NlZFZhcmlhYmxlc307XG4gIH1cbn1cblxuLyoqXG4gKiBDb2xsZWN0cyB0aGUgaW5wdXQgc2hhcGUocykgb2YgYSBsaXN0IG9mIGB0Zi5UZW5zb3JgcyBvclxuICogYHRmLlN5bWJvbGljVGVuc29yYHMuXG4gKlxuICogVE9ETyhtaWNoYWVsdGVycnkpOiBVcGRhdGUgUHlLZXJhcyBkb2NzIChiYWNrcG9ydCkuXG4gKlxuICogQHBhcmFtIGlucHV0VGVuc29ycyBMaXN0IG9mIGlucHV0IHRlbnNvcnMgKG9yIHNpbmdsZSBpbnB1dCB0ZW5zb3IpLlxuICpcbiAqIEByZXR1cm4gTGlzdCBvZiBzaGFwZSB0dXBsZXMgKG9yIHNpbmdsZSB0dXBsZSksIG9uZSB0dXBsZSBwZXIgaW5wdXQuXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3RJbnB1dFNoYXBlKGlucHV0VGVuc29yczogU3ltYm9saWNUZW5zb3J8U3ltYm9saWNUZW5zb3JbXXxUZW5zb3J8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICBUZW5zb3JbXSk6IFNoYXBlfFNoYXBlW10ge1xuICBpbnB1dFRlbnNvcnMgPVxuICAgICAgZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRUZW5zb3JzKSBhcyBTeW1ib2xpY1RlbnNvcltdIHwgVGVuc29yW107XG4gIGNvbnN0IHNoYXBlczogU2hhcGVbXSA9IFtdO1xuICBmb3IgKGNvbnN0IHggb2YgaW5wdXRUZW5zb3JzKSB7XG4gICAgc2hhcGVzLnB1c2goeC5zaGFwZSk7XG4gIH1cbiAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShzaGFwZXMpO1xufVxuXG4vKipcbiAqIEd1ZXNzZXMgb3V0cHV0IGR0eXBlIGJhc2VkIG9uIGlucHV0cy5cbiAqXG4gKiBBdCBwcmVzZW50LCBqdXN0IHJldHVybnMgJ2Zsb2F0MzInIGZvciBhbnkgaW5wdXQuXG4gKlxuICogQHBhcmFtIGlucHV0VGVuc29ycyBMaXN0IG9mIGlucHV0IHRlbnNvcnMgKG9yIHNpbmdsZSBpbnB1dCB0ZW5zb3IpLlxuICpcbiAqIEByZXR1cm4gVGhlIGd1ZXNzZWQgRFR5cGUuIEF0IHByZXNlbnQsIGFsd2F5cyByZXR1cm5zICdmbG9hdDMyJy5cbiAqL1xuZnVuY3Rpb24gZ3Vlc3NPdXRwdXREVHlwZShpbnB1dFRlbnNvcnM6IFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW118VGVuc29yfFxuICAgICAgICAgICAgICAgICAgICAgICAgICBUZW5zb3JbXSk6IERhdGFUeXBlIHtcbiAgcmV0dXJuICdmbG9hdDMyJztcbn1cblxuLyoqXG4gKiBSZXR1cm5zIHRoZSBsaXN0IG9mIGlucHV0IHRlbnNvcnMgbmVjZXNzYXJ5IHRvIGNvbXB1dGUgYHRlbnNvcmAuXG4gKlxuICogT3V0cHV0IHdpbGwgYWx3YXlzIGJlIGEgbGlzdCBvZiB0ZW5zb3JzIChwb3RlbnRpYWxseSB3aXRoIDEgZWxlbWVudCkuXG4gKlxuICogQHBhcmFtIHRlbnNvciBUaGUgdGVuc29yIHRvIHN0YXJ0IGZyb20uXG4gKiBAcGFyYW0gbGF5ZXIgT3JpZ2luIGxheWVyIG9mIHRoZSB0ZW5zb3IuXG4gKiBAcGFyYW0gbm9kZUluZGV4IE9yaWdpbiBub2RlIGluZGV4IG9mIHRoZSB0ZW5zb3IuXG4gKlxuICogQHJldHVybiBBcnJheSBvZiBpbnB1dCB0ZW5zb3JzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0U291cmNlSW5wdXRzKFxuICAgIHRlbnNvcjogU3ltYm9saWNUZW5zb3IsIGxheWVyPzogTGF5ZXIsXG4gICAgbm9kZUluZGV4PzogbnVtYmVyKTogU3ltYm9saWNUZW5zb3JbXSB7XG4gIGlmIChsYXllciA9PSBudWxsIHx8IChub2RlSW5kZXggIT0gbnVsbCAmJiBub2RlSW5kZXggPiAwKSkge1xuICAgIGxheWVyID0gdGVuc29yLnNvdXJjZUxheWVyO1xuICAgIG5vZGVJbmRleCA9IHRlbnNvci5ub2RlSW5kZXg7XG4gIH1cbiAgaWYgKGxheWVyLmluYm91bmROb2Rlcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW3RlbnNvcl07XG4gIH0gZWxzZSB7XG4gICAgY29uc3Qgbm9kZSA9IGxheWVyLmluYm91bmROb2Rlc1tub2RlSW5kZXhdO1xuICAgIGlmIChub2RlLmluYm91bmRMYXllcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gbm9kZS5pbnB1dFRlbnNvcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHNvdXJjZVRlbnNvcnM6IFN5bWJvbGljVGVuc29yW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IHggPSBub2RlLmlucHV0VGVuc29yc1tpXTtcbiAgICAgICAgY29uc3QgbGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbaV07XG4gICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGUubm9kZUluZGljZXNbaV07XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU291cmNlcyA9IGdldFNvdXJjZUlucHV0cyh4LCBsYXllciwgbm9kZUluZGV4KTtcbiAgICAgICAgLy8gQXZvaWQgaW5wdXQgcmVkdW5kYW5jeS5cbiAgICAgICAgZm9yIChjb25zdCB4IG9mIHByZXZpb3VzU291cmNlcykge1xuICAgICAgICAgIGlmIChzb3VyY2VUZW5zb3JzLmluZGV4T2YoeCkgPT09IC0xKSB7XG4gICAgICAgICAgICBzb3VyY2VUZW5zb3JzLnB1c2goeCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gc291cmNlVGVuc29ycztcbiAgICB9XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { ValueError } from '../errors';\nimport { Layer, Node, SymbolicTensor } from './topology';\nexport class InputLayer extends Layer {\n    constructor(args) {\n        super({\n            dtype: args.dtype,\n            name: args.name != null ? args.name : getUid('input').toString()\n        });\n        // Normalize config.batchSize and config.sparse\n        if (args.batchSize == null) {\n            args.batchSize = null;\n        }\n        if (args.sparse == null) {\n            args.sparse = false;\n        }\n        this.trainable = false;\n        this.built = true;\n        this.sparse = args.sparse;\n        if (args.inputShape != null && args.batchInputShape != null) {\n            throw new ValueError('Only provide the inputShape OR ' +\n                'batchInputShape argument to inputLayer, not both at the same time.');\n        }\n        let batchInputShape = args.batchInputShape;\n        if (batchInputShape == null) {\n            if (args.inputShape == null) {\n                throw new ValueError('An InputLayer should be passed either a ' +\n                    '`batchInputShape` or an `inputShape`.');\n            }\n            else {\n                batchInputShape = [args.batchSize].concat(args.inputShape);\n            }\n        }\n        else {\n            // TODO(michaelterry): Backport to PyKeras\n            if (args.batchSize != null) {\n                throw new ValueError('Cannot specify batchSize if batchInputShape is ' +\n                    'specified when creating an InputLayer.');\n            }\n        }\n        const dtype = args.dtype || 'float32';\n        this.batchInputShape = batchInputShape;\n        this.dtype = dtype;\n        // TODO(michaelterry): Backport this to PyKeras?\n        this.inputSpec = [{ shape: batchInputShape }];\n        const inputTensor = new SymbolicTensor(this.dtype, this.batchInputShape, this, [], {}, this.name);\n        inputTensor.nodeIndex = 0;\n        inputTensor.tensorIndex = 0;\n        // Create an input node to add to this.outboundNode.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new Node({\n            outboundLayer: this,\n            inboundLayers: [],\n            nodeIndices: [],\n            tensorIndices: [],\n            inputTensors: [inputTensor],\n            outputTensors: [inputTensor],\n            inputMasks: [null],\n            outputMasks: [null],\n            inputShapes: [batchInputShape],\n            outputShapes: [batchInputShape]\n        });\n    }\n    apply(inputs, kwargs) {\n        throw new ValueError('Cannot pass any input to an ' +\n            `InputLayer's apply() method. InputLayer name: ${this.name}`);\n    }\n    dispose() {\n        // dispose() for InputLayer is overridden as no-op.\n        return { refCountAfterDispose: this._refCount, numDisposedVariables: 0 };\n    }\n    getConfig() {\n        return {\n            batchInputShape: this.batchInputShape,\n            dtype: this.dtype,\n            sparse: this.sparse,\n            name: this.name\n        };\n    }\n}\n/** @nocollapse */\nInputLayer.className = 'InputLayer';\nserialization.registerClass(InputLayer);\nexport function Input(config) {\n    if (config.batchShape == null && config.shape == null) {\n        throw new Error('Please provide to Input either a `shape`' +\n            ' or a `batchShape` argument. Note that ' +\n            '`shape` does not include the batch ' +\n            'dimension.');\n    }\n    if (config.batchShape != null && config.shape != null) {\n        // TODO(michaelterry): Backport to PyKeras.\n        throw new ValueError('Please provide either a `shape` or `batchShape` ' +\n            'argument to Input, but not both.');\n    }\n    let batchShape = config.batchShape;\n    if (config.shape != null && batchShape == null) {\n        batchShape = [null].concat(config.shape);\n    }\n    let dtype = config.dtype;\n    if (dtype == null) {\n        dtype = 'float32';\n    }\n    const inputLayer = new InputLayer({\n        batchInputShape: batchShape,\n        name: config.name,\n        dtype,\n        sparse: config.sparse\n    });\n    const outputs = inputLayer.inboundNodes[0].outputTensors;\n    return outputs[0];\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5wdXRfbGF5ZXIuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvZW5naW5lL2lucHV0X2xheWVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFXLGFBQWEsRUFBUyxNQUFNLHVCQUF1QixDQUFDO0FBRXRFLE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUN4QyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBSXJDLE9BQU8sRUFBZ0IsS0FBSyxFQUFFLElBQUksRUFBRSxjQUFjLEVBQUMsTUFBTSxZQUFZLENBQUM7QUEyQnRFLE1BQU0sT0FBTyxVQUFXLFNBQVEsS0FBSztJQUluQyxZQUFZLElBQW9CO1FBQzlCLEtBQUssQ0FBQztZQUNKLEtBQUssRUFBRSxJQUFJLENBQUMsS0FBSztZQUNqQixJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUksSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQyxRQUFRLEVBQUU7U0FDakUsQ0FBQyxDQUFDO1FBQ0gsK0NBQStDO1FBQy9DLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLEVBQUU7WUFDMUIsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUM7U0FDdkI7UUFDRCxJQUFJLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxFQUFFO1lBQ3ZCLElBQUksQ0FBQyxNQUFNLEdBQUcsS0FBSyxDQUFDO1NBQ3JCO1FBRUQsSUFBSSxDQUFDLFNBQVMsR0FBRyxLQUFLLENBQUM7UUFDdkIsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxDQUFDLE1BQU0sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDO1FBRTFCLElBQUksSUFBSSxDQUFDLFVB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QyxVQUFVLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO1FBQ3JELE1BQU0sSUFBSSxLQUFLLENBQ1gsMENBQTBDO1lBQzFDLHlDQUF5QztZQUN6QyxxQ0FBcUM7WUFDckMsWUFBWSxDQUFDLENBQUM7S0FDbkI7SUFDRCxJQUFJLE1BQU0sQ0FBQyxVQUFVLElBQUksSUFBSSxJQUFJLE1BQU0sQ0FBQyxLQUFLLElBQUksSUFBSSxFQUFFO1FBQ3JELDJDQUEyQztRQUMzQyxNQUFNLElBQUksVUFBVSxDQUNoQixrREFBa0Q7WUFDbEQsa0NBQWtDLENBQUMsQ0FBQztLQUN6QztJQUNELElBQUksVUFBVSxHQUFHLE1BQU0sQ0FBQyxVQUFVLENBQUM7SUFDbkMsSUFBSSxNQUFNLENBQUMsS0FBSyxJQUFJLElBQUksSUFBSSxVQUFVLElBQUksSUFBSSxFQUFFO1FBQzlDLFVBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLE1BQU0sQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLENBQUM7S0FDMUM7SUFFRCxJQUFJLEtBQUssR0FBRyxNQUFNLENBQUMsS0FBSyxDQUFDO0lBQ3pCLElBQUksS0FBSyxJQUFJLElBQUksRUFBRTtRQUNqQixLQUFLLEdBQUcsU0FBUyxDQUFDO0tBQ25CO0lBRUQsTUFBTSxVQUFVLEdBQUcsSUFBSSxVQUFVLENBQUM7UUFDaEMsZUFBZSxFQUFFLFVBQVU7UUFDM0IsSUFBSSxFQUFFLE1BQU0sQ0FBQyxJQUFJO1FBQ2pCLEtBQUs7UUFDTCxNQUFNLEVBQUUsTUFBTSxDQUFDLE1BQU07S0FDdEIsQ0FBQyxDQUFDO0lBRUgsTUFBTSxPQUFPLEdBQUcsVUFBVSxDQUFDLFlBQVksQ0FBQyxDQUFDLENBQUMsQ0FBQyxhQUFhLENBQUM7SUFDekQsT0FBTyxPQUFPLENBQUMsQ0FBQyxDQUFDLENBQUM7QUFDcEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7RGF0YVR5cGUsIHNlcmlhbGl6YXRpb24sIFRlbnNvcn0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtnZXRVaWR9IGZyb20gJy4uL2JhY2tlbmQvc3RhdGUnO1xuaW1wb3J0IHtWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge0t3YXJnc30gZnJvbSAnLi4vdHlwZXMnO1xuXG5pbXBvcnQge0Rpc3Bvc2VSZXN1bHQsIExheWVyLCBOb2RlLCBTeW1ib2xpY1RlbnNvcn0gZnJvbSAnLi90b3BvbG9neSc7XG5cbi8qKlxuICogQ29uc3RydWN0b3IgYXJndW1lbnRzIGZvciBJbnB1dExheWVyLlxuICpcbiAqIE5vdGU6IFlvdSBzaG91bGQgcHJvdmlkZSBvbmx5IGlucHV0U2hhcGUgb3IgYmF0Y2hJbnB1dFNoYXBlIChub3QgYm90aCkuXG4gKiBJZiBvbmx5IGlucHV0U2hhcGUgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIGJhdGNoSW5wdXRTaGFwZSBpcyBkZXRlcm1pbmVkIGJ5XG4gKiB0aGUgYmF0Y2hTaXplIGFyZ3VtZW50IGFuZCB0aGUgaW5wdXRTaGFwZTogW2JhdGNoU2l6ZV0uY29uY2F0KGlucHV0U2hhcGUpLlxuICovXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgSW5wdXRMYXllckFyZ3Mge1xuICAvKiogSW5wdXQgc2hhcGUsIG5vdCBpbmNsdWRpbmcgdGhlIGJhdGNoIGF4aXMuICovXG4gIGlucHV0U2hhcGU/OiBTaGFwZTtcbiAgLyoqIE9wdGlvbmFsIGlucHV0IGJhdGNoIHNpemUgKGludGVnZXIgb3IgbnVsbCkuICovXG4gIGJhdGNoU2l6ZT86IG51bWJlcjtcbiAgLyoqIEJhdGNoIGlucHV0IHNoYXBlLCBpbmNsdWRpbmcgdGhlIGJhdGNoIGF4aXMuICovXG4gIGJhdGNoSW5wdXRTaGFwZT86IFNoYXBlO1xuICAvKiogRGF0YXR5cGUgb2YgdGhlIGlucHV0LiAgKi9cbiAgZHR5cGU/OiBEYXRhVHlwZTtcbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIHBsYWNlaG9sZGVyIGNyZWF0ZWQgaXMgbWVhbnQgdG8gYmUgc3BhcnNlLlxuICAgKi9cbiAgc3BhcnNlPzogYm9vbGVhbjsgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogTm90IGNsZWFyIHdoZXRoZXIgd2UnbGwgbmVlZCB0aGlzLlxuXG4gIC8qKiBOYW1lIG9mIHRoZSBsYXllci4gKi9cbiAgbmFtZT86IHN0cmluZztcbn1cblxuZXhwb3J0IGNsYXNzIElucHV0TGF5ZXIgZXh0ZW5kcyBMYXllciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ0lucHV0TGF5ZXInO1xuICBzcGFyc2U6IGJvb2xlYW47XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IElucHV0TGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoe1xuICAgICAgZHR5cGU6IGFyZ3MuZHR5cGUsXG4gICAgICBuYW1lOiBhcmdzLm5hbWUgIT0gbnVsbCA/IGFyZ3MubmFtZSA6IGdldFVpZCgnaW5wdXQnKS50b1N0cmluZygpXG4gICAgfSk7XG4gICAgLy8gTm9ybWFsaXplIGNvbmZpZy5iYXRjaFNpemUgYW5kIGNvbmZpZy5zcGFyc2VcbiAgICBpZiAoYXJncy5iYXRjaFNpemUgPT0gbnVsbCkge1xuICAgICAgYXJncy5iYXRjaFNpemUgPSBudWxsO1xuICAgIH1cbiAgICBpZiAoYXJncy5zcGFyc2UgPT0gbnVsbCkge1xuICAgICAgYXJncy5zcGFyc2UgPSBmYWxzZTtcbiAgICB9XG5cbiAgICB0aGlzLnRyYWluYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICAgIHRoaXMuc3BhcnNlID0gYXJncy5zcGFyc2U7XG5cbiAgICBpZiAoYXJncy5pbnB1dFNoYXBlICE9IG51bGwgJiYgYXJncy5iYXRjaElucHV0U2hhcGUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ09ubHkgcHJvdmlkZSB0aGUgaW5wdXRTaGFwZSBPUiAnICtcbiAgICAgICAgICAnYmF0Y2hJbnB1dFNoYXBlIGFyZ3VtZW50IHRvIGlucHV0TGF5ZXIsIG5vdCBib3RoIGF0IHRoZSBzYW1lIHRpbWUuJyk7XG4gICAgfVxuICAgIGxldCBiYXRjaElucHV0U2hhcGUgPSBhcmdzLmJhdGNoSW5wdXRTaGFwZTtcbiAgICBpZiAoYmF0Y2hJbnB1dFNoYXBlID09IG51bGwpIHtcbiAgICAgIGlmIChhcmdzLmlucHV0U2hhcGUgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICdBbiBJbnB1dExheWVyIHNob3VsZCBiZSBwYXNzZWQgZWl0aGVyIGEgJyArXG4gICAgICAgICAgICAnYGJhdGNoSW5wdXRTaGFwZWAgb3IgYW4gYGlucHV0U2hhcGVgLicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmF0Y2hJbnB1dFNoYXBlID0gW2FyZ3MuYmF0Y2hTaXplXS5jb25jYXQoYXJncy5pbnB1dFNoYXBlKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBCYWNrcG9ydCB0byBQeUtlcmFzXG4gICAgICBpZiAoYXJncy5iYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICdDYW5ub3Qgc3BlY2lmeSBiYXRjaFNpemUgaWYgYmF0Y2hJbnB1dFNoYXBlIGlzICcgK1xuICAgICAgICAgICAgJ3NwZWNpZmllZCB3aGVuIGNyZWF0aW5nIGFuIElucHV0TGF5ZXIuJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgZHR5cGUgPSBhcmdzLmR0eXBlIHx8ICdmbG9hdDMyJztcblxuICAgIHRoaXMuYmF0Y2hJbnB1dFNoYXBlID0gYmF0Y2hJbnB1dFNoYXBlO1xuICAgIHRoaXMuZHR5cGUgPSBkdHlwZTtcbiAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IEJhY2twb3J0IHRoaXMgdG8gUHlLZXJhcz9cbiAgICB0aGlzLmlucHV0U3BlYyA9IFt7c2hhcGU6IGJhdGNoSW5wdXRTaGFwZX1dO1xuXG4gICAgY29uc3QgaW5wdXRUZW5zb3IgPSBuZXcgU3ltYm9saWNUZW5zb3IoXG4gICAgICAgIHRoaXMuZHR5cGUsIHRoaXMuYmF0Y2hJbnB1dFNoYXBlLCB0aGlzLCBbXSwge30sIHRoaXMubmFtZSk7XG4gICAgaW5wdXRUZW5zb3Iubm9kZUluZGV4ID0gMDtcbiAgICBpbnB1dFRlbnNvci50ZW5zb3JJbmRleCA9IDA7XG5cbiAgICAvLyBDcmVhdGUgYW4gaW5wdXQgbm9kZSB0byBhZGQgdG8gdGhpcy5vdXRib3VuZE5vZGUuXG4gICAgLy8gKFRoaXMgY2FsbCBoYXMgc2lkZSBlZmZlY3RzLilcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tdW51c2VkLWV4cHJlc3Npb25cbiAgICBuZXcgTm9kZSh7XG4gICAgICBvdXRib3VuZExheWVyOiB0aGlzLFxuICAgICAgaW5ib3VuZExheWVyczogW10sXG4gICAgICBub2RlSW5kaWNlczogW10sXG4gICAgICB0ZW5zb3JJbmRpY2VzOiBbXSxcbiAgICAgIGlucHV0VGVuc29yczogW2lucHV0VGVuc29yXSxcbiAgICAgIG91dHB1dFRlbnNvcnM6IFtpbnB1dFRlbnNvcl0sXG4gICAgICBpbnB1dE1hc2tzOiBbbnVsbF0sXG4gICAgICBvdXRwdXRNYXNrczogW251bGxdLFxuICAgICAgaW5wdXRTaGFwZXM6IFtiYXRjaElucHV0U2hhcGVdLFxuICAgICAgb3V0cHV0U2hhcGVzOiBbYmF0Y2hJbnB1dFNoYXBlXVxuICAgIH0pO1xuICB9XG5cbiAgYXBwbHkoXG4gICAgICBpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcnxTeW1ib2xpY1RlbnNvcltdLFxuICAgICAga3dhcmdzPzogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdfFN5bWJvbGljVGVuc29yIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBwYXNzIGFueSBpbnB1dCB0byBhbiAnICtcbiAgICAgICAgYElucHV0TGF5ZXIncyBhcHBseSgpIG1ldGhvZC4gSW5wdXRMYXllciBuYW1lOiAke3RoaXMubmFtZX1gKTtcbiAgfVxuXG4gIGRpc3Bvc2UoKTogRGlzcG9zZVJlc3VsdCB7XG4gICAgLy8gZGlzcG9zZSgpIGZvciBJbnB1dExheWVyIGlzIG92ZXJyaWRkZW4gYXMgbm8tb3AuXG4gICAgcmV0dXJuIHtyZWZDb3VudEFmdGVyRGlzcG9zZTogdGhpcy5fcmVmQ291bnQsIG51bURpc3Bvc2VkVmFyaWFibGVzOiAwfTtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIHJldHVybiB7XG4gICAgICBiYXRjaElucHV0U2hhcGU6IHRoaXMuYmF0Y2hJbnB1dFNoYXBlLFxuICAgICAgZHR5cGU6IHRoaXMuZHR5cGUsXG4gICAgICBzcGFyc2U6IHRoaXMuc3BhcnNlLFxuICAgICAgbmFtZTogdGhpcy5uYW1lXG4gICAgfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKElucHV0TGF5ZXIpO1xuXG4vKipcbiAqIENvbmZpZyBmb3IgdGhlIElucHV0IGZ1bmN0aW9uLlxuICpcbiAqIE5vdGU6IFlvdSBzaG91bGQgcHJvdmlkZSBvbmx5IHNoYXBlIG9yIGJhdGNoU2hhcGUgKG5vdCBib3RoKS5cbiAqIElmIG9ubHkgc2hhcGUgaXMgcHJvdmlkZWQsIHRoZW4gdGhlIGJhdGNoU2hhcGUgYmVjb21lc1xuICogW251bGxdLmNvbmNhdChpbnB1dFNoYXBlKS5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBJbnB1dENvbmZpZyB7XG4gIC8qKlxuICAgKiBBIHNoYXBlLCBub3QgaW5jbHVkaW5nIHRoZSBiYXRjaCBzaXplLiBGb3IgaW5zdGFuY2UsIGBzaGFwZT1bMzJdYFxuICAgKiBpbmRpY2F0ZXMgdGhhdCB0aGUgZXhwZWN0ZWQgaW5wdXQgd2lsbCBiZSBiYXRjaGVzIG9mIDMyLWRpbWVuc2lvbmFsXG4gICAqIHZlY3RvcnMuXG4gICAqL1xuICBzaGFwZT86IFNoYXBlO1xuICAvKipcbiAgICogQSBzaGFwZSB0dXBsZSAoaW50ZWdlciksIGluY2x1ZGluZyB0aGUgYmF0Y2ggc2l6ZS4gRm9yIGluc3RhbmNlLFxuICAgKiBgYmF0Y2hTaGFwZT1bMTAsIDMyXWAgaW5kaWNhdGVzIHRoYXQgdGhlIGV4cGVjdGVkIGlucHV0IHdpbGwgYmUgYmF0Y2hlcyBvZlxuICAgKiAxMCAzMi1kaW1lbnNpb25hbCB2ZWN0b3JzLiBgYmF0Y2hTaGFwZT1bbnVsbCwgMzJdYCBpbmRpY2F0ZXMgYmF0Y2hlcyBvZiBhblxuICAgKiBhcmJpdHJhcnkgbnVtYmVyIG9mIDMyLWRpbWVuc2lvbmFsIHZlY3RvcnMuXG4gICAqL1xuICBiYXRjaFNoYXBlPzogU2hhcGU7XG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCBuYW1lIHN0cmluZyBmb3IgdGhlIGxheWVyLiBTaG91bGQgYmUgdW5pcXVlIGluIGEgbW9kZWwgKGRvIG5vdFxuICAgKiByZXVzZSB0aGUgc2FtZSBuYW1lIHR3aWNlKS4gSXQgd2lsbCBiZSBhdXRvZ2VuZXJhdGVkIGlmIGl0IGlzbid0IHByb3ZpZGVkLlxuICAgKi9cbiAgbmFtZT86IHN0cmluZztcbiAgZHR5cGU/OiBEYXRhVHlwZTtcbiAgLyoqXG4gICAqIEEgYm9vbGVhbiBzcGVjaWZ5aW5nIHdoZXRoZXIgdGhlIHBsYWNlaG9sZGVyIHRvIGJlIGNyZWF0ZWQgaXMgc3BhcnNlLlxuICAgKi9cbiAgc3BhcnNlPzogYm9vbGVhbjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIElucHV0KGNvbmZpZzogSW5wdXRDb25maWcpOiBTeW1ib2xpY1RlbnNvciB7XG4gIGlmIChjb25maWcuYmF0Y2hTaGFwZSA9PSBudWxsICYmIGNvbmZpZy5zaGFwZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnUGxlYXNlIHByb3ZpZGUgdG8gSW5wdXQgZWl0aGVyIGEgYHNoYXBlYCcgK1xuICAgICAgICAnIG9yIGEgYGJhdGNoU2hhcGVgIGFyZ3VtZW50LiBOb3RlIHRoYXQgJyArXG4gICAgICAgICdgc2hhcGVgIGRvZXMgbm90IGluY2x1ZGUgdGhlIGJhdGNoICcgK1xuICAgICAgICAnZGltZW5zaW9uLicpO1xuICB9XG4gIGlmIChjb25maWcuYmF0Y2hTaGFwZSAhPSBudWxsICYmIGNvbmZpZy5zaGFwZSAhPSBudWxsKSB7XG4gICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBCYWNrcG9ydCB0byBQeUtlcmFzLlxuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAnUGxlYXNlIHByb3ZpZGUgZWl0aGVyIGEgYHNoYXBlYCBvciBgYmF0Y2hTaGFwZWAgJyArXG4gICAgICAgICdhcmd1bWVudCB0byBJbnB1dCwgYnV0IG5vdCBib3RoLicpO1xuICB9XG4gIGxldCBiYXRjaFNoYXBlID0gY29uZmlnLmJhdGNoU2hhcGU7XG4gIGlmIChjb25maWcuc2hhcGUgIT0gbnVsbCAmJiBiYXRjaFNoYXBlID09IG51bGwpIHtcbiAgICBiYXRjaFNoYXBlID0gW251bGxdLmNvbmNhdChjb25maWcuc2hhcGUpO1xuICB9XG5cbiAgbGV0IGR0eXBlID0gY29uZmlnLmR0eXBlO1xuICBpZiAoZHR5cGUgPT0gbnVsbCkge1xuICAgIGR0eXBlID0gJ2Zsb2F0MzInO1xuICB9XG5cbiAgY29uc3QgaW5wdXRMYXllciA9IG5ldyBJbnB1dExheWVyKHtcbiAgICBiYXRjaElucHV0U2hhcGU6IGJhdGNoU2hhcGUsXG4gICAgbmFtZTogY29uZmlnLm5hbWUsXG4gICAgZHR5cGUsXG4gICAgc3BhcnNlOiBjb25maWcuc3BhcnNlXG4gIH0pO1xuXG4gIGNvbnN0IG91dHB1dHMgPSBpbnB1dExheWVyLmluYm91bmROb2Rlc1swXS5vdXRwdXRUZW5zb3JzO1xuICByZXR1cm4gb3V0cHV0c1swXTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Executor: Evaluates SymbolicTensor based on feeds.\n */\nimport { cast, dispose, memory, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from '../errors';\nimport { LruCache } from '../utils/executor_utils';\nimport { toList } from '../utils/generic_utils';\nimport { InputLayer } from './input_layer';\nimport { SymbolicTensor } from './topology';\n/**\n * Helper function to check the dtype and shape compatibility of a feed value.\n */\nfunction assertFeedCompatibility(key, val) {\n    // Check dtype compatibility.\n    if (key.dtype == null || key.dtype === val.dtype) {\n        //  a.  If types match, return val tensor as is.\n        return val;\n    }\n    try {\n        //  b. Attempt to convert to expected type.\n        return cast(val, key.dtype);\n    }\n    catch (err) {\n        //  c. If conversion fails, return helpful error.\n        throw new ValueError(`The dtype of the feed (${val.dtype}) can not be cast to the dtype ` +\n            `of the key '${key.name}' (${key.dtype}).`);\n    }\n}\n/**\n * FeedDict: A mapping from unique SymbolicTensors to feed values for them.\n * A feed value is a concrete value represented as an `Tensor`.\n */\nexport class FeedDict {\n    /**\n     * Constructor, optionally does copy-construction.\n     * @param feeds An Array of `Feed`s, or another `FeedDict`, in which case\n     *   copy-construction will be performed.\n     */\n    constructor(feeds) {\n        this.id2Value = {};\n        this.id2Mask = {};\n        this.name2Id = {};\n        if (feeds instanceof FeedDict) {\n            for (const id in feeds.id2Value) {\n                this.id2Value[id] = feeds.id2Value[id];\n                if (id in feeds.id2Mask) {\n                    this.id2Mask[id] = feeds.id2Mask[id];\n                }\n            }\n        }\n        else {\n            if (feeds == null) {\n                return;\n            }\n            for (const feed of feeds) {\n                this.add(feed.key, feed.value);\n            }\n        }\n    }\n    /**\n     * Add a key-value pair to the FeedDict.\n     *\n     * @param key The key of the feed.\n     * @param value The value of the tensor feed.\n     * @param mask The value of the mask feed (optional).\n     * @returns This `FeedDict`.\n     * @throws ValueError: If the key `SymbolicTensor` already exists in the\n     *   `FeedDict`.\n     */\n    add(key, value, mask) {\n        if (this.id2Value[key.id] == null) {\n            this.id2Value[key.id] = assertFeedCompatibility(key, value);\n            this.name2Id[key.name] = key.id;\n            if (mask != null) {\n                this.id2Mask[key.id] = mask;\n            }\n        }\n        else {\n            throw new ValueError(`Duplicate key: name=${key.name}, id=${key.id}`);\n        }\n        return this;\n    }\n    /**\n     * Add a Feed to the FeedDict.\n     * @param feed The new `Feed` to add.\n     * @returns This `FeedDict`.\n     */\n    addFeed(feed) {\n        this.add(feed.key, feed.value);\n    }\n    /**\n     * Probe whether a key already exists in the FeedDict.\n     * @param key\n     */\n    hasKey(key) {\n        return this.id2Value[key.id] != null;\n    }\n    /**\n     * Get all the SymbolicTensor available in this FeedDict.\n     */\n    names() {\n        return Object.keys(this.name2Id);\n    }\n    /**\n     * Get the feed value for given key.\n     * @param key The SymbolicTensor, or its name (as a string), of which the\n     *     value is sought.\n     * @returns If `key` exists, the corresponding feed value.\n     * @throws ValueError: If `key` does not exist in this `FeedDict`.\n     */\n    getValue(key) {\n        if (key instanceof SymbolicTensor) {\n            if (this.id2Value[key.id] == null) {\n                throw new ValueError(`Nonexistent key: ${key.name}`);\n            }\n            else {\n                return this.id2Value[key.id];\n            }\n        }\n        else {\n            const id = this.name2Id[key];\n            if (id == null) {\n                throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);\n            }\n            return this.id2Value[id];\n        }\n    }\n    /**\n     * Get the feed mask for given key.\n     * @param key The SymbolicTensor, or its name (as a string), of which the\n     *     value is sought.\n     * @returns If `key` exists, the corresponding feed mask.\n     * @throws ValueError: If `key` does not exist in this `FeedDict`.\n     */\n    getMask(key) {\n        if (key instanceof SymbolicTensor) {\n            if (this.id2Value[key.id] == null) {\n                throw new ValueError(`Nonexistent key: ${key.name}`);\n            }\n            else {\n                return this.id2Mask[key.id];\n            }\n        }\n        else {\n            const id = this.name2Id[key];\n            if (id == null) {\n                throw new ValueError(`Feed dict has no SymbolicTensor name: ${key}`);\n            }\n            return this.id2Mask[id];\n        }\n    }\n    /** Dispose all mask Tensors held by this object. */\n    disposeMasks() {\n        if (this.id2Mask != null) {\n            dispose(this.id2Mask);\n        }\n    }\n}\n// Cache for topologically sorted SymbolicTensors for given execution\n// targets (i.e., fetches).\nexport const cachedSorted = new LruCache();\n// Cache for recipient count maps for given execution targets (i.e., fetches).\nexport const cachedRecipientCounts = new LruCache();\nexport function updateCacheMaxEntries(maxEntries) {\n    if (cachedSorted != null) {\n        cachedSorted.setMaxEntries(maxEntries);\n    }\n    if (cachedRecipientCounts != null) {\n        cachedRecipientCounts.setMaxEntries(maxEntries);\n    }\n}\n/**\n * Execute a SymbolicTensor by using concrete feed values.\n *\n * A `SymbolicTensor` object is a node in a computation graph of TF.js\n * Layers. The object is backed by a source layer and input\n * `SymbolicTensor`s to the source layer. This method evaluates\n * the `call()` method of the source layer, using concrete values of the\n * inputs obtained from either\n * * `feedDict`, if the input key exists in `feedDict`, or else,\n * * a recursive call to `execute()` itself.\n *\n * @param x: The `SymbolicTensor` to execute.\n * @param feedDict: The feed values, as base condition of the recursion.\n *   execution.\n * @param kwargs: Optional keyword arguments.\n * @param probe: A probe object (of interface `ExecutionProbe`) used for\n *   testing memory footprint of `execute` calls.\n * @returns Result of the execution.\n * @throws ValueError: If any `SymbolicTensor`s from `InputLayer`s\n *   encountered during the execution lacks a feed value in `feedDict`.\n */\nexport function execute(fetches, feedDict, kwargs, probe) {\n    const training = kwargs == null ? false : kwargs['training'];\n    const arrayFetches = Array.isArray(fetches);\n    const fetchArray = arrayFetches ? fetches : [fetches];\n    const outputNames = fetchArray.map(t => t.name);\n    const finalOutputs = [];\n    const feedNames = feedDict.names();\n    for (const outputName of outputNames) {\n        if (feedNames.indexOf(outputName) !== -1) {\n            finalOutputs.push(feedDict.getValue(outputName));\n        }\n        else {\n            finalOutputs.push(null);\n        }\n    }\n    if (probe != null) {\n        // For optional probing of memory footprint during execution.\n        probe.maxNumTensors = -Infinity;\n        probe.minNumTensors = Infinity;\n    }\n    // Check cache.\n    const fetchAndFeedKey = outputNames.join(',') + '|' + feedDict.names().sort().join(',');\n    let sorted = cachedSorted.get(fetchAndFeedKey);\n    let recipientCounts;\n    if (sorted == null) {\n        // Cache doesn't contain the desired combination of fetches. Compute\n        // topological sort for the combination for the first time.\n        const out = getTopologicalSortAndRecipientCounts(fetchArray, feedDict);\n        sorted = out.sorted;\n        recipientCounts = out.recipientCounts;\n        // Store results in cache for future use.\n        cachedSorted.put(fetchAndFeedKey, sorted);\n        cachedRecipientCounts.put(fetchAndFeedKey, recipientCounts);\n    }\n    recipientCounts = {};\n    if (!training) {\n        Object.assign(recipientCounts, cachedRecipientCounts.get(fetchAndFeedKey));\n    }\n    const internalFeedDict = new FeedDict(feedDict);\n    // Start iterative execution on the topologically-sorted SymbolicTensors.\n    for (let i = 0; i < sorted.length; ++i) {\n        if (probe != null) {\n            // For optional probing of memory usage during execution.\n            const numTensors = memory().numTensors;\n            if (numTensors > probe.maxNumTensors) {\n                probe.maxNumTensors = numTensors;\n            }\n            if (numTensors < probe.minNumTensors) {\n                probe.minNumTensors = numTensors;\n            }\n        }\n        const symbolic = sorted[i];\n        const srcLayer = symbolic.sourceLayer;\n        if (srcLayer instanceof InputLayer) {\n            continue;\n        }\n        const inputValues = [];\n        const inputMasks = [];\n        const tensorsToDispose = [];\n        let maskExists = false;\n        for (const input of symbolic.inputs) {\n            const value = internalFeedDict.getValue(input);\n            const mask = internalFeedDict.getMask(input);\n            inputValues.push(value);\n            inputMasks.push(mask);\n            if (mask != null) {\n                maskExists = true;\n            }\n            if (!training) {\n                recipientCounts[input.name]--;\n                if (recipientCounts[input.name] === 0 && !feedDict.hasKey(input) &&\n                    outputNames.indexOf(input.name) === -1 && !value.isDisposed &&\n                    input.sourceLayer.stateful !== true) {\n                    tensorsToDispose.push(value);\n                }\n            }\n        }\n        if (maskExists) {\n            kwargs = kwargs || {};\n            kwargs['mask'] = inputMasks[0];\n        }\n        const outputTensors = toList(srcLayer.apply(inputValues, kwargs));\n        let outputMask = null;\n        if (srcLayer.supportsMasking) {\n            outputMask = srcLayer.computeMask(inputValues, inputMasks);\n        }\n        const layerOutputs = getNodeOutputs(symbolic);\n        const outputSymbolicTensors = Array.isArray(layerOutputs) ? layerOutputs : [layerOutputs];\n        for (let i = 0; i < outputSymbolicTensors.length; ++i) {\n            if (!internalFeedDict.hasKey(outputSymbolicTensors[i])) {\n                internalFeedDict.add(outputSymbolicTensors[i], outputTensors[i], Array.isArray(outputMask) ? outputMask[0] : outputMask);\n            }\n            const index = outputNames.indexOf(outputSymbolicTensors[i].name);\n            if (index !== -1) {\n                finalOutputs[index] = outputTensors[i];\n            }\n        }\n        if (!training) {\n            // Clean up Tensors that are no longer needed.\n            dispose(tensorsToDispose);\n        }\n    }\n    // NOTE(cais): Unlike intermediate tensors, we don't discard mask\n    // tensors as we go, because these tensors are sometimes passed over a\n    // series of mutliple layers, i.e., not obeying the immediate input\n    // relations in the graph. If this becomes a memory-usage concern,\n    // we can improve this in the future.\n    internalFeedDict.disposeMasks();\n    return arrayFetches ? finalOutputs : finalOutputs[0];\n}\n/**\n * Sort the `SymbolicTensor`s topologically, for an array of fetches.\n *\n * This function calls getTopologicalSortAndRecipientCountsForOneFetch and\n * merges their results.\n *\n * @param fetch The array of fetches requested. Must be a non-empty array.\n * @param feedDict The dictionary of fed values.\n * @returns sorted: Topologically-sorted array of SymbolicTensors.\n *   recipientCounts: Recipient counts for all SymbolicTensors in `sorted`.\n */\nfunction getTopologicalSortAndRecipientCounts(fetches, feedDict) {\n    util.assert(fetches != null && fetches.length > 0, () => `Expected at least one fetch, got none`);\n    let finalSorted = [];\n    let finalRecipientMap = {};\n    if (fetches.length === 1) {\n        // Special-casing 1 fetch for efficiency.\n        const out = getTopologicalSortAndRecipientCountsForOneFetch(fetches[0], feedDict);\n        finalSorted = out.sorted;\n        finalRecipientMap = out.recipientMap;\n    }\n    else {\n        const visited = new Set();\n        for (const fetch of fetches) {\n            const { sorted, recipientMap } = getTopologicalSortAndRecipientCountsForOneFetch(fetch, feedDict);\n            // Merge sorted SymbolicTensor Arrays.\n            for (const symbolicTensor of sorted) {\n                if (!visited.has(symbolicTensor.name)) {\n                    finalSorted.push(symbolicTensor);\n                    visited.add(symbolicTensor.name);\n                }\n            }\n            // Merge recipient maps.\n            for (const name in recipientMap) {\n                if (finalRecipientMap[name] == null) {\n                    finalRecipientMap[name] = new Set();\n                }\n                recipientMap[name].forEach(recipient => finalRecipientMap[name].add(recipient));\n            }\n        }\n    }\n    return {\n        sorted: finalSorted,\n        recipientCounts: recipientMap2Counts(finalRecipientMap)\n    };\n}\nfunction recipientMap2Counts(recipientMap) {\n    const recipientCounts = {};\n    for (const name in recipientMap) {\n        recipientCounts[name] = recipientMap[name].size;\n    }\n    return recipientCounts;\n}\n/**\n * Sort the `SymbolicTensor`s topologically, for a single fetch.\n *\n * This helper function processes the upstream SymbolicTensors of a single\n * fetch.\n *\n * @param fetch The single fetch requested.\n * @param feedDict The dictionary of fed values.\n * @returns sorted: Topologically-sorted array of SymbolicTensors.\n *   recipientMap: Recipient names for all SymbolicTensors in `sorted`.\n */\nexport function getTopologicalSortAndRecipientCountsForOneFetch(fetch, feedDict) {\n    const visited = new Set();\n    const sorted = [];\n    const recipientMap = {};\n    // Put keys of the feedDict into visited first, so they don't have to be\n    // walked. This is needed in case where there are feeds for intermediate\n    // SymbolicTensors of the graph.\n    for (const key of feedDict.names()) {\n        visited.add(key);\n    }\n    const stack = [];\n    const marks = [];\n    // Initial population of stack and marks.\n    stack.push(fetch);\n    while (stack.length > 0) {\n        const top = stack[stack.length - 1];\n        if (visited.has(top.name)) {\n            stack.pop();\n            continue;\n        }\n        const topIsMarked = marks[marks.length - 1] === stack.length - 1;\n        if (top.inputs.length === 0 || topIsMarked) {\n            // Input SymbolicTensor or all children have been visited.\n            stack.pop();\n            sorted.push(top);\n            visited.add(top.name);\n            if (topIsMarked) {\n                marks.pop();\n            }\n        }\n        else {\n            // A non-input SymbolicTensor whose upstream SymbolicTensors haven't\n            // been visited yet. Push them onto the stack.\n            marks.push(stack.length - 1);\n            for (const input of top.inputs) {\n                // Increment the recipient count. Note that this needs to happen\n                // regardless of whether the SymbolicTensor has been visited before.\n                if (recipientMap[input.name] == null) {\n                    recipientMap[input.name] = new Set();\n                }\n                recipientMap[input.name].add(top.name);\n                if (visited.has(input.name)) {\n                    continue; // Avoid repeated visits to the same SymbolicTensor.\n                }\n                stack.push(input);\n            }\n        }\n    }\n    return { sorted, recipientMap };\n}\n/**\n * Get the symbolic output tensors of the node to which a given fetch belongs.\n * @param fetch The fetched symbolic tensor.\n * @returns The Array of symbolic tensors output by the node to which `fetch`\n *   belongs.\n */\nfunction getNodeOutputs(fetch) {\n    let layerOutputs;\n    if (fetch.sourceLayer.inboundNodes.length === 1) {\n        layerOutputs = fetch.sourceLayer.output;\n    }\n    else {\n        let nodeIndex = null;\n        for (let i = 0; i < fetch.sourceLayer.inboundNodes.length; ++i) {\n            for (const outputTensor of fetch.sourceLayer.inboundNodes[i]\n                .outputTensors) {\n                if (outputTensor.id === fetch.id) {\n                    nodeIndex = i;\n                    break;\n                }\n            }\n        }\n        layerOutputs = fetch.sourceLayer.getOutputAt(nodeIndex);\n    }\n    return layerOutputs;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXhlY3V0b3IuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvZW5naW5lL2V4ZWN1dG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEVBQUMsSUFBSSxFQUFFLE9BQU8sRUFBRSxNQUFNLEVBQVUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFMUUsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUVyQyxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDakQsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBRTlDLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDekMsT0FBTyxFQUFDLGNBQWMsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUUxQzs7R0FFRztBQUNILFNBQVMsdUJBQXVCLENBQUMsR0FBbUIsRUFBRSxHQUFXO0lBQy9ELDZCQUE2QjtJQUM3QixJQUFJLEdBQUcsQ0FBQyxLQUFLLElBQUksSUFBSSxJQUFJLEdBQUcsQ0FBQyxLQUFLLEtBQUssR0FBRyxDQUFDLEtBQUssRUFBRTtRQUNoRCxnREFBZ0Q7UUFDaEQsT0FBTyxHQUFHLENBQUM7S0FDWjtJQUNELElBQUk7UUFDRiwyQ0FBMkM7UUFDM0MsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUM3QjtJQUFDLE9BQU8sR0FBRyxFQUFFO1FBQ1osaURBQWlEO1FBQ2pELE1BQU0sSUFBSSxVQUFVLENBQ2hCLDBCQUEwQixHQUFHLENBQUMsS0FBSyxpQ0FBaUM7WUFDcEUsZUFBZSxHQUFHLENBQUMsSUFBSSxNQUFNLEdBQUcsQ0FBQyxLQUFLLElBQUksQ0FBQyxDQUFDO0tBQ2pEO0FBQ0gsQ0FBQztBQVVEOzs7R0FHRztBQUNILE1B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WSxFQUFDLENBQUM7QUFDaEMsQ0FBQztBQUVEOzs7OztHQUtHO0FBQ0gsU0FBUyxjQUFjLENBQUMsS0FBcUI7SUFFM0MsSUFBSSxZQUE2QyxDQUFDO0lBQ2xELElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtRQUMvQyxZQUFZLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxNQUFNLENBQUM7S0FDekM7U0FBTTtRQUNMLElBQUksU0FBUyxHQUFXLElBQUksQ0FBQztRQUM3QixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsS0FBSyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsTUFBTSxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzlELEtBQUssTUFBTSxZQUFZLElBQUksS0FBSyxDQUFDLFdBQVcsQ0FBQyxZQUFZLENBQUMsQ0FBQyxDQUFDO2lCQUNsRCxhQUFhLEVBQUU7Z0JBQ3ZCLElBQUksWUFBWSxDQUFDLEVBQUUsS0FBSyxLQUFLLENBQUMsRUFBRSxFQUFFO29CQUNoQyxTQUFTLEdBQUcsQ0FBQyxDQUFDO29CQUNkLE1BQU07aUJBQ1A7YUFDRjtTQUNGO1FBQ0QsWUFBWSxHQUFHLEtBQUssQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQ3pEO0lBQ0QsT0FBTyxZQUFZLENBQUM7QUFDdEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogRXhlY3V0b3I6IEV2YWx1YXRlcyBTeW1ib2xpY1RlbnNvciBiYXNlZCBvbiBmZWVkcy5cbiAqL1xuXG5pbXBvcnQge2Nhc3QsIGRpc3Bvc2UsIG1lbW9yeSwgVGVuc29yLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge1ZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge0t3YXJnc30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtMcnVDYWNoZX0gZnJvbSAnLi4vdXRpbHMvZXhlY3V0b3JfdXRpbHMnO1xuaW1wb3J0IHt0b0xpc3R9IGZyb20gJy4uL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuXG5pbXBvcnQge0lucHV0TGF5ZXJ9IGZyb20gJy4vaW5wdXRfbGF5ZXInO1xuaW1wb3J0IHtTeW1ib2xpY1RlbnNvcn0gZnJvbSAnLi90b3BvbG9neSc7XG5cbi8qKlxuICogSGVscGVyIGZ1bmN0aW9uIHRvIGNoZWNrIHRoZSBkdHlwZSBhbmQgc2hhcGUgY29tcGF0aWJpbGl0eSBvZiBhIGZlZWQgdmFsdWUuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGtleTogU3ltYm9saWNUZW5zb3IsIHZhbDogVGVuc29yKTogVGVuc29yIHtcbiAgLy8gQ2hlY2sgZHR5cGUgY29tcGF0aWJpbGl0eS5cbiAgaWYgKGtleS5kdHlwZSA9PSBudWxsIHx8IGtleS5kdHlwZSA9PT0gdmFsLmR0eXBlKSB7XG4gICAgLy8gIGEuICBJZiB0eXBlcyBtYXRjaCwgcmV0dXJuIHZhbCB0ZW5zb3IgYXMgaXMuXG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICB0cnkge1xuICAgIC8vICBiLiBBdHRlbXB0IHRvIGNvbnZlcnQgdG8gZXhwZWN0ZWQgdHlwZS5cbiAgICByZXR1cm4gY2FzdCh2YWwsIGtleS5kdHlwZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIC8vICBjLiBJZiBjb252ZXJzaW9uIGZhaWxzLCByZXR1cm4gaGVscGZ1bCBlcnJvci5cbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgYFRoZSBkdHlwZSBvZiB0aGUgZmVlZCAoJHt2YWwuZHR5cGV9KSBjYW4gbm90IGJlIGNhc3QgdG8gdGhlIGR0eXBlIGAgK1xuICAgICAgICBgb2YgdGhlIGtleSAnJHtrZXkubmFtZX0nICgke2tleS5kdHlwZX0pLmApO1xuICB9XG59XG5cbi8qKlxuICogQSBjb25jcmV0ZSBUZW5zb3IgdmFsdWUgZm9yIGEgc3ltYm9saWMgdGVuc29yIGFzIHRoZSBrZXkuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgRmVlZCB7XG4gIGtleTogU3ltYm9saWNUZW5zb3I7XG4gIHZhbHVlOiBUZW5zb3I7XG59XG5cbi8qKlxuICogRmVlZERpY3Q6IEEgbWFwcGluZyBmcm9tIHVuaXF1ZSBTeW1ib2xpY1RlbnNvcnMgdG8gZmVlZCB2YWx1ZXMgZm9yIHRoZW0uXG4gKiBBIGZlZWQgdmFsdWUgaXMgYSBjb25jcmV0ZSB2YWx1ZSByZXByZXNlbnRlZCBhcyBhbiBgVGVuc29yYC5cbiAqL1xuZXhwb3J0IGNsYXNzIEZlZWREaWN0IHtcbiAgcHJpdmF0ZSBpZDJWYWx1ZToge1tpZDogbnVtYmVyXTogVGVuc29yfSA9IHt9O1xuICBwcml2YXRlIGlkMk1hc2s6IHtbaWQ6IG51bWJlcl06IFRlbnNvcn0gPSB7fTtcbiAgcHJpdmF0ZSBuYW1lMklkOiB7W25hbWU6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcblxuICAvKipcbiAgICogQ29uc3RydWN0b3IsIG9wdGlvbmFsbHkgZG9lcyBjb3B5LWNvbnN0cnVjdGlvbi5cbiAgICogQHBhcmFtIGZlZWRzIEFuIEFycmF5IG9mIGBGZWVkYHMsIG9yIGFub3RoZXIgYEZlZWREaWN0YCwgaW4gd2hpY2ggY2FzZVxuICAgKiAgIGNvcHktY29uc3RydWN0aW9uIHdpbGwgYmUgcGVyZm9ybWVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoZmVlZHM/OiBGZWVkW118RmVlZERpY3QpIHtcbiAgICBpZiAoZmVlZHMgaW5zdGFuY2VvZiBGZWVkRGljdCkge1xuICAgICAgZm9yIChjb25zdCBpZCBpbiBmZWVkcy5pZDJWYWx1ZSkge1xuICAgICAgICB0aGlzLmlkMlZhbHVlW2lkXSA9IGZlZWRzLmlkMlZhbHVlW2lkXTtcbiAgICAgICAgaWYgKGlkIGluIGZlZWRzLmlkMk1hc2spIHtcbiAgICAgICAgICB0aGlzLmlkMk1hc2tbaWRdID0gZmVlZHMuaWQyTWFza1tpZF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGZlZWRzID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgZm9yIChjb25zdCBmZWVkIG9mIGZlZWRzKSB7XG4gICAgICAgIHRoaXMuYWRkKGZlZWQua2V5LCBmZWVkLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQWRkIGEga2V5LXZhbHVlIHBhaXIgdG8gdGhlIEZlZWREaWN0LlxuICAgKlxuICAgKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGZlZWQuXG4gICAqIEBwYXJhbSB2YWx1ZSBUaGUgdmFsdWUgb2YgdGhlIHRlbnNvciBmZWVkLlxuICAgKiBAcGFyYW0gbWFzayBUaGUgdmFsdWUgb2YgdGhlIG1hc2sgZmVlZCAob3B0aW9uYWwpLlxuICAgKiBAcmV0dXJucyBUaGlzIGBGZWVkRGljdGAuXG4gICAqIEB0aHJvd3MgVmFsdWVFcnJvcjogSWYgdGhlIGtleSBgU3ltYm9saWNUZW5zb3JgIGFscmVhZHkgZXhpc3RzIGluIHRoZVxuICAgKiAgIGBGZWVkRGljdGAuXG4gICAqL1xuICBhZGQoa2V5OiBTeW1ib2xpY1RlbnNvciwgdmFsdWU6IFRlbnNvciwgbWFzaz86IFRlbnNvcik6IEZlZWREaWN0IHtcbiAgICBpZiAodGhpcy5pZDJWYWx1ZVtrZXkuaWRdID09IG51bGwpIHtcbiAgICAgIHRoaXMuaWQyVmFsdWVba2V5LmlkXSA9IGFzc2VydEZlZWRDb21wYXRpYmlsaXR5KGtleSwgdmFsdWUpO1xuICAgICAgdGhpcy5uYW1lMklkW2tleS5uYW1lXSA9IGtleS5pZDtcbiAgICAgIGlmIChtYXNrICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5pZDJNYXNrW2tleS5pZF0gPSBtYXNrO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgRHVwbGljYXRlIGtleTogbmFtZT0ke2tleS5uYW1lfSwgaWQ9JHtrZXkuaWR9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEFkZCBhIEZlZWQgdG8gdGhlIEZlZWREaWN0LlxuICAgKiBAcGFyYW0gZmVlZCBUaGUgbmV3IGBGZWVkYCB0byBhZGQuXG4gICAqIEByZXR1cm5zIFRoaXMgYEZlZWREaWN0YC5cbiAgICovXG4gIGFkZEZlZWQoZmVlZDogRmVlZCkge1xuICAgIHRoaXMuYWRkKGZlZWQua2V5LCBmZWVkLnZhbHVlKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9iZSB3aGV0aGVyIGEga2V5IGFscmVhZHkgZXhpc3RzIGluIHRoZSBGZWVkRGljdC5cbiAgICogQHBhcmFtIGtleVxuICAgKi9cbiAgaGFzS2V5KGtleTogU3ltYm9saWNUZW5zb3IpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5pZDJWYWx1ZVtrZXkuaWRdICE9IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogR2V0IGFsbCB0aGUgU3ltYm9saWNUZW5zb3IgYXZhaWxhYmxlIGluIHRoaXMgRmVlZERpY3QuXG4gICAqL1xuICBuYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMubmFtZTJJZCk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHRoZSBmZWVkIHZhbHVlIGZvciBnaXZlbiBrZXkuXG4gICAqIEBwYXJhbSBrZXkgVGhlIFN5bWJvbGljVGVuc29yLCBvciBpdHMgbmFtZSAoYXMgYSBzdHJpbmcpLCBvZiB3aGljaCB0aGVcbiAgICogICAgIHZhbHVlIGlzIHNvdWdodC5cbiAgICogQHJldHVybnMgSWYgYGtleWAgZXhpc3RzLCB0aGUgY29ycmVzcG9uZGluZyBmZWVkIHZhbHVlLlxuICAgKiBAdGhyb3dzIFZhbHVlRXJyb3I6IElmIGBrZXlgIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgYEZlZWREaWN0YC5cbiAgICovXG4gIGdldFZhbHVlKGtleTogU3ltYm9saWNUZW5zb3J8c3RyaW5nKTogVGVuc29yIHtcbiAgICBpZiAoa2V5IGluc3RhbmNlb2YgU3ltYm9saWNUZW5zb3IpIHtcbiAgICAgIGlmICh0aGlzLmlkMlZhbHVlW2tleS5pZF0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgTm9uZXhpc3RlbnQga2V5OiAke2tleS5uYW1lfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaWQyVmFsdWVba2V5LmlkXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaWQgPSB0aGlzLm5hbWUySWRba2V5XTtcbiAgICAgIGlmIChpZCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBGZWVkIGRpY3QgaGFzIG5vIFN5bWJvbGljVGVuc29yIG5hbWU6ICR7a2V5fWApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuaWQyVmFsdWVbaWRdO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGZlZWQgbWFzayBmb3IgZ2l2ZW4ga2V5LlxuICAgKiBAcGFyYW0ga2V5IFRoZSBTeW1ib2xpY1RlbnNvciwgb3IgaXRzIG5hbWUgKGFzIGEgc3RyaW5nKSwgb2Ygd2hpY2ggdGhlXG4gICAqICAgICB2YWx1ZSBpcyBzb3VnaHQuXG4gICAqIEByZXR1cm5zIElmIGBrZXlgIGV4aXN0cywgdGhlIGNvcnJlc3BvbmRpbmcgZmVlZCBtYXNrLlxuICAgKiBAdGhyb3dzIFZhbHVlRXJyb3I6IElmIGBrZXlgIGRvZXMgbm90IGV4aXN0IGluIHRoaXMgYEZlZWREaWN0YC5cbiAgICovXG4gIGdldE1hc2soa2V5OiBTeW1ib2xpY1RlbnNvcnxzdHJpbmcpOiBUZW5zb3Ige1xuICAgIGlmIChrZXkgaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvcikge1xuICAgICAgaWYgKHRoaXMuaWQyVmFsdWVba2V5LmlkXSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBOb25leGlzdGVudCBrZXk6ICR7a2V5Lm5hbWV9YCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gdGhpcy5pZDJNYXNrW2tleS5pZF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGlkID0gdGhpcy5uYW1lMklkW2tleV07XG4gICAgICBpZiAoaWQgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgRmVlZCBkaWN0IGhhcyBubyBTeW1ib2xpY1RlbnNvciBuYW1lOiAke2tleX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmlkMk1hc2tbaWRdO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBEaXNwb3NlIGFsbCBtYXNrIFRlbnNvcnMgaGVsZCBieSB0aGlzIG9iamVjdC4gKi9cbiAgZGlzcG9zZU1hc2tzKCkge1xuICAgIGlmICh0aGlzLmlkMk1hc2sgIT0gbnVsbCkge1xuICAgICAgZGlzcG9zZSh0aGlzLmlkMk1hc2spO1xuICAgIH1cbiAgfVxufVxuXG4vLyBDYWNoZSBmb3IgdG9wb2xvZ2ljYWxseSBzb3J0ZWQgU3ltYm9saWNUZW5zb3JzIGZvciBnaXZlbiBleGVjdXRpb25cbi8vIHRhcmdldHMgKGkuZS4sIGZldGNoZXMpLlxuZXhwb3J0IGNvbnN0IGNhY2hlZFNvcnRlZDogTHJ1Q2FjaGU8U3ltYm9saWNUZW5zb3JbXT4gPVxuICAgIG5ldyBMcnVDYWNoZTxTeW1ib2xpY1RlbnNvcltdPigpO1xuXG4vLyBDYWNoZSBmb3IgcmVjaXBpZW50IGNvdW50IG1hcHMgZm9yIGdpdmVuIGV4ZWN1dGlvbiB0YXJnZXRzIChpLmUuLCBmZXRjaGVzKS5cbmV4cG9ydCBjb25zdCBjYWNoZWRSZWNpcGllbnRDb3VudHM6IExydUNhY2hlPFJlY2lwaWVudENvdW50cz4gPVxuICAgIG5ldyBMcnVDYWNoZTxSZWNpcGllbnRDb3VudHM+KCk7XG5cbmV4cG9ydCBmdW5jdGlvbiB1cGRhdGVDYWNoZU1heEVudHJpZXMobWF4RW50cmllczogbnVtYmVyKSB7XG4gIGlmIChjYWNoZWRTb3J0ZWQgIT0gbnVsbCkge1xuICAgIGNhY2hlZFNvcnRlZC5zZXRNYXhFbnRyaWVzKG1heEVudHJpZXMpO1xuICB9XG4gIGlmIChjYWNoZWRSZWNpcGllbnRDb3VudHMgIT0gbnVsbCkge1xuICAgIGNhY2hlZFJlY2lwaWVudENvdW50cy5zZXRNYXhFbnRyaWVzKG1heEVudHJpZXMpO1xuICB9XG59XG5cbi8qKlxuICogSW50ZXJmYWNlIGZvciB0aGUgb3B0aW9uYWwgb2JqZWN0IHVzZWQgZm9yIHByb2JpbmcgdGhlIG1lbW9yeVxuICogdXNhZ2UgYW5kIG90aGVyIHN0YXRpc3RpY3MgZHVyaW5nIGV4ZWN1dGlvbi5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFeGVjdXRpb25Qcm9iZSB7XG4gIC8qKlxuICAgKiBNYXhpbXVtIG51bWJlciBvZiB0ZW5zb3JzIHRoYXQgZXhpc3QgZHVyaW5nIGFsbCBzdGVwcyBvZiB0aGVcbiAgICogZXhlY3V0aW9uLiBUZW5zb3IgY291bnRzIGFyZSBtZWFzdXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGV2ZXJ5XG4gICAqIHN0ZXAuXG4gICAqL1xuICBtYXhOdW1UZW5zb3JzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBNaW5pbXVtIG51bWJlciBvZiB0ZW5zb3JzIHRoYXQgZXhpc3QgZHVyaW5nIGFsbCBzdGVwcyBvZiB0aGVcbiAgICogZXhlY3V0aW9uLiBUZW5zb3IgY291bnRzIGFyZSBtZWFzdXJlZCBhdCB0aGUgYmVnaW5uaW5nIG9mIGV2ZXJ5XG4gICAqIHN0ZXAuXG4gICAqL1xuICBtaW5OdW1UZW5zb3JzPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIEV4ZWN1dGUgYSBTeW1ib2xpY1RlbnNvciBieSB1c2luZyBjb25jcmV0ZSBmZWVkIHZhbHVlcy5cbiAqXG4gKiBBIGBTeW1ib2xpY1RlbnNvcmAgb2JqZWN0IGlzIGEgbm9kZSBpbiBhIGNvbXB1dGF0aW9uIGdyYXBoIG9mIFRGLmpzXG4gKiBMYXllcnMuIFRoZSBvYmplY3QgaXMgYmFja2VkIGJ5IGEgc291cmNlIGxheWVyIGFuZCBpbnB1dFxuICogYFN5bWJvbGljVGVuc29yYHMgdG8gdGhlIHNvdXJjZSBsYXllci4gVGhpcyBtZXRob2QgZXZhbHVhdGVzXG4gKiB0aGUgYGNhbGwoKWAgbWV0aG9kIG9mIHRoZSBzb3VyY2UgbGF5ZXIsIHVzaW5nIGNvbmNyZXRlIHZhbHVlcyBvZiB0aGVcbiAqIGlucHV0cyBvYnRhaW5lZCBmcm9tIGVpdGhlclxuICogKiBgZmVlZERpY3RgLCBpZiB0aGUgaW5wdXQga2V5IGV4aXN0cyBpbiBgZmVlZERpY3RgLCBvciBlbHNlLFxuICogKiBhIHJlY3Vyc2l2ZSBjYWxsIHRvIGBleGVjdXRlKClgIGl0c2VsZi5cbiAqXG4gKiBAcGFyYW0geDogVGhlIGBTeW1ib2xpY1RlbnNvcmAgdG8gZXhlY3V0ZS5cbiAqIEBwYXJhbSBmZWVkRGljdDogVGhlIGZlZWQgdmFsdWVzLCBhcyBiYXNlIGNvbmRpdGlvbiBvZiB0aGUgcmVjdXJzaW9uLlxuICogICBleGVjdXRpb24uXG4gKiBAcGFyYW0ga3dhcmdzOiBPcHRpb25hbCBrZXl3b3JkIGFyZ3VtZW50cy5cbiAqIEBwYXJhbSBwcm9iZTogQSBwcm9iZSBvYmplY3QgKG9mIGludGVyZmFjZSBgRXhlY3V0aW9uUHJvYmVgKSB1c2VkIGZvclxuICogICB0ZXN0aW5nIG1lbW9yeSBmb290cHJpbnQgb2YgYGV4ZWN1dGVgIGNhbGxzLlxuICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSBleGVjdXRpb24uXG4gKiBAdGhyb3dzIFZhbHVlRXJyb3I6IElmIGFueSBgU3ltYm9saWNUZW5zb3JgcyBmcm9tIGBJbnB1dExheWVyYHNcbiAqICAgZW5jb3VudGVyZWQgZHVyaW5nIHRoZSBleGVjdXRpb24gbGFja3MgYSBmZWVkIHZhbHVlIGluIGBmZWVkRGljdGAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBleGVjdXRlKFxuICAgIGZldGNoZXM6IFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW10sIGZlZWREaWN0OiBGZWVkRGljdCxcbiAgICBrd2FyZ3M/OiBLd2FyZ3MsIHByb2JlPzogRXhlY3V0aW9uUHJvYmUpOiBUZW5zb3J8XG4gICAgVGVuc29yW118W1RlbnNvciB8IFRlbnNvcltdXSB7XG4gIGNvbnN0IHRyYWluaW5nOiBib29sZWFuID0ga3dhcmdzID09IG51bGwgPyBmYWxzZSA6IGt3YXJnc1sndHJhaW5pbmcnXTtcblxuICBjb25zdCBhcnJheUZldGNoZXMgPSBBcnJheS5pc0FycmF5KGZldGNoZXMpO1xuICBjb25zdCBmZXRjaEFycmF5OiBTeW1ib2xpY1RlbnNvcltdID1cbiAgICAgIGFycmF5RmV0Y2hlcyA/IGZldGNoZXMgYXMgU3ltYm9saWNUZW5zb3JbXSA6IFtmZXRjaGVzIGFzIFN5bWJvbGljVGVuc29yXTtcblxuICBjb25zdCBvdXRwdXROYW1lcyA9IGZldGNoQXJyYXkubWFwKHQgPT4gdC5uYW1lKTtcbiAgY29uc3QgZmluYWxPdXRwdXRzOiBUZW5zb3JbXSA9IFtdO1xuICBjb25zdCBmZWVkTmFtZXMgPSBmZWVkRGljdC5uYW1lcygpO1xuICBmb3IgKGNvbnN0IG91dHB1dE5hbWUgb2Ygb3V0cHV0TmFtZXMpIHtcbiAgICBpZiAoZmVlZE5hbWVzLmluZGV4T2Yob3V0cHV0TmFtZSkgIT09IC0xKSB7XG4gICAgICBmaW5hbE91dHB1dHMucHVzaChmZWVkRGljdC5nZXRWYWx1ZShvdXRwdXROYW1lKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZpbmFsT3V0cHV0cy5wdXNoKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChwcm9iZSAhPSBudWxsKSB7XG4gICAgLy8gRm9yIG9wdGlvbmFsIHByb2Jpbmcgb2YgbWVtb3J5IGZvb3RwcmludCBkdXJpbmcgZXhlY3V0aW9uLlxuICAgIHByb2JlLm1heE51bVRlbnNvcnMgPSAtSW5maW5pdHk7XG4gICAgcHJvYmUubWluTnVtVGVuc29ycyA9IEluZmluaXR5O1xuICB9XG5cbiAgLy8gQ2hlY2sgY2FjaGUuXG4gIGNvbnN0IGZldGNoQW5kRmVlZEtleSA9XG4gICAgICBvdXRwdXROYW1lcy5qb2luKCcsJykgKyAnfCcgKyBmZWVkRGljdC5uYW1lcygpLnNvcnQoKS5qb2luKCcsJyk7XG4gIGxldCBzb3J0ZWQ6IFN5bWJvbGljVGVuc29yW10gPSBjYWNoZWRTb3J0ZWQuZ2V0KGZldGNoQW5kRmVlZEtleSk7XG4gIGxldCByZWNpcGllbnRDb3VudHM6IHtbZmV0Y2hOYW1lOiBzdHJpbmddOiBudW1iZXJ9O1xuICBpZiAoc29ydGVkID09IG51bGwpIHtcbiAgICAvLyBDYWNoZSBkb2Vzbid0IGNvbnRhaW4gdGhlIGRlc2lyZWQgY29tYmluYXRpb24gb2YgZmV0Y2hlcy4gQ29tcHV0ZVxuICAgIC8vIHRvcG9sb2dpY2FsIHNvcnQgZm9yIHRoZSBjb21iaW5hdGlvbiBmb3IgdGhlIGZpcnN0IHRpbWUuXG4gICAgY29uc3Qgb3V0ID0gZ2V0VG9wb2xvZ2ljYWxTb3J0QW5kUmVjaXBpZW50Q291bnRzKGZldGNoQXJyYXksIGZlZWREaWN0KTtcbiAgICBzb3J0ZWQgPSBvdXQuc29ydGVkO1xuICAgIHJlY2lwaWVudENvdW50cyA9IG91dC5yZWNpcGllbnRDb3VudHM7XG5cbiAgICAvLyBTdG9yZSByZXN1bHRzIGluIGNhY2hlIGZvciBmdXR1cmUgdXNlLlxuICAgIGNhY2hlZFNvcnRlZC5wdXQoZmV0Y2hBbmRGZWVkS2V5LCBzb3J0ZWQpO1xuICAgIGNhY2hlZFJlY2lwaWVudENvdW50cy5wdXQoZmV0Y2hBbmRGZWVkS2V5LCByZWNpcGllbnRDb3VudHMpO1xuICB9XG4gIHJlY2lwaWVudENvdW50cyA9IHt9O1xuICBpZiAoIXRyYWluaW5nKSB7XG4gICAgT2JqZWN0LmFzc2lnbihyZWNpcGllbnRDb3VudHMsIGNhY2hlZFJlY2lwaWVudENvdW50cy5nZXQoZmV0Y2hBbmRGZWVkS2V5KSk7XG4gIH1cblxuICBjb25zdCBpbnRlcm5hbEZlZWREaWN0ID0gbmV3IEZlZWREaWN0KGZlZWREaWN0KTtcblxuICAvLyBTdGFydCBpdGVyYXRpdmUgZXhlY3V0aW9uIG9uIHRoZSB0b3BvbG9naWNhbGx5LXNvcnRlZCBTeW1ib2xpY1RlbnNvcnMuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgc29ydGVkLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKHByb2JlICE9IG51bGwpIHtcbiAgICAgIC8vIEZvciBvcHRpb25hbCBwcm9iaW5nIG9mIG1lbW9yeSB1c2FnZSBkdXJpbmcgZXhlY3V0aW9uLlxuICAgICAgY29uc3QgbnVtVGVuc29ycyA9IG1lbW9yeSgpLm51bVRlbnNvcnM7XG4gICAgICBpZiAobnVtVGVuc29ycyA+IHByb2JlLm1heE51bVRlbnNvcnMpIHtcbiAgICAgICAgcHJvYmUubWF4TnVtVGVuc29ycyA9IG51bVRlbnNvcnM7XG4gICAgICB9XG4gICAgICBpZiAobnVtVGVuc29ycyA8IHByb2JlLm1pbk51bVRlbnNvcnMpIHtcbiAgICAgICAgcHJvYmUubWluTnVtVGVuc29ycyA9IG51bVRlbnNvcnM7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgc3ltYm9saWMgPSBzb3J0ZWRbaV07XG4gICAgY29uc3Qgc3JjTGF5ZXIgPSBzeW1ib2xpYy5zb3VyY2VMYXllcjtcbiAgICBpZiAoc3JjTGF5ZXIgaW5zdGFuY2VvZiBJbnB1dExheWVyKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRWYWx1ZXM6IFRlbnNvcltdID0gW107XG4gICAgY29uc3QgaW5wdXRNYXNrczogVGVuc29yW10gPSBbXTtcbiAgICBjb25zdCB0ZW5zb3JzVG9EaXNwb3NlOiBUZW5zb3JbXSA9IFtdO1xuXG4gICAgbGV0IG1hc2tFeGlzdHMgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHN5bWJvbGljLmlucHV0cykge1xuICAgICAgY29uc3QgdmFsdWUgPSBpbnRlcm5hbEZlZWREaWN0LmdldFZhbHVlKGlucHV0KTtcbiAgICAgIGNvbnN0IG1hc2sgPSBpbnRlcm5hbEZlZWREaWN0LmdldE1hc2soaW5wdXQpO1xuICAgICAgaW5wdXRWYWx1ZXMucHVzaCh2YWx1ZSk7XG4gICAgICBpbnB1dE1hc2tzLnB1c2gobWFzayk7XG4gICAgICBpZiAobWFzayAhPSBudWxsKSB7XG4gICAgICAgIG1hc2tFeGlzdHMgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCF0cmFpbmluZykge1xuICAgICAgICByZWNpcGllbnRDb3VudHNbaW5wdXQubmFtZV0tLTtcbiAgICAgICAgaWYgKHJlY2lwaWVudENvdW50c1tpbnB1dC5uYW1lXSA9PT0gMCAmJiAhZmVlZERpY3QuaGFzS2V5KGlucHV0KSAmJlxuICAgICAgICAgICAgb3V0cHV0TmFtZXMuaW5kZXhPZihpbnB1dC5uYW1lKSA9PT0gLTEgJiYgIXZhbHVlLmlzRGlzcG9zZWQgJiZcbiAgICAgICAgICAgIGlucHV0LnNvdXJjZUxheWVyLnN0YXRlZnVsICE9PSB0cnVlKSB7XG4gICAgICAgICAgdGVuc29yc1RvRGlzcG9zZS5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXNrRXhpc3RzKSB7XG4gICAgICBrd2FyZ3MgPSBrd2FyZ3MgfHwge307XG4gICAgICBrd2FyZ3NbJ21hc2snXSA9IGlucHV0TWFza3NbMF07XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dFRlbnNvcnMgPVxuICAgICAgICB0b0xpc3Qoc3JjTGF5ZXIuYXBwbHkoaW5wdXRWYWx1ZXMsIGt3YXJncykpIGFzIFRlbnNvcltdO1xuICAgIGxldCBvdXRwdXRNYXNrOiBUZW5zb3J8VGVuc29yW10gPSBudWxsO1xuICAgIGlmIChzcmNMYXllci5zdXBwb3J0c01hc2tpbmcpIHtcbiAgICAgIG91dHB1dE1hc2sgPSBzcmNMYXllci5jb21wdXRlTWFzayhpbnB1dFZhbHVlcywgaW5wdXRNYXNrcyk7XG4gICAgfVxuICAgIGNvbnN0IGxheWVyT3V0cHV0cyA9IGdldE5vZGVPdXRwdXRzKHN5bWJvbGljKTtcbiAgICBjb25zdCBvdXRwdXRTeW1ib2xpY1RlbnNvcnMgPVxuICAgICAgICBBcnJheS5pc0FycmF5KGxheWVyT3V0cHV0cykgPyBsYXllck91dHB1dHMgOiBbbGF5ZXJPdXRwdXRzXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHB1dFN5bWJvbGljVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKCFpbnRlcm5hbEZlZWREaWN0Lmhhc0tleShvdXRwdXRTeW1ib2xpY1RlbnNvcnNbaV0pKSB7XG4gICAgICAgIGludGVybmFsRmVlZERpY3QuYWRkKFxuICAgICAgICAgICAgb3V0cHV0U3ltYm9saWNUZW5zb3JzW2ldLCBvdXRwdXRUZW5zb3JzW2ldLFxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvdXRwdXRNYXNrKSA/IG91dHB1dE1hc2tbMF0gOiBvdXRwdXRNYXNrKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGluZGV4ID0gb3V0cHV0TmFtZXMuaW5kZXhPZihvdXRwdXRTeW1ib2xpY1RlbnNvcnNbaV0ubmFtZSk7XG4gICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgIGZpbmFsT3V0cHV0c1tpbmRleF0gPSBvdXRwdXRUZW5zb3JzW2ldO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICghdHJhaW5pbmcpIHtcbiAgICAgIC8vIENsZWFuIHVwIFRlbnNvcnMgdGhhdCBhcmUgbm8gbG9uZ2VyIG5lZWRlZC5cbiAgICAgIGRpc3Bvc2UodGVuc29yc1RvRGlzcG9zZSk7XG4gICAgfVxuICB9XG4gIC8vIE5PVEUoY2Fpcyk6IFVubGlrZSBpbnRlcm1lZGlhdGUgdGVuc29ycywgd2UgZG9uJ3QgZGlzY2FyZCBtYXNrXG4gIC8vIHRlbnNvcnMgYXMgd2UgZ28sIGJlY2F1c2UgdGhlc2UgdGVuc29ycyBhcmUgc29tZXRpbWVzIHBhc3NlZCBvdmVyIGFcbiAgLy8gc2VyaWVzIG9mIG11dGxpcGxlIGxheWVycywgaS5lLiwgbm90IG9iZXlpbmcgdGhlIGltbWVkaWF0ZSBpbnB1dFxuICAvLyByZWxhdGlvbnMgaW4gdGhlIGdyYXBoLiBJZiB0aGlzIGJlY29tZXMgYSBtZW1vcnktdXNhZ2UgY29uY2VybixcbiAgLy8gd2UgY2FuIGltcHJvdmUgdGhpcyBpbiB0aGUgZnV0dXJlLlxuICBpbnRlcm5hbEZlZWREaWN0LmRpc3Bvc2VNYXNrcygpO1xuXG4gIHJldHVybiBhcnJheUZldGNoZXMgPyBmaW5hbE91dHB1dHMgOiBmaW5hbE91dHB1dHNbMF07XG59XG5cbnR5cGUgUmVjaXBpZW50Q291bnRzID0ge1xuICBbZmV0Y2hOYW1lOiBzdHJpbmddOiBudW1iZXJcbn07XG5cbmV4cG9ydCB0eXBlIFJlY2lwaWVudE1hcCA9IHtcbiAgW2ZldGNoTmFtZTogc3RyaW5nXTogU2V0PHN0cmluZz47XG59O1xuXG4vKipcbiAqIFNvcnQgdGhlIGBTeW1ib2xpY1RlbnNvcmBzIHRvcG9sb2dpY2FsbHksIGZvciBhbiBhcnJheSBvZiBmZXRjaGVzLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FsbHMgZ2V0VG9wb2xvZ2ljYWxTb3J0QW5kUmVjaXBpZW50Q291bnRzRm9yT25lRmV0Y2ggYW5kXG4gKiBtZXJnZXMgdGhlaXIgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0gZmV0Y2ggVGhlIGFycmF5IG9mIGZldGNoZXMgcmVxdWVzdGVkLiBNdXN0IGJlIGEgbm9uLWVtcHR5IGFycmF5LlxuICogQHBhcmFtIGZlZWREaWN0IFRoZSBkaWN0aW9uYXJ5IG9mIGZlZCB2YWx1ZXMuXG4gKiBAcmV0dXJucyBzb3J0ZWQ6IFRvcG9sb2dpY2FsbHktc29ydGVkIGFycmF5IG9mIFN5bWJvbGljVGVuc29ycy5cbiAqICAgcmVjaXBpZW50Q291bnRzOiBSZWNpcGllbnQgY291bnRzIGZvciBhbGwgU3ltYm9saWNUZW5zb3JzIGluIGBzb3J0ZWRgLlxuICovXG5mdW5jdGlvbiBnZXRUb3BvbG9naWNhbFNvcnRBbmRSZWNpcGllbnRDb3VudHMoXG4gICAgZmV0Y2hlczogU3ltYm9saWNUZW5zb3JbXSwgZmVlZERpY3Q6IEZlZWREaWN0KTpcbiAgICB7c29ydGVkOiBTeW1ib2xpY1RlbnNvcltdLCByZWNpcGllbnRDb3VudHM6IFJlY2lwaWVudENvdW50c30ge1xuICB1dGlsLmFzc2VydChcbiAgICAgIGZldGNoZXMgIT0gbnVsbCAmJiBmZXRjaGVzLmxlbmd0aCA+IDAsXG4gICAgICAoKSA9PiBgRXhwZWN0ZWQgYXQgbGVhc3Qgb25lIGZldGNoLCBnb3Qgbm9uZWApO1xuXG4gIGxldCBmaW5hbFNvcnRlZDogU3ltYm9saWNUZW5zb3JbXSA9IFtdO1xuICBsZXQgZmluYWxSZWNpcGllbnRNYXA6IFJlY2lwaWVudE1hcCA9IHt9O1xuICBpZiAoZmV0Y2hlcy5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBTcGVjaWFsLWNhc2luZyAxIGZldGNoIGZvciBlZmZpY2llbmN5LlxuICAgIGNvbnN0IG91dCA9XG4gICAgICAgIGdldFRvcG9sb2dpY2FsU29ydEFuZFJlY2lwaWVudENvdW50c0Zvck9uZUZldGNoKGZldGNoZXNbMF0sIGZlZWREaWN0KTtcbiAgICBmaW5hbFNvcnRlZCA9IG91dC5zb3J0ZWQ7XG4gICAgZmluYWxSZWNpcGllbnRNYXAgPSBvdXQucmVjaXBpZW50TWFwO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICBmb3IgKGNvbnN0IGZldGNoIG9mIGZldGNoZXMpIHtcbiAgICAgIGNvbnN0IHtzb3J0ZWQsIHJlY2lwaWVudE1hcH0gPVxuICAgICAgICAgIGdldFRvcG9sb2dpY2FsU29ydEFuZFJlY2lwaWVudENvdW50c0Zvck9uZUZldGNoKGZldGNoLCBmZWVkRGljdCk7XG5cbiAgICAgIC8vIE1lcmdlIHNvcnRlZCBTeW1ib2xpY1RlbnNvciBBcnJheXMuXG4gICAgICBmb3IgKGNvbnN0IHN5bWJvbGljVGVuc29yIG9mIHNvcnRlZCkge1xuICAgICAgICBpZiAoIXZpc2l0ZWQuaGFzKHN5bWJvbGljVGVuc29yLm5hbWUpKSB7XG4gICAgICAgICAgZmluYWxTb3J0ZWQucHVzaChzeW1ib2xpY1RlbnNvcik7XG4gICAgICAgICAgdmlzaXRlZC5hZGQoc3ltYm9saWNUZW5zb3IubmFtZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gTWVyZ2UgcmVjaXBpZW50IG1hcHMuXG4gICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gcmVjaXBpZW50TWFwKSB7XG4gICAgICAgIGlmIChmaW5hbFJlY2lwaWVudE1hcFtuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgZmluYWxSZWNpcGllbnRNYXBbbmFtZV0gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgfVxuICAgICAgICByZWNpcGllbnRNYXBbbmFtZV0uZm9yRWFjaChcbiAgICAgICAgICAgIHJlY2lwaWVudCA9PiBmaW5hbFJlY2lwaWVudE1hcFtuYW1lXS5hZGQocmVjaXBpZW50KSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc29ydGVkOiBmaW5hbFNvcnRlZCxcbiAgICByZWNpcGllbnRDb3VudHM6IHJlY2lwaWVudE1hcDJDb3VudHMoZmluYWxSZWNpcGllbnRNYXApXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlY2lwaWVudE1hcDJDb3VudHMocmVjaXBpZW50TWFwOiBSZWNpcGllbnRNYXApOiBSZWNpcGllbnRDb3VudHMge1xuICBjb25zdCByZWNpcGllbnRDb3VudHM6IFJlY2lwaWVudENvdW50cyA9IHt9O1xuICBmb3IgKGNvbnN0IG5hbWUgaW4gcmVjaXBpZW50TWFwKSB7XG4gICAgcmVjaXBpZW50Q291bnRzW25hbWVdID0gcmVjaXBpZW50TWFwW25hbWVdLnNpemU7XG4gIH1cbiAgcmV0dXJuIHJlY2lwaWVudENvdW50cztcbn1cblxuLyoqXG4gKiBTb3J0IHRoZSBgU3ltYm9saWNUZW5zb3JgcyB0b3BvbG9naWNhbGx5LCBmb3IgYSBzaW5nbGUgZmV0Y2guXG4gKlxuICogVGhpcyBoZWxwZXIgZnVuY3Rpb24gcHJvY2Vzc2VzIHRoZSB1cHN0cmVhbSBTeW1ib2xpY1RlbnNvcnMgb2YgYSBzaW5nbGVcbiAqIGZldGNoLlxuICpcbiAqIEBwYXJhbSBmZXRjaCBUaGUgc2luZ2xlIGZldGNoIHJlcXVlc3RlZC5cbiAqIEBwYXJhbSBmZWVkRGljdCBUaGUgZGljdGlvbmFyeSBvZiBmZWQgdmFsdWVzLlxuICogQHJldHVybnMgc29ydGVkOiBUb3BvbG9naWNhbGx5LXNvcnRlZCBhcnJheSBvZiBTeW1ib2xpY1RlbnNvcnMuXG4gKiAgIHJlY2lwaWVudE1hcDogUmVjaXBpZW50IG5hbWVzIGZvciBhbGwgU3ltYm9saWNUZW5zb3JzIGluIGBzb3J0ZWRgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0VG9wb2xvZ2ljYWxTb3J0QW5kUmVjaXBpZW50Q291bnRzRm9yT25lRmV0Y2goXG4gICAgZmV0Y2g6IFN5bWJvbGljVGVuc29yLCBmZWVkRGljdDogRmVlZERpY3QpOlxuICAgIHtzb3J0ZWQ6IFN5bWJvbGljVGVuc29yW10sIHJlY2lwaWVudE1hcDogUmVjaXBpZW50TWFwfSB7XG4gIGNvbnN0IHZpc2l0ZWQgPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgY29uc3Qgc29ydGVkOiBTeW1ib2xpY1RlbnNvcltdID0gW107XG4gIGNvbnN0IHJlY2lwaWVudE1hcDogUmVjaXBpZW50TWFwID0ge307XG5cbiAgLy8gUHV0IGtleXMgb2YgdGhlIGZlZWREaWN0IGludG8gdmlzaXRlZCBmaXJzdCwgc28gdGhleSBkb24ndCBoYXZlIHRvIGJlXG4gIC8vIHdhbGtlZC4gVGhpcyBpcyBuZWVkZWQgaW4gY2FzZSB3aGVyZSB0aGVyZSBhcmUgZmVlZHMgZm9yIGludGVybWVkaWF0ZVxuICAvLyBTeW1ib2xpY1RlbnNvcnMgb2YgdGhlIGdyYXBoLlxuICBmb3IgKGNvbnN0IGtleSBvZiBmZWVkRGljdC5uYW1lcygpKSB7XG4gICAgdmlzaXRlZC5hZGQoa2V5KTtcbiAgfVxuXG4gIGNvbnN0IHN0YWNrOiBTeW1ib2xpY1RlbnNvcltdID0gW107XG4gIGNvbnN0IG1hcmtzOiBudW1iZXJbXSA9IFtdO1xuXG4gIC8vIEluaXRpYWwgcG9wdWxhdGlvbiBvZiBzdGFjayBhbmQgbWFya3MuXG4gIHN0YWNrLnB1c2goZmV0Y2gpO1xuXG4gIHdoaWxlIChzdGFjay5sZW5ndGggPiAwKSB7XG4gICAgY29uc3QgdG9wID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgaWYgKHZpc2l0ZWQuaGFzKHRvcC5uYW1lKSkge1xuICAgICAgc3RhY2sucG9wKCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgdG9wSXNNYXJrZWQgPSBtYXJrc1ttYXJrcy5sZW5ndGggLSAxXSA9PT0gc3RhY2subGVuZ3RoIC0gMTtcbiAgICBpZiAodG9wLmlucHV0cy5sZW5ndGggPT09IDAgfHwgdG9wSXNNYXJrZWQpIHtcbiAgICAgIC8vIElucHV0IFN5bWJvbGljVGVuc29yIG9yIGFsbCBjaGlsZHJlbiBoYXZlIGJlZW4gdmlzaXRlZC5cbiAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgc29ydGVkLnB1c2godG9wKTtcbiAgICAgIHZpc2l0ZWQuYWRkKHRvcC5uYW1lKTtcbiAgICAgIGlmICh0b3BJc01hcmtlZCkge1xuICAgICAgICBtYXJrcy5wb3AoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gQSBub24taW5wdXQgU3ltYm9saWNUZW5zb3Igd2hvc2UgdXBzdHJlYW0gU3ltYm9saWNUZW5zb3JzIGhhdmVuJ3RcbiAgICAgIC8vIGJlZW4gdmlzaXRlZCB5ZXQuIFB1c2ggdGhlbSBvbnRvIHRoZSBzdGFjay5cbiAgICAgIG1hcmtzLnB1c2goc3RhY2subGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHRvcC5pbnB1dHMpIHtcbiAgICAgICAgLy8gSW5jcmVtZW50IHRoZSByZWNpcGllbnQgY291bnQuIE5vdGUgdGhhdCB0aGlzIG5lZWRzIHRvIGhhcHBlblxuICAgICAgICAvLyByZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhlIFN5bWJvbGljVGVuc29yIGhhcyBiZWVuIHZpc2l0ZWQgYmVmb3JlLlxuICAgICAgICBpZiAocmVjaXBpZW50TWFwW2lucHV0Lm5hbWVdID09IG51bGwpIHtcbiAgICAgICAgICByZWNpcGllbnRNYXBbaW5wdXQubmFtZV0gPSBuZXcgU2V0PHN0cmluZz4oKTtcbiAgICAgICAgfVxuICAgICAgICByZWNpcGllbnRNYXBbaW5wdXQubmFtZV0uYWRkKHRvcC5uYW1lKTtcblxuICAgICAgICBpZiAodmlzaXRlZC5oYXMoaW5wdXQubmFtZSkpIHtcbiAgICAgICAgICBjb250aW51ZTsgIC8vIEF2b2lkIHJlcGVhdGVkIHZpc2l0cyB0byB0aGUgc2FtZSBTeW1ib2xpY1RlbnNvci5cbiAgICAgICAgfVxuICAgICAgICBzdGFjay5wdXNoKGlucHV0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHtzb3J0ZWQsIHJlY2lwaWVudE1hcH07XG59XG5cbi8qKlxuICogR2V0IHRoZSBzeW1ib2xpYyBvdXRwdXQgdGVuc29ycyBvZiB0aGUgbm9kZSB0byB3aGljaCBhIGdpdmVuIGZldGNoIGJlbG9uZ3MuXG4gKiBAcGFyYW0gZmV0Y2ggVGhlIGZldGNoZWQgc3ltYm9saWMgdGVuc29yLlxuICogQHJldHVybnMgVGhlIEFycmF5IG9mIHN5bWJvbGljIHRlbnNvcnMgb3V0cHV0IGJ5IHRoZSBub2RlIHRvIHdoaWNoIGBmZXRjaGBcbiAqICAgYmVsb25ncy5cbiAqL1xuZnVuY3Rpb24gZ2V0Tm9kZU91dHB1dHMoZmV0Y2g6IFN5bWJvbGljVGVuc29yKTogU3ltYm9saWNUZW5zb3J8XG4gICAgU3ltYm9saWNUZW5zb3JbXSB7XG4gIGxldCBsYXllck91dHB1dHM6IFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW107XG4gIGlmIChmZXRjaC5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgbGF5ZXJPdXRwdXRzID0gZmV0Y2guc291cmNlTGF5ZXIub3V0cHV0O1xuICB9IGVsc2Uge1xuICAgIGxldCBub2RlSW5kZXg6IG51bWJlciA9IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBmZXRjaC5zb3VyY2VMYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGZvciAoY29uc3Qgb3V0cHV0VGVuc29yIG9mIGZldGNoLnNvdXJjZUxheWVyLmluYm91bmROb2Rlc1tpXVxuICAgICAgICAgICAgICAgLm91dHB1dFRlbnNvcnMpIHtcbiAgICAgICAgaWYgKG91dHB1dFRlbnNvci5pZCA9PT0gZmV0Y2guaWQpIHtcbiAgICAgICAgICBub2RlSW5kZXggPSBpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGxheWVyT3V0cHV0cyA9IGZldGNoLnNvdXJjZUxheWVyLmdldE91dHB1dEF0KG5vZGVJbmRleCk7XG4gIH1cbiAgcmV0dXJuIGxheWVyT3V0cHV0cztcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2022 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { env } from '@tensorflow/tfjs-core';\nimport { updateCacheMaxEntries } from './engine/executor';\nexport const ENV = env();\n/** The max number of entries for the caches of layers' topological sort. */\nENV.registerFlag('TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES', () => 100, updateCacheMaxEntries);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmxhZ3NfbGF5ZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2ZsYWdzX2xheWVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQUMsR0FBRyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFMUMsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFeEQsTUFBTSxDQUFDLE1BQU0sR0FBRyxHQUFHLEdBQUcsRUFBRSxDQUFDO0FBRXpCLDRFQUE0RTtBQUM1RSxHQUFHLENBQUMsWUFBWSxDQUNaLG9DQUFvQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEdBQUcsRUFBRSxxQkFBcUIsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjIgR29vZ2xlIExMQy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG5pbXBvcnQge2Vudn0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHt1cGRhdGVDYWNoZU1heEVudHJpZXN9IGZyb20gJy4vZW5naW5lL2V4ZWN1dG9yJztcblxuZXhwb3J0IGNvbnN0IEVOViA9IGVudigpO1xuXG4vKiogVGhlIG1heCBudW1iZXIgb2YgZW50cmllcyBmb3IgdGhlIGNhY2hlcyBvZiBsYXllcnMnIHRvcG9sb2dpY2FsIHNvcnQuICovXG5FTlYucmVnaXN0ZXJGbGFnKFxuICAgICdUT1BPTE9HSUNBTF9TT1JUX0NBQ0hFX01BWF9FTlRSSUVTJywgKCkgPT4gMTAwLCB1cGRhdGVDYWNoZU1heEVudHJpZXMpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/contraints.py */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { epsilon } from './backend/common';\nimport { deserializeKerasObject, serializeKerasObject } from './utils/generic_utils';\n/**\n * Helper function used by many of the Constraints to find the L2Norms.\n */\nfunction calcL2Norms(w, axis) {\n    return tidy(() => tfc.sqrt(tfc.sum(tfc.mul(w, w), axis, true)));\n}\n/**\n * Base class for functions that impose constraints on weight values\n *\n * @doc {\n *   heading: 'Constraints',\n *   subheading: 'Classes',\n *   namespace: 'constraints'\n * }\n */\nexport class Constraint extends serialization.Serializable {\n    getConfig() {\n        return {};\n    }\n}\nexport class MaxNorm extends Constraint {\n    constructor(args) {\n        super();\n        this.defaultMaxValue = 2;\n        this.defaultAxis = 0;\n        this.maxValue =\n            args.maxValue != null ? args.maxValue : this.defaultMaxValue;\n        this.axis = args.axis != null ? args.axis : this.defaultAxis;\n    }\n    apply(w) {\n        return tidy(() => {\n            const norms = calcL2Norms(w, this.axis);\n            const desired = tfc.clipByValue(norms, 0, this.maxValue);\n            return tfc.mul(w, tfc.div(desired, tfc.add(epsilon(), norms)));\n        });\n    }\n    getConfig() {\n        return { maxValue: this.maxValue, axis: this.axis };\n    }\n}\n/** @nocollapse */\nMaxNorm.className = 'MaxNorm';\nserialization.registerClass(MaxNorm);\nexport class UnitNorm extends Constraint {\n    constructor(args) {\n        super();\n        this.defaultAxis = 0;\n        this.axis = args.axis != null ? args.axis : this.defaultAxis;\n    }\n    apply(w) {\n        return tidy(() => tfc.div(w, tfc.add(epsilon(), calcL2Norms(w, this.axis))));\n    }\n    getConfig() {\n        return { axis: this.axis };\n    }\n}\n/** @nocollapse */\nUnitNorm.className = 'UnitNorm';\nserialization.registerClass(UnitNorm);\nexport class NonNeg extends Constraint {\n    apply(w) {\n        return tfc.relu(w);\n    }\n}\n/** @nocollapse */\nNonNeg.className = 'NonNeg';\nserialization.registerClass(NonNeg);\nexport class MinMaxNorm extends Constraint {\n    constructor(args) {\n        super();\n        this.defaultMinValue = 0.0;\n        this.defaultMaxValue = 1.0;\n        this.defaultRate = 1.0;\n        this.defaultAxis = 0;\n        this.minValue =\n            args.minValue != null ? args.minValue : this.defaultMinValue;\n        this.maxValue =\n            args.maxValue != null ? args.maxValue : this.defaultMaxValue;\n        this.rate = args.rate != null ? args.rate : this.defaultRate;\n        this.axis = args.axis != null ? args.axis : this.defaultAxis;\n    }\n    apply(w) {\n        return tidy(() => {\n            const norms = calcL2Norms(w, this.axis);\n            const desired = tfc.add(tfc.mul(this.rate, tfc.clipByValue(norms, this.minValue, this.maxValue)), tfc.mul(1.0 - this.rate, norms));\n            return tfc.mul(w, tfc.div(desired, tfc.add(epsilon(), norms)));\n        });\n    }\n    getConfig() {\n        return {\n            minValue: this.minValue,\n            maxValue: this.maxValue,\n            rate: this.rate,\n            axis: this.axis\n        };\n    }\n}\n/** @nocollapse */\nMinMaxNorm.className = 'MinMaxNorm';\nserialization.registerClass(MinMaxNorm);\n// Maps the JavaScript-like identifier keys to the corresponding registry\n// symbols.\nexport const CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP = {\n    'maxNorm': 'MaxNorm',\n    'minMaxNorm': 'MinMaxNorm',\n    'nonNeg': 'NonNeg',\n    'unitNorm': 'UnitNorm'\n};\nexport function serializeConstraint(constraint) {\n    return serializeKerasObject(constraint);\n}\nexport function deserializeConstraint(config, customObjects = {}) {\n    return deserializeKerasObject(config, serialization.SerializationMap.getMap().classNameMap, customObjects, 'constraint');\n}\nexport function getConstraint(identifier) {\n    if (identifier == null) {\n        return null;\n    }\n    if (typeof identifier === 'string') {\n        const className = identifier in CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP ?\n            CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :\n            identifier;\n        const config = { className, config: {} };\n        return deserializeConstraint(config);\n    }\n    else if (identifier instanceof Constraint) {\n        return identifier;\n    }\n    else {\n        return deserializeConstraint(identifier);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29uc3RyYWludHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvY29uc3RyYWludHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFFSCwwQ0FBMEM7QUFFMUMsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsYUFBYSxFQUFVLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ2xFLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUN6QyxPQUFPLEVBQUMsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVuRjs7R0FFRztBQUNILFNBQVMsV0FBVyxDQUFDLENBQVMsRUFBRSxJQUFZO0lBQzFDLE9BQU8sSUFBSSxDQUFDLEdBQUcsRUFBRSxDQUFDLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsQ0FBQyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO0FBQ2xFLENBQUM7QUFFRDs7Ozs7Ozs7R0FRRztBQUNILE1BQU0sT0FBZ0IsVUFBVyxTQUFRLGFBQWEsQ0FBQyxZQUFZO0lBR2pFLFNBQVM7UUFDUCxPQUFPLEVBQUUsQ0FBQztJQUNaLENBQUM7Q0FDRjtBQXdCRCxNQUFNLE9BQU8sT0FBUSxTQUFRLFVBQVU7SUFRckMsWUFBWSxJQUFpQjtRQUMzQixLQUFLLEVBQUUsQ0FBQztRQUpPLG9CQUFlLEdBQUcsQ0FBQyxDQUFDO1FBQ3BCLGdCQUFXLEdBQUcsQ0FBQyxDQUFDO1FBSS9CLElBQUksQ0FBQyxRQUFRO1lBQ1QsSUFBSSxDQUFDLFFBQVEsSUFBSSxJQUFJLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsQ0FBQyxDQUFDLElBQUksQ0FB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QUFVLEVBQUU7UUFDM0MsT0FBTyxVQUFVLENBQUM7S0FDbkI7U0FBTTtRQUNMLE9BQU8scUJBQXFCLENBQUMsVUFBVSxDQUFDLENBQUM7S0FDMUM7QUFDSCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyogT3JpZ2luYWwgc291cmNlOiBrZXJhcy9jb250cmFpbnRzLnB5ICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtzZXJpYWxpemF0aW9uLCBUZW5zb3IsIHRpZHl9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge2Vwc2lsb259IGZyb20gJy4vYmFja2VuZC9jb21tb24nO1xuaW1wb3J0IHtkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0LCBzZXJpYWxpemVLZXJhc09iamVjdH0gZnJvbSAnLi91dGlscy9nZW5lcmljX3V0aWxzJztcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCBieSBtYW55IG9mIHRoZSBDb25zdHJhaW50cyB0byBmaW5kIHRoZSBMMk5vcm1zLlxuICovXG5mdW5jdGlvbiBjYWxjTDJOb3Jtcyh3OiBUZW5zb3IsIGF4aXM6IG51bWJlcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHRmYy5zcXJ0KHRmYy5zdW0odGZjLm11bCh3LCB3KSwgYXhpcywgdHJ1ZSkpKTtcbn1cblxuLyoqXG4gKiBCYXNlIGNsYXNzIGZvciBmdW5jdGlvbnMgdGhhdCBpbXBvc2UgY29uc3RyYWludHMgb24gd2VpZ2h0IHZhbHVlc1xuICpcbiAqIEBkb2Mge1xuICogICBoZWFkaW5nOiAnQ29uc3RyYWludHMnLFxuICogICBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsXG4gKiAgIG5hbWVzcGFjZTogJ2NvbnN0cmFpbnRzJ1xuICogfVxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29uc3RyYWludCBleHRlbmRzIHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlIHtcbiAgLyogUG9ydGluZyBub3RlOiB3YXMgX19jYWxsX18sIGFwcGx5IGNob3NlbiB0byBtYXRjaCBvdGhlciBzaW1pbGFyIGNob2ljZXMgKi9cbiAgYWJzdHJhY3QgYXBwbHkodzogVGVuc29yKTogVGVuc29yO1xuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICByZXR1cm4ge307XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNYXhOb3JtQXJncyB7XG4gIC8qKlxuICAgKiBNYXhpbXVtIG5vcm0gZm9yIGluY29taW5nIHdlaWdodHNcbiAgICovXG4gIG1heFZhbHVlPzogbnVtYmVyO1xuICAvKipcbiAgICogQXhpcyBhbG9uZyB3aGljaCB0byBjYWxjdWxhdGUgbm9ybXMuXG4gICAqXG4gICAqICBGb3IgaW5zdGFuY2UsIGluIGEgYERlbnNlYCBsYXllciB0aGUgd2VpZ2h0IG1hdHJpeFxuICAgKiAgaGFzIHNoYXBlIGBbaW5wdXREaW0sIG91dHB1dERpbV1gLFxuICAgKiAgc2V0IGBheGlzYCB0byBgMGAgdG8gY29uc3RyYWluIGVhY2ggd2VpZ2h0IHZlY3RvclxuICAgKiAgb2YgbGVuZ3RoIGBbaW5wdXREaW0sXWAuXG4gICAqICBJbiBhIGBDb252MkRgIGxheWVyIHdpdGggYGRhdGFGb3JtYXQ9XCJjaGFubmVsc19sYXN0XCJgLFxuICAgKiAgdGhlIHdlaWdodCB0ZW5zb3IgaGFzIHNoYXBlXG4gICAqICBgW3Jvd3MsIGNvbHMsIGlucHV0RGVwdGgsIG91dHB1dERlcHRoXWAsXG4gICAqICBzZXQgYGF4aXNgIHRvIGBbMCwgMSwgMl1gXG4gICAqICB0byBjb25zdHJhaW4gdGhlIHdlaWdodHMgb2YgZWFjaCBmaWx0ZXIgdGVuc29yIG9mIHNpemVcbiAgICogIGBbcm93cywgY29scywgaW5wdXREZXB0aF1gLlxuICAgKi9cbiAgYXhpcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIE1heE5vcm0gZXh0ZW5kcyBDb25zdHJhaW50IHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyByZWFkb25seSBjbGFzc05hbWUgPSAnTWF4Tm9ybSc7XG4gIHByaXZhdGUgbWF4VmFsdWU6IG51bWJlcjtcbiAgcHJpdmF0ZSBheGlzOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdE1heFZhbHVlID0gMjtcbiAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0QXhpcyA9IDA7XG5cbiAgY29uc3RydWN0b3IoYXJnczogTWF4Tm9ybUFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubWF4VmFsdWUgPVxuICAgICAgICBhcmdzLm1heFZhbHVlICE9IG51bGwgPyBhcmdzLm1heFZhbHVlIDogdGhpcy5kZWZhdWx0TWF4VmFsdWU7XG4gICAgdGhpcy5heGlzID0gYXJncy5heGlzICE9IG51bGwgPyBhcmdzLmF4aXMgOiB0aGlzLmRlZmF1bHRBeGlzO1xuICB9XG5cbiAgYXBwbHkodzogVGVuc29yKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBub3JtcyA9IGNhbGNMMk5vcm1zKHcsIHRoaXMuYXhpcyk7XG4gICAgICBjb25zdCBkZXNpcmVkID0gdGZjLmNsaXBCeVZhbHVlKG5vcm1zLCAwLCB0aGlzLm1heFZhbHVlKTtcbiAgICAgIHJldHVybiB0ZmMubXVsKHcsIHRmYy5kaXYoZGVzaXJlZCwgdGZjLmFkZChlcHNpbG9uKCksIG5vcm1zKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgcmV0dXJuIHttYXhWYWx1ZTogdGhpcy5tYXhWYWx1ZSwgYXhpczogdGhpcy5heGlzfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heE5vcm0pO1xuXG5leHBvcnQgaW50ZXJmYWNlIFVuaXROb3JtQXJncyB7XG4gIC8qKlxuICAgKiBBeGlzIGFsb25nIHdoaWNoIHRvIGNhbGN1bGF0ZSBub3Jtcy5cbiAgICpcbiAgICogRm9yIGluc3RhbmNlLCBpbiBhIGBEZW5zZWAgbGF5ZXIgdGhlIHdlaWdodCBtYXRyaXhcbiAgICogaGFzIHNoYXBlIGBbaW5wdXREaW0sIG91dHB1dERpbV1gLFxuICAgKiBzZXQgYGF4aXNgIHRvIGAwYCB0byBjb25zdHJhaW4gZWFjaCB3ZWlnaHQgdmVjdG9yXG4gICAqIG9mIGxlbmd0aCBgW2lucHV0RGltLF1gLlxuICAgKiBJbiBhIGBDb252MkRgIGxheWVyIHdpdGggYGRhdGFGb3JtYXQ9XCJjaGFubmVsc19sYXN0XCJgLFxuICAgKiB0aGUgd2VpZ2h0IHRlbnNvciBoYXMgc2hhcGVcbiAgICogW3Jvd3MsIGNvbHMsIGlucHV0RGVwdGgsIG91dHB1dERlcHRoXWAsXG4gICAqIHNldCBgYXhpc2AgdG8gYFswLCAxLCAyXWBcbiAgICogdG8gY29uc3RyYWluIHRoZSB3ZWlnaHRzIG9mIGVhY2ggZmlsdGVyIHRlbnNvciBvZiBzaXplXG4gICAqIGBbcm93cywgY29scywgaW5wdXREZXB0aF1gLlxuICAgKi9cbiAgYXhpcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFVuaXROb3JtIGV4dGVuZHMgQ29uc3RyYWludCB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ1VuaXROb3JtJztcbiAgcHJpdmF0ZSBheGlzOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdEF4aXMgPSAwO1xuICBjb25zdHJ1Y3RvcihhcmdzOiBVbml0Tm9ybUFyZ3MpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuYXhpcyA9IGFyZ3MuYXhpcyAhPSBudWxsID8gYXJncy5heGlzIDogdGhpcy5kZWZhdWx0QXhpcztcbiAgfVxuXG4gIGFwcGx5KHc6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRpZHkoXG4gICAgICAgICgpID0+IHRmYy5kaXYodywgdGZjLmFkZChlcHNpbG9uKCksIGNhbGNMMk5vcm1zKHcsIHRoaXMuYXhpcykpKSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICByZXR1cm4ge2F4aXM6IHRoaXMuYXhpc307XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhVbml0Tm9ybSk7XG5cbmV4cG9ydCBjbGFzcyBOb25OZWcgZXh0ZW5kcyBDb25zdHJhaW50IHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyByZWFkb25seSBjbGFzc05hbWUgPSAnTm9uTmVnJztcblxuICBhcHBseSh3OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0ZmMucmVsdSh3KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE5vbk5lZyk7XG5cbmV4cG9ydCBpbnRlcmZhY2UgTWluTWF4Tm9ybUFyZ3Mge1xuICAvKipcbiAgICogTWluaW11bSBub3JtIGZvciBpbmNvbWluZyB3ZWlnaHRzXG4gICAqL1xuICBtaW5WYWx1ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIE1heGltdW0gbm9ybSBmb3IgaW5jb21pbmcgd2VpZ2h0c1xuICAgKi9cbiAgbWF4VmFsdWU/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBBeGlzIGFsb25nIHdoaWNoIHRvIGNhbGN1bGF0ZSBub3Jtcy5cbiAgICogRm9yIGluc3RhbmNlLCBpbiBhIGBEZW5zZWAgbGF5ZXIgdGhlIHdlaWdodCBtYXRyaXhcbiAgICogaGFzIHNoYXBlIGBbaW5wdXREaW0sIG91dHB1dERpbV1gLFxuICAgKiBzZXQgYGF4aXNgIHRvIGAwYCB0byBjb25zdHJhaW4gZWFjaCB3ZWlnaHQgdmVjdG9yXG4gICAqIG9mIGxlbmd0aCBgW2lucHV0RGltLF1gLlxuICAgKiBJbiBhIGBDb252MkRgIGxheWVyIHdpdGggYGRhdGFGb3JtYXQ9XCJjaGFubmVsc19sYXN0XCJgLFxuICAgKiB0aGUgd2VpZ2h0IHRlbnNvciBoYXMgc2hhcGVcbiAgICogYFtyb3dzLCBjb2xzLCBpbnB1dERlcHRoLCBvdXRwdXREZXB0aF1gLFxuICAgKiBzZXQgYGF4aXNgIHRvIGBbMCwgMSwgMl1gXG4gICAqIHRvIGNvbnN0cmFpbiB0aGUgd2VpZ2h0cyBvZiBlYWNoIGZpbHRlciB0ZW5zb3Igb2Ygc2l6ZVxuICAgKiBgW3Jvd3MsIGNvbHMsIGlucHV0RGVwdGhdYC5cbiAgICovXG4gIGF4aXM/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBSYXRlIGZvciBlbmZvcmNpbmcgdGhlIGNvbnN0cmFpbnQ6IHdlaWdodHMgd2lsbCBiZSByZXNjYWxlZCB0byB5aWVsZDpcbiAgICogYCgxIC0gcmF0ZSkgKiBub3JtICsgcmF0ZSAqIG5vcm0uY2xpcChtaW5WYWx1ZSwgbWF4VmFsdWUpYC5cbiAgICogRWZmZWN0aXZlbHksIHRoaXMgbWVhbnMgdGhhdCByYXRlPTEuMCBzdGFuZHMgZm9yIHN0cmljdFxuICAgKiBlbmZvcmNlbWVudCBvZiB0aGUgY29uc3RyYWludCwgd2hpbGUgcmF0ZTwxLjAgbWVhbnMgdGhhdFxuICAgKiB3ZWlnaHRzIHdpbGwgYmUgcmVzY2FsZWQgYXQgZWFjaCBzdGVwIHRvIHNsb3dseSBtb3ZlXG4gICAqIHRvd2FyZHMgYSB2YWx1ZSBpbnNpZGUgdGhlIGRlc2lyZWQgaW50ZXJ2YWwuXG4gICAqL1xuICByYXRlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgTWluTWF4Tm9ybSBleHRlbmRzIENvbnN0cmFpbnQge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIHJlYWRvbmx5IGNsYXNzTmFtZSA9ICdNaW5NYXhOb3JtJztcbiAgcHJpdmF0ZSBtaW5WYWx1ZTogbnVtYmVyO1xuICBwcml2YXRlIG1heFZhbHVlOiBudW1iZXI7XG4gIHByaXZhdGUgcmF0ZTogbnVtYmVyO1xuICBwcml2YXRlIGF4aXM6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBkZWZhdWx0TWluVmFsdWUgPSAwLjA7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVmYXVsdE1heFZhbHVlID0gMS4wO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRSYXRlID0gMS4wO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlZmF1bHRBeGlzID0gMDtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBNaW5NYXhOb3JtQXJncykge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5taW5WYWx1ZSA9XG4gICAgICAgIGFyZ3MubWluVmFsdWUgIT0gbnVsbCA/IGFyZ3MubWluVmFsdWUgOiB0aGlzLmRlZmF1bHRNaW5WYWx1ZTtcbiAgICB0aGlzLm1heFZhbHVlID1cbiAgICAgICAgYXJncy5tYXhWYWx1ZSAhPSBudWxsID8gYXJncy5tYXhWYWx1ZSA6IHRoaXMuZGVmYXVsdE1heFZhbHVlO1xuICAgIHRoaXMucmF0ZSA9IGFyZ3MucmF0ZSAhPSBudWxsID8gYXJncy5yYXRlIDogdGhpcy5kZWZhdWx0UmF0ZTtcbiAgICB0aGlzLmF4aXMgPSBhcmdzLmF4aXMgIT0gbnVsbCA/IGFyZ3MuYXhpcyA6IHRoaXMuZGVmYXVsdEF4aXM7XG4gIH1cblxuICBhcHBseSh3OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IG5vcm1zID0gY2FsY0wyTm9ybXModywgdGhpcy5heGlzKTtcbiAgICAgIGNvbnN0IGRlc2lyZWQgPSB0ZmMuYWRkKFxuICAgICAgICAgIHRmYy5tdWwoXG4gICAgICAgICAgICAgIHRoaXMucmF0ZSwgdGZjLmNsaXBCeVZhbHVlKG5vcm1zLCB0aGlzLm1pblZhbHVlLCB0aGlzLm1heFZhbHVlKSksXG4gICAgICAgICAgdGZjLm11bCgxLjAgLSB0aGlzLnJhdGUsIG5vcm1zKSk7XG4gICAgICByZXR1cm4gdGZjLm11bCh3LCB0ZmMuZGl2KGRlc2lyZWQsIHRmYy5hZGQoZXBzaWxvbigpLCBub3JtcykpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIHJldHVybiB7XG4gICAgICBtaW5WYWx1ZTogdGhpcy5taW5WYWx1ZSxcbiAgICAgIG1heFZhbHVlOiB0aGlzLm1heFZhbHVlLFxuICAgICAgcmF0ZTogdGhpcy5yYXRlLFxuICAgICAgYXhpczogdGhpcy5heGlzXG4gICAgfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1pbk1heE5vcm0pO1xuXG4vKiogQGRvY2lubGluZSAqL1xuZXhwb3J0IHR5cGUgQ29uc3RyYWludElkZW50aWZpZXIgPVxuICAgICdtYXhOb3JtJ3wnbWluTWF4Tm9ybSd8J25vbk5lZyd8J3VuaXROb3JtJ3xzdHJpbmc7XG5cbi8vIE1hcHMgdGhlIEphdmFTY3JpcHQtbGlrZSBpZGVudGlmaWVyIGtleXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcmVnaXN0cnlcbi8vIHN5bWJvbHMuXG5leHBvcnQgY29uc3QgQ09OU1RSQUlOVF9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA6XG4gICAge1tpZGVudGlmaWVyIGluIENvbnN0cmFpbnRJZGVudGlmaWVyXTogc3RyaW5nfSA9IHtcbiAgICAgICdtYXhOb3JtJzogJ01heE5vcm0nLFxuICAgICAgJ21pbk1heE5vcm0nOiAnTWluTWF4Tm9ybScsXG4gICAgICAnbm9uTmVnJzogJ05vbk5lZycsXG4gICAgICAndW5pdE5vcm0nOiAnVW5pdE5vcm0nXG4gICAgfTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUNvbnN0cmFpbnQoY29uc3RyYWludDogQ29uc3RyYWludCk6XG4gICAgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0VmFsdWUge1xuICByZXR1cm4gc2VyaWFsaXplS2VyYXNPYmplY3QoY29uc3RyYWludCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZUNvbnN0cmFpbnQoXG4gICAgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QsXG4gICAgY3VzdG9tT2JqZWN0czogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge30pOiBDb25zdHJhaW50IHtcbiAgcmV0dXJuIGRlc2VyaWFsaXplS2VyYXNPYmplY3QoXG4gICAgICBjb25maWcsIHNlcmlhbGl6YXRpb24uU2VyaWFsaXphdGlvbk1hcC5nZXRNYXAoKS5jbGFzc05hbWVNYXAsXG4gICAgICBjdXN0b21PYmplY3RzLCAnY29uc3RyYWludCcpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Q29uc3RyYWludChpZGVudGlmaWVyOiBDb25zdHJhaW50SWRlbnRpZmllcnxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdHxDb25zdHJhaW50KTogQ29uc3RyYWludCB7XG4gIGlmIChpZGVudGlmaWVyID09IG51bGwpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY2xhc3NOYW1lID0gaWRlbnRpZmllciBpbiBDT05TVFJBSU5UX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUCA/XG4gICAgICAgIENPTlNUUkFJTlRfSURFTlRJRklFUl9SRUdJU1RSWV9TWU1CT0xfTUFQW2lkZW50aWZpZXJdIDpcbiAgICAgICAgaWRlbnRpZmllcjtcbiAgICBjb25zdCBjb25maWcgPSB7Y2xhc3NOYW1lLCBjb25maWc6IHt9fTtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVDb25zdHJhaW50KGNvbmZpZyk7XG4gIH0gZWxzZSBpZiAoaWRlbnRpZmllciBpbnN0YW5jZW9mIENvbnN0cmFpbnQpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVDb25zdHJhaW50KGlkZW50aWZpZXIpO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { dispose } from '@tensorflow/tfjs-core';\n/**\n * Turn any Scalar values in a Logs object into actual number values.\n *\n * @param logs The `Logs` object to be resolved in place.\n */\nexport async function resolveScalarsInLogs(logs) {\n    if (logs == null) {\n        return;\n    }\n    const promises = [];\n    const keys = [];\n    const scalarsToDispose = [];\n    for (const key in logs) {\n        const value = logs[key];\n        if (typeof value !== 'number') {\n            const valueScalar = value;\n            promises.push(valueScalar.data());\n            keys.push(key);\n            scalarsToDispose.push(valueScalar);\n        }\n    }\n    if (promises.length > 0) {\n        const values = await Promise.all(promises);\n        for (let i = 0; i < values.length; ++i) {\n            logs[keys[i]] = values[i][0];\n        }\n        // Dispose the original scalar tensors.\n        dispose(scalarsToDispose);\n    }\n}\n/**\n * Dispose all Tensors in an UnresolvedLogs object.\n *\n * @param logs An `UnresolvedLogs` object potentially containing `tf.Tensor`s in\n *   places where the values can be `tf.Tensor` or `number`.\n */\nexport function disposeTensorsInLogs(logs) {\n    if (logs == null) {\n        return;\n    }\n    for (const key in logs) {\n        const value = logs[key];\n        if (typeof value !== 'number') {\n            value.dispose();\n        }\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9ncy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sb2dzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFDLE9BQU8sRUFBUyxNQUFNLHVCQUF1QixDQUFDO0FBV3REOzs7O0dBSUc7QUFDSCxNQUFNLENBQUMsS0FBSyxVQUFVLG9CQUFvQixDQUFDLElBQW9CO0lBQzdELElBQUksSUFBSSxJQUFJLElBQUksRUFBRTtRQUNoQixPQUFPO0tBQ1I7SUFDRCxNQUFNLFFBQVEsR0FBdUQsRUFBRSxDQUFDO0lBQ3hFLE1BQU0sSUFBSSxHQUFhLEVBQUUsQ0FBQztJQUMxQixNQUFNLGdCQUFnQixHQUFhLEVBQUUsQ0FBQztJQUN0QyxLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtRQUN0QixNQUFNLEtBQUssR0FBRyxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7UUFDeEIsSUFBSSxPQUFPLEtBQUssS0FBSyxRQUFRLEVBQUU7WUFDN0IsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDO1lBQzFCLFFBQVEsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLElBQUksRUFBRSxDQUFDLENBQUM7WUFDbEMsSUFBSSxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsQ0FBQztZQUNmLGdCQUFnQixDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztTQUNwQztLQUNGO0lBQ0QsSUFBSSxRQUFRLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtRQUN2QixNQUFNLE1BQU0sR0FBRyxNQUFNLE9BQU8sQ0FBQyxHQUFHLENBQUMsUUFBUSxDQUFDLENBQUM7UUFDM0MsS0FBSyxJQUFJLENBQUMsR0FBRyxDQUFDLEVBQUUsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxNQUFNLEVBQUUsRUFBRSxDQUFDLEVBQUU7WUFDdEMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQyxHQUFHLE1BQU0sQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUM5QjtRQUNELHVDQUF1QztRQUN2QyxPQUFPLENBQUMsZ0JBQWdCLENBQUMsQ0FBQztLQUMzQjtBQUNILENBQUM7QUFFRDs7Ozs7R0FLRztBQUNILE1BQU0sVUFBVSxvQkFBb0IsQ0FBQyxJQUFvQjtJQUN2RCxJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7UUFDaEIsT0FBTztLQUNSO0lBQ0QsS0FBSyxNQUFNLEdBQUcsSUFBSSxJQUFJLEVBQUU7UUFDdEIsTUFBTSxLQUFLLEdBQUcsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3hCLElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1lBQzdCLEtBQUssQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNqQjtLQUNGO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7ZGlzcG9zZSwgU2NhbGFyfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG4vKipcbiAqIExvZ3MgaW4gd2hpY2ggdmFsdWVzIGNhbiBiZSBlaXRoZXIgbnVtYmVycyBvciBUZW5zb3JzIChTY2FsYXJzKS5cbiAqXG4gKiBVc2VkIGludGVybmFsbHkuXG4gKi9cbmV4cG9ydCB0eXBlIFVucmVzb2x2ZWRMb2dzID0ge1xuICBba2V5OiBzdHJpbmddOiBudW1iZXJ8U2NhbGFyO1xufTtcblxuLyoqXG4gKiBUdXJuIGFueSBTY2FsYXIgdmFsdWVzIGluIGEgTG9ncyBvYmplY3QgaW50byBhY3R1YWwgbnVtYmVyIHZhbHVlcy5cbiAqXG4gKiBAcGFyYW0gbG9ncyBUaGUgYExvZ3NgIG9iamVjdCB0byBiZSByZXNvbHZlZCBpbiBwbGFjZS5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3M6IFVucmVzb2x2ZWRMb2dzKSB7XG4gIGlmIChsb2dzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3QgcHJvbWlzZXM6IEFycmF5PFByb21pc2U8RmxvYXQzMkFycmF5fEludDMyQXJyYXl8VWludDhBcnJheT4+ID0gW107XG4gIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG4gIGNvbnN0IHNjYWxhcnNUb0Rpc3Bvc2U6IFNjYWxhcltdID0gW107XG4gIGZvciAoY29uc3Qga2V5IGluIGxvZ3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGxvZ3Nba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgY29uc3QgdmFsdWVTY2FsYXIgPSB2YWx1ZTtcbiAgICAgIHByb21pc2VzLnB1c2godmFsdWVTY2FsYXIuZGF0YSgpKTtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgc2NhbGFyc1RvRGlzcG9zZS5wdXNoKHZhbHVlU2NhbGFyKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb21pc2VzLmxlbmd0aCA+IDApIHtcbiAgICBjb25zdCB2YWx1ZXMgPSBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxvZ3Nba2V5c1tpXV0gPSB2YWx1ZXNbaV1bMF07XG4gICAgfVxuICAgIC8vIERpc3Bvc2UgdGhlIG9yaWdpbmFsIHNjYWxhciB0ZW5zb3JzLlxuICAgIGRpc3Bvc2Uoc2NhbGFyc1RvRGlzcG9zZSk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwb3NlIGFsbCBUZW5zb3JzIGluIGFuIFVucmVzb2x2ZWRMb2dzIG9iamVjdC5cbiAqXG4gKiBAcGFyYW0gbG9ncyBBbiBgVW5yZXNvbHZlZExvZ3NgIG9iamVjdCBwb3RlbnRpYWxseSBjb250YWluaW5nIGB0Zi5UZW5zb3JgcyBpblxuICogICBwbGFjZXMgd2hlcmUgdGhlIHZhbHVlcyBjYW4gYmUgYHRmLlRlbnNvcmAgb3IgYG51bWJlcmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlVGVuc29yc0luTG9ncyhsb2dzOiBVbnJlc29sdmVkTG9ncykge1xuICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IGluIGxvZ3MpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGxvZ3Nba2V5XTtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnbnVtYmVyJykge1xuICAgICAgdmFsdWUuZGlzcG9zZSgpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIExvZ3MgaW4gd2hpY2ggdmFsdWVzIGNhbiBvbmx5IGJlIG51bWJlcnMuXG4gKlxuICogVXNlZCB3aGVuIGNhbGxpbmcgY2xpZW50LXByb3ZpZGVkIGN1c3RvbSBjYWxsYmFja3MuXG4gKi9cbmV4cG9ydCB0eXBlIExvZ3MgPSB7XG4gIFtrZXk6IHN0cmluZ106IG51bWJlcjtcbn07XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/callbacks.py */\nimport { add, div, keep, mul, nextFrame, tidy, util } from '@tensorflow/tfjs-core';\nimport { ValueError } from './errors';\nimport { resolveScalarsInLogs } from './logs';\nimport * as generic_utils from './utils/generic_utils';\n/** Verbosity logging level when fitting a model. */\nexport var ModelLoggingVerbosity;\n(function (ModelLoggingVerbosity) {\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"SILENT\"] = 0] = \"SILENT\";\n    ModelLoggingVerbosity[ModelLoggingVerbosity[\"VERBOSE\"] = 1] = \"VERBOSE\";\n})(ModelLoggingVerbosity || (ModelLoggingVerbosity = {}));\n/** How often to yield to the main thread when training (in ms). */\nexport const DEFAULT_YIELD_EVERY_MS = 125;\n/**\n * Abstract base class used to build new callbacks.\n *\n * The `logs` dictionary that callback methods take as argument will contain\n * keys for quantities relevant to the current batch or epoch.\n *\n * Currently, the `.fit()` method of the `Sequential` model class\n * will include the following quantities in the `logs` that\n * it passes to its callbacks:\n *\n * onEpochEnd: Logs include `acc` and `loss`, and optionally include `valLoss`\n *   (if validation is enabled in `fit`), and `valAcc` (if validation and\n *   accuracy monitoring are enabled).\n * onBatchBegin: Logs include `size`, the number of samples in the current\n *   batch.\n * onBatchEnd: Logs include `loss`, and optionally `acc` (if accuracy monitoring\n *   is enabled).\n */\nexport class BaseCallback {\n    constructor() {\n        // TODO(michaelterry): This type is a best guess.\n        this.validationData = null;\n    }\n    setParams(params) {\n        this.params = params;\n    }\n    async onEpochBegin(epoch, logs) { }\n    async onEpochEnd(epoch, logs) { }\n    async onBatchBegin(batch, logs) { }\n    async onBatchEnd(batch, logs) { }\n    async onTrainBegin(logs) { }\n    async onTrainEnd(logs) { }\n    // LayersModel needs to call Callback.setModel(), but cannot actually depend\n    // on Callback because that creates a cyclic dependency.  Providing this no-op\n    // method on BaseCallback breaks the cycle: this way LayersModel can depend on\n    // BaseCallback but not on Callback.  The argument is typed as `Container`\n    // (the superclass of LayersModel) to avoid recapitulating the cycle. Callback\n    // overrides this method and enforces that the argument is really a\n    // LayersModel.\n    setModel(model) {\n        // Do nothing. Use Callback instead of BaseCallback to track the model.\n    }\n}\n/**\n * Container abstracting a list of callbacks.\n */\nexport class CallbackList {\n    // TODO(cais): When the need arises, uncomment the following lines and\n    // implement the queue for time values.\n    // private deltaTBatch: number;\n    // private deltaTsBatchBegin: Array<number>;\n    // private deltaTsBatchEnd: Array<number>;\n    /**\n     * Constructor of CallbackList.\n     * @param callbacks Array of `Callback` instances.\n     * @param queueLength Queue length for keeping running statistics over\n     *   callback execution time.\n     */\n    constructor(callbacks, queueLength = 10) {\n        // TODO(cais): Make use of queueLength when implementing the queue for time\n        // values.\n        if (callbacks == null) {\n            callbacks = [];\n        }\n        this.callbacks = callbacks;\n        this.queueLength = queueLength;\n    }\n    append(callback) {\n        this.callbacks.push(callback);\n    }\n    setParams(params) {\n        for (const callback of this.callbacks) {\n            callback.setParams(params);\n        }\n    }\n    setModel(model) {\n        for (const callback of this.callbacks) {\n            callback.setModel(model);\n        }\n    }\n    /**\n     * Called at the start of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochBegin(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochBegin(epoch, logs);\n        }\n    }\n    /**\n     * Called at the end of an epoch.\n     * @param epoch Index of epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onEpochEnd(epoch, logs);\n        }\n    }\n    /**\n     * Called  right before processing a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchBegin(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchBegin(batch, logs);\n        }\n    }\n    /**\n     * Called at the end of a batch.\n     * @param batch Index of batch within the current epoch.\n     * @param logs Dictionary of logs.\n     */\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onBatchEnd(batch, logs);\n        }\n    }\n    /**\n     * Called at the beginning of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainBegin(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainBegin(logs);\n        }\n    }\n    /**\n     * Called at the end of training.\n     * @param logs Dictionary of logs.\n     */\n    async onTrainEnd(logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        for (const callback of this.callbacks) {\n            await callback.onTrainEnd(logs);\n        }\n    }\n}\n/**\n * Callback that accumulates epoch averages of metrics.\n *\n * This callback is automatically applied to every LayersModel.\n */\nexport class BaseLogger extends BaseCallback {\n    constructor() {\n        super();\n    }\n    async onEpochBegin(epoch) {\n        this.seen = 0;\n        this.totals = {};\n    }\n    async onBatchEnd(batch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        const batchSize = logs['size'] == null ? 0 : logs['size'];\n        this.seen += batchSize;\n        for (const key in logs) {\n            const value = logs[key];\n            if (typeof value === 'number') {\n                if (!this.totals.hasOwnProperty(key)) {\n                    this.totals[key] = 0;\n                }\n                this.totals[key] = this.totals[key] + value * batchSize;\n            }\n            else {\n                let oldTotalsToDispose;\n                if (key in this.totals) {\n                    oldTotalsToDispose = this.totals[key];\n                }\n                else {\n                    this.totals[key] = 0;\n                }\n                const total = tidy(() => add((this.totals[key]), mul(value, batchSize)));\n                this.totals[key] = total;\n                if (oldTotalsToDispose != null) {\n                    oldTotalsToDispose.dispose();\n                }\n            }\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs != null) {\n            for (const key of this.params['metrics']) {\n                if (this.totals[key] == null) {\n                    continue;\n                }\n                if (typeof this.totals[key] === 'number') {\n                    logs[key] = this.totals[key] / this.seen;\n                }\n                else {\n                    tidy(() => {\n                        const log = mul(div(1, this.seen), this.totals[key]);\n                        logs[key] = log;\n                        this.totals[key].dispose();\n                        keep(logs[key]);\n                    });\n                }\n            }\n        }\n    }\n}\n/**\n * Callback that records events into a `History` object. This callback is\n * automatically applied to every TF.js Layers model. The `History` object\n * gets returned by the `fit` method of models.\n */\nexport class History extends BaseCallback {\n    async onTrainBegin(logs) {\n        this.epoch = [];\n        this.history = {};\n    }\n    async onEpochEnd(epoch, logs) {\n        if (logs == null) {\n            logs = {};\n        }\n        this.epoch.push(epoch);\n        for (const key in logs) {\n            if (this.history[key] == null) {\n                this.history[key] = [];\n            }\n            this.history[key].push(logs[key]);\n        }\n    }\n    /**\n     * Await the values of all losses and metrics.\n     */\n    async syncData() {\n        const promises = [];\n        const keys = [];\n        const indices = [];\n        for (const key in this.history) {\n            const valueArray = this.history[key];\n            for (let i = 0; i < valueArray.length; ++i) {\n                if (typeof valueArray[i] !== 'number') {\n                    const valueScalar = valueArray[i];\n                    promises.push(valueScalar.data());\n                    keys.push(key);\n                    indices.push(i);\n                }\n            }\n        }\n        const values = await Promise.all(promises);\n        for (let n = 0; n < values.length; ++n) {\n            const tensorToDispose = this.history[keys[n]][indices[n]];\n            tensorToDispose.dispose();\n            this.history[keys[n]][indices[n]] = values[n][0];\n        }\n    }\n}\n/**\n * Custom callback for training.\n */\nexport class CustomCallback extends BaseCallback {\n    constructor(args, yieldEvery) {\n        super();\n        this.currentEpoch = 0;\n        this.nowFunc = args.nowFunc;\n        this.nextFrameFunc = args.nextFrameFunc || nextFrame;\n        this.yieldEvery = yieldEvery || 'auto';\n        if (this.yieldEvery === 'auto') {\n            this.yieldEvery = DEFAULT_YIELD_EVERY_MS;\n        }\n        if (this.yieldEvery === 'never' && args.onYield != null) {\n            throw new Error('yieldEvery is `never` but you provided an `onYield` callback. ' +\n                'Either change `yieldEvery` or remove the callback');\n        }\n        if (util.isNumber(this.yieldEvery)) {\n            // Decorate `maybeWait` so it will be called at most once every\n            // `yieldEvery` ms.\n            this.maybeWait = generic_utils.debounce(this.maybeWait.bind(this), this.yieldEvery, this.nowFunc);\n        }\n        this.trainBegin = args.onTrainBegin;\n        this.trainEnd = args.onTrainEnd;\n        this.epochBegin = args.onEpochBegin;\n        this.epochEnd = args.onEpochEnd;\n        this.batchBegin = args.onBatchBegin;\n        this.batchEnd = args.onBatchEnd;\n        this.yield = args.onYield;\n    }\n    async maybeWait(epoch, batch, logs) {\n        const ps = [];\n        if (this.yield != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.yield(epoch, batch, logs));\n        }\n        ps.push(this.nextFrameFunc());\n        await Promise.all(ps);\n    }\n    async onEpochBegin(epoch, logs) {\n        this.currentEpoch = epoch;\n        if (this.epochBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.epochBegin(epoch, logs);\n        }\n    }\n    async onEpochEnd(epoch, logs) {\n        const ps = [];\n        if (this.epochEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.epochEnd(epoch, logs));\n        }\n        if (this.yieldEvery === 'epoch') {\n            ps.push(this.nextFrameFunc());\n        }\n        await Promise.all(ps);\n    }\n    async onBatchBegin(batch, logs) {\n        if (this.batchBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.batchBegin(batch, logs);\n        }\n    }\n    async onBatchEnd(batch, logs) {\n        const ps = [];\n        if (this.batchEnd != null) {\n            await resolveScalarsInLogs(logs);\n            ps.push(this.batchEnd(batch, logs));\n        }\n        if (this.yieldEvery === 'batch') {\n            ps.push(this.nextFrameFunc());\n        }\n        else if (util.isNumber(this.yieldEvery)) {\n            ps.push(this.maybeWait(this.currentEpoch, batch, logs));\n        }\n        await Promise.all(ps);\n    }\n    async onTrainBegin(logs) {\n        if (this.trainBegin != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainBegin(logs);\n        }\n    }\n    async onTrainEnd(logs) {\n        if (this.trainEnd != null) {\n            await resolveScalarsInLogs(logs);\n            await this.trainEnd(logs);\n        }\n    }\n}\n/**\n * Standardize callbacks or configurations of them to an Array of callbacks.\n */\nexport function standardizeCallbacks(callbacks, yieldEvery) {\n    if (callbacks == null) {\n        callbacks = {};\n    }\n    if (callbacks instanceof BaseCallback) {\n        return [callbacks];\n    }\n    if (Array.isArray(callbacks) && callbacks[0] instanceof BaseCallback) {\n        return callbacks;\n    }\n    // Convert custom callback configs to custom callback objects.\n    const callbackConfigs = generic_utils.toList(callbacks);\n    return callbackConfigs.map(callbackConfig => new CustomCallback(callbackConfig, yieldEvery));\n}\n/**\n * A global registry for callback constructors to be used during\n * LayersModel.fit().\n */\nexport class CallbackConstructorRegistry {\n    /**\n     * Blocks public access to constructor.\n     */\n    constructor() { }\n    /**\n     * Register a tf.LayersModel.fit() callback constructor.\n     *\n     * The registered callback constructor will be used to instantiate\n     * callbacks for every tf.LayersModel.fit() call afterwards.\n     *\n     * @param verbosityLevel Level of verbosity at which the `callbackConstructor`\n     *   is to be reigstered.\n     * @param callbackConstructor A no-arg constructor for `tf.Callback`.\n     * @throws Error, if the same callbackConstructor has been registered before,\n     *   either at the same or a different `verbosityLevel`.\n     */\n    static registerCallbackConstructor(verbosityLevel, callbackConstructor) {\n        util.assert(verbosityLevel >= 0 && Number.isInteger(verbosityLevel), () => `Verbosity level is expected to be an integer >= 0, ` +\n            `but got ${verbosityLevel}`);\n        CallbackConstructorRegistry.checkForDuplicate(callbackConstructor);\n        if (CallbackConstructorRegistry.constructors[verbosityLevel] == null) {\n            CallbackConstructorRegistry.constructors[verbosityLevel] = [];\n        }\n        CallbackConstructorRegistry.constructors[verbosityLevel].push(callbackConstructor);\n    }\n    static checkForDuplicate(callbackConstructor) {\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const constructors = CallbackConstructorRegistry.constructors[+levelName];\n            constructors.forEach(ctor => {\n                if (ctor === callbackConstructor) {\n                    throw new ValueError('Duplicate callback constructor.');\n                }\n            });\n        }\n    }\n    /**\n     * Clear all registered callback constructors.\n     */\n    static clear() {\n        CallbackConstructorRegistry.constructors = {};\n    }\n    /**\n     * Create callbacks using the registered callback constructors.\n     *\n     * Given `verbosityLevel`, all constructors registered at that level or above\n     * will be called and the instantiated callbacks will be used.\n     *\n     * @param verbosityLevel: Level of verbosity.\n     */\n    static createCallbacks(verbosityLevel) {\n        const constructors = [];\n        for (const levelName in CallbackConstructorRegistry.constructors) {\n            const level = +levelName;\n            if (verbosityLevel >= level) {\n                constructors.push(...CallbackConstructorRegistry.constructors[level]);\n            }\n        }\n        return constructors.map(ctor => new ctor());\n    }\n}\nCallbackConstructorRegistry.constructors = {};\nexport function configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics) {\n    const history = new History();\n    const actualCallbacks = [\n        new BaseLogger(), ...CallbackConstructorRegistry.createCallbacks(verbose)\n    ];\n    if (callbacks != null) {\n        actualCallbacks.push(...callbacks);\n    }\n    actualCallbacks.push(history);\n    const callbackList = new CallbackList(actualCallbacks);\n    // TODO(cais): Figure out when this LayersModel instance can have a\n    // dynamically\n    //   set property called 'callback_model' as in PyKeras.\n    callbackList.setParams({\n        epochs,\n        initialEpoch,\n        samples: numTrainSamples,\n        steps: stepsPerEpoch,\n        batchSize,\n        verbose,\n        doValidation,\n        metrics: callbackMetrics,\n    });\n    return { callbackList, history };\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYmFzZV9jYWxsYmFja3MuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvYmFzZV9jYWxsYmFja3MudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFFSCx5Q0FBeUM7QUFFekMsT0FBTyxFQUFDLEdBQUcsRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLEdBQUcsRUFBRSxTQUFTLEVBQWtCLElBQUksRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUdqRyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ3BDLE9BQU8sRUFBTyxvQkFBb0IsRUFBaUIsTUFBTSxRQUFRLENBQUM7QUFDbEUsT0FBTyxLQUFLLGFBQWEsTUFBTSx1QkFBdUIsQ0FBQztBQUV2RCxvREFBb0Q7QUFDcEQsTUFBTSxDQUFOLElBQVkscUJBR1g7QUFIRCxXQUFZLHFCQUFxQjtJQUMvQixxRUFBVSxDQUFBO0lBQ1YsdUVBQVcsQ0FBQTtBQUNiLENBQUMsRUFIVyxxQkFBcUIsS0FBckIscUJBQXFCLFFBR2hDO0FBRUQsbUVBQW1FO0FBQ25FLE1BQU0sQ0FBQyxNQUFNLHNCQUFzQixHQUFHLEdBQUcsQ0FBQztBQVExQzs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FpQkc7QUFDSCxNQUFNLE9BQWdCLFlBQVk7SUFBbEM7UUFDRSxpREFBaUQ7UUFDakQsbUJBQWMsR0FBb0IsSUFBSSxDQUFDO0lBZ0N6QyxDQUFDO0lBMUJDLFNBQVMsQ0FBQyxNQUFjO1FBQ3RCLElBQUksQ0FBQyxNQUFNLEdBQUcsTUFBTSxDQUFDO0lBQ3ZCLENBQUM7SUFFRCxLQUFLLENBQUMsWUFBWSxDQUFDLEtBQWEsRUFBRSxJQUFxQixJQUFHLENBQUM7SUFFM0QsS0FBSyxDQUFDLFVBQVUsQ0FBQyxLQUFhLEVBQUUsSUFBcUIsSUFBRyxDQUFDO0lBRXpELEtBQUssQ0FBQyxZQUFZLENBQUMsS0FBYSxFQUFFLElB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RSxZQUFxQixFQUN4QyxlQUF5QjtJQUMzQixNQUFNLE9BQU8sR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDO0lBQzlCLE1BQU0sZUFBZSxHQUFtQjtRQUN0QyxJQUFJLFVBQVUsRUFBRSxFQUFFLEdBQUcsMkJBQTJCLENBQUMsZUFBZSxDQUFDLE9BQU8sQ0FBQztLQUMxRSxDQUFDO0lBQ0YsSUFBSSxTQUFTLElBQUksSUFBSSxFQUFFO1FBQ3JCLGVBQWUsQ0FBQyxJQUFJLENBQUMsR0FBRyxTQUFTLENBQUMsQ0FBQztLQUNwQztJQUNELGVBQWUsQ0FBQyxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUM7SUFDOUIsTUFBTSxZQUFZLEdBQUcsSUFBSSxZQUFZLENBQUMsZUFBZSxDQUFDLENBQUM7SUFFdkQsbUVBQW1FO0lBQ25FLGNBQWM7SUFDZCx3REFBd0Q7SUFFeEQsWUFBWSxDQUFDLFNBQVMsQ0FBQztRQUNyQixNQUFNO1FBQ04sWUFBWTtRQUNaLE9BQU8sRUFBRSxlQUFlO1FBQ3hCLEtBQUssRUFBRSxhQUFhO1FBQ3BCLFNBQVM7UUFDVCxPQUFPO1FBQ1AsWUFBWTtRQUNaLE9BQU8sRUFBRSxlQUFlO0tBQ3pCLENBQUMsQ0FBQztJQUNILE9BQU8sRUFBQyxZQUFZLEVBQUUsT0FBTyxFQUFDLENBQUM7QUFDakMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qIE9yaWdpbmFsIHNvdXJjZToga2VyYXMvY2FsbGJhY2tzLnB5ICovXG5cbmltcG9ydCB7YWRkLCBkaXYsIGtlZXAsIG11bCwgbmV4dEZyYW1lLCBTY2FsYXIsIFRlbnNvciwgdGlkeSwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtDb250YWluZXJ9IGZyb20gJy4vZW5naW5lL2NvbnRhaW5lcic7XG5pbXBvcnQge1ZhbHVlRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7TG9ncywgcmVzb2x2ZVNjYWxhcnNJbkxvZ3MsIFVucmVzb2x2ZWRMb2dzfSBmcm9tICcuL2xvZ3MnO1xuaW1wb3J0ICogYXMgZ2VuZXJpY191dGlscyBmcm9tICcuL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuXG4vKiogVmVyYm9zaXR5IGxvZ2dpbmcgbGV2ZWwgd2hlbiBmaXR0aW5nIGEgbW9kZWwuICovXG5leHBvcnQgZW51bSBNb2RlbExvZ2dpbmdWZXJib3NpdHkge1xuICBTSUxFTlQgPSAwLFxuICBWRVJCT1NFID0gMVxufVxuXG4vKiogSG93IG9mdGVuIHRvIHlpZWxkIHRvIHRoZSBtYWluIHRocmVhZCB3aGVuIHRyYWluaW5nIChpbiBtcykuICovXG5leHBvcnQgY29uc3QgREVGQVVMVF9ZSUVMRF9FVkVSWV9NUyA9IDEyNTtcblxuZXhwb3J0IHR5cGUgUGFyYW1zID0ge1xuICBba2V5OiBzdHJpbmddOiBudW1iZXJ8c3RyaW5nfGJvb2xlYW58bnVtYmVyW118c3RyaW5nW118Ym9vbGVhbltdO1xufTtcblxuZXhwb3J0IHR5cGUgWWllbGRFdmVyeU9wdGlvbnMgPSAnYXV0byd8J2JhdGNoJ3wnZXBvY2gnfCduZXZlcid8bnVtYmVyO1xuXG4vKipcbiAqIEFic3RyYWN0IGJhc2UgY2xhc3MgdXNlZCB0byBidWlsZCBuZXcgY2FsbGJhY2tzLlxuICpcbiAqIFRoZSBgbG9nc2AgZGljdGlvbmFyeSB0aGF0IGNhbGxiYWNrIG1ldGhvZHMgdGFrZSBhcyBhcmd1bWVudCB3aWxsIGNvbnRhaW5cbiAqIGtleXMgZm9yIHF1YW50aXRpZXMgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgYmF0Y2ggb3IgZXBvY2guXG4gKlxuICogQ3VycmVudGx5LCB0aGUgYC5maXQoKWAgbWV0aG9kIG9mIHRoZSBgU2VxdWVudGlhbGAgbW9kZWwgY2xhc3NcbiAqIHdpbGwgaW5jbHVkZSB0aGUgZm9sbG93aW5nIHF1YW50aXRpZXMgaW4gdGhlIGBsb2dzYCB0aGF0XG4gKiBpdCBwYXNzZXMgdG8gaXRzIGNhbGxiYWNrczpcbiAqXG4gKiBvbkVwb2NoRW5kOiBMb2dzIGluY2x1ZGUgYGFjY2AgYW5kIGBsb3NzYCwgYW5kIG9wdGlvbmFsbHkgaW5jbHVkZSBgdmFsTG9zc2BcbiAqICAgKGlmIHZhbGlkYXRpb24gaXMgZW5hYmxlZCBpbiBgZml0YCksIGFuZCBgdmFsQWNjYCAoaWYgdmFsaWRhdGlvbiBhbmRcbiAqICAgYWNjdXJhY3kgbW9uaXRvcmluZyBhcmUgZW5hYmxlZCkuXG4gKiBvbkJhdGNoQmVnaW46IExvZ3MgaW5jbHVkZSBgc2l6ZWAsIHRoZSBudW1iZXIgb2Ygc2FtcGxlcyBpbiB0aGUgY3VycmVudFxuICogICBiYXRjaC5cbiAqIG9uQmF0Y2hFbmQ6IExvZ3MgaW5jbHVkZSBgbG9zc2AsIGFuZCBvcHRpb25hbGx5IGBhY2NgIChpZiBhY2N1cmFjeSBtb25pdG9yaW5nXG4gKiAgIGlzIGVuYWJsZWQpLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQmFzZUNhbGxiYWNrIHtcbiAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBUaGlzIHR5cGUgaXMgYSBiZXN0IGd1ZXNzLlxuICB2YWxpZGF0aW9uRGF0YTogVGVuc29yfFRlbnNvcltdID0gbnVsbDtcbiAgLyoqXG4gICAqIFRyYWluaW5nIHBhcmFtZXRlcnMgKGVnLiB2ZXJib3NpdHksIGJhdGNoIHNpemUsIG51bWJlciBvZiBlcG9jaHMuLi4pLlxuICAgKi9cbiAgcGFyYW1zOiBQYXJhbXM7XG5cbiAgc2V0UGFyYW1zKHBhcmFtczogUGFyYW1zKTogdm9pZCB7XG4gICAgdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gIH1cblxuICBhc3luYyBvbkVwb2NoQmVnaW4oZXBvY2g6IG51bWJlciwgbG9ncz86IFVucmVzb2x2ZWRMb2dzKSB7fVxuXG4gIGFzeW5jIG9uRXBvY2hFbmQoZXBvY2g6IG51bWJlciwgbG9ncz86IFVucmVzb2x2ZWRMb2dzKSB7fVxuXG4gIGFzeW5jIG9uQmF0Y2hCZWdpbihiYXRjaDogbnVtYmVyLCBsb2dzPzogVW5yZXNvbHZlZExvZ3MpIHt9XG5cbiAgYXN5bmMgb25CYXRjaEVuZChiYXRjaDogbnVtYmVyLCBsb2dzPzogVW5yZXNvbHZlZExvZ3MpIHt9XG5cbiAgYXN5bmMgb25UcmFpbkJlZ2luKGxvZ3M/OiBVbnJlc29sdmVkTG9ncykge31cblxuICBhc3luYyBvblRyYWluRW5kKGxvZ3M/OiBVbnJlc29sdmVkTG9ncykge31cblxuICAvLyBMYXllcnNNb2RlbCBuZWVkcyB0byBjYWxsIENhbGxiYWNrLnNldE1vZGVsKCksIGJ1dCBjYW5ub3QgYWN0dWFsbHkgZGVwZW5kXG4gIC8vIG9uIENhbGxiYWNrIGJlY2F1c2UgdGhhdCBjcmVhdGVzIGEgY3ljbGljIGRlcGVuZGVuY3kuICBQcm92aWRpbmcgdGhpcyBuby1vcFxuICAvLyBtZXRob2Qgb24gQmFzZUNhbGxiYWNrIGJyZWFrcyB0aGUgY3ljbGU6IHRoaXMgd2F5IExheWVyc01vZGVsIGNhbiBkZXBlbmQgb25cbiAgLy8gQmFzZUNhbGxiYWNrIGJ1dCBub3Qgb24gQ2FsbGJhY2suICBUaGUgYXJndW1lbnQgaXMgdHlwZWQgYXMgYENvbnRhaW5lcmBcbiAgLy8gKHRoZSBzdXBlcmNsYXNzIG9mIExheWVyc01vZGVsKSB0byBhdm9pZCByZWNhcGl0dWxhdGluZyB0aGUgY3ljbGUuIENhbGxiYWNrXG4gIC8vIG92ZXJyaWRlcyB0aGlzIG1ldGhvZCBhbmQgZW5mb3JjZXMgdGhhdCB0aGUgYXJndW1lbnQgaXMgcmVhbGx5IGFcbiAgLy8gTGF5ZXJzTW9kZWwuXG4gIHNldE1vZGVsKG1vZGVsOiBDb250YWluZXIpOiB2b2lkIHtcbiAgICAvLyBEbyBub3RoaW5nLiBVc2UgQ2FsbGJhY2sgaW5zdGVhZCBvZiBCYXNlQ2FsbGJhY2sgdG8gdHJhY2sgdGhlIG1vZGVsLlxuICB9XG59XG5cbi8qKlxuICogQ29udGFpbmVyIGFic3RyYWN0aW5nIGEgbGlzdCBvZiBjYWxsYmFja3MuXG4gKi9cbmV4cG9ydCBjbGFzcyBDYWxsYmFja0xpc3Qge1xuICBjYWxsYmFja3M6IEJhc2VDYWxsYmFja1tdO1xuICBxdWV1ZUxlbmd0aDogbnVtYmVyO1xuXG4gIC8vIFRPRE8oY2Fpcyk6IFdoZW4gdGhlIG5lZWQgYXJpc2VzLCB1bmNvbW1lbnQgdGhlIGZvbGxvd2luZyBsaW5lcyBhbmRcbiAgLy8gaW1wbGVtZW50IHRoZSBxdWV1ZSBmb3IgdGltZSB2YWx1ZXMuXG4gIC8vIHByaXZhdGUgZGVsdGFUQmF0Y2g6IG51bWJlcjtcbiAgLy8gcHJpdmF0ZSBkZWx0YVRzQmF0Y2hCZWdpbjogQXJyYXk8bnVtYmVyPjtcbiAgLy8gcHJpdmF0ZSBkZWx0YVRzQmF0Y2hFbmQ6IEFycmF5PG51bWJlcj47XG5cbiAgLyoqXG4gICAqIENvbnN0cnVjdG9yIG9mIENhbGxiYWNrTGlzdC5cbiAgICogQHBhcmFtIGNhbGxiYWNrcyBBcnJheSBvZiBgQ2FsbGJhY2tgIGluc3RhbmNlcy5cbiAgICogQHBhcmFtIHF1ZXVlTGVuZ3RoIFF1ZXVlIGxlbmd0aCBmb3Iga2VlcGluZyBydW5uaW5nIHN0YXRpc3RpY3Mgb3ZlclxuICAgKiAgIGNhbGxiYWNrIGV4ZWN1dGlvbiB0aW1lLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FsbGJhY2tzPzogQmFzZUNhbGxiYWNrW10sIHF1ZXVlTGVuZ3RoID0gMTApIHtcbiAgICAvLyBUT0RPKGNhaXMpOiBNYWtlIHVzZSBvZiBxdWV1ZUxlbmd0aCB3aGVuIGltcGxlbWVudGluZyB0aGUgcXVldWUgZm9yIHRpbWVcbiAgICAvLyB2YWx1ZXMuXG4gICAgaWYgKGNhbGxiYWNrcyA9PSBudWxsKSB7XG4gICAgICBjYWxsYmFja3MgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG4gICAgdGhpcy5xdWV1ZUxlbmd0aCA9IHF1ZXVlTGVuZ3RoO1xuICB9XG5cbiAgYXBwZW5kKGNhbGxiYWNrOiBCYXNlQ2FsbGJhY2spOiB2b2lkIHtcbiAgICB0aGlzLmNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgfVxuXG4gIHNldFBhcmFtcyhwYXJhbXM6IFBhcmFtcyk6IHZvaWQge1xuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgIGNhbGxiYWNrLnNldFBhcmFtcyhwYXJhbXMpO1xuICAgIH1cbiAgfVxuXG4gIHNldE1vZGVsKG1vZGVsOiBDb250YWluZXIpOiB2b2lkIHtcbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICBjYWxsYmFjay5zZXRNb2RlbChtb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBhdCB0aGUgc3RhcnQgb2YgYW4gZXBvY2guXG4gICAqIEBwYXJhbSBlcG9jaCBJbmRleCBvZiBlcG9jaC5cbiAgICogQHBhcmFtIGxvZ3MgRGljdGlvbmFyeSBvZiBsb2dzLlxuICAgKi9cbiAgYXN5bmMgb25FcG9jaEJlZ2luKGVwb2NoOiBudW1iZXIsIGxvZ3M/OiBVbnJlc29sdmVkTG9ncykge1xuICAgIGlmIChsb2dzID09IG51bGwpIHtcbiAgICAgIGxvZ3MgPSB7fTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiB0aGlzLmNhbGxiYWNrcykge1xuICAgICAgYXdhaXQgY2FsbGJhY2sub25FcG9jaEJlZ2luKGVwb2NoLCBsb2dzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGF0IHRoZSBlbmQgb2YgYW4gZXBvY2guXG4gICAqIEBwYXJhbSBlcG9jaCBJbmRleCBvZiBlcG9jaC5cbiAgICogQHBhcmFtIGxvZ3MgRGljdGlvbmFyeSBvZiBsb2dzLlxuICAgKi9cbiAgYXN5bmMgb25FcG9jaEVuZChlcG9jaDogbnVtYmVyLCBsb2dzPzogVW5yZXNvbHZlZExvZ3MpIHtcbiAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICBsb2dzID0ge307XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgIGF3YWl0IGNhbGxiYWNrLm9uRXBvY2hFbmQoZXBvY2gsIGxvZ3MpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgIHJpZ2h0IGJlZm9yZSBwcm9jZXNzaW5nIGEgYmF0Y2guXG4gICAqIEBwYXJhbSBiYXRjaCBJbmRleCBvZiBiYXRjaCB3aXRoaW4gdGhlIGN1cnJlbnQgZXBvY2guXG4gICAqIEBwYXJhbSBsb2dzIERpY3Rpb25hcnkgb2YgbG9ncy5cbiAgICovXG4gIGFzeW5jIG9uQmF0Y2hCZWdpbihiYXRjaDogbnVtYmVyLCBsb2dzPzogVW5yZXNvbHZlZExvZ3MpIHtcbiAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICBsb2dzID0ge307XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgIGF3YWl0IGNhbGxiYWNrLm9uQmF0Y2hCZWdpbihiYXRjaCwgbG9ncyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCBhdCB0aGUgZW5kIG9mIGEgYmF0Y2guXG4gICAqIEBwYXJhbSBiYXRjaCBJbmRleCBvZiBiYXRjaCB3aXRoaW4gdGhlIGN1cnJlbnQgZXBvY2guXG4gICAqIEBwYXJhbSBsb2dzIERpY3Rpb25hcnkgb2YgbG9ncy5cbiAgICovXG4gIGFzeW5jIG9uQmF0Y2hFbmQoYmF0Y2g6IG51bWJlciwgbG9ncz86IFVucmVzb2x2ZWRMb2dzKSB7XG4gICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgbG9ncyA9IHt9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICBhd2FpdCBjYWxsYmFjay5vbkJhdGNoRW5kKGJhdGNoLCBsb2dzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGF0IHRoZSBiZWdpbm5pbmcgb2YgdHJhaW5pbmcuXG4gICAqIEBwYXJhbSBsb2dzIERpY3Rpb25hcnkgb2YgbG9ncy5cbiAgICovXG4gIGFzeW5jIG9uVHJhaW5CZWdpbihsb2dzPzogVW5yZXNvbHZlZExvZ3MpIHtcbiAgICBpZiAobG9ncyA9PSBudWxsKSB7XG4gICAgICBsb2dzID0ge307XG4gICAgfVxuICAgIGZvciAoY29uc3QgY2FsbGJhY2sgb2YgdGhpcy5jYWxsYmFja3MpIHtcbiAgICAgIGF3YWl0IGNhbGxiYWNrLm9uVHJhaW5CZWdpbihsb2dzKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIGF0IHRoZSBlbmQgb2YgdHJhaW5pbmcuXG4gICAqIEBwYXJhbSBsb2dzIERpY3Rpb25hcnkgb2YgbG9ncy5cbiAgICovXG4gIGFzeW5jIG9uVHJhaW5FbmQobG9ncz86IFVucmVzb2x2ZWRMb2dzKSB7XG4gICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgbG9ncyA9IHt9O1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuY2FsbGJhY2tzKSB7XG4gICAgICBhd2FpdCBjYWxsYmFjay5vblRyYWluRW5kKGxvZ3MpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIHRoYXQgYWNjdW11bGF0ZXMgZXBvY2ggYXZlcmFnZXMgb2YgbWV0cmljcy5cbiAqXG4gKiBUaGlzIGNhbGxiYWNrIGlzIGF1dG9tYXRpY2FsbHkgYXBwbGllZCB0byBldmVyeSBMYXllcnNNb2RlbC5cbiAqL1xuZXhwb3J0IGNsYXNzIEJhc2VMb2dnZXIgZXh0ZW5kcyBCYXNlQ2FsbGJhY2sge1xuICBwcml2YXRlIHNlZW46IG51bWJlcjtcbiAgcHJpdmF0ZSB0b3RhbHM6IFVucmVzb2x2ZWRMb2dzO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICBhc3luYyBvbkVwb2NoQmVnaW4oZXBvY2g6IG51bWJlcikge1xuICAgIHRoaXMuc2VlbiA9IDA7XG4gICAgdGhpcy50b3RhbHMgPSB7fTtcbiAgfVxuXG4gIGFzeW5jIG9uQmF0Y2hFbmQoYmF0Y2g6IG51bWJlciwgbG9ncz86IFVucmVzb2x2ZWRMb2dzKSB7XG4gICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgbG9ncyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBiYXRjaFNpemUgPSBsb2dzWydzaXplJ10gPT0gbnVsbCA/IDAgOiBsb2dzWydzaXplJ10gYXMgbnVtYmVyO1xuICAgIHRoaXMuc2VlbiArPSBiYXRjaFNpemU7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gbG9ncykge1xuICAgICAgY29uc3QgdmFsdWUgPSBsb2dzW2tleV07XG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgICAgICBpZiAoIXRoaXMudG90YWxzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICB0aGlzLnRvdGFsc1trZXldID0gMDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRvdGFsc1trZXldID0gdGhpcy50b3RhbHNba2V5XSBhcyBudW1iZXIgKyB2YWx1ZSAqIGJhdGNoU2l6ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCBvbGRUb3RhbHNUb0Rpc3Bvc2U6IFNjYWxhcjtcbiAgICAgICAgaWYgKGtleSBpbiB0aGlzLnRvdGFscykge1xuICAgICAgICAgIG9sZFRvdGFsc1RvRGlzcG9zZSA9IHRoaXMudG90YWxzW2tleV0gYXMgU2NhbGFyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMudG90YWxzW2tleV0gPSAwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvdGFsOiBTY2FsYXIgPVxuICAgICAgICAgICAgdGlkeSgoKSA9PiBhZGQoKHRoaXMudG90YWxzW2tleV0pLCBtdWwodmFsdWUsIGJhdGNoU2l6ZSkpKTtcbiAgICAgICAgdGhpcy50b3RhbHNba2V5XSA9IHRvdGFsO1xuICAgICAgICBpZiAob2xkVG90YWxzVG9EaXNwb3NlICE9IG51bGwpIHtcbiAgICAgICAgICBvbGRUb3RhbHNUb0Rpc3Bvc2UuZGlzcG9zZSgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgb25FcG9jaEVuZChlcG9jaDogbnVtYmVyLCBsb2dzPzogVW5yZXNvbHZlZExvZ3MpIHtcbiAgICBpZiAobG9ncyAhPSBudWxsKSB7XG4gICAgICBmb3IgKGNvbnN0IGtleSBvZiB0aGlzLnBhcmFtc1snbWV0cmljcyddIGFzIHN0cmluZ1tdKSB7XG4gICAgICAgIGlmICh0aGlzLnRvdGFsc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRoaXMudG90YWxzW2tleV0gPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgbG9nc1trZXldID0gdGhpcy50b3RhbHNba2V5XSBhcyBudW1iZXIgLyB0aGlzLnNlZW47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGlkeSgoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBsb2c6IFNjYWxhciA9IG11bChkaXYoMSwgdGhpcy5zZWVuKSwgdGhpcy50b3RhbHNba2V5XSk7XG4gICAgICAgICAgICBsb2dzW2tleV0gPSBsb2c7XG4gICAgICAgICAgICAodGhpcy50b3RhbHNba2V5XSBhcyBUZW5zb3IpLmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGtlZXAobG9nc1trZXldIGFzIFNjYWxhcik7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDYWxsYmFjayB0aGF0IHJlY29yZHMgZXZlbnRzIGludG8gYSBgSGlzdG9yeWAgb2JqZWN0LiBUaGlzIGNhbGxiYWNrIGlzXG4gKiBhdXRvbWF0aWNhbGx5IGFwcGxpZWQgdG8gZXZlcnkgVEYuanMgTGF5ZXJzIG1vZGVsLiBUaGUgYEhpc3RvcnlgIG9iamVjdFxuICogZ2V0cyByZXR1cm5lZCBieSB0aGUgYGZpdGAgbWV0aG9kIG9mIG1vZGVscy5cbiAqL1xuZXhwb3J0IGNsYXNzIEhpc3RvcnkgZXh0ZW5kcyBCYXNlQ2FsbGJhY2sge1xuICBlcG9jaDogbnVtYmVyW107XG4gIGhpc3Rvcnk6IHtba2V5OiBzdHJpbmddOiBBcnJheTxudW1iZXJ8VGVuc29yPn07XG5cbiAgYXN5bmMgb25UcmFpbkJlZ2luKGxvZ3M/OiBVbnJlc29sdmVkTG9ncykge1xuICAgIHRoaXMuZXBvY2ggPSBbXTtcbiAgICB0aGlzLmhpc3RvcnkgPSB7fTtcbiAgfVxuXG4gIGFzeW5jIG9uRXBvY2hFbmQoZXBvY2g6IG51bWJlciwgbG9ncz86IFVucmVzb2x2ZWRMb2dzKSB7XG4gICAgaWYgKGxvZ3MgPT0gbnVsbCkge1xuICAgICAgbG9ncyA9IHt9O1xuICAgIH1cbiAgICB0aGlzLmVwb2NoLnB1c2goZXBvY2gpO1xuICAgIGZvciAoY29uc3Qga2V5IGluIGxvZ3MpIHtcbiAgICAgIGlmICh0aGlzLmhpc3Rvcnlba2V5XSA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuaGlzdG9yeVtrZXldID0gW107XG4gICAgICB9XG4gICAgICB0aGlzLmhpc3Rvcnlba2V5XS5wdXNoKGxvZ3Nba2V5XSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEF3YWl0IHRoZSB2YWx1ZXMgb2YgYWxsIGxvc3NlcyBhbmQgbWV0cmljcy5cbiAgICovXG4gIGFzeW5jIHN5bmNEYXRhKCkge1xuICAgIGNvbnN0IHByb21pc2VzOiBBcnJheTxQcm9taXNlPEZsb2F0MzJBcnJheXxJbnQzMkFycmF5fFVpbnQ4QXJyYXk+PiA9IFtdO1xuICAgIGNvbnN0IGtleXM6IHN0cmluZ1tdID0gW107XG4gICAgY29uc3QgaW5kaWNlczogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0aGlzLmhpc3RvcnkpIHtcbiAgICAgIGNvbnN0IHZhbHVlQXJyYXkgPSB0aGlzLmhpc3Rvcnlba2V5XTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWVBcnJheS5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlQXJyYXlbaV0gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgY29uc3QgdmFsdWVTY2FsYXIgPSB2YWx1ZUFycmF5W2ldIGFzIFRlbnNvcjtcbiAgICAgICAgICBwcm9taXNlcy5wdXNoKHZhbHVlU2NhbGFyLmRhdGEoKSk7XG4gICAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICAgICAgaW5kaWNlcy5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IGF3YWl0IFByb21pc2UuYWxsKHByb21pc2VzKTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IHZhbHVlcy5sZW5ndGg7ICsrbikge1xuICAgICAgY29uc3QgdGVuc29yVG9EaXNwb3NlID0gdGhpcy5oaXN0b3J5W2tleXNbbl1dW2luZGljZXNbbl1dIGFzIFRlbnNvcjtcbiAgICAgIHRlbnNvclRvRGlzcG9zZS5kaXNwb3NlKCk7XG4gICAgICB0aGlzLmhpc3Rvcnlba2V5c1tuXV1baW5kaWNlc1tuXV0gPSB2YWx1ZXNbbl1bMF07XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ3VzdG9tQ2FsbGJhY2tBcmdzIHtcbiAgb25UcmFpbkJlZ2luPzogKGxvZ3M/OiBMb2dzKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgb25UcmFpbkVuZD86IChsb2dzPzogTG9ncykgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIG9uRXBvY2hCZWdpbj86IChlcG9jaDogbnVtYmVyLCBsb2dzPzogTG9ncykgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIG9uRXBvY2hFbmQ/OiAoZXBvY2g6IG51bWJlciwgbG9ncz86IExvZ3MpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICBvbkJhdGNoQmVnaW4/OiAoYmF0Y2g6IG51bWJlciwgbG9ncz86IExvZ3MpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICBvbkJhdGNoRW5kPzogKGJhdGNoOiBudW1iZXIsIGxvZ3M/OiBMb2dzKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgb25ZaWVsZD86IChlcG9jaDogbnVtYmVyLCBiYXRjaDogbnVtYmVyLCBsb2dzOiBMb2dzKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgLy8gVXNlZCBmb3IgdGVzdCBESSBtb2NraW5nLlxuICBub3dGdW5jPzogRnVuY3Rpb247XG4gIG5leHRGcmFtZUZ1bmM/OiBGdW5jdGlvbjtcbn1cblxuLyoqXG4gKiBDdXN0b20gY2FsbGJhY2sgZm9yIHRyYWluaW5nLlxuICovXG5leHBvcnQgY2xhc3MgQ3VzdG9tQ2FsbGJhY2sgZXh0ZW5kcyBCYXNlQ2FsbGJhY2sge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgdHJhaW5CZWdpbjogKGxvZ3M/OiBMb2dzKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHRyYWluRW5kOiAobG9ncz86IExvZ3MpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZXBvY2hCZWdpbjpcbiAgICAgIChlcG9jaDogbnVtYmVyLCBsb2dzPzogTG9ncykgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIHByb3RlY3RlZCByZWFkb25seSBlcG9jaEVuZDpcbiAgICAgIChlcG9jaDogbnVtYmVyLCBsb2dzPzogTG9ncykgPT4gdm9pZCB8IFByb21pc2U8dm9pZD47XG4gIHByb3RlY3RlZCByZWFkb25seSBiYXRjaEJlZ2luOlxuICAgICAgKGJhdGNoOiBudW1iZXIsIGxvZ3M/OiBMb2dzKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGJhdGNoRW5kOlxuICAgICAgKGJhdGNoOiBudW1iZXIsIGxvZ3M/OiBMb2dzKSA9PiB2b2lkIHwgUHJvbWlzZTx2b2lkPjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHlpZWxkOlxuICAgICAgKGVwb2NoOiBudW1iZXIsIGJhdGNoOiBudW1iZXIsIGxvZ3M6IExvZ3MpID0+IHZvaWQgfCBQcm9taXNlPHZvaWQ+O1xuXG4gIHByaXZhdGUgeWllbGRFdmVyeTogWWllbGRFdmVyeU9wdGlvbnM7XG4gIHByaXZhdGUgY3VycmVudEVwb2NoID0gMDtcbiAgcHVibGljIG5vd0Z1bmM6IEZ1bmN0aW9uO1xuICBwdWJsaWMgbmV4dEZyYW1lRnVuYzogRnVuY3Rpb247XG5cbiAgY29uc3RydWN0b3IoYXJnczogQ3VzdG9tQ2FsbGJhY2tBcmdzLCB5aWVsZEV2ZXJ5PzogWWllbGRFdmVyeU9wdGlvbnMpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMubm93RnVuYyA9IGFyZ3Mubm93RnVuYztcbiAgICB0aGlzLm5leHRGcmFtZUZ1bmMgPSBhcmdzLm5leHRGcmFtZUZ1bmMgfHwgbmV4dEZyYW1lO1xuICAgIHRoaXMueWllbGRFdmVyeSA9IHlpZWxkRXZlcnkgfHwgJ2F1dG8nO1xuICAgIGlmICh0aGlzLnlpZWxkRXZlcnkgPT09ICdhdXRvJykge1xuICAgICAgdGhpcy55aWVsZEV2ZXJ5ID0gREVGQVVMVF9ZSUVMRF9FVkVSWV9NUztcbiAgICB9XG4gICAgaWYgKHRoaXMueWllbGRFdmVyeSA9PT0gJ25ldmVyJyAmJiBhcmdzLm9uWWllbGQgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICd5aWVsZEV2ZXJ5IGlzIGBuZXZlcmAgYnV0IHlvdSBwcm92aWRlZCBhbiBgb25ZaWVsZGAgY2FsbGJhY2suICcgK1xuICAgICAgICAgICdFaXRoZXIgY2hhbmdlIGB5aWVsZEV2ZXJ5YCBvciByZW1vdmUgdGhlIGNhbGxiYWNrJyk7XG4gICAgfVxuICAgIGlmICh1dGlsLmlzTnVtYmVyKHRoaXMueWllbGRFdmVyeSkpIHtcbiAgICAgIC8vIERlY29yYXRlIGBtYXliZVdhaXRgIHNvIGl0IHdpbGwgYmUgY2FsbGVkIGF0IG1vc3Qgb25jZSBldmVyeVxuICAgICAgLy8gYHlpZWxkRXZlcnlgIG1zLlxuICAgICAgdGhpcy5tYXliZVdhaXQgPSBnZW5lcmljX3V0aWxzLmRlYm91bmNlKFxuICAgICAgICAgIHRoaXMubWF5YmVXYWl0LmJpbmQodGhpcyksIHRoaXMueWllbGRFdmVyeSBhcyBudW1iZXIsIHRoaXMubm93RnVuYyk7XG4gICAgfVxuICAgIHRoaXMudHJhaW5CZWdpbiA9IGFyZ3Mub25UcmFpbkJlZ2luO1xuICAgIHRoaXMudHJhaW5FbmQgPSBhcmdzLm9uVHJhaW5FbmQ7XG4gICAgdGhpcy5lcG9jaEJlZ2luID0gYXJncy5vbkVwb2NoQmVnaW47XG4gICAgdGhpcy5lcG9jaEVuZCA9IGFyZ3Mub25FcG9jaEVuZDtcbiAgICB0aGlzLmJhdGNoQmVnaW4gPSBhcmdzLm9uQmF0Y2hCZWdpbjtcbiAgICB0aGlzLmJhdGNoRW5kID0gYXJncy5vbkJhdGNoRW5kO1xuICAgIHRoaXMueWllbGQgPSBhcmdzLm9uWWllbGQ7XG4gIH1cblxuICBhc3luYyBtYXliZVdhaXQoZXBvY2g6IG51bWJlciwgYmF0Y2g6IG51bWJlciwgbG9nczogVW5yZXNvbHZlZExvZ3MpIHtcbiAgICBjb25zdCBwczogQXJyYXk8dm9pZHxQcm9taXNlPHZvaWQ+PiA9IFtdO1xuICAgIGlmICh0aGlzLnlpZWxkICE9IG51bGwpIHtcbiAgICAgIGF3YWl0IHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpO1xuICAgICAgcHMucHVzaCh0aGlzLnlpZWxkKGVwb2NoLCBiYXRjaCwgbG9ncyBhcyBMb2dzKSk7XG4gICAgfVxuICAgIHBzLnB1c2godGhpcy5uZXh0RnJhbWVGdW5jKCkpO1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHBzKTtcbiAgfVxuXG4gIGFzeW5jIG9uRXBvY2hCZWdpbihlcG9jaDogbnVtYmVyLCBsb2dzPzogVW5yZXNvbHZlZExvZ3MpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICB0aGlzLmN1cnJlbnRFcG9jaCA9IGVwb2NoO1xuICAgIGlmICh0aGlzLmVwb2NoQmVnaW4gIT0gbnVsbCkge1xuICAgICAgYXdhaXQgcmVzb2x2ZVNjYWxhcnNJbkxvZ3MobG9ncyk7XG4gICAgICBhd2FpdCB0aGlzLmVwb2NoQmVnaW4oZXBvY2gsIGxvZ3MgYXMgTG9ncyk7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgb25FcG9jaEVuZChlcG9jaDogbnVtYmVyLCBsb2dzPzogVW5yZXNvbHZlZExvZ3MpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBjb25zdCBwczogQXJyYXk8dm9pZHxQcm9taXNlPHZvaWQ+PiA9IFtdO1xuICAgIGlmICh0aGlzLmVwb2NoRW5kICE9IG51bGwpIHtcbiAgICAgIGF3YWl0IHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpO1xuICAgICAgcHMucHVzaCh0aGlzLmVwb2NoRW5kKGVwb2NoLCBsb2dzIGFzIExvZ3MpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMueWllbGRFdmVyeSA9PT0gJ2Vwb2NoJykge1xuICAgICAgcHMucHVzaCh0aGlzLm5leHRGcmFtZUZ1bmMoKSk7XG4gICAgfVxuICAgIGF3YWl0IFByb21pc2UuYWxsKHBzKTtcbiAgfVxuXG4gIGFzeW5jIG9uQmF0Y2hCZWdpbihiYXRjaDogbnVtYmVyLCBsb2dzPzogVW5yZXNvbHZlZExvZ3MpOiBQcm9taXNlPHZvaWQ+IHtcbiAgICBpZiAodGhpcy5iYXRjaEJlZ2luICE9IG51bGwpIHtcbiAgICAgIGF3YWl0IHJlc29sdmVTY2FsYXJzSW5Mb2dzKGxvZ3MpO1xuICAgICAgYXdhaXQgdGhpcy5iYXRjaEJlZ2luKGJhdGNoLCBsb2dzIGFzIExvZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG9uQmF0Y2hFbmQoYmF0Y2g6IG51bWJlciwgbG9ncz86IFVucmVzb2x2ZWRMb2dzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgY29uc3QgcHM6IEFycmF5PHZvaWR8UHJvbWlzZTx2b2lkPj4gPSBbXTtcbiAgICBpZiAodGhpcy5iYXRjaEVuZCAhPSBudWxsKSB7XG4gICAgICBhd2FpdCByZXNvbHZlU2NhbGFyc0luTG9ncyhsb2dzKTtcbiAgICAgIHBzLnB1c2godGhpcy5iYXRjaEVuZChiYXRjaCwgbG9ncyBhcyBMb2dzKSk7XG4gICAgfVxuICAgIGlmICh0aGlzLnlpZWxkRXZlcnkgPT09ICdiYXRjaCcpIHtcbiAgICAgIHBzLnB1c2godGhpcy5uZXh0RnJhbWVGdW5jKCkpO1xuICAgIH0gZWxzZSBpZiAodXRpbC5pc051bWJlcih0aGlzLnlpZWxkRXZlcnkpKSB7XG4gICAgICBwcy5wdXNoKHRoaXMubWF5YmVXYWl0KHRoaXMuY3VycmVudEVwb2NoLCBiYXRjaCwgbG9ncykpO1xuICAgIH1cbiAgICBhd2FpdCBQcm9taXNlLmFsbChwcyk7XG4gIH1cblxuICBhc3luYyBvblRyYWluQmVnaW4obG9ncz86IFVucmVzb2x2ZWRMb2dzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMudHJhaW5CZWdpbiAhPSBudWxsKSB7XG4gICAgICBhd2FpdCByZXNvbHZlU2NhbGFyc0luTG9ncyhsb2dzKTtcbiAgICAgIGF3YWl0IHRoaXMudHJhaW5CZWdpbihsb2dzIGFzIExvZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGFzeW5jIG9uVHJhaW5FbmQobG9ncz86IFVucmVzb2x2ZWRMb2dzKTogUHJvbWlzZTx2b2lkPiB7XG4gICAgaWYgKHRoaXMudHJhaW5FbmQgIT0gbnVsbCkge1xuICAgICAgYXdhaXQgcmVzb2x2ZVNjYWxhcnNJbkxvZ3MobG9ncyk7XG4gICAgICBhd2FpdCB0aGlzLnRyYWluRW5kKGxvZ3MgYXMgTG9ncyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogU3RhbmRhcmRpemUgY2FsbGJhY2tzIG9yIGNvbmZpZ3VyYXRpb25zIG9mIHRoZW0gdG8gYW4gQXJyYXkgb2YgY2FsbGJhY2tzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhbmRhcmRpemVDYWxsYmFja3MoXG4gICAgY2FsbGJhY2tzOiBCYXNlQ2FsbGJhY2t8QmFzZUNhbGxiYWNrW118Q3VzdG9tQ2FsbGJhY2tBcmdzfFxuICAgIEN1c3RvbUNhbGxiYWNrQXJnc1tdLFxuICAgIHlpZWxkRXZlcnk6IFlpZWxkRXZlcnlPcHRpb25zKTogQmFzZUNhbGxiYWNrW10ge1xuICBpZiAoY2FsbGJhY2tzID09IG51bGwpIHtcbiAgICBjYWxsYmFja3MgPSB7fSBhcyBCYXNlQ2FsbGJhY2s7XG4gIH1cbiAgaWYgKGNhbGxiYWNrcyBpbnN0YW5jZW9mIEJhc2VDYWxsYmFjaykge1xuICAgIHJldHVybiBbY2FsbGJhY2tzXTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShjYWxsYmFja3MpICYmIGNhbGxiYWNrc1swXSBpbnN0YW5jZW9mIEJhc2VDYWxsYmFjaykge1xuICAgIHJldHVybiBjYWxsYmFja3MgYXMgQmFzZUNhbGxiYWNrW107XG4gIH1cbiAgLy8gQ29udmVydCBjdXN0b20gY2FsbGJhY2sgY29uZmlncyB0byBjdXN0b20gY2FsbGJhY2sgb2JqZWN0cy5cbiAgY29uc3QgY2FsbGJhY2tDb25maWdzID1cbiAgICAgIGdlbmVyaWNfdXRpbHMudG9MaXN0KGNhbGxiYWNrcykgYXMgQ3VzdG9tQ2FsbGJhY2tBcmdzW107XG4gIHJldHVybiBjYWxsYmFja0NvbmZpZ3MubWFwKFxuICAgICAgY2FsbGJhY2tDb25maWcgPT4gbmV3IEN1c3RvbUNhbGxiYWNrKGNhbGxiYWNrQ29uZmlnLCB5aWVsZEV2ZXJ5KSk7XG59XG5cbmV4cG9ydCBkZWNsYXJlIHR5cGUgQmFzZUNhbGxiYWNrQ29uc3RydWN0b3IgPSB7XG4gIG5ldyAoKTogQmFzZUNhbGxiYWNrXG59O1xuXG4vKipcbiAqIEEgZ2xvYmFsIHJlZ2lzdHJ5IGZvciBjYWxsYmFjayBjb25zdHJ1Y3RvcnMgdG8gYmUgdXNlZCBkdXJpbmdcbiAqIExheWVyc01vZGVsLmZpdCgpLlxuICovXG5leHBvcnQgY2xhc3MgQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5IHtcbiAgcHJpdmF0ZSBzdGF0aWMgY29uc3RydWN0b3JzOlxuICAgICAge1t2ZXJib3NpdHlMZXZlbDogbnVtYmVyXTogQmFzZUNhbGxiYWNrQ29uc3RydWN0b3JbXX0gPSB7fTtcblxuICAvKipcbiAgICogQmxvY2tzIHB1YmxpYyBhY2Nlc3MgdG8gY29uc3RydWN0b3IuXG4gICAqL1xuICBwcml2YXRlIGNvbnN0cnVjdG9yKCkge31cblxuICAvKipcbiAgICogUmVnaXN0ZXIgYSB0Zi5MYXllcnNNb2RlbC5maXQoKSBjYWxsYmFjayBjb25zdHJ1Y3Rvci5cbiAgICpcbiAgICogVGhlIHJlZ2lzdGVyZWQgY2FsbGJhY2sgY29uc3RydWN0b3Igd2lsbCBiZSB1c2VkIHRvIGluc3RhbnRpYXRlXG4gICAqIGNhbGxiYWNrcyBmb3IgZXZlcnkgdGYuTGF5ZXJzTW9kZWwuZml0KCkgY2FsbCBhZnRlcndhcmRzLlxuICAgKlxuICAgKiBAcGFyYW0gdmVyYm9zaXR5TGV2ZWwgTGV2ZWwgb2YgdmVyYm9zaXR5IGF0IHdoaWNoIHRoZSBgY2FsbGJhY2tDb25zdHJ1Y3RvcmBcbiAgICogICBpcyB0byBiZSByZWlnc3RlcmVkLlxuICAgKiBAcGFyYW0gY2FsbGJhY2tDb25zdHJ1Y3RvciBBIG5vLWFyZyBjb25zdHJ1Y3RvciBmb3IgYHRmLkNhbGxiYWNrYC5cbiAgICogQHRocm93cyBFcnJvciwgaWYgdGhlIHNhbWUgY2FsbGJhY2tDb25zdHJ1Y3RvciBoYXMgYmVlbiByZWdpc3RlcmVkIGJlZm9yZSxcbiAgICogICBlaXRoZXIgYXQgdGhlIHNhbWUgb3IgYSBkaWZmZXJlbnQgYHZlcmJvc2l0eUxldmVsYC5cbiAgICovXG4gIHN0YXRpYyByZWdpc3RlckNhbGxiYWNrQ29uc3RydWN0b3IoXG4gICAgICB2ZXJib3NpdHlMZXZlbDogbnVtYmVyLCBjYWxsYmFja0NvbnN0cnVjdG9yOiBCYXNlQ2FsbGJhY2tDb25zdHJ1Y3Rvcikge1xuICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICB2ZXJib3NpdHlMZXZlbCA+PSAwICYmIE51bWJlci5pc0ludGVnZXIodmVyYm9zaXR5TGV2ZWwpLFxuICAgICAgICAoKSA9PiBgVmVyYm9zaXR5IGxldmVsIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGludGVnZXIgPj0gMCwgYCArXG4gICAgICAgICAgICBgYnV0IGdvdCAke3ZlcmJvc2l0eUxldmVsfWApO1xuICAgIENhbGxiYWNrQ29uc3RydWN0b3JSZWdpc3RyeS5jaGVja0ZvckR1cGxpY2F0ZShjYWxsYmFja0NvbnN0cnVjdG9yKTtcbiAgICBpZiAoQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5LmNvbnN0cnVjdG9yc1t2ZXJib3NpdHlMZXZlbF0gPT0gbnVsbCkge1xuICAgICAgQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5LmNvbnN0cnVjdG9yc1t2ZXJib3NpdHlMZXZlbF0gPSBbXTtcbiAgICB9XG4gICAgQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5LmNvbnN0cnVjdG9yc1t2ZXJib3NpdHlMZXZlbF0ucHVzaChcbiAgICAgICAgY2FsbGJhY2tDb25zdHJ1Y3Rvcik7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBjaGVja0ZvckR1cGxpY2F0ZShjYWxsYmFja0NvbnN0cnVjdG9yOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgQmFzZUNhbGxiYWNrQ29uc3RydWN0b3IpIHtcbiAgICBmb3IgKGNvbnN0IGxldmVsTmFtZSBpbiBDYWxsYmFja0NvbnN0cnVjdG9yUmVnaXN0cnkuY29uc3RydWN0b3JzKSB7XG4gICAgICBjb25zdCBjb25zdHJ1Y3RvcnMgPSBDYWxsYmFja0NvbnN0cnVjdG9yUmVnaXN0cnkuY29uc3RydWN0b3JzWytsZXZlbE5hbWVdO1xuICAgICAgY29uc3RydWN0b3JzLmZvckVhY2goY3RvciA9PiB7XG4gICAgICAgIGlmIChjdG9yID09PSBjYWxsYmFja0NvbnN0cnVjdG9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ0R1cGxpY2F0ZSBjYWxsYmFjayBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENsZWFyIGFsbCByZWdpc3RlcmVkIGNhbGxiYWNrIGNvbnN0cnVjdG9ycy5cbiAgICovXG4gIHByb3RlY3RlZCBzdGF0aWMgY2xlYXIoKSB7XG4gICAgQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5LmNvbnN0cnVjdG9ycyA9IHt9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZSBjYWxsYmFja3MgdXNpbmcgdGhlIHJlZ2lzdGVyZWQgY2FsbGJhY2sgY29uc3RydWN0b3JzLlxuICAgKlxuICAgKiBHaXZlbiBgdmVyYm9zaXR5TGV2ZWxgLCBhbGwgY29uc3RydWN0b3JzIHJlZ2lzdGVyZWQgYXQgdGhhdCBsZXZlbCBvciBhYm92ZVxuICAgKiB3aWxsIGJlIGNhbGxlZCBhbmQgdGhlIGluc3RhbnRpYXRlZCBjYWxsYmFja3Mgd2lsbCBiZSB1c2VkLlxuICAgKlxuICAgKiBAcGFyYW0gdmVyYm9zaXR5TGV2ZWw6IExldmVsIG9mIHZlcmJvc2l0eS5cbiAgICovXG4gIHN0YXRpYyBjcmVhdGVDYWxsYmFja3ModmVyYm9zaXR5TGV2ZWw6IG51bWJlcik6IEJhc2VDYWxsYmFja1tdIHtcbiAgICBjb25zdCBjb25zdHJ1Y3RvcnM6IEJhc2VDYWxsYmFja0NvbnN0cnVjdG9yW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxldmVsTmFtZSBpbiBDYWxsYmFja0NvbnN0cnVjdG9yUmVnaXN0cnkuY29uc3RydWN0b3JzKSB7XG4gICAgICBjb25zdCBsZXZlbCA9ICtsZXZlbE5hbWU7XG4gICAgICBpZiAodmVyYm9zaXR5TGV2ZWwgPj0gbGV2ZWwpIHtcbiAgICAgICAgY29uc3RydWN0b3JzLnB1c2goLi4uQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5LmNvbnN0cnVjdG9yc1tsZXZlbF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY29uc3RydWN0b3JzLm1hcChjdG9yID0+IG5ldyBjdG9yKCkpO1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmVDYWxsYmFja3MoXG4gICAgY2FsbGJhY2tzOiBCYXNlQ2FsbGJhY2tbXSwgdmVyYm9zZTogTW9kZWxMb2dnaW5nVmVyYm9zaXR5LCBlcG9jaHM6IG51bWJlcixcbiAgICBpbml0aWFsRXBvY2g6IG51bWJlciwgbnVtVHJhaW5TYW1wbGVzOiBudW1iZXIsIHN0ZXBzUGVyRXBvY2g6IG51bWJlcixcbiAgICBiYXRjaFNpemU6IG51bWJlciwgZG9WYWxpZGF0aW9uOiBib29sZWFuLFxuICAgIGNhbGxiYWNrTWV0cmljczogc3RyaW5nW10pOiB7Y2FsbGJhY2tMaXN0OiBDYWxsYmFja0xpc3QsIGhpc3Rvcnk6IEhpc3Rvcnl9IHtcbiAgY29uc3QgaGlzdG9yeSA9IG5ldyBIaXN0b3J5KCk7XG4gIGNvbnN0IGFjdHVhbENhbGxiYWNrczogQmFzZUNhbGxiYWNrW10gPSBbXG4gICAgbmV3IEJhc2VMb2dnZXIoKSwgLi4uQ2FsbGJhY2tDb25zdHJ1Y3RvclJlZ2lzdHJ5LmNyZWF0ZUNhbGxiYWNrcyh2ZXJib3NlKVxuICBdO1xuICBpZiAoY2FsbGJhY2tzICE9IG51bGwpIHtcbiAgICBhY3R1YWxDYWxsYmFja3MucHVzaCguLi5jYWxsYmFja3MpO1xuICB9XG4gIGFjdHVhbENhbGxiYWNrcy5wdXNoKGhpc3RvcnkpO1xuICBjb25zdCBjYWxsYmFja0xpc3QgPSBuZXcgQ2FsbGJhY2tMaXN0KGFjdHVhbENhbGxiYWNrcyk7XG5cbiAgLy8gVE9ETyhjYWlzKTogRmlndXJlIG91dCB3aGVuIHRoaXMgTGF5ZXJzTW9kZWwgaW5zdGFuY2UgY2FuIGhhdmUgYVxuICAvLyBkeW5hbWljYWxseVxuICAvLyAgIHNldCBwcm9wZXJ0eSBjYWxsZWQgJ2NhbGxiYWNrX21vZGVsJyBhcyBpbiBQeUtlcmFzLlxuXG4gIGNhbGxiYWNrTGlzdC5zZXRQYXJhbXMoe1xuICAgIGVwb2NocyxcbiAgICBpbml0aWFsRXBvY2gsXG4gICAgc2FtcGxlczogbnVtVHJhaW5TYW1wbGVzLFxuICAgIHN0ZXBzOiBzdGVwc1BlckVwb2NoLFxuICAgIGJhdGNoU2l6ZSxcbiAgICB2ZXJib3NlLFxuICAgIGRvVmFsaWRhdGlvbixcbiAgICBtZXRyaWNzOiBjYWxsYmFja01ldHJpY3MsXG4gIH0pO1xuICByZXR1cm4ge2NhbGxiYWNrTGlzdCwgaGlzdG9yeX07XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original Source layers/__init__.py */\nimport { serialization } from '@tensorflow/tfjs-core';\nimport { deserializeKerasObject } from '../utils/generic_utils';\n/**\n * Instantiate a layer from a config dictionary.\n * @param config dict of the form {class_name: str, config: dict}\n * @param customObjects dict mapping class names (or function names)\n *   of custom (non-Keras) objects to class/functions\n * @param fastWeightInit Optional flag to use fast weight initialization\n *   during deserialization. This is applicable to cases in which\n *   the initialization will be immediately overwritten by loaded weight\n *   values. Default: `false`.\n * @returns Layer instance (may be LayersModel, Sequential, Layer...)\n */\nexport function deserialize(config, customObjects = {}, fastWeightInit = false) {\n    return deserializeKerasObject(config, serialization.SerializationMap.getMap().classNameMap, customObjects, 'layer', fastWeightInit);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsaXphdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvc2VyaWFsaXphdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILHdDQUF3QztBQUN4QyxPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFcEQsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFFOUQ7Ozs7Ozs7Ozs7R0FVRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3ZCLE1BQWdDLEVBQ2hDLGdCQUFnQixFQUE4QixFQUM5QyxjQUFjLEdBQUcsS0FBSztJQUN4QixPQUFPLHNCQUFzQixDQUN6QixNQUFNLEVBQUUsYUFBYSxDQUFDLGdCQUFnQixDQUFDLE1BQU0sRUFBRSxDQUFDLFlBQVksRUFDNUQsYUFBYSxFQUFFLE9BQU8sRUFBRSxjQUFjLENBQUMsQ0FBQztBQUM5QyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyogT3JpZ2luYWwgU291cmNlIGxheWVycy9fX2luaXRfXy5weSAqL1xuaW1wb3J0IHtzZXJpYWxpemF0aW9ufSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge2Rlc2VyaWFsaXplS2VyYXNPYmplY3R9IGZyb20gJy4uL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuXG4vKipcbiAqIEluc3RhbnRpYXRlIGEgbGF5ZXIgZnJvbSBhIGNvbmZpZyBkaWN0aW9uYXJ5LlxuICogQHBhcmFtIGNvbmZpZyBkaWN0IG9mIHRoZSBmb3JtIHtjbGFzc19uYW1lOiBzdHIsIGNvbmZpZzogZGljdH1cbiAqIEBwYXJhbSBjdXN0b21PYmplY3RzIGRpY3QgbWFwcGluZyBjbGFzcyBuYW1lcyAob3IgZnVuY3Rpb24gbmFtZXMpXG4gKiAgIG9mIGN1c3RvbSAobm9uLUtlcmFzKSBvYmplY3RzIHRvIGNsYXNzL2Z1bmN0aW9uc1xuICogQHBhcmFtIGZhc3RXZWlnaHRJbml0IE9wdGlvbmFsIGZsYWcgdG8gdXNlIGZhc3Qgd2VpZ2h0IGluaXRpYWxpemF0aW9uXG4gKiAgIGR1cmluZyBkZXNlcmlhbGl6YXRpb24uIFRoaXMgaXMgYXBwbGljYWJsZSB0byBjYXNlcyBpbiB3aGljaFxuICogICB0aGUgaW5pdGlhbGl6YXRpb24gd2lsbCBiZSBpbW1lZGlhdGVseSBvdmVyd3JpdHRlbiBieSBsb2FkZWQgd2VpZ2h0XG4gKiAgIHZhbHVlcy4gRGVmYXVsdDogYGZhbHNlYC5cbiAqIEByZXR1cm5zIExheWVyIGluc3RhbmNlIChtYXkgYmUgTGF5ZXJzTW9kZWwsIFNlcXVlbnRpYWwsIExheWVyLi4uKVxuICovXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemUoXG4gICAgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QsXG4gICAgY3VzdG9tT2JqZWN0cyA9IHt9IGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCxcbiAgICBmYXN0V2VpZ2h0SW5pdCA9IGZhbHNlKTogc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGUge1xuICByZXR1cm4gZGVzZXJpYWxpemVLZXJhc09iamVjdChcbiAgICAgIGNvbmZpZywgc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCxcbiAgICAgIGN1c3RvbU9iamVjdHMsICdsYXllcicsIGZhc3RXZWlnaHRJbml0KTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original Source: losses.py */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { tidy, util } from '@tensorflow/tfjs-core';\nimport { epsilon } from './backend/common';\nimport * as K from './backend/tfjs_backend';\nimport { ValueError } from './errors';\n/**\n * Normalizes a tensor wrt the L2 norm alongside the specified axis.\n * @param x\n * @param axis Axis along which to perform normalization.\n */\nexport function l2Normalize(x, axis) {\n    return tidy(() => {\n        if (x.dtype !== 'float32') {\n            x = tfc.cast(x, 'float32');\n        }\n        const squareSum = tfc.sum(K.square(x), axis, true);\n        const epsilonTensor = tfc.fill(squareSum.shape, epsilon());\n        const norm = tfc.sqrt(tfc.maximum(squareSum, epsilonTensor));\n        return tfc.div(x, norm);\n    });\n}\nexport function meanSquaredError(yTrue, yPred) {\n    return tidy(() => tfc.mean(K.square(tfc.sub(yPred, yTrue)), -1));\n}\nexport function meanAbsoluteError(yTrue, yPred) {\n    return tidy(() => tfc.mean(tfc.abs(tfc.sub(yPred, yTrue)), -1));\n}\nexport function meanAbsolutePercentageError(yTrue, yPred) {\n    return tidy(() => {\n        const diff = tfc.sub(yTrue, yPred);\n        const clippedTrue = tfc.clipByValue(tfc.abs(yTrue), epsilon(), Number.MAX_VALUE);\n        const absResult = tfc.abs(tfc.div(diff, clippedTrue));\n        return tfc.mul(100, tfc.mean(absResult, -1));\n    });\n}\nexport function meanSquaredLogarithmicError(yTrue, yPred) {\n    return tidy(() => {\n        const clippedPred = tfc.clipByValue(yPred, epsilon(), Number.MAX_VALUE);\n        const firstLog = tfc.log(tfc.add(1, clippedPred));\n        const clippedTrue = tfc.clipByValue(yTrue, epsilon(), Number.MAX_VALUE);\n        const secondLog = tfc.log(tfc.add(1, clippedTrue));\n        return tfc.mean(K.square(tfc.sub(firstLog, secondLog)), -1);\n    });\n}\nexport function squaredHinge(yTrue, yPred) {\n    return tidy(() => {\n        const maxResult = tfc.maximum(0, tfc.sub(1, tfc.mul(yTrue, yPred)));\n        return tfc.mean(K.square(maxResult), -1);\n    });\n}\nexport function hinge(yTrue, yPred) {\n    return tidy(() => {\n        const maxResult = tfc.maximum(0, tfc.sub(1, tfc.mul(yTrue, yPred)));\n        return tfc.mean(maxResult, -1);\n    });\n}\nexport function categoricalHinge(yTrue, yPred) {\n    return tidy(() => {\n        const pos = tfc.sum(tfc.mul(yTrue, yPred), -1);\n        const neg = tfc.max(tfc.mul(tfc.sub(1, yTrue), yPred), -1);\n        return tfc.maximum(0, tfc.add(1, tfc.sub(neg, pos)));\n    });\n}\n/**\n * Logarithm of the hyperbolic cosine of the prediction error.\n *\n * `log(cosh(x))` is approximately equal to `(x ** 2) / 2` for small `x` and\n * to `abs(x) - log(2)` for large `x`. This means that 'logcosh' works mostly\n * like the mean squared error, but will not be so strongly affected by the\n * occasional wildly incorrect prediction.\n */\nexport function logcosh(yTrue, yPred) {\n    return tidy(() => {\n        const log2 = Math.log(2);\n        const predictionDiff = tfc.sub(yPred, yTrue);\n        const logcoshResult = tfc.sub(tfc.add(predictionDiff, tfc.softplus(tfc.mul(-2, predictionDiff))), log2);\n        return tfc.mean(logcoshResult, -1);\n    });\n}\nexport function categoricalCrossentropy(target, output, fromLogits = false) {\n    return tidy(() => {\n        if (fromLogits) {\n            output = tfc.softmax(output);\n        }\n        else {\n            // scale preds so that the class probabilities of each sample sum to 1.\n            const outputSum = tfc.sum(output, output.shape.length - 1, true);\n            output = tfc.div(output, outputSum);\n        }\n        output = tfc.clipByValue(output, epsilon(), 1 - epsilon());\n        return tfc.neg(tfc.sum(tfc.mul(tfc.cast(target, 'float32'), tfc.log(output)), output.shape.length - 1));\n    });\n}\n/**\n * Categorical crossentropy with integer targets.\n *\n * @param target An integer tensor.\n * @param output A tensor resulting from a softmax (unless `fromLogits` is\n *  `true`, in which case `output` is expected to be the logits).\n * @param fromLogits Boolean, whether `output` is the result of a softmax, or is\n *   a tensor of logits.\n */\nexport function sparseCategoricalCrossentropy(target, output, fromLogits = false) {\n    return tidy(() => {\n        const flatTarget = tfc.cast(tfc.floor(K.flatten(target)), 'int32');\n        output = tfc.clipByValue(output, epsilon(), 1 - epsilon());\n        const outputShape = output.shape;\n        const oneHotTarget = tfc.reshape(tfc.oneHot(flatTarget, outputShape[outputShape.length - 1]), outputShape);\n        return categoricalCrossentropy(oneHotTarget, output, fromLogits);\n    });\n}\n/**\n * From TensorFlow's implementation in nn_impl.py:\n *\n * For brevity, let `x = logits`, `z = labels`.  The logistic loss is\n *      z * -log(sigmoid(x)) + (1 - z) * -log(1 - sigmoid(x))\n *    = z * -log(1 / (1 + exp(-x))) + (1 - z) * -log(exp(-x) / (1 + exp(-x)))\n *    = z * log(1 + exp(-x)) + (1 - z) * (-log(exp(-x)) + log(1 + exp(-x)))\n *    = z * log(1 + exp(-x)) + (1 - z) * (x + log(1 + exp(-x))\n *    = (1 - z) * x + log(1 + exp(-x))\n *    = x - x * z + log(1 + exp(-x))\n * For x < 0, to avoid overflow in exp(-x), we reformulate the above\n *      x - x * z + log(1 + exp(-x))\n *    = log(exp(x)) - x * z + log(1 + exp(-x))\n *    = - x * z + log(1 + exp(x))\n * Hence, to ensure stability and avoid overflow, the implementation uses this\n * equivalent formulation\n *    max(x, 0) - x * z + log(1 + exp(-abs(x)))\n *\n * @param labels The labels.\n * @param logits The logits.\n */\nexport function sigmoidCrossEntropyWithLogits(labels, logits) {\n    if (!util.arraysEqual(labels.shape, logits.shape)) {\n        throw new ValueError(`logits and labels must have the same shape, but got shapes ` +\n            `${JSON.stringify(labels.shape)} and ${JSON.stringify(logits.shape)}`);\n    }\n    return tidy(() => {\n        // The logistic loss formula from above is\n        //   x - x * z + log(1 + exp(-x))\n        // For x < 0, a more numerically stable formula is\n        //   -x * z + log(1 + exp(x))\n        // Note that these two expressions can be combined into the following:\n        //   max(x, 0) - x * z + log(1 + exp(-abs(x)))\n        const reluLogits = tfc.relu(logits);\n        const negAbsLogits = tfc.neg(tfc.abs(logits));\n        return tfc.add(tfc.sub(reluLogits, tfc.mul(logits, labels)), tfc.log1p(tfc.exp(negAbsLogits)));\n    });\n}\nexport function binaryCrossentropy(yTrue, yPred) {\n    return tidy(() => {\n        let y;\n        y = tfc.clipByValue(yPred, epsilon(), 1 - epsilon());\n        y = tfc.log(tfc.div(y, tfc.sub(1, y)));\n        return tfc.mean(sigmoidCrossEntropyWithLogits(yTrue, y), -1);\n    });\n}\nexport function kullbackLeiblerDivergence(yTrue, yPred) {\n    return tidy(() => {\n        const clippedTrue = tfc.clipByValue(yTrue, epsilon(), 1);\n        const clippedPred = tfc.clipByValue(yPred, epsilon(), 1);\n        return tfc.sum(tfc.mul(yTrue, tfc.log(tfc.div(clippedTrue, clippedPred))), -1);\n    });\n}\nexport function poisson(yTrue, yPred) {\n    return tidy(() => {\n        const logPred = tfc.log(tfc.add(epsilon(), yPred));\n        return tfc.mean(tfc.sub(yPred, tfc.mul(yTrue, logPred)), -1);\n    });\n}\nexport function cosineProximity(yTrue, yPred) {\n    return tidy(() => {\n        const trueNormalized = l2Normalize(yTrue, -1);\n        const predNormalized = l2Normalize(yPred, -1);\n        const trueXPred = tfc.mul(trueNormalized, predNormalized);\n        return tfc.neg(tfc.sum(trueXPred, -1));\n    });\n}\nexport const mse = meanSquaredError;\nexport const MSE = meanSquaredError;\nexport const mae = meanAbsoluteError;\nexport const MAE = meanAbsoluteError;\nexport const mape = meanAbsolutePercentageError;\nexport const MAPE = meanAbsolutePercentageError;\nexport const msle = meanSquaredLogarithmicError;\nexport const MSLE = meanSquaredLogarithmicError;\nexport const kld = kullbackLeiblerDivergence;\nexport const KLD = kullbackLeiblerDivergence;\nexport const cosine = cosineProximity;\n// TODO(michaelterry): Add deserialize() function.\nexport const lossesMap = {\n    meanSquaredError,\n    meanAbsoluteError,\n    meanAbsolutePercentageError,\n    meanSquaredLogarithmicError,\n    squaredHinge,\n    hinge,\n    categoricalHinge,\n    logcosh,\n    categoricalCrossentropy,\n    sparseCategoricalCrossentropy,\n    binaryCrossentropy,\n    kullbackLeiblerDivergence,\n    poisson,\n    cosineProximity\n};\n// Porting note: This diverges from the PyKeras implementation and may need to\n// change based on (de)serialization requirements.\nexport function get(identifierOrFn) {\n    if (typeof identifierOrFn === 'string') {\n        if (identifierOrFn in lossesMap) {\n            return lossesMap[identifierOrFn];\n        }\n        let errMsg = `Unknown loss ${identifierOrFn}`;\n        if (identifierOrFn.toLowerCase().includes('softmaxcrossentropy')) {\n            errMsg = `Unknown loss ${identifierOrFn}. ` +\n                'Use \"categoricalCrossentropy\" as the string name for ' +\n                'tf.losses.softmaxCrossEntropy';\n        }\n        throw new ValueError(errMsg);\n    }\n    else {\n        return identifierOrFn;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9zc2VzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2xvc3Nlcy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILGdDQUFnQztBQUNoQyxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBbUIsSUFBSSxFQUFFLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRW5FLE9BQU8sRUFBQyxPQUFPLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUN6QyxPQUFPLEtBQUssQ0FBQyxNQUFNLHdCQUF3QixDQUFDO0FBQzVDLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFHcEM7Ozs7R0FJRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQUMsQ0FBUyxFQUFFLElBQWE7SUFDbEQsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDLENBQUMsS0FBSyxLQUFLLFNBQVMsRUFBRTtZQUN6QixDQUFDLEdBQUcsR0FBRyxDQUFDLElBQUksQ0FBQyxDQUFDLEVBQUUsU0FBUyxDQUFDLENBQUM7U0FDNUI7UUFDRCxNQUFNLFNBQVMsR0FBRyxHQUFHLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxFQUFFLElBQUksQ0FBQyxDQUFDO1FBQ25ELE1BQU0sYUFBYSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBUyxDQUFDLEtBQUssRUFBRSxPQUFPLEVBQUUsQ0FBQyxDQUFDO1FBQzNELE1BQU0sSUFBSSxHQUFHLEdBQUcsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLE9BQU8sQ0FBQyxTQUFTLEVBQUUsYUFBYSxDQUFDLENBQUMsQ0FBQztRQUM3RCxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLElBQUksQ0FBQyxDQUFDO0lBQzFCLENBQUMs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SUFDM0IsWUFBWTtJQUNaLEtBQUs7SUFDTCxnQkFBZ0I7SUFDaEIsT0FBTztJQUNQLHVCQUF1QjtJQUN2Qiw2QkFBNkI7SUFDN0Isa0JBQWtCO0lBQ2xCLHlCQUF5QjtJQUN6QixPQUFPO0lBQ1AsZUFBZTtDQUNoQixDQUFDO0FBRUYsOEVBQThFO0FBQzlFLGtEQUFrRDtBQUNsRCxNQUFNLFVBQVUsR0FBRyxDQUFDLGNBQXFDO0lBQ3ZELElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFFO1FBQ3RDLElBQUksY0FBYyxJQUFJLFNBQVMsRUFBRTtZQUMvQixPQUFPLFNBQVMsQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUNsQztRQUNELElBQUksTUFBTSxHQUFHLGdCQUFnQixjQUFjLEVBQUUsQ0FBQztRQUM5QyxJQUFJLGNBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxRQUFRLENBQUMscUJBQXFCLENBQUMsRUFBRTtZQUNoRSxNQUFNLEdBQUcsZ0JBQWdCLGNBQWMsSUFBSTtnQkFDdkMsdURBQXVEO2dCQUN2RCwrQkFBK0IsQ0FBQztTQUNyQztRQUNELE1BQU0sSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLENBQUM7S0FDOUI7U0FBTTtRQUNMLE9BQU8sY0FBYyxDQUFDO0tBQ3ZCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qIE9yaWdpbmFsIFNvdXJjZTogbG9zc2VzLnB5ICovXG5pbXBvcnQgKiBhcyB0ZmMgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7VGVuc29yLCBUZW5zb3IxRCwgdGlkeSwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtlcHNpbG9ufSBmcm9tICcuL2JhY2tlbmQvY29tbW9uJztcbmltcG9ydCAqIGFzIEsgZnJvbSAnLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge1ZhbHVlRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcbmltcG9ydCB7TG9zc09yTWV0cmljRm59IGZyb20gJy4vdHlwZXMnO1xuXG4vKipcbiAqIE5vcm1hbGl6ZXMgYSB0ZW5zb3Igd3J0IHRoZSBMMiBub3JtIGFsb25nc2lkZSB0aGUgc3BlY2lmaWVkIGF4aXMuXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIGF4aXMgQXhpcyBhbG9uZyB3aGljaCB0byBwZXJmb3JtIG5vcm1hbGl6YXRpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsMk5vcm1hbGl6ZSh4OiBUZW5zb3IsIGF4aXM/OiBudW1iZXIpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKHguZHR5cGUgIT09ICdmbG9hdDMyJykge1xuICAgICAgeCA9IHRmYy5jYXN0KHgsICdmbG9hdDMyJyk7XG4gICAgfVxuICAgIGNvbnN0IHNxdWFyZVN1bSA9IHRmYy5zdW0oSy5zcXVhcmUoeCksIGF4aXMsIHRydWUpO1xuICAgIGNvbnN0IGVwc2lsb25UZW5zb3IgPSB0ZmMuZmlsbChzcXVhcmVTdW0uc2hhcGUsIGVwc2lsb24oKSk7XG4gICAgY29uc3Qgbm9ybSA9IHRmYy5zcXJ0KHRmYy5tYXhpbXVtKHNxdWFyZVN1bSwgZXBzaWxvblRlbnNvcikpO1xuICAgIHJldHVybiB0ZmMuZGl2KHgsIG5vcm0pO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1lYW5TcXVhcmVkRXJyb3IoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHRmYy5tZWFuKEsuc3F1YXJlKHRmYy5zdWIoeVByZWQsIHlUcnVlKSksIC0xKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZWFuQWJzb2x1dGVFcnJvcih5VHJ1ZTogVGVuc29yLCB5UHJlZDogVGVuc29yKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4gdGZjLm1lYW4odGZjLmFicyh0ZmMuc3ViKHlQcmVkLCB5VHJ1ZSkpLCAtMSkpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yKFxuICAgIHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgZGlmZiA9IHRmYy5zdWIoeVRydWUsIHlQcmVkKTtcbiAgICBjb25zdCBjbGlwcGVkVHJ1ZSA9XG4gICAgICAgIHRmYy5jbGlwQnlWYWx1ZSh0ZmMuYWJzKHlUcnVlKSwgZXBzaWxvbigpLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICBjb25zdCBhYnNSZXN1bHQgPSB0ZmMuYWJzKHRmYy5kaXYoZGlmZiwgY2xpcHBlZFRydWUpKTtcbiAgICByZXR1cm4gdGZjLm11bCgxMDAsIHRmYy5tZWFuKGFic1Jlc3VsdCwgLTEpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3IoXG4gICAgeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBjbGlwcGVkUHJlZCA9IHRmYy5jbGlwQnlWYWx1ZSh5UHJlZCwgZXBzaWxvbigpLCBOdW1iZXIuTUFYX1ZBTFVFKTtcbiAgICBjb25zdCBmaXJzdExvZyA9IHRmYy5sb2codGZjLmFkZCgxLCBjbGlwcGVkUHJlZCkpO1xuXG4gICAgY29uc3QgY2xpcHBlZFRydWUgPSB0ZmMuY2xpcEJ5VmFsdWUoeVRydWUsIGVwc2lsb24oKSwgTnVtYmVyLk1BWF9WQUxVRSk7XG4gICAgY29uc3Qgc2Vjb25kTG9nID0gdGZjLmxvZyh0ZmMuYWRkKDEsIGNsaXBwZWRUcnVlKSk7XG5cbiAgICByZXR1cm4gdGZjLm1lYW4oSy5zcXVhcmUodGZjLnN1YihmaXJzdExvZywgc2Vjb25kTG9nKSksIC0xKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcXVhcmVkSGluZ2UoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBtYXhSZXN1bHQgPSB0ZmMubWF4aW11bSgwLCB0ZmMuc3ViKDEsIHRmYy5tdWwoeVRydWUsIHlQcmVkKSkpO1xuICAgIHJldHVybiB0ZmMubWVhbihLLnNxdWFyZShtYXhSZXN1bHQpLCAtMSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaGluZ2UoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBtYXhSZXN1bHQgPSB0ZmMubWF4aW11bSgwLCB0ZmMuc3ViKDEsIHRmYy5tdWwoeVRydWUsIHlQcmVkKSkpO1xuICAgIHJldHVybiB0ZmMubWVhbihtYXhSZXN1bHQsIC0xKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBjYXRlZ29yaWNhbEhpbmdlKHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgcG9zID0gdGZjLnN1bSh0ZmMubXVsKHlUcnVlLCB5UHJlZCksIC0xKTtcbiAgICBjb25zdCBuZWcgPSB0ZmMubWF4KHRmYy5tdWwodGZjLnN1YigxLCB5VHJ1ZSksIHlQcmVkKSwgLTEpO1xuICAgIHJldHVybiB0ZmMubWF4aW11bSgwLCB0ZmMuYWRkKDEsIHRmYy5zdWIobmVnLCBwb3MpKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIExvZ2FyaXRobSBvZiB0aGUgaHlwZXJib2xpYyBjb3NpbmUgb2YgdGhlIHByZWRpY3Rpb24gZXJyb3IuXG4gKlxuICogYGxvZyhjb3NoKHgpKWAgaXMgYXBwcm94aW1hdGVseSBlcXVhbCB0byBgKHggKiogMikgLyAyYCBmb3Igc21hbGwgYHhgIGFuZFxuICogdG8gYGFicyh4KSAtIGxvZygyKWAgZm9yIGxhcmdlIGB4YC4gVGhpcyBtZWFucyB0aGF0ICdsb2djb3NoJyB3b3JrcyBtb3N0bHlcbiAqIGxpa2UgdGhlIG1lYW4gc3F1YXJlZCBlcnJvciwgYnV0IHdpbGwgbm90IGJlIHNvIHN0cm9uZ2x5IGFmZmVjdGVkIGJ5IHRoZVxuICogb2NjYXNpb25hbCB3aWxkbHkgaW5jb3JyZWN0IHByZWRpY3Rpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBsb2djb3NoKHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgbG9nMiA9IE1hdGgubG9nKDIpO1xuICAgIGNvbnN0IHByZWRpY3Rpb25EaWZmID0gdGZjLnN1Yih5UHJlZCwgeVRydWUpO1xuICAgIGNvbnN0IGxvZ2Nvc2hSZXN1bHQgPSB0ZmMuc3ViKFxuICAgICAgICB0ZmMuYWRkKHByZWRpY3Rpb25EaWZmLCB0ZmMuc29mdHBsdXModGZjLm11bCgtMiwgcHJlZGljdGlvbkRpZmYpKSksXG4gICAgICAgIGxvZzIpO1xuICAgIHJldHVybiB0ZmMubWVhbihsb2djb3NoUmVzdWx0LCAtMSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkoXG4gICAgdGFyZ2V0OiBUZW5zb3IsIG91dHB1dDogVGVuc29yLCBmcm9tTG9naXRzID0gZmFsc2UpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKGZyb21Mb2dpdHMpIHtcbiAgICAgIG91dHB1dCA9IHRmYy5zb2Z0bWF4KG91dHB1dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNjYWxlIHByZWRzIHNvIHRoYXQgdGhlIGNsYXNzIHByb2JhYmlsaXRpZXMgb2YgZWFjaCBzYW1wbGUgc3VtIHRvIDEuXG4gICAgICBjb25zdCBvdXRwdXRTdW0gPSB0ZmMuc3VtKG91dHB1dCwgb3V0cHV0LnNoYXBlLmxlbmd0aCAtIDEsIHRydWUpO1xuICAgICAgb3V0cHV0ID0gdGZjLmRpdihvdXRwdXQsIG91dHB1dFN1bSk7XG4gICAgfVxuICAgIG91dHB1dCA9IHRmYy5jbGlwQnlWYWx1ZShvdXRwdXQsIGVwc2lsb24oKSwgMSAtIGVwc2lsb24oKSk7XG4gICAgcmV0dXJuIHRmYy5uZWcodGZjLnN1bShcbiAgICAgICAgdGZjLm11bCh0ZmMuY2FzdCh0YXJnZXQsICdmbG9hdDMyJyksIHRmYy5sb2cob3V0cHV0KSksXG4gICAgICAgIG91dHB1dC5zaGFwZS5sZW5ndGggLSAxKSk7XG4gIH0pO1xufVxuXG4vKipcbiAqIENhdGVnb3JpY2FsIGNyb3NzZW50cm9weSB3aXRoIGludGVnZXIgdGFyZ2V0cy5cbiAqXG4gKiBAcGFyYW0gdGFyZ2V0IEFuIGludGVnZXIgdGVuc29yLlxuICogQHBhcmFtIG91dHB1dCBBIHRlbnNvciByZXN1bHRpbmcgZnJvbSBhIHNvZnRtYXggKHVubGVzcyBgZnJvbUxvZ2l0c2AgaXNcbiAqICBgdHJ1ZWAsIGluIHdoaWNoIGNhc2UgYG91dHB1dGAgaXMgZXhwZWN0ZWQgdG8gYmUgdGhlIGxvZ2l0cykuXG4gKiBAcGFyYW0gZnJvbUxvZ2l0cyBCb29sZWFuLCB3aGV0aGVyIGBvdXRwdXRgIGlzIHRoZSByZXN1bHQgb2YgYSBzb2Z0bWF4LCBvciBpc1xuICogICBhIHRlbnNvciBvZiBsb2dpdHMuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weShcbiAgICB0YXJnZXQ6IFRlbnNvciwgb3V0cHV0OiBUZW5zb3IsIGZyb21Mb2dpdHMgPSBmYWxzZSk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBmbGF0VGFyZ2V0ID1cbiAgICAgICAgdGZjLmNhc3QodGZjLmZsb29yKEsuZmxhdHRlbih0YXJnZXQpKSwgJ2ludDMyJykgYXMgVGVuc29yMUQ7XG4gICAgb3V0cHV0ID0gdGZjLmNsaXBCeVZhbHVlKG91dHB1dCwgZXBzaWxvbigpLCAxIC0gZXBzaWxvbigpKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IG91dHB1dC5zaGFwZTtcbiAgICBjb25zdCBvbmVIb3RUYXJnZXQgPSB0ZmMucmVzaGFwZShcbiAgICAgICAgdGZjLm9uZUhvdChmbGF0VGFyZ2V0LCBvdXRwdXRTaGFwZVtvdXRwdXRTaGFwZS5sZW5ndGggLSAxXSksXG4gICAgICAgIG91dHB1dFNoYXBlKTtcbiAgICByZXR1cm4gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHkob25lSG90VGFyZ2V0LCBvdXRwdXQsIGZyb21Mb2dpdHMpO1xuICB9KTtcbn1cblxuLyoqXG4gKiBGcm9tIFRlbnNvckZsb3cncyBpbXBsZW1lbnRhdGlvbiBpbiBubl9pbXBsLnB5OlxuICpcbiAqIEZvciBicmV2aXR5LCBsZXQgYHggPSBsb2dpdHNgLCBgeiA9IGxhYmVsc2AuICBUaGUgbG9naXN0aWMgbG9zcyBpc1xuICogICAgICB6ICogLWxvZyhzaWdtb2lkKHgpKSArICgxIC0geikgKiAtbG9nKDEgLSBzaWdtb2lkKHgpKVxuICogICAgPSB6ICogLWxvZygxIC8gKDEgKyBleHAoLXgpKSkgKyAoMSAtIHopICogLWxvZyhleHAoLXgpIC8gKDEgKyBleHAoLXgpKSlcbiAqICAgID0geiAqIGxvZygxICsgZXhwKC14KSkgKyAoMSAtIHopICogKC1sb2coZXhwKC14KSkgKyBsb2coMSArIGV4cCgteCkpKVxuICogICAgPSB6ICogbG9nKDEgKyBleHAoLXgpKSArICgxIC0geikgKiAoeCArIGxvZygxICsgZXhwKC14KSlcbiAqICAgID0gKDEgLSB6KSAqIHggKyBsb2coMSArIGV4cCgteCkpXG4gKiAgICA9IHggLSB4ICogeiArIGxvZygxICsgZXhwKC14KSlcbiAqIEZvciB4IDwgMCwgdG8gYXZvaWQgb3ZlcmZsb3cgaW4gZXhwKC14KSwgd2UgcmVmb3JtdWxhdGUgdGhlIGFib3ZlXG4gKiAgICAgIHggLSB4ICogeiArIGxvZygxICsgZXhwKC14KSlcbiAqICAgID0gbG9nKGV4cCh4KSkgLSB4ICogeiArIGxvZygxICsgZXhwKC14KSlcbiAqICAgID0gLSB4ICogeiArIGxvZygxICsgZXhwKHgpKVxuICogSGVuY2UsIHRvIGVuc3VyZSBzdGFiaWxpdHkgYW5kIGF2b2lkIG92ZXJmbG93LCB0aGUgaW1wbGVtZW50YXRpb24gdXNlcyB0aGlzXG4gKiBlcXVpdmFsZW50IGZvcm11bGF0aW9uXG4gKiAgICBtYXgoeCwgMCkgLSB4ICogeiArIGxvZygxICsgZXhwKC1hYnMoeCkpKVxuICpcbiAqIEBwYXJhbSBsYWJlbHMgVGhlIGxhYmVscy5cbiAqIEBwYXJhbSBsb2dpdHMgVGhlIGxvZ2l0cy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKFxuICAgIGxhYmVsczogVGVuc29yLCBsb2dpdHM6IFRlbnNvcik6IFRlbnNvciB7XG4gIGlmICghdXRpbC5hcnJheXNFcXVhbChsYWJlbHMuc2hhcGUsIGxvZ2l0cy5zaGFwZSkpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgYGxvZ2l0cyBhbmQgbGFiZWxzIG11c3QgaGF2ZSB0aGUgc2FtZSBzaGFwZSwgYnV0IGdvdCBzaGFwZXMgYCArXG4gICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGxhYmVscy5zaGFwZSl9IGFuZCAke0pTT04uc3RyaW5naWZ5KGxvZ2l0cy5zaGFwZSl9YCk7XG4gIH1cbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIC8vIFRoZSBsb2dpc3RpYyBsb3NzIGZvcm11bGEgZnJvbSBhYm92ZSBpc1xuICAgIC8vICAgeCAtIHggKiB6ICsgbG9nKDEgKyBleHAoLXgpKVxuICAgIC8vIEZvciB4IDwgMCwgYSBtb3JlIG51bWVyaWNhbGx5IHN0YWJsZSBmb3JtdWxhIGlzXG4gICAgLy8gICAteCAqIHogKyBsb2coMSArIGV4cCh4KSlcbiAgICAvLyBOb3RlIHRoYXQgdGhlc2UgdHdvIGV4cHJlc3Npb25zIGNhbiBiZSBjb21iaW5lZCBpbnRvIHRoZSBmb2xsb3dpbmc6XG4gICAgLy8gICBtYXgoeCwgMCkgLSB4ICogeiArIGxvZygxICsgZXhwKC1hYnMoeCkpKVxuICAgIGNvbnN0IHJlbHVMb2dpdHMgPSB0ZmMucmVsdShsb2dpdHMpO1xuICAgIGNvbnN0IG5lZ0Fic0xvZ2l0cyA9IHRmYy5uZWcodGZjLmFicyhsb2dpdHMpKTtcbiAgICByZXR1cm4gdGZjLmFkZChcbiAgICAgICAgdGZjLnN1YihyZWx1TG9naXRzLCB0ZmMubXVsKGxvZ2l0cywgbGFiZWxzKSksXG4gICAgICAgIHRmYy5sb2cxcCh0ZmMuZXhwKG5lZ0Fic0xvZ2l0cykpKTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBiaW5hcnlDcm9zc2VudHJvcHkoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBsZXQgeTogVGVuc29yO1xuICAgIHkgPSB0ZmMuY2xpcEJ5VmFsdWUoeVByZWQsIGVwc2lsb24oKSwgMSAtIGVwc2lsb24oKSk7XG4gICAgeSA9IHRmYy5sb2codGZjLmRpdih5LCB0ZmMuc3ViKDEsIHkpKSk7XG4gICAgcmV0dXJuIHRmYy5tZWFuKHNpZ21vaWRDcm9zc0VudHJvcHlXaXRoTG9naXRzKHlUcnVlLCB5KSwgLTEpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGt1bGxiYWNrTGVpYmxlckRpdmVyZ2VuY2UoXG4gICAgeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBjbGlwcGVkVHJ1ZSA9IHRmYy5jbGlwQnlWYWx1ZSh5VHJ1ZSwgZXBzaWxvbigpLCAxKTtcbiAgICBjb25zdCBjbGlwcGVkUHJlZCA9IHRmYy5jbGlwQnlWYWx1ZSh5UHJlZCwgZXBzaWxvbigpLCAxKTtcbiAgICByZXR1cm4gdGZjLnN1bShcbiAgICAgICAgdGZjLm11bCh5VHJ1ZSwgdGZjLmxvZyh0ZmMuZGl2KGNsaXBwZWRUcnVlLCBjbGlwcGVkUHJlZCkpKSwgLTEpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBvaXNzb24oeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjb25zdCBsb2dQcmVkID0gdGZjLmxvZyh0ZmMuYWRkKGVwc2lsb24oKSwgeVByZWQpKTtcbiAgICByZXR1cm4gdGZjLm1lYW4odGZjLnN1Yih5UHJlZCwgdGZjLm11bCh5VHJ1ZSwgbG9nUHJlZCkpLCAtMSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY29zaW5lUHJveGltaXR5KHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgdHJ1ZU5vcm1hbGl6ZWQgPSBsMk5vcm1hbGl6ZSh5VHJ1ZSwgLTEpO1xuICAgIGNvbnN0IHByZWROb3JtYWxpemVkID0gbDJOb3JtYWxpemUoeVByZWQsIC0xKTtcbiAgICBjb25zdCB0cnVlWFByZWQgPSB0ZmMubXVsKHRydWVOb3JtYWxpemVkLCBwcmVkTm9ybWFsaXplZCk7XG4gICAgcmV0dXJuIHRmYy5uZWcodGZjLnN1bSh0cnVlWFByZWQsIC0xKSk7XG4gIH0pO1xufVxuXG5leHBvcnQgY29uc3QgbXNlID0gbWVhblNxdWFyZWRFcnJvcjtcbmV4cG9ydCBjb25zdCBNU0UgPSBtZWFuU3F1YXJlZEVycm9yO1xuZXhwb3J0IGNvbnN0IG1hZSA9IG1lYW5BYnNvbHV0ZUVycm9yO1xuZXhwb3J0IGNvbnN0IE1BRSA9IG1lYW5BYnNvbHV0ZUVycm9yO1xuZXhwb3J0IGNvbnN0IG1hcGUgPSBtZWFuQWJzb2x1dGVQZXJjZW50YWdlRXJyb3I7XG5leHBvcnQgY29uc3QgTUFQRSA9IG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjtcbmV4cG9ydCBjb25zdCBtc2xlID0gbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yO1xuZXhwb3J0IGNvbnN0IE1TTEUgPSBtZWFuU3F1YXJlZExvZ2FyaXRobWljRXJyb3I7XG5leHBvcnQgY29uc3Qga2xkID0ga3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZTtcbmV4cG9ydCBjb25zdCBLTEQgPSBrdWxsYmFja0xlaWJsZXJEaXZlcmdlbmNlO1xuZXhwb3J0IGNvbnN0IGNvc2luZSA9IGNvc2luZVByb3hpbWl0eTtcblxuLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgZGVzZXJpYWxpemUoKSBmdW5jdGlvbi5cblxuZXhwb3J0IGNvbnN0IGxvc3Nlc01hcDoge1tmdW5jdGlvbk5hbWU6IHN0cmluZ106IExvc3NPck1ldHJpY0ZufSA9IHtcbiAgbWVhblNxdWFyZWRFcnJvcixcbiAgbWVhbkFic29sdXRlRXJyb3IsXG4gIG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcixcbiAgbWVhblNxdWFyZWRMb2dhcml0aG1pY0Vycm9yLFxuICBzcXVhcmVkSGluZ2UsXG4gIGhpbmdlLFxuICBjYXRlZ29yaWNhbEhpbmdlLFxuICBsb2djb3NoLFxuICBjYXRlZ29yaWNhbENyb3NzZW50cm9weSxcbiAgc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHksXG4gIGJpbmFyeUNyb3NzZW50cm9weSxcbiAga3VsbGJhY2tMZWlibGVyRGl2ZXJnZW5jZSxcbiAgcG9pc3NvbixcbiAgY29zaW5lUHJveGltaXR5XG59O1xuXG4vLyBQb3J0aW5nIG5vdGU6IFRoaXMgZGl2ZXJnZXMgZnJvbSB0aGUgUHlLZXJhcyBpbXBsZW1lbnRhdGlvbiBhbmQgbWF5IG5lZWQgdG9cbi8vIGNoYW5nZSBiYXNlZCBvbiAoZGUpc2VyaWFsaXphdGlvbiByZXF1aXJlbWVudHMuXG5leHBvcnQgZnVuY3Rpb24gZ2V0KGlkZW50aWZpZXJPckZuOiBzdHJpbmd8TG9zc09yTWV0cmljRm4pOiBMb3NzT3JNZXRyaWNGbiB7XG4gIGlmICh0eXBlb2YgaWRlbnRpZmllck9yRm4gPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKGlkZW50aWZpZXJPckZuIGluIGxvc3Nlc01hcCkge1xuICAgICAgcmV0dXJuIGxvc3Nlc01hcFtpZGVudGlmaWVyT3JGbl07XG4gICAgfVxuICAgIGxldCBlcnJNc2cgPSBgVW5rbm93biBsb3NzICR7aWRlbnRpZmllck9yRm59YDtcbiAgICBpZiAoaWRlbnRpZmllck9yRm4udG9Mb3dlckNhc2UoKS5pbmNsdWRlcygnc29mdG1heGNyb3NzZW50cm9weScpKSB7XG4gICAgICBlcnJNc2cgPSBgVW5rbm93biBsb3NzICR7aWRlbnRpZmllck9yRm59LiBgICtcbiAgICAgICAgICAnVXNlIFwiY2F0ZWdvcmljYWxDcm9zc2VudHJvcHlcIiBhcyB0aGUgc3RyaW5nIG5hbWUgZm9yICcgK1xuICAgICAgICAgICd0Zi5sb3NzZXMuc29mdG1heENyb3NzRW50cm9weSc7XG4gICAgfVxuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGVyck1zZyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXJPckZuO1xuICB9XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Built-in metrics.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { tidy } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { NotImplementedError, ValueError } from './errors';\nimport { categoricalCrossentropy as categoricalCrossentropyLoss, cosineProximity, meanAbsoluteError, meanAbsolutePercentageError, meanSquaredError, sparseCategoricalCrossentropy as sparseCategoricalCrossentropyLoss } from './losses';\nimport { binaryCrossentropy as lossBinaryCrossentropy } from './losses';\nimport { lossesMap } from './losses';\nimport * as util from './utils/generic_utils';\nexport function binaryAccuracy(yTrue, yPred) {\n    return tidy(() => {\n        const threshold = tfc.mul(.5, tfc.onesLike(yPred));\n        const yPredThresholded = K.cast(tfc.greater(yPred, threshold), yTrue.dtype);\n        return tfc.mean(tfc.equal(yTrue, yPredThresholded), -1);\n    });\n}\nexport function categoricalAccuracy(yTrue, yPred) {\n    return tidy(() => K.cast(tfc.equal(tfc.argMax(yTrue, -1), tfc.argMax(yPred, -1)), 'float32'));\n}\nfunction truePositives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 1))), 'float32');\n    });\n}\nfunction falseNegatives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 1), tfc.equal(yPred, 0))), 'float32');\n    });\n}\nfunction falsePositives(yTrue, yPred) {\n    return tidy(() => {\n        return tfc.cast(tfc.sum(tfc.logicalAnd(tfc.equal(yTrue, 0), tfc.equal(yPred, 1))), 'float32');\n    });\n}\nexport function precision(yTrue, yPred) {\n    return tidy(() => {\n        const tp = truePositives(yTrue, yPred);\n        const fp = falsePositives(yTrue, yPred);\n        const denominator = tfc.add(tp, fp);\n        return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n    });\n}\nexport function recall(yTrue, yPred) {\n    return tidy(() => {\n        const tp = truePositives(yTrue, yPred);\n        const fn = falseNegatives(yTrue, yPred);\n        const denominator = tfc.add(tp, fn);\n        return tfc.cast(tfc.where(tfc.greater(denominator, 0), tfc.div(tp, denominator), 0), 'float32');\n    });\n}\nexport function binaryCrossentropy(yTrue, yPred) {\n    return lossBinaryCrossentropy(yTrue, yPred);\n}\nexport function sparseCategoricalAccuracy(yTrue, yPred) {\n    if (yTrue.rank === yPred.rank) {\n        yTrue = tfc.squeeze(yTrue, [yTrue.rank - 1]);\n    }\n    yPred = tfc.argMax(yPred, -1);\n    if (yPred.dtype !== yTrue.dtype) {\n        yPred = tfc.cast(yPred, yTrue.dtype);\n    }\n    return tfc.cast(tfc.equal(yTrue, yPred), 'float32');\n}\nexport function topKCategoricalAccuracy(yTrue, yPred) {\n    throw new NotImplementedError();\n}\nexport function sparseTopKCategoricalAccuracy(yTrue, yPred) {\n    throw new NotImplementedError();\n}\n// Aliases.\nexport const mse = meanSquaredError;\nexport const MSE = meanSquaredError;\nexport const mae = meanAbsoluteError;\nexport const MAE = meanAbsoluteError;\nexport const mape = meanAbsolutePercentageError;\nexport const MAPE = meanAbsolutePercentageError;\nexport const categoricalCrossentropy = categoricalCrossentropyLoss;\nexport const cosine = cosineProximity;\nexport const sparseCategoricalCrossentropy = sparseCategoricalCrossentropyLoss;\n// TODO(cais, nielsene): Add serialize().\nexport const metricsMap = {\n    binaryAccuracy,\n    categoricalAccuracy,\n    precision,\n    categoricalCrossentropy,\n    sparseCategoricalCrossentropy,\n    mse,\n    MSE,\n    mae,\n    MAE,\n    mape,\n    MAPE,\n    cosine\n};\nexport function get(identifier) {\n    if (typeof identifier === 'string' && identifier in metricsMap) {\n        return metricsMap[identifier];\n    }\n    else if (typeof identifier !== 'string' && identifier != null) {\n        return identifier;\n    }\n    else {\n        throw new ValueError(`Unknown metric ${identifier}`);\n    }\n}\n/**\n * Get the shortcut function name.\n *\n * If the fn name is a string,\n *   directly return the string name.\n * If the function is included in metricsMap or lossesMap,\n *   return key of the map.\n *   - If the function relative to multiple keys,\n *     return the first found key as the function name.\n *   - If the function exists in both lossesMap and metricsMap,\n *     search lossesMap first.\n * If the function is not included in metricsMap or lossesMap,\n *   return the function name.\n *\n * @param fn loss function, metric function, or short cut name.\n * @returns Loss or Metric name in string.\n */\nexport function getLossOrMetricName(fn) {\n    util.assert(fn !== null, `Unknown LossOrMetricFn ${fn}`);\n    if (typeof fn === 'string') {\n        return fn;\n    }\n    else {\n        let fnName;\n        for (const key of Object.keys(lossesMap)) {\n            if (lossesMap[key] === fn) {\n                fnName = key;\n                break;\n            }\n        }\n        if (fnName !== undefined) {\n            return fnName;\n        }\n        for (const key of Object.keys(metricsMap)) {\n            if (metricsMap[key] === fn) {\n                fnName = key;\n                break;\n            }\n        }\n        if (fnName !== undefined) {\n            return fnName;\n        }\n        return fn.name;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWV0cmljcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9tZXRyaWNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBUyxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVuRCxPQUFPLEtBQUssQ0FBQyxNQUFNLHdCQUF3QixDQUFDO0FBQzVDLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxVQUFVLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDekQsT0FBTyxFQUFDLHVCQUF1QixJQUFJLDJCQUEyQixFQUFFLGVBQWUsRUFBRSxpQkFBaUIsRUFBRSwyQkFBMkIsRUFBRSxnQkFBZ0IsRUFBRSw2QkFBNkIsSUFBSSxpQ0FBaUMsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUN2TyxPQUFPLEVBQUMsa0JBQWtCLElBQUksc0JBQXNCLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDdEUsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUVuQyxPQUFPLEtBQUssSUFBSSxNQUFNLHVCQUF1QixDQUFDO0FBRTlDLE1BQU0sVUFBVSxjQUFjLENBQUMsS0FBYSxFQUFFLEtBQWE7SUFDekQsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ2YsTUFBTSxTQUFTLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsR0FBRyxDQUFDLFFBQVEsQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1FBQ25ELE1BQU0sZ0JBQWdCLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxTQUFTLENBQUMsRUFBRSxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDNUUsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FB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LFVBQVUsSUFBSSxJQUFJLEVBQUU7UUFDL0QsT0FBTyxVQUFVLENBQUM7S0FDbkI7U0FBTTtRQUNMLE1BQU0sSUFBSSxVQUFVLENBQUMsa0JBQWtCLFVBQVUsRUFBRSxDQUFDLENBQUM7S0FDdEQ7QUFDSCxDQUFDO0FBRUQ7Ozs7Ozs7Ozs7Ozs7Ozs7R0FnQkc7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQUMsRUFBeUI7SUFDM0QsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLEtBQUssSUFBSSxFQUFFLDBCQUEwQixFQUFFLEVBQUUsQ0FBQyxDQUFDO0lBQ3pELElBQUksT0FBTyxFQUFFLEtBQUssUUFBUSxFQUFFO1FBQzFCLE9BQU8sRUFBRSxDQUFDO0tBQ1g7U0FBTTtRQUNMLElBQUksTUFBTSxDQUFDO1FBQ1gsS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxFQUFFO1lBQ3hDLElBQUksU0FBUyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDekIsTUFBTSxHQUFHLEdBQUcsQ0FBQztnQkFDYixNQUFNO2FBQ1A7U0FDRjtRQUNELElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUN4QixPQUFPLE1BQU0sQ0FBQztTQUNmO1FBQ0QsS0FBSyxNQUFNLEdBQUcsSUFBSSxNQUFNLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxFQUFFO1lBQ3pDLElBQUksVUFBVSxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsRUFBRTtnQkFDMUIsTUFBTSxHQUFHLEdBQUcsQ0FBQztnQkFDYixNQUFNO2FBQ1A7U0FDRjtRQUNELElBQUksTUFBTSxLQUFLLFNBQVMsRUFBRTtZQUN4QixPQUFPLE1BQU0sQ0FBQztTQUNmO1FBQ0QsT0FBUSxFQUFlLENBQUMsSUFBSSxDQUFDO0tBQzlCO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogQnVpbHQtaW4gbWV0cmljcy5cbiAqL1xuXG5pbXBvcnQgKiBhcyB0ZmMgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7VGVuc29yLCB0aWR5fSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQgKiBhcyBLIGZyb20gJy4vYmFja2VuZC90ZmpzX2JhY2tlbmQnO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuL2Vycm9ycyc7XG5pbXBvcnQge2NhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5IGFzIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5TG9zcywgY29zaW5lUHJveGltaXR5LCBtZWFuQWJzb2x1dGVFcnJvciwgbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yLCBtZWFuU3F1YXJlZEVycm9yLCBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSBhcyBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weUxvc3N9IGZyb20gJy4vbG9zc2VzJztcbmltcG9ydCB7YmluYXJ5Q3Jvc3NlbnRyb3B5IGFzIGxvc3NCaW5hcnlDcm9zc2VudHJvcHl9IGZyb20gJy4vbG9zc2VzJztcbmltcG9ydCB7bG9zc2VzTWFwfSBmcm9tICcuL2xvc3Nlcyc7XG5pbXBvcnQge0xvc3NPck1ldHJpY0ZufSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi91dGlscy9nZW5lcmljX3V0aWxzJztcblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeUFjY3VyYWN5KHlUcnVlOiBUZW5zb3IsIHlQcmVkOiBUZW5zb3IpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY29uc3QgdGhyZXNob2xkID0gdGZjLm11bCguNSwgdGZjLm9uZXNMaWtlKHlQcmVkKSk7XG4gICAgY29uc3QgeVByZWRUaHJlc2hvbGRlZCA9IEsuY2FzdCh0ZmMuZ3JlYXRlcih5UHJlZCwgdGhyZXNob2xkKSwgeVRydWUuZHR5cGUpO1xuICAgIHJldHVybiB0ZmMubWVhbih0ZmMuZXF1YWwoeVRydWUsIHlQcmVkVGhyZXNob2xkZWQpLCAtMSk7XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2F0ZWdvcmljYWxBY2N1cmFjeSh5VHJ1ZTogVGVuc29yLCB5UHJlZDogVGVuc29yKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoXG4gICAgICAoKSA9PiBLLmNhc3QoXG4gICAgICAgICAgdGZjLmVxdWFsKHRmYy5hcmdNYXgoeVRydWUsIC0xKSwgdGZjLmFyZ01heCh5UHJlZCwgLTEpKSwgJ2Zsb2F0MzInKSk7XG59XG5cbmZ1bmN0aW9uIHRydWVQb3NpdGl2ZXMoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICByZXR1cm4gdGZjLmNhc3QoXG4gICAgICAgIHRmYy5zdW0odGZjLmxvZ2ljYWxBbmQodGZjLmVxdWFsKHlUcnVlLCAxKSwgdGZjLmVxdWFsKHlQcmVkLCAxKSkpLFxuICAgICAgICAnZmxvYXQzMicpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmFsc2VOZWdhdGl2ZXMoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICByZXR1cm4gdGZjLmNhc3QoXG4gICAgICAgIHRmYy5zdW0odGZjLmxvZ2ljYWxBbmQodGZjLmVxdWFsKHlUcnVlLCAxKSwgdGZjLmVxdWFsKHlQcmVkLCAwKSkpLFxuICAgICAgICAnZmxvYXQzMicpO1xuICB9KTtcbn1cblxuZnVuY3Rpb24gZmFsc2VQb3NpdGl2ZXMoeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICByZXR1cm4gdGZjLmNhc3QoXG4gICAgICAgIHRmYy5zdW0odGZjLmxvZ2ljYWxBbmQodGZjLmVxdWFsKHlUcnVlLCAwKSwgdGZjLmVxdWFsKHlQcmVkLCAxKSkpLFxuICAgICAgICAnZmxvYXQzMicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHByZWNpc2lvbih5VHJ1ZTogVGVuc29yLCB5UHJlZDogVGVuc29yKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIGNvbnN0IHRwID0gdHJ1ZVBvc2l0aXZlcyh5VHJ1ZSwgeVByZWQpO1xuICAgIGNvbnN0IGZwID0gZmFsc2VQb3NpdGl2ZXMoeVRydWUsIHlQcmVkKTtcblxuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gdGZjLmFkZCh0cCwgZnApO1xuXG4gICAgcmV0dXJuIHRmYy5jYXN0KFxuICAgICAgICB0ZmMud2hlcmUodGZjLmdyZWF0ZXIoZGVub21pbmF0b3IsIDApLCB0ZmMuZGl2KHRwLCBkZW5vbWluYXRvciksIDApLFxuICAgICAgICAnZmxvYXQzMicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHJlY2FsbCh5VHJ1ZTogVGVuc29yLCB5UHJlZDogVGVuc29yKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIGNvbnN0IHRwID0gdHJ1ZVBvc2l0aXZlcyh5VHJ1ZSwgeVByZWQpO1xuICAgIGNvbnN0IGZuID0gZmFsc2VOZWdhdGl2ZXMoeVRydWUsIHlQcmVkKTtcblxuICAgIGNvbnN0IGRlbm9taW5hdG9yID0gdGZjLmFkZCh0cCwgZm4pO1xuXG4gICAgcmV0dXJuIHRmYy5jYXN0KFxuICAgICAgICB0ZmMud2hlcmUodGZjLmdyZWF0ZXIoZGVub21pbmF0b3IsIDApLCB0ZmMuZGl2KHRwLCBkZW5vbWluYXRvciksIDApLFxuICAgICAgICAnZmxvYXQzMicpO1xuICB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJpbmFyeUNyb3NzZW50cm9weSh5VHJ1ZTogVGVuc29yLCB5UHJlZDogVGVuc29yKTogVGVuc29yIHtcbiAgcmV0dXJuIGxvc3NCaW5hcnlDcm9zc2VudHJvcHkoeVRydWUsIHlQcmVkKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3koXG4gICAgeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIGlmICh5VHJ1ZS5yYW5rID09PSB5UHJlZC5yYW5rKSB7XG4gICAgeVRydWUgPSB0ZmMuc3F1ZWV6ZSh5VHJ1ZSwgW3lUcnVlLnJhbmsgLSAxXSk7XG4gIH1cbiAgeVByZWQgPSB0ZmMuYXJnTWF4KHlQcmVkLCAtMSk7XG4gIGlmICh5UHJlZC5kdHlwZSAhPT0geVRydWUuZHR5cGUpIHtcbiAgICB5UHJlZCA9IHRmYy5jYXN0KHlQcmVkLCB5VHJ1ZS5kdHlwZSk7XG4gIH1cbiAgcmV0dXJuIHRmYy5jYXN0KHRmYy5lcXVhbCh5VHJ1ZSwgeVByZWQpLCAnZmxvYXQzMicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdG9wS0NhdGVnb3JpY2FsQWNjdXJhY3koeVRydWU6IFRlbnNvciwgeVByZWQ6IFRlbnNvcik6IFRlbnNvciB7XG4gIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzcGFyc2VUb3BLQ2F0ZWdvcmljYWxBY2N1cmFjeShcbiAgICB5VHJ1ZTogVGVuc29yLCB5UHJlZDogVGVuc29yKTogVGVuc29yIHtcbiAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbn1cblxuLy8gQWxpYXNlcy5cbmV4cG9ydCBjb25zdCBtc2UgPSBtZWFuU3F1YXJlZEVycm9yO1xuZXhwb3J0IGNvbnN0IE1TRSA9IG1lYW5TcXVhcmVkRXJyb3I7XG5leHBvcnQgY29uc3QgbWFlID0gbWVhbkFic29sdXRlRXJyb3I7XG5leHBvcnQgY29uc3QgTUFFID0gbWVhbkFic29sdXRlRXJyb3I7XG5leHBvcnQgY29uc3QgbWFwZSA9IG1lYW5BYnNvbHV0ZVBlcmNlbnRhZ2VFcnJvcjtcbmV4cG9ydCBjb25zdCBNQVBFID0gbWVhbkFic29sdXRlUGVyY2VudGFnZUVycm9yO1xuZXhwb3J0IGNvbnN0IGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5ID0gY2F0ZWdvcmljYWxDcm9zc2VudHJvcHlMb3NzO1xuZXhwb3J0IGNvbnN0IGNvc2luZSA9IGNvc2luZVByb3hpbWl0eTtcbmV4cG9ydCBjb25zdCBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSA9IHNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5TG9zcztcblxuLy8gVE9ETyhjYWlzLCBuaWVsc2VuZSk6IEFkZCBzZXJpYWxpemUoKS5cblxuZXhwb3J0IGNvbnN0IG1ldHJpY3NNYXA6IHtbZnVuY3Rpb25OYW1lOiBzdHJpbmddOiBMb3NzT3JNZXRyaWNGbn0gPSB7XG4gIGJpbmFyeUFjY3VyYWN5LFxuICBjYXRlZ29yaWNhbEFjY3VyYWN5LFxuICBwcmVjaXNpb24sXG4gIGNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5LFxuICBzcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weSxcbiAgbXNlLFxuICBNU0UsXG4gIG1hZSxcbiAgTUFFLFxuICBtYXBlLFxuICBNQVBFLFxuICBjb3NpbmVcbn07XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXQoaWRlbnRpZmllcjogc3RyaW5nfExvc3NPck1ldHJpY0ZuKTogTG9zc09yTWV0cmljRm4ge1xuICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnICYmIGlkZW50aWZpZXIgaW4gbWV0cmljc01hcCkge1xuICAgIHJldHVybiBtZXRyaWNzTWFwW2lkZW50aWZpZXJdO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBpZGVudGlmaWVyICE9PSAnc3RyaW5nJyAmJiBpZGVudGlmaWVyICE9IG51bGwpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihgVW5rbm93biBtZXRyaWMgJHtpZGVudGlmaWVyfWApO1xuICB9XG59XG5cbi8qKlxuICogR2V0IHRoZSBzaG9ydGN1dCBmdW5jdGlvbiBuYW1lLlxuICpcbiAqIElmIHRoZSBmbiBuYW1lIGlzIGEgc3RyaW5nLFxuICogICBkaXJlY3RseSByZXR1cm4gdGhlIHN0cmluZyBuYW1lLlxuICogSWYgdGhlIGZ1bmN0aW9uIGlzIGluY2x1ZGVkIGluIG1ldHJpY3NNYXAgb3IgbG9zc2VzTWFwLFxuICogICByZXR1cm4ga2V5IG9mIHRoZSBtYXAuXG4gKiAgIC0gSWYgdGhlIGZ1bmN0aW9uIHJlbGF0aXZlIHRvIG11bHRpcGxlIGtleXMsXG4gKiAgICAgcmV0dXJuIHRoZSBmaXJzdCBmb3VuZCBrZXkgYXMgdGhlIGZ1bmN0aW9uIG5hbWUuXG4gKiAgIC0gSWYgdGhlIGZ1bmN0aW9uIGV4aXN0cyBpbiBib3RoIGxvc3Nlc01hcCBhbmQgbWV0cmljc01hcCxcbiAqICAgICBzZWFyY2ggbG9zc2VzTWFwIGZpcnN0LlxuICogSWYgdGhlIGZ1bmN0aW9uIGlzIG5vdCBpbmNsdWRlZCBpbiBtZXRyaWNzTWFwIG9yIGxvc3Nlc01hcCxcbiAqICAgcmV0dXJuIHRoZSBmdW5jdGlvbiBuYW1lLlxuICpcbiAqIEBwYXJhbSBmbiBsb3NzIGZ1bmN0aW9uLCBtZXRyaWMgZnVuY3Rpb24sIG9yIHNob3J0IGN1dCBuYW1lLlxuICogQHJldHVybnMgTG9zcyBvciBNZXRyaWMgbmFtZSBpbiBzdHJpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb3NzT3JNZXRyaWNOYW1lKGZuOiBzdHJpbmd8TG9zc09yTWV0cmljRm4pOiBzdHJpbmcge1xuICB1dGlsLmFzc2VydChmbiAhPT0gbnVsbCwgYFVua25vd24gTG9zc09yTWV0cmljRm4gJHtmbn1gKTtcbiAgaWYgKHR5cGVvZiBmbiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZm47XG4gIH0gZWxzZSB7XG4gICAgbGV0IGZuTmFtZTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhsb3NzZXNNYXApKSB7XG4gICAgICBpZiAobG9zc2VzTWFwW2tleV0gPT09IGZuKSB7XG4gICAgICAgIGZuTmFtZSA9IGtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZuTmFtZTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobWV0cmljc01hcCkpIHtcbiAgICAgIGlmIChtZXRyaWNzTWFwW2tleV0gPT09IGZuKSB7XG4gICAgICAgIGZuTmFtZSA9IGtleTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChmbk5hbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZuTmFtZTtcbiAgICB9XG4gICAgcmV0dXJuIChmbiBhcyBGdW5jdGlvbikubmFtZTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Optimizers.\n */\nimport { train } from '@tensorflow/tfjs-core';\nimport { epsilon } from './backend/common';\nimport { ValueError } from './errors';\n// Add (de)serialize()\n// Porting note: This diverges from the PyKeras implementation and may need to\n// change based on (de)serialization requirements.\nexport function getOptimizer(identifier) {\n    const optimizerMap = {\n        'Adagrad': () => train.adagrad(0.01),\n        'Adadelta': () => train.adadelta(1, 0.95, epsilon()),\n        'Adam': () => train.adam(0.001, 0.9, 0.999, epsilon()),\n        'Adamax': () => train.adamax(0.002, 0.9, 0.999, epsilon(), 0),\n        'RMSProp': () => train.rmsprop(0.001, 0.9, 0, epsilon()),\n        'SGD': () => train.sgd(0.01)\n    };\n    optimizerMap['adagrad'] = optimizerMap['Adagrad'];\n    optimizerMap['adadelta'] = optimizerMap['Adadelta'];\n    optimizerMap['adam'] = optimizerMap['Adam'];\n    optimizerMap['adamax'] = optimizerMap['Adamax'];\n    optimizerMap['rmsprop'] = optimizerMap['RMSProp'];\n    optimizerMap['sgd'] = optimizerMap['SGD'];\n    if (identifier in optimizerMap) {\n        return optimizerMap[identifier]();\n    }\n    throw new ValueError(`Unknown Optimizer ${identifier}`);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3B0aW1pemVycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9vcHRpbWl6ZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEVBQVksS0FBSyxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdkQsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLGtCQUFrQixDQUFDO0FBRXpDLE9BQU8sRUFBQyxVQUFVLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFFcEMsc0JBQXNCO0FBRXRCLDhFQUE4RTtBQUM5RSxrREFBa0Q7QUFDbEQsTUFBTSxVQUFVLFlBQVksQ0FBQyxVQUFrQjtJQUM3QyxNQUFNLFlBQVksR0FBK0M7UUFDL0QsU0FBUyxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDO1FBQ3BDLFVBQVUsRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsUUFBUSxDQUFDLENBQUMsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLENBQUM7UUFDcEQsTUFBTSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLENBQUM7UUFDdEQsUUFBUSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxNQUFNLENBQUMsS0FBSyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLEVBQUUsQ0FBQyxDQUFDO1FBQzdELFNBQVMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsT0FBTyxDQUFDLEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLE9BQU8sRUFBRSxDQUFDO1FBQ3hELEtBQUssRUFBRSxHQUFHLEVBQUUsQ0FBQyxLQUFLLENBQUMsR0FBRyxDQUFDLElBQUksQ0FBQztLQUM3QixDQUFDO0lBQ0YsWUFBWSxDQUFDLFNBQVMsQ0FBQyxHQUFHLFlBQVksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNsRCxZQUFZLENBQUMsVUFBVSxDQUFDLEdBQUcsWUFBWSxDQUFDLFVBQVUsQ0FBQyxDQUFDO0lBQ3BELFlBQVksQ0FBQyxNQUFNLENBQUMsR0FBRyxZQUFZLENBQUMsTUFBTSxDQUFDLENBQUM7SUFDNUMsWUFBWSxDQUFDLFFBQVEsQ0FBQyxHQUFHLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQztJQUNoRCxZQUFZLENBQUMsU0FBUyxDQUFDLEdBQUcsWUFBWSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQ2xELFlBQVksQ0FBQyxLQUFLLENBQUMsR0FBRyxZQUFZLENBQUMsS0FBSyxDQUFDLENBQUM7SUFFMUMsSUFBSSxVQUFVLElBQUksWUFBWSxFQUFFO1FBQzlCLE9BQU8sWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7S0FDbkM7SUFDRCxNQUFNLElBQUksVUFBVSxDQUFDLHFCQUFxQixVQUFVLEVBQUUsQ0FBQyxDQUFDO0FBQzFELENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIE9wdGltaXplcnMuXG4gKi9cblxuaW1wb3J0IHtPcHRpbWl6ZXIsIHRyYWlufSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge2Vwc2lsb259IGZyb20gJy4vYmFja2VuZC9jb21tb24nO1xuXG5pbXBvcnQge1ZhbHVlRXJyb3J9IGZyb20gJy4vZXJyb3JzJztcblxuLy8gQWRkIChkZSlzZXJpYWxpemUoKVxuXG4vLyBQb3J0aW5nIG5vdGU6IFRoaXMgZGl2ZXJnZXMgZnJvbSB0aGUgUHlLZXJhcyBpbXBsZW1lbnRhdGlvbiBhbmQgbWF5IG5lZWQgdG9cbi8vIGNoYW5nZSBiYXNlZCBvbiAoZGUpc2VyaWFsaXphdGlvbiByZXF1aXJlbWVudHMuXG5leHBvcnQgZnVuY3Rpb24gZ2V0T3B0aW1pemVyKGlkZW50aWZpZXI6IHN0cmluZyk6IE9wdGltaXplciB7XG4gIGNvbnN0IG9wdGltaXplck1hcDoge1tvcHRpbWl6ZXJOYW1lOiBzdHJpbmddOiAoKSA9PiBPcHRpbWl6ZXJ9ID0ge1xuICAgICdBZGFncmFkJzogKCkgPT4gdHJhaW4uYWRhZ3JhZCgwLjAxKSxcbiAgICAnQWRhZGVsdGEnOiAoKSA9PiB0cmFpbi5hZGFkZWx0YSgxLCAwLjk1LCBlcHNpbG9uKCkpLFxuICAgICdBZGFtJzogKCkgPT4gdHJhaW4uYWRhbSgwLjAwMSwgMC45LCAwLjk5OSwgZXBzaWxvbigpKSxcbiAgICAnQWRhbWF4JzogKCkgPT4gdHJhaW4uYWRhbWF4KDAuMDAyLCAwLjksIDAuOTk5LCBlcHNpbG9uKCksIDApLFxuICAgICdSTVNQcm9wJzogKCkgPT4gdHJhaW4ucm1zcHJvcCgwLjAwMSwgMC45LCAwLCBlcHNpbG9uKCkpLFxuICAgICdTR0QnOiAoKSA9PiB0cmFpbi5zZ2QoMC4wMSlcbiAgfTtcbiAgb3B0aW1pemVyTWFwWydhZGFncmFkJ10gPSBvcHRpbWl6ZXJNYXBbJ0FkYWdyYWQnXTtcbiAgb3B0aW1pemVyTWFwWydhZGFkZWx0YSddID0gb3B0aW1pemVyTWFwWydBZGFkZWx0YSddO1xuICBvcHRpbWl6ZXJNYXBbJ2FkYW0nXSA9IG9wdGltaXplck1hcFsnQWRhbSddO1xuICBvcHRpbWl6ZXJNYXBbJ2FkYW1heCddID0gb3B0aW1pemVyTWFwWydBZGFtYXgnXTtcbiAgb3B0aW1pemVyTWFwWydybXNwcm9wJ10gPSBvcHRpbWl6ZXJNYXBbJ1JNU1Byb3AnXTtcbiAgb3B0aW1pemVyTWFwWydzZ2QnXSA9IG9wdGltaXplck1hcFsnU0dEJ107XG5cbiAgaWYgKGlkZW50aWZpZXIgaW4gb3B0aW1pemVyTWFwKSB7XG4gICAgcmV0dXJuIG9wdGltaXplck1hcFtpZGVudGlmaWVyXSgpO1xuICB9XG4gIHRocm93IG5ldyBWYWx1ZUVycm9yKGBVbmtub3duIE9wdGltaXplciAke2lkZW50aWZpZXJ9YCk7XG59XG4iXX0=","/**\n * @license\n * Copyright 2019 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/** Utility functions related to user-defined metadata. */\n// Maximum recommended serialized size for user-defined metadata.\n// Beyond this limit, a warning message will be printed during model loading and\n// saving.\nexport const MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH = 1 * 1024 * 1024;\n/**\n * Check validity of user-defined metadata.\n *\n * @param userDefinedMetadata\n * @param modelName Name of the model that the user-defined metadata belongs to.\n *   Used during construction of error messages.\n * @param checkSize Whether to check the size of the metadata is under\n *   recommended limit. Default: `false`. If `true`, will try stringify the\n *   JSON object and print a console warning if the serialzied size is above the\n *   limit.\n * @throws Error if `userDefinedMetadata` is not a plain JSON object.\n */\nexport function checkUserDefinedMetadata(userDefinedMetadata, modelName, checkSize = false) {\n    if (userDefinedMetadata == null ||\n        typeof userDefinedMetadata !== 'object' ||\n        Object.getPrototypeOf(userDefinedMetadata) !== Object.prototype ||\n        !plainObjectCheck(userDefinedMetadata)) {\n        throw new Error('User-defined metadata is expected to be a JSON object, but is not.');\n    }\n    if (checkSize) {\n        const out = JSON.stringify(userDefinedMetadata);\n        if (out.length > MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH) {\n            console.warn(`User-defined metadata of model \"${modelName}\" is too large in ` +\n                `size (length=${out.length} when serialized). It is not ` +\n                `recommended to store such large objects in user-defined metadata. ` +\n                `Please make sure its serialized length is <= ` +\n                `${MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH}.`);\n        }\n    }\n}\n/**\n * Check if an input is plain JSON object or any valid subfield of it.\n *\n * @param x The input to be checked.\n * @param assertObject Whether to assert `x` is a JSON object, i.e., reject\n *   cases of arrays and primitives.\n * @return Returns `true` if and only if `x` is a plain JSON object,\n *   a JSON-valid primitive including string, number, boolean and null,\n *   or an array of the said types.\n */\n// tslint:disable-next-line:no-any\nexport function plainObjectCheck(x) {\n    if (x === null) {\n        // Note: typeof `null` is 'object', and `null` is valid in JSON.\n        return true;\n    }\n    else if (typeof x === 'object') {\n        if (Object.getPrototypeOf(x) === Object.prototype) {\n            // `x` is a JavaScript object and its prototype is Object.\n            const keys = Object.keys(x);\n            for (const key of keys) {\n                if (typeof key !== 'string') {\n                    // JSON keys must be strings.\n                    return false;\n                }\n                if (!plainObjectCheck(x[key])) { // Recursive call.\n                    return false;\n                }\n            }\n            return true;\n        }\n        else {\n            // `x` is a JavaScript object but its prototype is not Object.\n            if (Array.isArray(x)) {\n                // `x` is a JavaScript array.\n                for (const item of x) {\n                    if (!plainObjectCheck(item)) { // Recursive call.\n                        return false;\n                    }\n                }\n                return true;\n            }\n            else {\n                // `x` is a JavaScript object and its prototype is not Object,\n                // and it's not an Array. I.e., it's a complex object such as\n                // `Error` and `Date`.\n                return false;\n            }\n        }\n    }\n    else {\n        // `x` is not a JavaScript object or `null`.\n        const xType = typeof x;\n        return xType === 'string' || xType === 'number' || xType === 'boolean';\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXNlcl9kZWZpbmVkX21ldGFkYXRhLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL3VzZXJfZGVmaW5lZF9tZXRhZGF0YS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILDBEQUEwRDtBQUUxRCxpRUFBaUU7QUFDakUsZ0ZBQWdGO0FBQ2hGLFVBQVU7QUFDVixNQUFNLENBQUMsTUFBTSwyQ0FBMkMsR0FBRyxDQUFDLEdBQUcsSUFBSSxHQUFHLElBQUksQ0FBQztBQUUzRTs7Ozs7Ozs7Ozs7R0FXRztBQUNILE1BQU0sVUFBVSx3QkFBd0IsQ0FDcEMsbUJBQXVCLEVBQUUsU0FBaUIsRUFBRSxTQUFTLEdBQUcsS0FBSztJQUMvRCxJQUFJLG1CQUFtQixJQUFJLElBQUk7UUFDM0IsT0FBTyxtQkFBbUIsS0FBSyxRQUFRO1FBQ3ZDLE1BQU0sQ0FBQyxjQUFjLENBQUMsbUJBQW1CLENBQUMsS0FBSyxNQUFNLENBQUMsU0FBUztRQUMvRCxDQUFDLGdCQUFnQixDQUFDLG1CQUFtQixDQUFDLEVBQUU7UUFDMUMsTUFBTSxJQUFJLEtBQUssQ0FDWCxvRUFBb0UsQ0FBQyxDQUFDO0tBQzNFO0lBRUQsSUFBSSxTQUFTLEVBQUU7UUFDYixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDaEQsSUFBSSxHQUFHLENBQUMsTUFBTSxHQUFHLDJDQUEyQyxFQUFFO1lBQzVELE9BQU8sQ0FBQyxJQUFJLENBQ1IsbUNBQW1DLFNBQVMsb0JBQW9CO2dCQUNoRSxnQkFBZ0IsR0FBRyxDQUFDLE1BQU0sK0JBQStCO2dCQUN6RCxvRUFBb0U7Z0JBQ3BFLCtDQUErQztnQkFDL0MsR0FBRywyQ0FBMkMsR0FBRyxDQUFDLENBQUM7U0FDeEQ7S0FDRjtBQUNILENBQUM7QUFFRDs7Ozs7Ozs7O0dBU0c7QUFDSCxrQ0FBa0M7QUFDbEMsTUFBTSxVQUFVLGdCQUFnQixDQUFDLENBQU07SUFDckMsSUFBSSxDQUFDLEtBQUssSUFBSSxFQUFFO1FBQ2QsZ0VBQWdFO1FBQ2hFLE9BQU8sSUFBSSxDQUFDO0tBQ2I7U0FBTSxJQUFJLE9BQU8sQ0FBQyxLQUFLLFFBQVEsRUFBRTtRQUNoQyxJQUFJLE1BQU0sQ0FBQyxjQUFjLENBQUMsQ0FBQyxDQUFDLEtBQUssTUFBTSxDQUFDLFNBQVMsRUFBRTtZQUNqRCwwREFBMEQ7WUFDMUQsTUFBTSxJQUFJLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM1QixLQUFLLE1BQU0sR0FBRyxJQUFJLElBQUksRUFBRTtnQkFDdEIsSUFBSSxPQUFPLEdBQUcsS0FBSyxRQUFRLEVBQUU7b0JBQzNCLDZCQUE2QjtvQkFDN0IsT0FBTyxLQUFLLENBQUM7aUJBQ2Q7Z0JBQ0QsSUFBSSxDQUFDLGdCQUFnQixDQUFDLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLEVBQUcsa0JBQWtCO29CQUNsRCxPQUFPLEtBQUssQ0FBQztpQkFDZDthQUNGO1lBQ0QsT0FBTyxJQUFJLENBQUM7U0FDYjthQUFNO1lBQ0wsOERBQThEO1lBQzlELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLENBQUMsRUFBRTtnQkFDcEIsNkJBQTZCO2dCQUM3QixLQUFLLE1BQU0sSUFBSSxJQUFJLENBQUMsRUFBRTtvQkFDcEIsSUFBSSxDQUFDLGdCQUFnQixDQUFDLElBQUksQ0FBQyxFQUFFLEVBQUcsa0JBQWtCO3dCQUNoRCxPQUFPLEtBQUssQ0FBQztxQkFDZDtpQkFDRjtnQkFDRCxPQUFPLElBQUksQ0FBQzthQUNiO2lCQUFNO2dCQUNMLDhEQUE4RDtnQkFDOUQsNkRBQTZEO2dCQUM3RCxzQkFBc0I7Z0JBQ3RCLE9BQU8sS0FBSyxDQUFDO2FBQ2Q7U0FDRjtLQUNGO1NBQU07UUFDTCw0Q0FBNEM7UUFDNUMsTUFBTSxLQUFLLEdBQUcsT0FBTyxDQUFDLENBQUM7UUFDdkIsT0FBTyxLQUFLLEtBQUssUUFBUSxJQUFJLEtBQUssS0FBSyxRQUFRLElBQUksS0FBSyxLQUFLLFNBQVMsQ0FBQztLQUN4RTtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKiogVXRpbGl0eSBmdW5jdGlvbnMgcmVsYXRlZCB0byB1c2VyLWRlZmluZWQgbWV0YWRhdGEuICovXG5cbi8vIE1heGltdW0gcmVjb21tZW5kZWQgc2VyaWFsaXplZCBzaXplIGZvciB1c2VyLWRlZmluZWQgbWV0YWRhdGEuXG4vLyBCZXlvbmQgdGhpcyBsaW1pdCwgYSB3YXJuaW5nIG1lc3NhZ2Ugd2lsbCBiZSBwcmludGVkIGR1cmluZyBtb2RlbCBsb2FkaW5nIGFuZFxuLy8gc2F2aW5nLlxuZXhwb3J0IGNvbnN0IE1BWF9VU0VSX0RFRklORURfTUVUQURBVEFfU0VSSUFMSVpFRF9MRU5HVEggPSAxICogMTAyNCAqIDEwMjQ7XG5cbi8qKlxuICogQ2hlY2sgdmFsaWRpdHkgb2YgdXNlci1kZWZpbmVkIG1ldGFkYXRhLlxuICpcbiAqIEBwYXJhbSB1c2VyRGVmaW5lZE1ldGFkYXRhXG4gKiBAcGFyYW0gbW9kZWxOYW1lIE5hbWUgb2YgdGhlIG1vZGVsIHRoYXQgdGhlIHVzZXItZGVmaW5lZCBtZXRhZGF0YSBiZWxvbmdzIHRvLlxuICogICBVc2VkIGR1cmluZyBjb25zdHJ1Y3Rpb24gb2YgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gY2hlY2tTaXplIFdoZXRoZXIgdG8gY2hlY2sgdGhlIHNpemUgb2YgdGhlIG1ldGFkYXRhIGlzIHVuZGVyXG4gKiAgIHJlY29tbWVuZGVkIGxpbWl0LiBEZWZhdWx0OiBgZmFsc2VgLiBJZiBgdHJ1ZWAsIHdpbGwgdHJ5IHN0cmluZ2lmeSB0aGVcbiAqICAgSlNPTiBvYmplY3QgYW5kIHByaW50IGEgY29uc29sZSB3YXJuaW5nIGlmIHRoZSBzZXJpYWx6aWVkIHNpemUgaXMgYWJvdmUgdGhlXG4gKiAgIGxpbWl0LlxuICogQHRocm93cyBFcnJvciBpZiBgdXNlckRlZmluZWRNZXRhZGF0YWAgaXMgbm90IGEgcGxhaW4gSlNPTiBvYmplY3QuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1VzZXJEZWZpbmVkTWV0YWRhdGEoXG4gICAgdXNlckRlZmluZWRNZXRhZGF0YToge30sIG1vZGVsTmFtZTogc3RyaW5nLCBjaGVja1NpemUgPSBmYWxzZSk6IHZvaWQge1xuICBpZiAodXNlckRlZmluZWRNZXRhZGF0YSA9PSBudWxsIHx8XG4gICAgICB0eXBlb2YgdXNlckRlZmluZWRNZXRhZGF0YSAhPT0gJ29iamVjdCcgfHxcbiAgICAgIE9iamVjdC5nZXRQcm90b3R5cGVPZih1c2VyRGVmaW5lZE1ldGFkYXRhKSAhPT0gT2JqZWN0LnByb3RvdHlwZSB8fFxuICAgICAgIXBsYWluT2JqZWN0Q2hlY2sodXNlckRlZmluZWRNZXRhZGF0YSkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdVc2VyLWRlZmluZWQgbWV0YWRhdGEgaXMgZXhwZWN0ZWQgdG8gYmUgYSBKU09OIG9iamVjdCwgYnV0IGlzIG5vdC4nKTtcbiAgfVxuXG4gIGlmIChjaGVja1NpemUpIHtcbiAgICBjb25zdCBvdXQgPSBKU09OLnN0cmluZ2lmeSh1c2VyRGVmaW5lZE1ldGFkYXRhKTtcbiAgICBpZiAob3V0Lmxlbmd0aCA+IE1BWF9VU0VSX0RFRklORURfTUVUQURBVEFfU0VSSUFMSVpFRF9MRU5HVEgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICBgVXNlci1kZWZpbmVkIG1ldGFkYXRhIG9mIG1vZGVsIFwiJHttb2RlbE5hbWV9XCIgaXMgdG9vIGxhcmdlIGluIGAgK1xuICAgICAgICAgIGBzaXplIChsZW5ndGg9JHtvdXQubGVuZ3RofSB3aGVuIHNlcmlhbGl6ZWQpLiBJdCBpcyBub3QgYCArXG4gICAgICAgICAgYHJlY29tbWVuZGVkIHRvIHN0b3JlIHN1Y2ggbGFyZ2Ugb2JqZWN0cyBpbiB1c2VyLWRlZmluZWQgbWV0YWRhdGEuIGAgK1xuICAgICAgICAgIGBQbGVhc2UgbWFrZSBzdXJlIGl0cyBzZXJpYWxpemVkIGxlbmd0aCBpcyA8PSBgICtcbiAgICAgICAgICBgJHtNQVhfVVNFUl9ERUZJTkVEX01FVEFEQVRBX1NFUklBTElaRURfTEVOR1RIfS5gKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhbiBpbnB1dCBpcyBwbGFpbiBKU09OIG9iamVjdCBvciBhbnkgdmFsaWQgc3ViZmllbGQgb2YgaXQuXG4gKlxuICogQHBhcmFtIHggVGhlIGlucHV0IHRvIGJlIGNoZWNrZWQuXG4gKiBAcGFyYW0gYXNzZXJ0T2JqZWN0IFdoZXRoZXIgdG8gYXNzZXJ0IGB4YCBpcyBhIEpTT04gb2JqZWN0LCBpLmUuLCByZWplY3RcbiAqICAgY2FzZXMgb2YgYXJyYXlzIGFuZCBwcmltaXRpdmVzLlxuICogQHJldHVybiBSZXR1cm5zIGB0cnVlYCBpZiBhbmQgb25seSBpZiBgeGAgaXMgYSBwbGFpbiBKU09OIG9iamVjdCxcbiAqICAgYSBKU09OLXZhbGlkIHByaW1pdGl2ZSBpbmNsdWRpbmcgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4gYW5kIG51bGwsXG4gKiAgIG9yIGFuIGFycmF5IG9mIHRoZSBzYWlkIHR5cGVzLlxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG5leHBvcnQgZnVuY3Rpb24gcGxhaW5PYmplY3RDaGVjayh4OiBhbnkpOiBib29sZWFuIHtcbiAgaWYgKHggPT09IG51bGwpIHtcbiAgICAvLyBOb3RlOiB0eXBlb2YgYG51bGxgIGlzICdvYmplY3QnLCBhbmQgYG51bGxgIGlzIHZhbGlkIGluIEpTT04uXG4gICAgcmV0dXJuIHRydWU7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHggPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKE9iamVjdC5nZXRQcm90b3R5cGVPZih4KSA9PT0gT2JqZWN0LnByb3RvdHlwZSkge1xuICAgICAgLy8gYHhgIGlzIGEgSmF2YVNjcmlwdCBvYmplY3QgYW5kIGl0cyBwcm90b3R5cGUgaXMgT2JqZWN0LlxuICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHgpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgICBpZiAodHlwZW9mIGtleSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAvLyBKU09OIGtleXMgbXVzdCBiZSBzdHJpbmdzLlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBsYWluT2JqZWN0Q2hlY2soeFtrZXldKSkgeyAgLy8gUmVjdXJzaXZlIGNhbGwuXG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gYHhgIGlzIGEgSmF2YVNjcmlwdCBvYmplY3QgYnV0IGl0cyBwcm90b3R5cGUgaXMgbm90IE9iamVjdC5cbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHgpKSB7XG4gICAgICAgIC8vIGB4YCBpcyBhIEphdmFTY3JpcHQgYXJyYXkuXG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB4KSB7XG4gICAgICAgICAgaWYgKCFwbGFpbk9iamVjdENoZWNrKGl0ZW0pKSB7ICAvLyBSZWN1cnNpdmUgY2FsbC5cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBgeGAgaXMgYSBKYXZhU2NyaXB0IG9iamVjdCBhbmQgaXRzIHByb3RvdHlwZSBpcyBub3QgT2JqZWN0LFxuICAgICAgICAvLyBhbmQgaXQncyBub3QgYW4gQXJyYXkuIEkuZS4sIGl0J3MgYSBjb21wbGV4IG9iamVjdCBzdWNoIGFzXG4gICAgICAgIC8vIGBFcnJvcmAgYW5kIGBEYXRlYC5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBgeGAgaXMgbm90IGEgSmF2YVNjcmlwdCBvYmplY3Qgb3IgYG51bGxgLlxuICAgIGNvbnN0IHhUeXBlID0gdHlwZW9mIHg7XG4gICAgcmV0dXJuIHhUeXBlID09PSAnc3RyaW5nJyB8fCB4VHlwZSA9PT0gJ251bWJlcicgfHwgeFR5cGUgPT09ICdib29sZWFuJztcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { countParamsInWeights } from './variable_utils';\n/**\n * Print the summary of a LayersModel object.\n *\n * @param model tf.LayersModel instance.\n * @param lineLength Total length of printed lines. Set this to adapt to the\n *   display to different terminal or console sizes.\n * @param positions Relative or absolute positions of log elements in each\n *   line. Each number corresponds to right-most (i.e., ending) position of a\n *   column.\n *   If not provided, defaults to `[0.45, 0.85, 1]` for sequential-like\n *   models and `[0.33, 0.55, 0.67, 1]` for non-sequential like models.\n * @param printFn Print function to use.\n *   It will be called on each line of the summary. You can provide a custom\n *   function in order to capture the string summary. Defaults to `console.log`.\n */\nexport function printSummary(model, lineLength, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    const sequentialLike = isModelSequentialLike(model);\n    // Header names for different log elements.\n    const toDisplay = ['Layer (type)', 'Input Shape', 'Output shape', 'Param #'];\n    if (sequentialLike) {\n        lineLength = lineLength || 90;\n        positions = positions || [0.32, 0.61, 0.89, 1];\n    }\n    else {\n        lineLength = lineLength || 115;\n        positions = positions || [0.24, 0.48, 0.70, 0.80, 1];\n        // Header names for different log elements.\n    }\n    if (positions[positions.length - 1] <= 1) {\n        // `positions` is relative. Convert it to absolute positioning.\n        positions = positions.map(p => Math.floor(lineLength * p));\n    }\n    let relevantNodes;\n    if (!sequentialLike) {\n        toDisplay.push('Receives inputs');\n        relevantNodes = [];\n        for (const depth in model.nodesByDepth) {\n            relevantNodes.push(...model.nodesByDepth[depth]);\n        }\n    }\n    printFn('_'.repeat(lineLength));\n    printRow(toDisplay, positions, printFn);\n    printFn('='.repeat(lineLength));\n    const layers = model.layers;\n    for (let i = 0; i < layers.length; ++i) {\n        if (sequentialLike) {\n            printLayerSummary(layers[i], positions, printFn);\n        }\n        else {\n            printLayerSummaryWithConnections(layers[i], positions, relevantNodes, printFn);\n        }\n        printFn((i === layers.length - 1 ? '=' : '_').repeat(lineLength));\n    }\n    // tslint:disable-next-line:no-any\n    model.checkTrainableWeightsConsistency();\n    const trainableCount = countTrainableParams(model);\n    const nonTrainableCount = countParamsInWeights(model.nonTrainableWeights);\n    printFn(`Total params: ${trainableCount + nonTrainableCount}`);\n    printFn(`Trainable params: ${trainableCount}`);\n    printFn(`Non-trainable params: ${nonTrainableCount}`);\n    printFn('_'.repeat(lineLength));\n}\nfunction countTrainableParams(model) {\n    let trainableCount;\n    // tslint:disable:no-any\n    if (model.collectedTrainableWeights != null) {\n        trainableCount =\n            countParamsInWeights(model.collectedTrainableWeights);\n    }\n    else {\n        trainableCount = countParamsInWeights(model.trainableWeights);\n    }\n    // tslint:enable:no-any\n    return trainableCount;\n}\nfunction isModelSequentialLike(model) {\n    let sequentialLike = true;\n    const nodesByDepth = [];\n    const nodes = [];\n    for (const depth in model.nodesByDepth) {\n        nodesByDepth.push(model.nodesByDepth[depth]);\n    }\n    for (const depthNodes of nodesByDepth) {\n        if (depthNodes.length > 1 ||\n            depthNodes.length === 1 && depthNodes[0].inboundLayers.length > 1) {\n            sequentialLike = false;\n            break;\n        }\n        nodes.push(...depthNodes);\n    }\n    if (sequentialLike) {\n        // Search for shared layers.\n        for (const layer of model.layers) {\n            let flag = false;\n            for (const node of layer.inboundNodes) {\n                if (nodes.indexOf(node) !== -1) {\n                    if (flag) {\n                        sequentialLike = false;\n                        break;\n                    }\n                    else {\n                        flag = true;\n                    }\n                }\n            }\n            if (!sequentialLike) {\n                break;\n            }\n        }\n    }\n    return sequentialLike;\n}\nfunction printRow(fields, positions, \n// tslint:disable-next-line:no-any\nprintFn = console.log) {\n    let line = '';\n    for (let i = 0; i < fields.length; ++i) {\n        if (i > 0) {\n            line = line.slice(0, line.length - 1) + ' ';\n        }\n        line += fields[i];\n        line = line.slice(0, positions[i]);\n        line += ' '.repeat(positions[i] - line.length);\n    }\n    printFn(line);\n}\n/**\n * Prints a summary for a single Layer, without connectivity information.\n *\n * @param layer: Layer instance to print.\n */\nfunction printLayerSummary(layer, positions, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    let inputShape;\n    try {\n        inputShape = (layer.inboundNodes.map(x => JSON.stringify(x.inputShapes))).join(',');\n    }\n    catch (err) {\n        inputShape = 'multiple';\n    }\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const fields = [`${name} (${className})`, inputShape,\n        outputShape, layer.countParams().toString()];\n    printRow(fields, positions, printFn);\n}\n/**\n * Prints a summary for a single Layer, with connectivity information.\n */\nfunction printLayerSummaryWithConnections(layer, positions, relevantNodes, \n// tslint:disable-next-line:no-any\nprintFn) {\n    let outputShape;\n    let inputShape;\n    try {\n        inputShape = (layer.inboundNodes.map(x => JSON.stringify(x.inputShapes))).join(',');\n    }\n    catch (err) {\n        inputShape = 'multiple';\n    }\n    try {\n        outputShape = JSON.stringify(layer.outputShape);\n    }\n    catch (err) {\n        outputShape = 'multiple';\n    }\n    const connections = [];\n    for (const node of layer.inboundNodes) {\n        if (relevantNodes != null && relevantNodes.length > 0 &&\n            relevantNodes.indexOf(node) === -1) {\n            continue;\n        }\n        for (let i = 0; i < node.inboundLayers.length; ++i) {\n            const inboundLayer = node.inboundLayers[i].name;\n            const inboundLayerIndex = node.nodeIndices[i];\n            const inboundTensorIndex = node.tensorIndices[i];\n            connections.push(`${inboundLayer}[${inboundLayerIndex}][${inboundTensorIndex}]`);\n        }\n    }\n    const name = layer.name;\n    const className = layer.getClassName();\n    const firstConnection = connections.length === 0 ? '' : connections[0];\n    const fields = [\n        `${name} (${className})`, inputShape,\n        outputShape, layer.countParams().toString(),\n        firstConnection\n    ];\n    printRow(fields, positions, printFn);\n    for (let i = 1; i < connections.length; ++i) {\n        printRow(['', '', '', '', connections[i]], positions, printFn);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF5ZXJfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvdXRpbHMvbGF5ZXJfdXRpbHMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFJSCxPQUFPLEVBQUMsb0JBQW9CLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQUV0RDs7Ozs7Ozs7Ozs7Ozs7R0FjRztBQUNILE1BQU0sVUFBVSxZQUFZLENBQ3hCLEtBQWdCLEVBQUUsVUFBbUIsRUFBRSxTQUFvQjtBQUMzRCxrQ0FBa0M7QUFDbEMsVUFDSSxPQUFPLENBQUMsR0FBRztJQUNqQixNQUFNLGNBQWMsR0FBRyxxQkFBcUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUVwRCwyQ0FBMkM7SUFDM0MsTUFBTSxTQUFTLEdBQWEsQ0FBQyxjQUFjLEVBQUUsYUFBYSxFQUFFLGNBQWMsRUFBRSxTQUFTLENBQUMsQ0FBQztJQUN2RixJQUFJLGNBQWMsRUFBRTtRQUNsQixVQUFVLEdBQUcsVUFBVSxJQUFJLEVBQUUsQ0FBQztRQUM5QixTQUFTLEdBQUcsU0FBUyxJQUFJLENBQUMsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDaEQ7U0FBTTtRQUNMLFVBQVUsR0FBRyxVQUFVLElBQUksR0FBRyxDQUFDO1FBQy9CLFNBQVMsR0FBRyxTQUFTLElBQUksQ0FBQyxJQUFJLEVBQUUsSUFBSSxFQUFFLElBQUksRUFBRSxJQUFJLEVBQUUsQ0FBQyxDQUFDLENBQUM7UUFDckQsMkNBQTJDO0tBQzVDO0lBRUQsSUFBSSxTQUFTLENBQUMsU0FBUyxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUU7UUFDeEMsK0RBQStEO1FBQy9ELFNBQVMsR0FBRyxTQUFTLENBQUMsR0FBRyxDQUFDLENBQUMsQ0FBQyxFQUFFLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxVQUFVLEdB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ICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0IHtDb250YWluZXJ9IGZyb20gJy4uL2VuZ2luZS9jb250YWluZXInO1xuaW1wb3J0IHtMYXllciwgTm9kZX0gZnJvbSAnLi4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7Y291bnRQYXJhbXNJbldlaWdodHN9IGZyb20gJy4vdmFyaWFibGVfdXRpbHMnO1xuXG4vKipcbiAqIFByaW50IHRoZSBzdW1tYXJ5IG9mIGEgTGF5ZXJzTW9kZWwgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBtb2RlbCB0Zi5MYXllcnNNb2RlbCBpbnN0YW5jZS5cbiAqIEBwYXJhbSBsaW5lTGVuZ3RoIFRvdGFsIGxlbmd0aCBvZiBwcmludGVkIGxpbmVzLiBTZXQgdGhpcyB0byBhZGFwdCB0byB0aGVcbiAqICAgZGlzcGxheSB0byBkaWZmZXJlbnQgdGVybWluYWwgb3IgY29uc29sZSBzaXplcy5cbiAqIEBwYXJhbSBwb3NpdGlvbnMgUmVsYXRpdmUgb3IgYWJzb2x1dGUgcG9zaXRpb25zIG9mIGxvZyBlbGVtZW50cyBpbiBlYWNoXG4gKiAgIGxpbmUuIEVhY2ggbnVtYmVyIGNvcnJlc3BvbmRzIHRvIHJpZ2h0LW1vc3QgKGkuZS4sIGVuZGluZykgcG9zaXRpb24gb2YgYVxuICogICBjb2x1bW4uXG4gKiAgIElmIG5vdCBwcm92aWRlZCwgZGVmYXVsdHMgdG8gYFswLjQ1LCAwLjg1LCAxXWAgZm9yIHNlcXVlbnRpYWwtbGlrZVxuICogICBtb2RlbHMgYW5kIGBbMC4zMywgMC41NSwgMC42NywgMV1gIGZvciBub24tc2VxdWVudGlhbCBsaWtlIG1vZGVscy5cbiAqIEBwYXJhbSBwcmludEZuIFByaW50IGZ1bmN0aW9uIHRvIHVzZS5cbiAqICAgSXQgd2lsbCBiZSBjYWxsZWQgb24gZWFjaCBsaW5lIG9mIHRoZSBzdW1tYXJ5LiBZb3UgY2FuIHByb3ZpZGUgYSBjdXN0b21cbiAqICAgZnVuY3Rpb24gaW4gb3JkZXIgdG8gY2FwdHVyZSB0aGUgc3RyaW5nIHN1bW1hcnkuIERlZmF1bHRzIHRvIGBjb25zb2xlLmxvZ2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwcmludFN1bW1hcnkoXG4gICAgbW9kZWw6IENvbnRhaW5lciwgbGluZUxlbmd0aD86IG51bWJlciwgcG9zaXRpb25zPzogbnVtYmVyW10sXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHByaW50Rm46IChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pID0+IHZvaWQgPVxuICAgICAgICBjb25zb2xlLmxvZyk6IHZvaWQge1xuICBjb25zdCBzZXF1ZW50aWFsTGlrZSA9IGlzTW9kZWxTZXF1ZW50aWFsTGlrZShtb2RlbCk7XG5cbiAgLy8gSGVhZGVyIG5hbWVzIGZvciBkaWZmZXJlbnQgbG9nIGVsZW1lbnRzLlxuICBjb25zdCB0b0Rpc3BsYXk6IHN0cmluZ1tdID0gWydMYXllciAodHlwZSknLCAnSW5wdXQgU2hhcGUnLCAnT3V0cHV0IHNoYXBlJywgJ1BhcmFtICMnXTtcbiAgaWYgKHNlcXVlbnRpYWxMaWtlKSB7XG4gICAgbGluZUxlbmd0aCA9IGxpbmVMZW5ndGggfHwgOTA7XG4gICAgcG9zaXRpb25zID0gcG9zaXRpb25zIHx8IFswLjMyLCAwLjYxLCAwLjg5LCAxXTtcbiAgfSBlbHNlIHtcbiAgICBsaW5lTGVuZ3RoID0gbGluZUxlbmd0aCB8fCAxMTU7XG4gICAgcG9zaXRpb25zID0gcG9zaXRpb25zIHx8IFswLjI0LCAwLjQ4LCAwLjcwLCAwLjgwLCAxXTtcbiAgICAvLyBIZWFkZXIgbmFtZXMgZm9yIGRpZmZlcmVudCBsb2cgZWxlbWVudHMuXG4gIH1cblxuICBpZiAocG9zaXRpb25zW3Bvc2l0aW9ucy5sZW5ndGggLSAxXSA8PSAxKSB7XG4gICAgLy8gYHBvc2l0aW9uc2AgaXMgcmVsYXRpdmUuIENvbnZlcnQgaXQgdG8gYWJzb2x1dGUgcG9zaXRpb25pbmcuXG4gICAgcG9zaXRpb25zID0gcG9zaXRpb25zLm1hcChwID0+IE1hdGguZmxvb3IobGluZUxlbmd0aCAqIHApKTtcbiAgfVxuXG4gIGxldCByZWxldmFudE5vZGVzOiBOb2RlW107XG4gIGlmICghc2VxdWVudGlhbExpa2UpIHtcbiAgICB0b0Rpc3BsYXkucHVzaCgnUmVjZWl2ZXMgaW5wdXRzJyk7XG4gICAgcmVsZXZhbnROb2RlcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZGVwdGggaW4gbW9kZWwubm9kZXNCeURlcHRoKSB7XG4gICAgICByZWxldmFudE5vZGVzLnB1c2goLi4ubW9kZWwubm9kZXNCeURlcHRoW2RlcHRoXSk7XG4gICAgfVxuICB9XG5cbiAgcHJpbnRGbignXycucmVwZWF0KGxpbmVMZW5ndGgpKTtcbiAgcHJpbnRSb3codG9EaXNwbGF5LCBwb3NpdGlvbnMsIHByaW50Rm4pO1xuICBwcmludEZuKCc9Jy5yZXBlYXQobGluZUxlbmd0aCkpO1xuXG4gIGNvbnN0IGxheWVycyA9IG1vZGVsLmxheWVycztcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBsYXllcnMubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoc2VxdWVudGlhbExpa2UpIHtcbiAgICAgIHByaW50TGF5ZXJTdW1tYXJ5KGxheWVyc1tpXSwgcG9zaXRpb25zLCBwcmludEZuKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcHJpbnRMYXllclN1bW1hcnlXaXRoQ29ubmVjdGlvbnMoXG4gICAgICAgICAgbGF5ZXJzW2ldLCBwb3NpdGlvbnMsIHJlbGV2YW50Tm9kZXMsIHByaW50Rm4pO1xuICAgIH1cbiAgICBwcmludEZuKChpID09PSBsYXllcnMubGVuZ3RoIC0gMSA/ICc9JyA6ICdfJykucmVwZWF0KGxpbmVMZW5ndGgpKTtcbiAgfVxuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgKG1vZGVsIGFzIGFueSkuY2hlY2tUcmFpbmFibGVXZWlnaHRzQ29uc2lzdGVuY3koKTtcblxuICBjb25zdCB0cmFpbmFibGVDb3VudCA9IGNvdW50VHJhaW5hYmxlUGFyYW1zKG1vZGVsKTtcbiAgY29uc3Qgbm9uVHJhaW5hYmxlQ291bnQgPSBjb3VudFBhcmFtc0luV2VpZ2h0cyhtb2RlbC5ub25UcmFpbmFibGVXZWlnaHRzKTtcblxuICBwcmludEZuKGBUb3RhbCBwYXJhbXM6ICR7dHJhaW5hYmxlQ291bnQgKyBub25UcmFpbmFibGVDb3VudH1gKTtcbiAgcHJpbnRGbihgVHJhaW5hYmxlIHBhcmFtczogJHt0cmFpbmFibGVDb3VudH1gKTtcbiAgcHJpbnRGbihgTm9uLXRyYWluYWJsZSBwYXJhbXM6ICR7bm9uVHJhaW5hYmxlQ291bnR9YCk7XG4gIHByaW50Rm4oJ18nLnJlcGVhdChsaW5lTGVuZ3RoKSk7XG59XG5cbmZ1bmN0aW9uIGNvdW50VHJhaW5hYmxlUGFyYW1zKG1vZGVsOiBDb250YWluZXIpOiBudW1iZXIge1xuICBsZXQgdHJhaW5hYmxlQ291bnQ6IG51bWJlcjtcbiAgLy8gdHNsaW50OmRpc2FibGU6bm8tYW55XG4gIGlmICgobW9kZWwgYXMgYW55KS5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzICE9IG51bGwpIHtcbiAgICB0cmFpbmFibGVDb3VudCA9XG4gICAgICAgIGNvdW50UGFyYW1zSW5XZWlnaHRzKChtb2RlbCBhcyBhbnkpLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMpO1xuICB9IGVsc2Uge1xuICAgIHRyYWluYWJsZUNvdW50ID0gY291bnRQYXJhbXNJbldlaWdodHMobW9kZWwudHJhaW5hYmxlV2VpZ2h0cyk7XG4gIH1cbiAgLy8gdHNsaW50OmVuYWJsZTpuby1hbnlcbiAgcmV0dXJuIHRyYWluYWJsZUNvdW50O1xufVxuXG5mdW5jdGlvbiBpc01vZGVsU2VxdWVudGlhbExpa2UobW9kZWw6IENvbnRhaW5lcik6IGJvb2xlYW4ge1xuICBsZXQgc2VxdWVudGlhbExpa2UgPSB0cnVlO1xuICBjb25zdCBub2Rlc0J5RGVwdGg6IE5vZGVbXVtdID0gW107XG4gIGNvbnN0IG5vZGVzOiBOb2RlW10gPSBbXTtcbiAgZm9yIChjb25zdCBkZXB0aCBpbiBtb2RlbC5ub2Rlc0J5RGVwdGgpIHtcbiAgICBub2Rlc0J5RGVwdGgucHVzaChtb2RlbC5ub2Rlc0J5RGVwdGhbZGVwdGhdKTtcbiAgfVxuICBmb3IgKGNvbnN0IGRlcHRoTm9kZXMgb2Ygbm9kZXNCeURlcHRoKSB7XG4gICAgaWYgKGRlcHRoTm9kZXMubGVuZ3RoID4gMSB8fFxuICAgICAgICBkZXB0aE5vZGVzLmxlbmd0aCA9PT0gMSAmJiBkZXB0aE5vZGVzWzBdLmluYm91bmRMYXllcnMubGVuZ3RoID4gMSkge1xuICAgICAgc2VxdWVudGlhbExpa2UgPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBub2Rlcy5wdXNoKC4uLmRlcHRoTm9kZXMpO1xuICB9XG4gIGlmIChzZXF1ZW50aWFsTGlrZSkge1xuICAgIC8vIFNlYXJjaCBmb3Igc2hhcmVkIGxheWVycy5cbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIG1vZGVsLmxheWVycykge1xuICAgICAgbGV0IGZsYWcgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgbm9kZSBvZiBsYXllci5pbmJvdW5kTm9kZXMpIHtcbiAgICAgICAgaWYgKG5vZGVzLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgaWYgKGZsYWcpIHtcbiAgICAgICAgICAgIHNlcXVlbnRpYWxMaWtlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmxhZyA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIXNlcXVlbnRpYWxMaWtlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gc2VxdWVudGlhbExpa2U7XG59XG5cbmZ1bmN0aW9uIHByaW50Um93KFxuICAgIGZpZWxkczogc3RyaW5nW10sIHBvc2l0aW9uczogbnVtYmVyW10sXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHByaW50Rm46IChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pID0+IHZvaWQgPSBjb25zb2xlLmxvZykge1xuICBsZXQgbGluZSA9ICcnO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGZpZWxkcy5sZW5ndGg7ICsraSkge1xuICAgIGlmIChpID4gMCkge1xuICAgICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgbGluZS5sZW5ndGggLSAxKSArICcgJztcbiAgICB9XG4gICAgbGluZSArPSBmaWVsZHNbaV07XG4gICAgbGluZSA9IGxpbmUuc2xpY2UoMCwgcG9zaXRpb25zW2ldKTtcbiAgICBsaW5lICs9ICcgJy5yZXBlYXQocG9zaXRpb25zW2ldIC0gbGluZS5sZW5ndGgpO1xuICB9XG4gIHByaW50Rm4obGluZSk7XG59XG5cbi8qKlxuICogUHJpbnRzIGEgc3VtbWFyeSBmb3IgYSBzaW5nbGUgTGF5ZXIsIHdpdGhvdXQgY29ubmVjdGl2aXR5IGluZm9ybWF0aW9uLlxuICpcbiAqIEBwYXJhbSBsYXllcjogTGF5ZXIgaW5zdGFuY2UgdG8gcHJpbnQuXG4gKi9cbmZ1bmN0aW9uIHByaW50TGF5ZXJTdW1tYXJ5KFxuICAgIGxheWVyOiBMYXllciwgcG9zaXRpb25zOiBudW1iZXJbXSxcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgcHJpbnRGbjogKG1lc3NhZ2U/OiBhbnksIC4uLm9wdGlvbmFsUGFyYW1zOiBhbnlbXSkgPT4gdm9pZCkge1xuICBsZXQgb3V0cHV0U2hhcGU6IHN0cmluZztcbiAgbGV0IGlucHV0U2hhcGU6IHN0cmluZztcblxuICB0cnkge1xuICAgIGlucHV0U2hhcGUgPSAobGF5ZXIuaW5ib3VuZE5vZGVzLm1hcChcbiAgICAgIHggPT4gSlNPTi5zdHJpbmdpZnkoeC5pbnB1dFNoYXBlcylcbiAgICApKS5qb2luKCcsJyk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlucHV0U2hhcGUgPSAnbXVsdGlwbGUnO1xuICB9XG5cbiAgdHJ5IHtcbiAgICBvdXRwdXRTaGFwZSA9IEpTT04uc3RyaW5naWZ5KGxheWVyLm91dHB1dFNoYXBlKTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgb3V0cHV0U2hhcGUgPSAnbXVsdGlwbGUnO1xuICB9XG5cbiAgY29uc3QgbmFtZSA9IGxheWVyLm5hbWU7XG4gIGNvbnN0IGNsYXNzTmFtZSA9IGxheWVyLmdldENsYXNzTmFtZSgpO1xuICBjb25zdCBmaWVsZHM6IHN0cmluZ1tdID1cbiAgICAgIFtgJHtuYW1lfSAoJHtjbGFzc05hbWV9KWAsIGlucHV0U2hhcGUsXG4gICAgICBvdXRwdXRTaGFwZSwgbGF5ZXIuY291bnRQYXJhbXMoKS50b1N0cmluZygpXTtcbiAgcHJpbnRSb3coZmllbGRzLCBwb3NpdGlvbnMsIHByaW50Rm4pO1xufVxuXG4vKipcbiAqIFByaW50cyBhIHN1bW1hcnkgZm9yIGEgc2luZ2xlIExheWVyLCB3aXRoIGNvbm5lY3Rpdml0eSBpbmZvcm1hdGlvbi5cbiAqL1xuZnVuY3Rpb24gcHJpbnRMYXllclN1bW1hcnlXaXRoQ29ubmVjdGlvbnMoXG4gICAgbGF5ZXI6IExheWVyLCBwb3NpdGlvbnM6IG51bWJlcltdLCByZWxldmFudE5vZGVzOiBOb2RlW10sXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIHByaW50Rm46IChtZXNzYWdlPzogYW55LCAuLi5vcHRpb25hbFBhcmFtczogYW55W10pID0+IHZvaWQpIHtcbiAgbGV0IG91dHB1dFNoYXBlOiBzdHJpbmc7XG4gIGxldCBpbnB1dFNoYXBlOiBzdHJpbmc7XG5cbiAgdHJ5IHtcbiAgICBpbnB1dFNoYXBlID0gKGxheWVyLmluYm91bmROb2Rlcy5tYXAoXG4gICAgICB4ID0+IEpTT04uc3RyaW5naWZ5KHguaW5wdXRTaGFwZXMpXG4gICAgKSkuam9pbignLCcpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpbnB1dFNoYXBlID0gJ211bHRpcGxlJztcbiAgfVxuXG4gIHRyeSB7XG4gICAgb3V0cHV0U2hhcGUgPSBKU09OLnN0cmluZ2lmeShsYXllci5vdXRwdXRTaGFwZSk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIG91dHB1dFNoYXBlID0gJ211bHRpcGxlJztcbiAgfVxuXG4gIGNvbnN0IGNvbm5lY3Rpb25zOiBzdHJpbmdbXSA9IFtdO1xuICBmb3IgKGNvbnN0IG5vZGUgb2YgbGF5ZXIuaW5ib3VuZE5vZGVzKSB7XG4gICAgaWYgKHJlbGV2YW50Tm9kZXMgIT0gbnVsbCAmJiByZWxldmFudE5vZGVzLmxlbmd0aCA+IDAgJiZcbiAgICAgICAgcmVsZXZhbnROb2Rlcy5pbmRleE9mKG5vZGUpID09PSAtMSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBpbmJvdW5kTGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbaV0ubmFtZTtcbiAgICAgIGNvbnN0IGluYm91bmRMYXllckluZGV4ID0gbm9kZS5ub2RlSW5kaWNlc1tpXTtcbiAgICAgIGNvbnN0IGluYm91bmRUZW5zb3JJbmRleCA9IG5vZGUudGVuc29ySW5kaWNlc1tpXTtcbiAgICAgIGNvbm5lY3Rpb25zLnB1c2goXG4gICAgICAgICAgYCR7aW5ib3VuZExheWVyfVske2luYm91bmRMYXllckluZGV4fV1bJHtpbmJvdW5kVGVuc29ySW5kZXh9XWApO1xuICAgIH1cbiAgfVxuICBjb25zdCBuYW1lID0gbGF5ZXIubmFtZTtcbiAgY29uc3QgY2xhc3NOYW1lID0gbGF5ZXIuZ2V0Q2xhc3NOYW1lKCk7XG4gIGNvbnN0IGZpcnN0Q29ubmVjdGlvbiA9IGNvbm5lY3Rpb25zLmxlbmd0aCA9PT0gMCA/ICcnIDogY29ubmVjdGlvbnNbMF07XG4gIGNvbnN0IGZpZWxkczogc3RyaW5nW10gPSBbXG4gICAgYCR7bmFtZX0gKCR7Y2xhc3NOYW1lfSlgLCBpbnB1dFNoYXBlLFxuICAgIG91dHB1dFNoYXBlLCBsYXllci5jb3VudFBhcmFtcygpLnRvU3RyaW5nKCksXG4gICAgZmlyc3RDb25uZWN0aW9uXG4gIF07XG5cbiAgcHJpbnRSb3coZmllbGRzLCBwb3NpdGlvbnMsIHByaW50Rm4pO1xuICBmb3IgKGxldCBpID0gMTsgaSA8IGNvbm5lY3Rpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgcHJpbnRSb3coWycnLCAnJywgJycsICcnLCBjb25uZWN0aW9uc1tpXV0sIHBvc2l0aW9ucywgcHJpbnRGbik7XG4gIH1cbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport * as generic_utils from '../utils/generic_utils';\n// tslint:enable\n/**\n * Test whether a value in an array is the name of a LayersModel or Layer.\n * @param key The key name that the value is found under. Note that the key\n *   may not be at the level immediately above the value, if the value is in a\n *   nested array.\n * @param index Index of the value in the Array that it is found in.\n * @param value The value object.\n * @returns A boolean indicating whether value is a name.\n */\nfunction isArrayItemInputOrOutputName(key, index, value) {\n    return (key === 'inboundNodes' || key === 'outputLayers' ||\n        key === 'inputLayers') &&\n        index === 0 && typeof value === 'string';\n}\n/**\n * Convert a Pythonic config object to TypeScript config object.\n * @param pythonicConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertPythonicToTs(pythonicConfig, key) {\n    if (pythonicConfig === null) {\n        return null;\n    }\n    else if (typeof pythonicConfig === 'string') {\n        return generic_utils.toCamelCase(pythonicConfig);\n    }\n    else if ((typeof pythonicConfig === 'number') ||\n        (typeof pythonicConfig === 'boolean')) {\n        return pythonicConfig;\n    }\n    else if (pythonicConfig instanceof Array) {\n        const tsArray = [];\n        const arrayLength = pythonicConfig.length;\n        for (let i = 0; i < arrayLength; ++i) {\n            const item = pythonicConfig[i];\n            if (isArrayItemInputOrOutputName(key, i, item)) {\n                tsArray.push(item);\n            }\n            else {\n                tsArray.push(convertPythonicToTs(item, key));\n            }\n        }\n        return tsArray;\n    }\n    else {\n        const tsDict = {};\n        for (const pythonicKey of Object.keys(pythonicConfig)) {\n            const pythonicValue = pythonicConfig[pythonicKey];\n            if (pythonicKey === 'name' && typeof pythonicValue === 'string') {\n                // Special case the 'name' key with a string value. Name values, such as\n                // the names of LayersModel and Layer instances, should not undergo the\n                // camel-case conversion.\n                tsDict[pythonicKey] = pythonicValue;\n            }\n            else {\n                const tsKey = generic_utils.toCamelCase(pythonicKey);\n                tsDict[tsKey] = convertPythonicToTs(pythonicValue, tsKey);\n            }\n        }\n        return tsDict;\n    }\n}\n/**\n * Convert a TypeScript config object to Python config object.\n * @param tsConfig The config object to convert.\n * @param key Optional key name of the object being converted.\n * @returns Result of the conversion.\n */\nexport function convertTsToPythonic(tsConfig, key) {\n    if (tsConfig === null || tsConfig === undefined) {\n        return null;\n    }\n    else if (typeof tsConfig === 'string') {\n        return generic_utils.toSnakeCase(tsConfig);\n    }\n    else if ((typeof tsConfig === 'number') || (typeof tsConfig === 'boolean')) {\n        return tsConfig;\n    }\n    else if (tsConfig instanceof Array) {\n        const pyArray = [];\n        const arrayLength = tsConfig.length;\n        for (let i = 0; i < arrayLength; ++i) {\n            const item = tsConfig[i];\n            if (isArrayItemInputOrOutputName(key, i, item)) {\n                pyArray.push(item);\n            }\n            else {\n                pyArray.push(convertTsToPythonic(item, key));\n            }\n        }\n        return pyArray;\n    }\n    else {\n        const pyDict = {};\n        for (const tsKey of Object.keys(tsConfig)) {\n            const tsValue = tsConfig[tsKey];\n            const pyKey = generic_utils.toSnakeCase(tsKey);\n            if ((tsKey === 'name' || tsKey === 'className') &&\n                typeof tsValue === 'string') {\n                // Special case the 'name' key with a string value. Name values, such as\n                // the names of LayersModel and Layer instances, should not undergo the\n                // snake-case conversion.\n                pyDict[pyKey] = tsValue;\n            }\n            else {\n                pyDict[pyKey] = convertTsToPythonic(tsValue, tsKey);\n            }\n        }\n        return pyDict;\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VyaWFsaXphdGlvbl91dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy91dGlscy9zZXJpYWxpemF0aW9uX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBVUgsT0FBTyxLQUFLLGFBQWEsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxnQkFBZ0I7QUFFaEI7Ozs7Ozs7O0dBUUc7QUFDSCxTQUFTLDRCQUE0QixDQUNqQyxHQUFXLEVBQUUsS0FBYSxFQUFFLEtBQVE7SUFDdEMsT0FBTyxDQUFDLEdBQUcsS0FBSyxjQUFjLElBQUksR0FBRyxLQUFLLGNBQWM7UUFDaEQsR0FBRyxLQUFLLGFBQWEsQ0FBQztRQUMxQixLQUFLLEtBQUssQ0FBQyxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsQ0FBQztBQUMvQyxDQUFDO0FBRUQ7Ozs7O0dBS0c7QUFDSCxNQUFNLFVBQVUsbUJBQW1CLENBQy9CLGNBQTJCLEVBQUUsR0FBWTtJQUMzQyxJQUFJLGNBQWMsS0FBSyxJQUFJLEVBQUU7UUFDM0IsT0FBTyxJQUFJLENBQUM7S0FDYjtTQUFNLElBQUksT0FBTyxjQUFjLEtBQUssUUFBUSxFQUFFO1FBQzdDLE9BQU8sYUFBYSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsQ0FBQztLQUNsRDtTQUFNLElBQ0gsQ0FBQyxPQUFPLGNBQWMsS0FBSyxRQUFRLENBQUM7UUFDcEMsQ0FBQyxPQUFPLGNBQWMsS0FBSyxTQUFTLENBQUMsRUFBRTtRQUN6QyxPQUFPLGNBQWMsQ0FBQztLQUN2QjtTQUFNLElBQUksY0FBYyxZQUFZLEtBQUssRUFBRTtRQUMxQyxNQUFNLE9BQU8sR0FBRyxFQUFFLENBQUM7UUFDbkIsTUFBTSxXQUFXLEdBQUcsY0FBYyxDQUFDLE1BQU0sQ0FBQztRQUMxQyxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsV0FBVyxFQUFF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Qy9CLHdFQUF3RTtnQkFDeEUsdUVBQXVFO2dCQUN2RSx5QkFBeUI7Z0JBQ3pCLE1BQU0sQ0FBQyxLQUFLLENBQUMsR0FBRyxPQUFPLENBQUM7YUFDekI7aUJBQU07Z0JBQ0wsTUFBTSxDQUFDLEtBQUssQ0FBQyxHQUFHLG1CQUFtQixDQUFDLE9BQU8sRUFBRSxLQUFLLENBQUMsQ0FBQzthQUNyRDtTQUNGO1FBQ0QsT0FBTyxNQUFNLENBQUM7S0FDZjtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBQb3J0aW5nIG5vdGU6IFRoaXMgZmlsZSBkb2Vzbid0IGV4aXN0IGluIFB5S2VyYXMuXG4vLyBJdHMgcHVycG9zZSBoZXJlIGlzIHRvIGNlbnRyYWxpemUgdGhlIGJvdW5kYXJ5IGxheWVyIGJldHdlZW5cbi8vIHRmanMtbGF5ZXJzJ3MgaW50ZXJuYWwgQ29uZmlnIFRTLUNlbnRyaWMgZm9ybWF0IGFuZCBQeUtlcmFzJ3Ncbi8vIHNlcmlhbGl6ZWQgUHl0aG9uIENvbmZpZyBmb3JtYXQuXG5cbmltcG9ydCB7c2VyaWFsaXphdGlvbn0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtQeUpzb25WYWx1ZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L3R5cGVzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG4vLyB0c2xpbnQ6ZW5hYmxlXG5cbi8qKlxuICogVGVzdCB3aGV0aGVyIGEgdmFsdWUgaW4gYW4gYXJyYXkgaXMgdGhlIG5hbWUgb2YgYSBMYXllcnNNb2RlbCBvciBMYXllci5cbiAqIEBwYXJhbSBrZXkgVGhlIGtleSBuYW1lIHRoYXQgdGhlIHZhbHVlIGlzIGZvdW5kIHVuZGVyLiBOb3RlIHRoYXQgdGhlIGtleVxuICogICBtYXkgbm90IGJlIGF0IHRoZSBsZXZlbCBpbW1lZGlhdGVseSBhYm92ZSB0aGUgdmFsdWUsIGlmIHRoZSB2YWx1ZSBpcyBpbiBhXG4gKiAgIG5lc3RlZCBhcnJheS5cbiAqIEBwYXJhbSBpbmRleCBJbmRleCBvZiB0aGUgdmFsdWUgaW4gdGhlIEFycmF5IHRoYXQgaXQgaXMgZm91bmQgaW4uXG4gKiBAcGFyYW0gdmFsdWUgVGhlIHZhbHVlIG9iamVjdC5cbiAqIEByZXR1cm5zIEEgYm9vbGVhbiBpbmRpY2F0aW5nIHdoZXRoZXIgdmFsdWUgaXMgYSBuYW1lLlxuICovXG5mdW5jdGlvbiBpc0FycmF5SXRlbUlucHV0T3JPdXRwdXROYW1lPFQ+KFxuICAgIGtleTogc3RyaW5nLCBpbmRleDogbnVtYmVyLCB2YWx1ZTogVCk6IGJvb2xlYW4ge1xuICByZXR1cm4gKGtleSA9PT0gJ2luYm91bmROb2RlcycgfHwga2V5ID09PSAnb3V0cHV0TGF5ZXJzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ2lucHV0TGF5ZXJzJykgJiZcbiAgICAgIGluZGV4ID09PSAwICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZyc7XG59XG5cbi8qKlxuICogQ29udmVydCBhIFB5dGhvbmljIGNvbmZpZyBvYmplY3QgdG8gVHlwZVNjcmlwdCBjb25maWcgb2JqZWN0LlxuICogQHBhcmFtIHB5dGhvbmljQ29uZmlnIFRoZSBjb25maWcgb2JqZWN0IHRvIGNvbnZlcnQuXG4gKiBAcGFyYW0ga2V5IE9wdGlvbmFsIGtleSBuYW1lIG9mIHRoZSBvYmplY3QgYmVpbmcgY29udmVydGVkLlxuICogQHJldHVybnMgUmVzdWx0IG9mIHRoZSBjb252ZXJzaW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udmVydFB5dGhvbmljVG9UcyhcbiAgICBweXRob25pY0NvbmZpZzogUHlKc29uVmFsdWUsIGtleT86IHN0cmluZyk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFZhbHVlIHtcbiAgaWYgKHB5dGhvbmljQ29uZmlnID09PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIHB5dGhvbmljQ29uZmlnID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBnZW5lcmljX3V0aWxzLnRvQ2FtZWxDYXNlKHB5dGhvbmljQ29uZmlnKTtcbiAgfSBlbHNlIGlmIChcbiAgICAgICh0eXBlb2YgcHl0aG9uaWNDb25maWcgPT09ICdudW1iZXInKSB8fFxuICAgICAgKHR5cGVvZiBweXRob25pY0NvbmZpZyA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgIHJldHVybiBweXRob25pY0NvbmZpZztcbiAgfSBlbHNlIGlmIChweXRob25pY0NvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgY29uc3QgdHNBcnJheSA9IFtdO1xuICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gcHl0aG9uaWNDb25maWcubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IHB5dGhvbmljQ29uZmlnW2ldO1xuICAgICAgaWYgKGlzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUoa2V5LCBpLCBpdGVtKSkge1xuICAgICAgICB0c0FycmF5LnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0c0FycmF5LnB1c2goY29udmVydFB5dGhvbmljVG9UcyhpdGVtLCBrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRzQXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgdHNEaWN0OiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHB5dGhvbmljS2V5IG9mIE9iamVjdC5rZXlzKHB5dGhvbmljQ29uZmlnKSkge1xuICAgICAgY29uc3QgcHl0aG9uaWNWYWx1ZSA9IHB5dGhvbmljQ29uZmlnW3B5dGhvbmljS2V5XTtcbiAgICAgIGlmIChweXRob25pY0tleSA9PT0gJ25hbWUnICYmIHR5cGVvZiBweXRob25pY1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdGhlICduYW1lJyBrZXkgd2l0aCBhIHN0cmluZyB2YWx1ZS4gTmFtZSB2YWx1ZXMsIHN1Y2ggYXNcbiAgICAgICAgLy8gdGhlIG5hbWVzIG9mIExheWVyc01vZGVsIGFuZCBMYXllciBpbnN0YW5jZXMsIHNob3VsZCBub3QgdW5kZXJnbyB0aGVcbiAgICAgICAgLy8gY2FtZWwtY2FzZSBjb252ZXJzaW9uLlxuICAgICAgICB0c0RpY3RbcHl0aG9uaWNLZXldID0gcHl0aG9uaWNWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IHRzS2V5ID0gZ2VuZXJpY191dGlscy50b0NhbWVsQ2FzZShweXRob25pY0tleSk7XG4gICAgICAgIHRzRGljdFt0c0tleV0gPSBjb252ZXJ0UHl0aG9uaWNUb1RzKHB5dGhvbmljVmFsdWUsIHRzS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRzRGljdDtcbiAgfVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBUeXBlU2NyaXB0IGNvbmZpZyBvYmplY3QgdG8gUHl0aG9uIGNvbmZpZyBvYmplY3QuXG4gKiBAcGFyYW0gdHNDb25maWcgVGhlIGNvbmZpZyBvYmplY3QgdG8gY29udmVydC5cbiAqIEBwYXJhbSBrZXkgT3B0aW9uYWwga2V5IG5hbWUgb2YgdGhlIG9iamVjdCBiZWluZyBjb252ZXJ0ZWQuXG4gKiBAcmV0dXJucyBSZXN1bHQgb2YgdGhlIGNvbnZlcnNpb24uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252ZXJ0VHNUb1B5dGhvbmljKFxuICAgIHRzQ29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RWYWx1ZSwga2V5Pzogc3RyaW5nKTogUHlKc29uVmFsdWUge1xuICBpZiAodHNDb25maWcgPT09IG51bGwgfHwgdHNDb25maWcgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiB0c0NvbmZpZyA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZ2VuZXJpY191dGlscy50b1NuYWtlQ2FzZSh0c0NvbmZpZyk7XG4gIH0gZWxzZSBpZiAoXG4gICAgICAodHlwZW9mIHRzQ29uZmlnID09PSAnbnVtYmVyJykgfHwgKHR5cGVvZiB0c0NvbmZpZyA9PT0gJ2Jvb2xlYW4nKSkge1xuICAgIHJldHVybiB0c0NvbmZpZztcbiAgfSBlbHNlIGlmICh0c0NvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgY29uc3QgcHlBcnJheSA9IFtdO1xuICAgIGNvbnN0IGFycmF5TGVuZ3RoID0gdHNDb25maWcubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXlMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgaXRlbSA9IHRzQ29uZmlnW2ldO1xuICAgICAgaWYgKGlzQXJyYXlJdGVtSW5wdXRPck91dHB1dE5hbWUoa2V5LCBpLCBpdGVtKSkge1xuICAgICAgICBweUFycmF5LnB1c2goaXRlbSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBweUFycmF5LnB1c2goY29udmVydFRzVG9QeXRob25pYyhpdGVtLCBrZXkpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHB5QXJyYXk7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcHlEaWN0OiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7fTtcbiAgICBmb3IgKGNvbnN0IHRzS2V5IG9mIE9iamVjdC5rZXlzKHRzQ29uZmlnKSkge1xuICAgICAgY29uc3QgdHNWYWx1ZSA9IHRzQ29uZmlnW3RzS2V5XTtcbiAgICAgIGNvbnN0IHB5S2V5ID0gZ2VuZXJpY191dGlscy50b1NuYWtlQ2FzZSh0c0tleSk7XG4gICAgICBpZiAoKHRzS2V5ID09PSAnbmFtZScgfHwgdHNLZXkgPT09ICdjbGFzc05hbWUnKSAmJlxuICAgICAgICAgIHR5cGVvZiB0c1ZhbHVlID09PSAnc3RyaW5nJykge1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgdGhlICduYW1lJyBrZXkgd2l0aCBhIHN0cmluZyB2YWx1ZS4gTmFtZSB2YWx1ZXMsIHN1Y2ggYXNcbiAgICAgICAgLy8gdGhlIG5hbWVzIG9mIExheWVyc01vZGVsIGFuZCBMYXllciBpbnN0YW5jZXMsIHNob3VsZCBub3QgdW5kZXJnbyB0aGVcbiAgICAgICAgLy8gc25ha2UtY2FzZSBjb252ZXJzaW9uLlxuICAgICAgICBweURpY3RbcHlLZXldID0gdHNWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHB5RGljdFtweUtleV0gPSBjb252ZXJ0VHNUb1B5dGhvbmljKHRzVmFsdWUsIHRzS2V5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHB5RGljdDtcbiAgfVxufVxuIl19","/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nconst version = '3.18.0';\nexport { version };\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVyc2lvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy92ZXJzaW9uLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLHFDQUFxQztBQUVyQyx3REFBd0Q7QUFDeEQsTUFBTSxPQUFPLEdBQUcsUUFBUSxDQUFDO0FBQ3pCLE9BQU8sRUFBQyxPQUFPLEVBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKiBAbGljZW5zZSBTZWUgdGhlIExJQ0VOU0UgZmlsZS4gKi9cblxuLy8gVGhpcyBjb2RlIGlzIGF1dG8tZ2VuZXJhdGVkLCBkbyBub3QgbW9kaWZ5IHRoaXMgZmlsZSFcbmNvbnN0IHZlcnNpb24gPSAnMy4xOC4wJztcbmV4cG9ydCB7dmVyc2lvbn07XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source: keras/engine/topology.py */\nimport { tidy } from '@tensorflow/tfjs-core';\nimport { getUid } from '../backend/state';\nimport { NotImplementedError, RuntimeError, ValueError } from '../errors';\nimport { deserialize as deserializeLayer } from '../layers/serialization';\nimport * as generic_utils from '../utils/generic_utils';\nimport { convertTsToPythonic } from '../utils/serialization_utils';\nimport * as types_utils from '../utils/types_utils';\nimport { batchSetValue } from '../variables';\nimport { version as layersVersion } from '../version';\nimport { execute, FeedDict } from './executor';\nimport { InputLayer } from './input_layer';\nimport { Layer, Node } from './topology';\n/**\n * A Container is a directed acyclic graph of layers.\n *\n * It is the topological form of a \"model\". A LayersModel\n * is simply a Container with added training routines.\n *\n */\nexport class Container extends Layer {\n    constructor(args) {\n        // No args passed to super's constructor.\n        super({});\n        this.containerNodes = new Set();\n        this.name = args.name;\n        if (this.name == null) {\n            const prefix = this.getClassName().toLowerCase();\n            this.name = getUid(prefix);\n        }\n        this.supportsMasking = false;\n        this.trainable_ = true;\n        // TODO(michaelterry): Initialize perInputLosses/Updates here.\n        // Container-specific properties.\n        if (Array.isArray(args.inputs)) {\n            this.inputs = args.inputs.slice();\n        }\n        else {\n            this.inputs = [args.inputs];\n        }\n        if (Array.isArray(args.outputs)) {\n            this.outputs = args.outputs.slice();\n        }\n        else {\n            this.outputs = [args.outputs];\n        }\n        // Check for redundancy in inputs.\n        if (generic_utils.unique(this.inputs).length !== this.inputs.length) {\n            throw new ValueError('The list of inputs passed to the model is ' +\n                'redundant. All inputs should only appear once. Found: ' +\n                `${this.inputs.map(x => x.name)}`);\n        }\n        // Check for redundancy in outputs.\n        if (generic_utils.unique(this.outputs).length !== this.outputs.length) {\n            console.warn('The list of outputs passed to the model is redundant. ' +\n                'All outputs should only appear once. Found: ' +\n                `${this.outputs.map(x => x.name)}`);\n        }\n        /*\n          List of initial layers (1 to 1 mapping with this.inputs, hence the same\n          layer might appear twice)\n        */\n        this.inputLayers = [];\n        this.inputLayersNodeIndices = [];\n        this.inputLayersTensorIndices = [];\n        /*\n          List of layers (1 to 1 mapping with this.outputs, hence the same layer\n          might appear twice)\n        */\n        this.outputLayers = [];\n        this.outputLayersNodeIndices = [];\n        this.outputLayersTensorIndices = [];\n        /*\n          All layers in order of horizontal graph traversal. Entries are unique.\n          Includes input and output layers.\n        */\n        this.layers = [];\n        /*\n          References to container layers that were constructed internally. We need\n          these to properly dispose of tensors from nested containers.\n        */\n        this.internalContainerRefs = [];\n        // TODO(michaelterry): Determine if caching still needed with eager\n        // backend.\n        /*\n          This is for performance optimization when calling the Container on new\n          inputs. Every time the Container is called on a set on input tensors,\n          we compute the output tensors, output masks and output shapes in one pass,\n          then cache them here. When one of these outputs is queried later,\n          we retrieve it from there instead of recomputing it.\n        */\n        // this.outputTensorCache = {};\n        // this.outputShapeCache = {};\n        // Build this.outputLayers:\n        for (const x of this.outputs) {\n            const layer = x.sourceLayer;\n            const nodeIndex = x.nodeIndex;\n            const tensorIndex = x.tensorIndex;\n            this.outputLayers.push(layer);\n            this.outputLayersNodeIndices.push(nodeIndex);\n            this.outputLayersTensorIndices.push(tensorIndex);\n        }\n        // TODO(michaelterry): Add output mask cache code.\n        // Build this.inputLayers:\n        for (const x of this.inputs) {\n            const layer = x.sourceLayer;\n            const nodeIndex = x.nodeIndex;\n            const tensorIndex = x.tensorIndex;\n            /*\n              It's supposed to be an input layer, so only one node\n              and one tensor output.\n            */\n            generic_utils.assert(nodeIndex === 0, 'input layer has >1 nodes');\n            generic_utils.assert(tensorIndex === 0, 'input layer has >1 tensors');\n            this.inputLayers.push(layer);\n            this.inputLayersNodeIndices.push(nodeIndex);\n            this.inputLayersTensorIndices.push(tensorIndex);\n        }\n        // Build this.inputNames and this.outputNames.\n        this.inputNames = [];\n        this.outputNames = [];\n        this.feedInputShapes = [];\n        this.feedInputNames = [];\n        this.feedOutputNames = [];\n        for (let i = 0; i < this.inputLayers.length; i++) {\n            const layer = this.inputLayers[i];\n            // Check that layer is an InputLayer.\n            if (!(layer instanceof InputLayer)) {\n                throw new TypeError('Input layers to a LayersModel must be InputLayer objects. ' +\n                    `Received inputs: ${args.inputs}. ` +\n                    `Input ${i} (0-based) originates ` +\n                    `from layer type ${layer.getClassName()}.`);\n            }\n            this.inputNames.push(layer.name);\n            this.feedInputShapes.push(layer.batchInputShape);\n            this.feedInputNames.push(layer.name);\n        }\n        for (const layer of this.outputLayers) {\n            this.outputNames.push(layer.name);\n        }\n        this.internalInputShapes = this.inputs.map(x => x.shape);\n        this.internalOutputShapes = this.outputs.map(x => x.shape);\n        /*\n          Container_nodes: set of nodes included in the graph (not all nodes\n          included in the layers are relevant to the current graph).\n        */\n        // ids of all nodes relevant to the Container:\n        const nodesDepths = {};\n        // To recover nodes from their ID.\n        const nodeIDToNode = {};\n        const layersDepths = {};\n        // To layers from their ID.\n        const layerIDToLayer = {};\n        const layerIndices = {};\n        const nodesInDecreasingDepth = [];\n        /**\n         * Builds a map of the graph of layers.\n         *\n         * This recursively updates the map `layerIndices`,\n         * the list `nodesInDecreasingDepth` and the set `containerNodes`.\n         *\n         * @param tensor Some tensor in a graph.\n         * @param finishedNodes Set of nodes whose subgraphs have been traversed\n         *         completely. Useful to prevent duplicated work.\n         * @param nodesInProgress Set of nodes that are currently active on the\n         *         recursion stack. Useful to detect cycles.\n         * @param layer Layer from which `tensor` comes from. If not provided,\n         *   will be obtained from tensor.sourceLayer.\n         * @param nodeIndex Node index from which `tensor` comes from.\n         * @param tensorIndex TensorIndex from which `tensor` comes from.\n         *\n         * @exception RuntimeError if a cycle is detected.\n         */\n        const buildMapOfGraph = (tensor, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex) => {\n            if (layer == null || nodeIndex == null || tensorIndex == null) {\n                layer = tensor.sourceLayer;\n                nodeIndex = tensor.nodeIndex;\n                tensorIndex = tensor.tensorIndex;\n            }\n            const node = layer.inboundNodes[nodeIndex];\n            // Prevent cycles.\n            if (nodesInProgress.indexOf(node) !== -1) {\n                throw new RuntimeError(`The tensor ${tensor.name} at layer \"${layer.name}\" ` +\n                    'is part of a cycle.');\n            }\n            // Don't repeat work for shared subgraphs\n            if (finishedNodes.indexOf(node) !== -1) {\n                return;\n            }\n            // Update containerNodes.\n            this.containerNodes.add(Container.nodeKey(layer, nodeIndex));\n            // Store the traversal order for layer sorting.\n            if (!(layer.id in layerIndices)) {\n                layerIndices[layer.id] = Object.keys(layerIndices).length;\n            }\n            if (nodesInProgress.indexOf(node) === -1) {\n                nodesInProgress.push(node);\n            }\n            // Propagate to all previous tensors connected to this node.\n            const numInboundLayers = node.inboundLayers.length;\n            for (let i = 0; i < numInboundLayers; i++) {\n                const x = node.inputTensors[i];\n                const layer = node.inboundLayers[i];\n                const nodeIndex = node.nodeIndices[i];\n                const tensorIndex = node.tensorIndices[i];\n                buildMapOfGraph(x, finishedNodes, nodesInProgress, layer, nodeIndex, tensorIndex);\n            }\n            finishedNodes.push(node);\n            while (nodesInProgress.indexOf(node) >= 0) {\n                nodesInProgress.splice(nodesInProgress.indexOf(node), 1);\n            }\n            nodesInDecreasingDepth.push(node);\n        };\n        const finishedNodes = [];\n        const nodesInProgress = [];\n        for (const x of this.outputs) {\n            buildMapOfGraph(x, finishedNodes, nodesInProgress);\n        }\n        const reversedNodesInDecreasingDepth = nodesInDecreasingDepth.slice().reverse();\n        for (const node of reversedNodesInDecreasingDepth) {\n            nodeIDToNode[node.id] = node;\n            // If the depth is not set, the node has no outbound nodes (depth 0).\n            if (!(node.id in nodesDepths)) {\n                nodesDepths[node.id] = 0;\n            }\n            let depth = nodesDepths[node.id];\n            // Update the depth of the corresponding layer\n            const previousDepth = (layersDepths[node.outboundLayer.id] == null ?\n                0 :\n                layersDepths[node.outboundLayer.id]);\n            /*\n              If we've seen this layer before at a higher depth, we should use that\n              depth instead of the node depth.  This is necessary for shared layers\n              that have inputs at different depth levels in the graph.\n            */\n            depth = Math.max(depth, previousDepth);\n            layersDepths[node.outboundLayer.id] = depth;\n            layerIDToLayer[node.outboundLayer.id] = node.outboundLayer;\n            nodesDepths[node.id] = depth;\n            // Update the depth of inbound nodes.\n            for (let i = 0; i < node.inboundLayers.length; i++) {\n                const inboundLayer = node.inboundLayers[i];\n                const nodeIndex = node.nodeIndices[i];\n                const inboundNode = inboundLayer.inboundNodes[nodeIndex];\n                const previousDepth = (nodesDepths[inboundNode.id] == null ? 0 :\n                    nodesDepths[inboundNode.id]);\n                nodesDepths[inboundNode.id] = Math.max(depth + 1, previousDepth);\n                nodeIDToNode[inboundNode.id] = inboundNode;\n            }\n        }\n        // Build a dict {depth: list of nodes with this depth}\n        const nodesByDepth = {};\n        for (const nodeID in nodesDepths) {\n            const depth = nodesDepths[nodeID];\n            if (!(depth in nodesByDepth)) {\n                nodesByDepth[depth] = [];\n            }\n            nodesByDepth[depth].push(nodeIDToNode[nodeID]);\n        }\n        // Build a dict {depth: list of layers with this depth}\n        const layersByDepth = {};\n        for (const layerID in layersDepths) {\n            const depth = layersDepths[layerID];\n            if (!(depth in layersByDepth)) {\n                layersByDepth[depth] = [];\n            }\n            layersByDepth[depth].push(layerIDToLayer[layerID]);\n        }\n        // Get sorted list of layer depths.\n        let depthKeys = Object.keys(layersByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(generic_utils.reverseNumberCompare);\n        // Set this.layers and this.layersByDepth.\n        this.layers = [];\n        for (const depth of depthKeys) {\n            const layersForDepth = layersByDepth[depth];\n            // Container.layers needs to have a deterministic order:\n            // here we order them by traversal order.\n            layersForDepth.sort((a, b) => {\n                const aIndex = layerIndices[a.id];\n                const bIndex = layerIndices[b.id];\n                if (aIndex < bIndex) {\n                    return -1;\n                }\n                if (aIndex > bIndex) {\n                    return 1;\n                }\n                return 0;\n            });\n            for (const layer of layersForDepth) {\n                if (layer instanceof Container) {\n                    this.internalContainerRefs.push(layer);\n                }\n                this.layers.push(layer);\n            }\n        }\n        this.layersByDepth = layersByDepth;\n        // Get sorted list of node depths;\n        depthKeys = Object.keys(nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(generic_utils.reverseNumberCompare);\n        // Check that all tensors required are computable.\n        // computable_tensors: all tensors in the graph\n        // that can be computed from the inputs provided.\n        const computableTensors = this.inputs.slice();\n        // To provide a better error msg.\n        const layersWithCompleteInput = [];\n        for (const depth of depthKeys) {\n            for (const node of nodesByDepth[depth]) {\n                const layer = node.outboundLayer;\n                if (layer != null) {\n                    for (const x of node.inputTensors) {\n                        if (computableTensors.indexOf(x) === -1) {\n                            throw new RuntimeError(`Graph disconnected: cannot obtain value for tensor ${x}` +\n                                ` at layer \"${layer.name}\". ` +\n                                'The following previous layers were accessed without ' +\n                                `issue: ${layersWithCompleteInput}`);\n                        }\n                    }\n                    for (const x of node.outputTensors) {\n                        computableTensors.push(x);\n                    }\n                    layersWithCompleteInput.push(layer.name);\n                }\n            }\n        }\n        // Set this.containerNodes and this.nodesByDepth.\n        this.nodesByDepth = nodesByDepth;\n        // Ensure name unicity, which will be crucial for serialization\n        // (since serialized nodes refer to layers by their name).\n        const allNames = this.layers.map(x => x.name);\n        for (const name of allNames) {\n            const numOccurrences = allNames.filter(x => x === name).length;\n            if (numOccurrences !== 1) {\n                throw new RuntimeError(`The name \"${name}\" is used ${numOccurrences} times ` +\n                    'in the model. All layer names should be unique. Layer names: ' +\n                    JSON.stringify(allNames));\n            }\n        }\n        // Layer parameters.\n        // The new container starts with a single inbound node\n        // for its inputs, and no outbound nodes.\n        // Will be appended to by future calls to apply().\n        this.outboundNodes = [];\n        // Will be appended to below, and by future calls to apply().\n        this.inboundNodes = [];\n        // Create the node linking internal inputs to internal outputs.\n        // (This call has side effects.)\n        // tslint:disable-next-line:no-unused-expression\n        new Node({\n            outboundLayer: this,\n            inboundLayers: [],\n            nodeIndices: [],\n            tensorIndices: [],\n            inputTensors: this.inputs,\n            outputTensors: this.outputs,\n            inputMasks: this.inputs.map(x => null),\n            outputMasks: this.outputs.map(x => null),\n            inputShapes: this.inputs.map(x => x.shape),\n            outputShapes: this.outputs.map(x => x.shape)\n        });\n        this.built = true;\n        this._refCount = 1; // The ref count of a container always start at 1.\n    }\n    assertNotDisposed() {\n        if (this._refCount === 0) {\n            throw new Error(`Container '${this.name}' is already disposed.`);\n        }\n    }\n    /**\n     * Attempt to dispose a LayersModel's weights.\n     *\n     * This method decrease the reference count of the LayersModel object by 1.\n     *\n     * A LayersModel is reference-counted. Its reference count is incremented by 1\n     * when it is first constructed and when it is used as a Layer of another\n     * LayersModel.\n     *\n     * If the reference count of a LayersModel becomes 0, the `dispose` method of\n     * all its constituent `Layer`s will be called.\n     *\n     * Note: If the reference count is greater than 0 after the decrement, the\n     * `dispose` method of its constituent `Layer`s will *not* be called.\n     *\n     * After a LayersModel is disposed, it cannot be used in calls such as\n     * 'predict`, `evaluate` or `fit` anymore.\n     *\n     * @returns A DisposeResult Object with the following fields:\n     *   - refCountAfterDispose: The reference count of the LayersModel after this\n     *     `dispose()` call.\n     *   - numDisposedVariables: Number of `tf.Variable`s (i.e., weights) disposed\n     *     during this `dispose()` call.\n     * @throws {Error} If the layer is not built yet, or if the LayersModel has\n     *   already been disposed.\n     */\n    dispose() {\n        this.assertNotDisposed();\n        const result = { refCountAfterDispose: null, numDisposedVariables: 0 };\n        if (--this._refCount === 0) {\n            for (const layer of this.layers) {\n                result.numDisposedVariables += layer.dispose().numDisposedVariables;\n            }\n            // Call dispose on each internally created container layer again to ensure\n            // their refCounts hit zero and their tensors are subsequently deleted.\n            for (const container of this.internalContainerRefs) {\n                result.numDisposedVariables += container.dispose().numDisposedVariables;\n            }\n        }\n        result.refCountAfterDispose = this._refCount;\n        return result;\n    }\n    get trainable() {\n        return this.trainable_;\n    }\n    set trainable(trainable) {\n        this.layers.forEach(layer => {\n            // tslint:disable-next-line:no-any\n            layer._trainableWeights\n                .forEach(w => w.trainable = trainable);\n        });\n        this.trainable_ = trainable;\n    }\n    get trainableWeights() {\n        // Porting Note: This check below is to prevent errors where the\n        //   _trainableWeights inherited from the parent class (Layer) gets\n        //   inadvertently used.\n        if (this._trainableWeights.length > 0) {\n            throw new ValueError('Container instance unexpectedly contains _trainableWeights.' +\n                'The trainable weights of a Container are a union of the ' +\n                'trainable weights of its consituent Layers. Its own ' +\n                '_trainableWeights must remain an empty Array.');\n        }\n        if (!this.trainable) {\n            return [];\n        }\n        let weights = [];\n        for (const layer of this.layers) {\n            weights = weights.concat(layer.trainableWeights);\n        }\n        return weights;\n    }\n    get nonTrainableWeights() {\n        const weights = [];\n        for (const layer of this.layers) {\n            weights.push(...layer.nonTrainableWeights);\n        }\n        if (!this.trainable) {\n            const trainableWeights = [];\n            for (const layer of this.layers) {\n                trainableWeights.push(...layer.trainableWeights);\n            }\n            return trainableWeights.concat(weights);\n        }\n        return weights;\n    }\n    get weights() {\n        return this.trainableWeights.concat(this.nonTrainableWeights);\n    }\n    /**\n     * Loads all layer weights from a JSON object.\n     *\n     * Porting Note: HDF5 weight files cannot be directly loaded in JavaScript /\n     *   TypeScript. The utility script at `scripts/pykeras.py` offers means\n     *   to convert them into JSON strings compatible with this method.\n     * Porting Note: TensorFlow.js Layers supports only loading by name currently.\n     *\n     * @param weights A JSON mapping weight names to weight values as nested\n     *   arrays of numbers, or a `NamedTensorMap`, i.e., a JSON mapping weight\n     *   names to `tf.Tensor` objects.\n     * @param strict Require that the provided weights exactly match those\n     *   required by the container.  Default: `true`.  Passing `false` means that\n     *   extra weights and missing weights will be silently ignored.\n     */\n    loadWeights(weights, strict = true) {\n        const nameToWeight = {};\n        let totalWeightsCount = 0;\n        for (const layer of this.layers) {\n            for (const weight of layer.weights) {\n                if (nameToWeight[weight.originalName] != null) {\n                    throw new ValueError(`Duplicate weight name: ${weight.originalName}`);\n                }\n                nameToWeight[weight.originalName] = weight;\n                totalWeightsCount++;\n            }\n        }\n        const weightValueTuples = [];\n        for (const name in weights) {\n            // TF 2.2.0 added cell name to the weight name in the format of\n            // layer_name/cell_name/weight_name, we need to remove\n            // the inner cell name.\n            let validatedName = name;\n            if (nameToWeight[name] == null) {\n                const tokens = name.split('/');\n                const shortenNameArray = tokens.slice(0, -2).concat([tokens[tokens.length - 1]]);\n                validatedName = shortenNameArray.join('/');\n            }\n            if (nameToWeight[validatedName] != null) {\n                weightValueTuples.push([nameToWeight[validatedName], weights[name]]);\n            }\n            else if (strict) {\n                throw new ValueError(`Provided weight data has no target variable: ${name}`);\n            }\n            delete nameToWeight[validatedName];\n        }\n        if (strict) {\n            // Check that all weights are set.\n            const unsetNames = [];\n            for (const name in nameToWeight) {\n                unsetNames.push(name);\n            }\n            if (unsetNames.length > 0) {\n                throw new ValueError(`${unsetNames.length} of ${totalWeightsCount} weights are not set: ` +\n                    `${unsetNames}`);\n            }\n        }\n        batchSetValue(weightValueTuples);\n    }\n    /**\n     * Util shared between different serialization methods.\n     * @returns LayersModel config with Keras version information added.\n     */\n    updatedConfig() {\n        const theConfig = this.getConfig();\n        const modelConfig = {};\n        modelConfig['className'] = this.getClassName();\n        modelConfig['config'] = theConfig;\n        modelConfig['kerasVersion'] = `tfjs-layers ${layersVersion}`;\n        // TODO(nielsene): Replace something like K.backend() once\n        // possible.\n        modelConfig['backend'] = 'TensorFlow.js';\n        return modelConfig;\n    }\n    /**\n     * Returns a JSON string containing the network configuration.\n     *\n     * To load a network from a JSON save file, use\n     * models.modelFromJSON(jsonString);\n     * @param extraJsonArgs Unused in tfjs-layers, maintained for PyKeras\n     * @param returnString Whether the return value should be stringified\n     *    (default: `true`).\n     * @returns a JSON string if `returnString` (default), or a JSON object if\n     *   `!returnString`.\n     */\n    // tslint:disable-next-line:no-any\n    toJSON(unused, returnString = true) {\n        const modelConfig = convertTsToPythonic(this.updatedConfig());\n        return returnString ? JSON.stringify(modelConfig) : modelConfig;\n    }\n    /**\n     * Call the model on new inputs.\n     *\n     * In this case `call` just reapplies all ops in the graph to the new inputs\n     * (e.g. build a new computational graph from the provided inputs).\n     *\n     * @param inputs A tensor or list of tensors.\n     * @param mask A mask or list of masks. A mask can be either a tensor or null\n     *   (no mask).\n     *\n     * @return A tensor if there is a single output, or a list of tensors if there\n     *   are more than one outputs.\n     */\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = generic_utils.toList(inputs);\n            const feedDict = new FeedDict();\n            for (let i = 0; i < this.inputs.length; ++i) {\n                feedDict.add(this.inputs[i], inputs[i]);\n            }\n            return execute(this.outputs, feedDict, kwargs);\n        });\n    }\n    /**\n     * Computes an output mask tensor.\n     *\n     * @param inputs Tensor or list of tensors.\n     * @param mask Tensor or list of tensors.\n     *\n     * @return null or a tensor (or list of tensors, one per output tensor of the\n     * layer).\n     */\n    computeMask(inputs, mask) {\n        return tidy(() => {\n            inputs = generic_utils.toList(inputs);\n            let masks;\n            if (mask == null) {\n                masks = generic_utils.pyListRepeat(null, inputs.length);\n            }\n            else {\n                masks = generic_utils.toList(mask);\n            }\n            // TODO(michaelterry): Add support for mask caching.\n            return this.runInternalGraph(inputs, masks)[1];\n        });\n    }\n    /**\n     * Computes the output shape of the layer.\n     *\n     * Assumes that the layer will be built to match that input shape provided.\n     *\n     * @param inputShape A shape (tuple of integers) or a list of shape tuples\n     *   (one per output tensor of the layer). Shape tuples can include null for\n     *   free dimensions, instead of an integer.\n     */\n    computeOutputShape(inputShape) {\n        const inputShapes = types_utils.normalizeShapeList(inputShape);\n        if (inputShapes.length !== this.inputLayers.length) {\n            throw new ValueError(`Invalid inputShape argument ${inputShape}: ` +\n                `model has ${this.inputLayers.length} tensor inputs.`);\n        }\n        // TODO(michaelterry): Add caching\n        const layersToOutputShapes = {};\n        for (let i = 0; i < inputShapes.length; i++) {\n            const layer = this.inputLayers[i];\n            const inputShape = inputShapes[i];\n            // It's an input layer: computeOutputShape is identity,\n            // and there is only one node and one tensor output.\n            const shapeKey = layer.name + '_0_0';\n            layersToOutputShapes[shapeKey] = inputShape;\n        }\n        const depthKeys = Object.keys(this.nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(generic_utils.reverseNumberCompare);\n        // Iterate over nodes, by depth level.\n        if (depthKeys.length > 1) {\n            for (const depth of depthKeys) {\n                const nodes = this.nodesByDepth[depth];\n                for (const node of nodes) {\n                    // This is always a single layer, never a list.\n                    const layer = node.outboundLayer;\n                    if (this.inputLayers.map(x => x.id).indexOf(layer.id) !== -1) {\n                        // We've already covered the input layers a few lines above.\n                        continue;\n                    }\n                    // Potentially redundant list, same size of node.inputTensors.\n                    const inputShapes = [];\n                    for (let j = 0; j < node.inboundLayers.length; j++) {\n                        const inboundLayer = node.inboundLayers[j];\n                        const nodeIndex = node.nodeIndices[j];\n                        const tensorIndex = node.tensorIndices[j];\n                        const shapeKey = `${inboundLayer.name}_${nodeIndex}_${tensorIndex}`;\n                        const inputShape = layersToOutputShapes[shapeKey];\n                        inputShapes.push(inputShape);\n                    }\n                    const outputShape = layer.computeOutputShape(generic_utils.singletonOrArray(inputShapes));\n                    const outputShapes = types_utils.normalizeShapeList(outputShape);\n                    const nodeIndex = layer.inboundNodes.indexOf(node);\n                    for (let j = 0; j < outputShapes.length; j++) {\n                        const shapeKey = `${layer.name}_${nodeIndex}_${j}`;\n                        layersToOutputShapes[shapeKey] = outputShapes[j];\n                    }\n                }\n            }\n        }\n        // Read final output shapes from layersToOutputShapes.\n        const outputShapes = [];\n        const outputShapeKeys = [];\n        for (let i = 0; i < this.outputLayers.length; i++) {\n            const layer = this.outputLayers[i];\n            const nodeIndex = this.outputLayersNodeIndices[i];\n            const tensorIndex = this.outputLayersTensorIndices[i];\n            const shapeKey = `${layer.name}_${nodeIndex}_${tensorIndex}`;\n            outputShapeKeys.push(shapeKey);\n        }\n        for (let i = 0; i < outputShapeKeys.length; i++) {\n            const key = outputShapeKeys[i];\n            generic_utils.assert(key in layersToOutputShapes);\n            outputShapes.push(layersToOutputShapes[key]);\n        }\n        // TODO(michaelterry): Update cache\n        return generic_utils.singletonOrArray(outputShapes);\n    }\n    /**\n     * Computes output tensors for new inputs.\n     *\n     * Note:\n     *   - Expects `inputs` to be a list (potentially with 1 element).\n     *\n     * @param inputs List of tensors\n     * @param masks List of masks (tensors or null).\n     * @return Three lists: outputTensors, outputMasks, outputShapes\n     */\n    runInternalGraph(inputs, masks) {\n        if (masks == null) {\n            masks = generic_utils.pyListRepeat(null, inputs.length);\n        }\n        // Dictionary mapping reference tensors to tuples\n        // (computed tensor, compute mask)\n        // we assume a 1:1 mapping from tensor to mask\n        // TODO: raise exception when a `.computeMask()` call\n        // does not return a list the same size as `call`\n        const tensorMap = {};\n        for (let i = 0; i < this.inputs.length; ++i) {\n            const x = this.inputs[i];\n            const y = inputs[i];\n            const mask = masks[i];\n            tensorMap[x.id] = [y, mask];\n        }\n        const depthKeys = Object.keys(this.nodesByDepth)\n            .map(x => parseInt(x, 10))\n            .sort(generic_utils.reverseNumberCompare);\n        for (const depth of depthKeys) {\n            const nodes = this.nodesByDepth[depth];\n            for (const node of nodes) {\n                // This is always a single layer, never a list.\n                const layer = node.outboundLayer;\n                const referenceInputTensors = node.inputTensors;\n                const referenceOutputTensors = node.outputTensors;\n                // If all previous input tensors are available in tensorMap,\n                // then call node.inboundLayer on them.\n                // List of tuples [input, mask]:\n                const computedData = new Array();\n                for (const x of referenceInputTensors) {\n                    if (x.id in tensorMap) {\n                        computedData.push(tensorMap[x.id]);\n                    }\n                }\n                if (computedData.length === referenceInputTensors.length) {\n                    // TODO(michaelterry): Add K.name_scope here, if we need it.\n                    let kwargs = {};\n                    let computedTensors;\n                    let computedMasks;\n                    let outputTensors;\n                    let outputMasks;\n                    // call layer\n                    if (node.callArgs != null) {\n                        kwargs = node.callArgs;\n                    }\n                    if (computedData.length === 1) {\n                        const [computedTensor, computedMask] = computedData[0];\n                        if (kwargs['mask'] == null) {\n                            kwargs['mask'] = computedMask;\n                        }\n                        outputTensors =\n                            generic_utils.toList(layer.call(computedTensor, kwargs));\n                        outputMasks = generic_utils.toList(layer.computeMask(computedTensor, computedMask));\n                        computedTensors = [computedTensor];\n                        computedMasks = [computedMask];\n                    }\n                    else {\n                        computedTensors = computedData.map(x => x[0]);\n                        computedMasks = computedData.map(x => x[1]);\n                        if (kwargs['mask'] == null) {\n                            kwargs['mask'] = computedMasks;\n                        }\n                        outputTensors =\n                            generic_utils.toList(layer.call(computedTensors, kwargs));\n                        outputMasks = generic_utils.toList(layer.computeMask(computedTensors, computedMasks));\n                    }\n                    if (layer.activityRegularizer) {\n                        throw new NotImplementedError('LayersModel invocation with concrete Tensor value(s) in the ' +\n                            'presence of activity regularizer(s) is not supported yet.');\n                    }\n                    // TODO(michaelterry): Add model updates and losses\n                    // Update tensor map.\n                    for (let i = 0; i < referenceOutputTensors.length; ++i) {\n                        const x = referenceOutputTensors[i];\n                        const y = outputTensors[i];\n                        const mask = outputMasks[i];\n                        tensorMap[x.id] = [y, mask];\n                    }\n                }\n            }\n        }\n        const outputTensors = [];\n        const outputMasks = [];\n        const outputShapes = [];\n        for (const x of this.outputs) {\n            generic_utils.assert(x.id in tensorMap, `Could not compute output ${x.name} : ${x.id}`);\n            const [tensor, mask] = tensorMap[x.id];\n            outputShapes.push(tensor.shape);\n            outputTensors.push(tensor);\n            outputMasks.push(mask);\n        }\n        // TODO(michaelterry): Add support for caches.\n        return [outputTensors, outputMasks, outputShapes];\n    }\n    /**\n     * Builds a map of internal node keys to node ordering.\n     * Used in serializaion a node orderings may change as unused nodes are\n     * dropped. Porting Note:  This helper method was pulled out of getConfig to\n     * improve readability.\n     * @param layers An array of Layers in the model.\n     * @returns Map of Node Keys to index order within the layer.\n     */\n    buildNodeConversionMap(layers) {\n        const nodeConversionMap = {};\n        let keptNodes;\n        for (const layer of this.layers) {\n            keptNodes = layer instanceof Container ? 1 : 0;\n            for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {\n                const nodeKey = Container.nodeKey(layer, originalNodeIndex);\n                if (this.containerNodes.has(nodeKey)) {\n                    // i.e. we mark it to be saved\n                    nodeConversionMap[nodeKey] = keptNodes;\n                    keptNodes += 1;\n                }\n            }\n        }\n        return nodeConversionMap;\n    }\n    /**\n     * Retrieves a layer based on either its name (unique) or index.\n     *\n     * Indices are based on order of horizontal graph traversal (bottom-up).\n     *\n     * If both `name` and `index` are specified, `index` takes precedence.\n     *\n     * @param name Name of layer.\n     * @param index Index of layer.\n     * @returns A Layer instance.\n     * @throws ValueError: In case of invalid layer name or index.\n     *\n     * @doc {\n     *    heading: 'Layers',\n     *    subheading: 'Classes',\n     *    namespace: 'layers',\n     *    subclasses: ['LayersModel']\n     * }\n     */\n    getLayer(name, index) {\n        if (index != null) {\n            if (this.layers.length <= index) {\n                throw new ValueError(`Was asked to retrieve layer at index ${index}, but model only ` +\n                    `has ${this.layers.length} layer(s).`);\n            }\n            else {\n                return this.layers[index];\n            }\n        }\n        else {\n            if (name == null) {\n                throw new ValueError('Provide either a layer name or layer index');\n            }\n        }\n        for (const layer of this.layers) {\n            if (layer.name === name) {\n                return layer;\n            }\n        }\n        throw new ValueError(`No such layer: ${name}`);\n    }\n    /**\n     * Retrieves the Container's current loss values.\n     *\n     * Used for regularizers during training.\n     */\n    calculateLosses() {\n        // Porting Node: This is an augmentation to Container.loss in PyKeras.\n        //   In PyKeras, Container.loss returns symbolic tensors. Here a concrete\n        //   Tensor (specifically Scalar) values are returned. This is due to the\n        //   imperative backend.\n        return tidy(() => {\n            const losses = [];\n            for (const layer of this.layers) {\n                for (let nodeIndex = 0; nodeIndex < layer.inboundNodes.length; ++nodeIndex) {\n                    const nodeKey = Container.nodeKey(layer, nodeIndex);\n                    if (this.containerNodes.has(nodeKey)) {\n                        losses.push(...layer.calculateLosses());\n                    }\n                }\n            }\n            // TODO(cais): Add any unconditional model-level losses?\n            return losses;\n        });\n    }\n    getConfig() {\n        const config = { name: this.name };\n        // Build a map from layer unique name (self._node_key)\n        // to the index of the nodes that are saved in the config.\n        // Only nodes in container_nodes are saved.\n        const nodeConversionMap = this.buildNodeConversionMap(this.layers);\n        // Serialize and save the layers in layerConfigs\n        const layerConfigs = [];\n        for (const layer of this.layers) {\n            const layerClassName = layer.getClassName();\n            const layerConfig = layer.getConfig();\n            const filteredInboundNodes = [];\n            for (let originalNodeIndex = 0; originalNodeIndex < layer.inboundNodes.length; originalNodeIndex++) {\n                const node = layer.inboundNodes[originalNodeIndex];\n                const nodeKey = Container.nodeKey(layer, originalNodeIndex);\n                let kwargs = {};\n                if (this.containerNodes.has(nodeKey)) {\n                    // The node is relevant to the model:\n                    // add to filteredInboundNodes.\n                    if (node.callArgs) {\n                        try {\n                            JSON.stringify(node.callArgs);\n                            kwargs = node.callArgs;\n                        }\n                        catch (err) {\n                            console.warn(`Layer ${layer.name} was passed ` +\n                                `non-serializable keyword arguments: ` +\n                                `${node.callArgs}. They will not be included ` +\n                                `in the serialized model (and thus will be ` +\n                                `missing at deserialization time).`);\n                            kwargs = {};\n                        }\n                    }\n                    if (node.inboundLayers.length > 0) {\n                        const nodeData = [];\n                        for (let i = 0; i < node.inboundLayers.length; i++) {\n                            const inboundLayer = node.inboundLayers[i];\n                            const nodeIndex = node.nodeIndices[i];\n                            const tensorIndex = node.tensorIndices[i];\n                            const nodeKey = Container.nodeKey(inboundLayer, nodeIndex);\n                            let newNodeIndex = nodeConversionMap[nodeKey];\n                            if (newNodeIndex == null) {\n                                newNodeIndex = 0;\n                            }\n                            nodeData.push([inboundLayer.name, newNodeIndex, tensorIndex, kwargs]);\n                        }\n                        filteredInboundNodes.push(nodeData);\n                    }\n                }\n            }\n            const dict = {};\n            dict['name'] = layer.name;\n            dict['className'] = layerClassName;\n            dict['config'] = layerConfig;\n            dict['inboundNodes'] = filteredInboundNodes;\n            layerConfigs.push(dict);\n        }\n        config['layers'] = layerConfigs;\n        // Gather info about inputs and outputs\n        const modelInputs = [];\n        for (let i = 0; i < this.inputLayers.length; i++) {\n            const layer = this.inputLayers[i];\n            const nodeIndex = this.inputLayersNodeIndices[i];\n            const nodeKey = Container.nodeKey(layer, nodeIndex);\n            if (!this.containerNodes.has(nodeKey)) {\n                continue;\n            }\n            let newNodeIndex = nodeConversionMap[nodeKey];\n            if (newNodeIndex === null || newNodeIndex === undefined) {\n                newNodeIndex = 0;\n            }\n            const tensorIndex = this.inputLayersTensorIndices[i];\n            modelInputs.push([layer.name, newNodeIndex, tensorIndex]);\n        }\n        config['inputLayers'] = modelInputs;\n        const modelOutputs = [];\n        for (let i = 0; i < this.outputLayers.length; i++) {\n            const layer = this.outputLayers[i];\n            const nodeIndex = this.outputLayersNodeIndices[i];\n            const nodeKey = Container.nodeKey(layer, nodeIndex);\n            if (!this.containerNodes.has(nodeKey)) {\n                continue;\n            }\n            let newNodeIndex = nodeConversionMap[nodeKey];\n            if (newNodeIndex === null || newNodeIndex === undefined) {\n                newNodeIndex = 0;\n            }\n            const tensorIndex = this.outputLayersTensorIndices[i];\n            modelOutputs.push([layer.name, newNodeIndex, tensorIndex]);\n        }\n        config['outputLayers'] = modelOutputs;\n        return config;\n    }\n    /**\n     * Instantiates a LayersModel from its config (output of `get_config()`).\n     * @param cls the class to create\n     * @param config LayersModel config dictionary.\n     * @param customObjects An optional dictionary of custom objects.\n     * @param fastWeightInit Optional flag to use fast weight initialization\n     *   during deserialization. This is applicable to cases in which\n     *   the initialization will be immediately overwritten by loaded weight\n     *   values. Default: `false`.\n     * @returns A LayersModel instance.\n     * @throws ValueError: In case of improperly formatted config dict.\n     */\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n        // Layer instances created during\n        // the graph reconstruction process\n        const createdLayers = {};\n        // Dictionary mapping layer instances to\n        // node data that specifies a layer call.\n        // It acts as a queue that maintains any unprocessed\n        // layer call until it becomes possible to process it\n        // (i.e. until the input tensors to the call all exist).\n        const unprocessedNodes = {};\n        function addUnprocessedNode(layer, nodeData) {\n            if (!(layer.name in unprocessedNodes)) {\n                unprocessedNodes[layer.name] = [nodeData];\n            }\n            else {\n                unprocessedNodes[layer.name].push(nodeData);\n            }\n        }\n        function processNode(layer, nodeData) {\n            const inputTensors = [];\n            let kwargs;\n            for (const inputData of nodeData) {\n                const inboundLayerName = inputData[0];\n                const inboundNodeIndex = inputData[1];\n                const inboundTensorIndex = inputData[2];\n                kwargs = inputData[3] == null ?\n                    {} :\n                    inputData[3];\n                if (!(inboundLayerName in createdLayers)) {\n                    addUnprocessedNode(layer, nodeData);\n                    return;\n                }\n                const inboundLayer = createdLayers[inboundLayerName];\n                if (inboundLayer.inboundNodes.length <= inboundNodeIndex) {\n                    addUnprocessedNode(layer, nodeData);\n                    return;\n                }\n                const inboundNode = inboundLayer.inboundNodes[inboundNodeIndex];\n                inputTensors.push(inboundNode.outputTensors[inboundTensorIndex]);\n            }\n            // Call layer on its inputs, thus creating the node\n            // and building the layer if needed.\n            // Note: This has Eager vs Graph Implications.\n            if (inputTensors.length > 0) {\n                layer.apply(generic_utils.singletonOrArray(inputTensors), kwargs); // was ** kwargs\n            }\n        }\n        /**\n         * Deserialize a layer, then call it on appropriate inputs.\n         * @param layerData: layer config dict.\n         * @throws ValueError: In case of improperly formatted `layer_data`\n         * dict.\n         */\n        function processLayer(layerData) {\n            const layerName = layerData['name'];\n            // Instantiate layer.\n            const layer = deserializeLayer(layerData, config['customObjects'] != null ?\n                config['customObjects'] :\n                {});\n            layer.setFastWeightInitDuringBuild(fastWeightInit);\n            createdLayers[layerName] = layer;\n            // Gather layer inputs.\n            const inboundNodesData = layerData['inboundNodes'];\n            inboundNodesData.forEach(nodeData => {\n                if (!(nodeData instanceof Array)) {\n                    throw new ValueError(`Corrupted configuration, expected array for nodeData: ${nodeData}`);\n                }\n                // We don't process nodes (i.e. make layer calls)\n                // on the fly because the inbound node may not yet exist,\n                // in case of layer shared at different topological depths\n                // (e.g.a model such as A(B(A(B(x)))))\n                addUnprocessedNode(layer, nodeData);\n            });\n        }\n        // First, we create all layers and enqueue nodes to be processed.\n        const name = config['name'];\n        const layersFromConfig = config['layers'];\n        for (const layerData of layersFromConfig) {\n            processLayer(layerData);\n        }\n        // Then we process nodes in order of layer depth.\n        // Nodes that cannot yet be processed(if the inbound node\n        // does not yet exist) are re - enqueued, and the process\n        // is repeated until all nodes are processed.\n        while (!generic_utils.isObjectEmpty(unprocessedNodes)) {\n            for (const layerData of layersFromConfig) {\n                const layer = createdLayers[layerData['name']];\n                if (layer.name in unprocessedNodes) {\n                    const currentUnprocessedNodesForLayer = unprocessedNodes[layer.name];\n                    delete unprocessedNodes[layer.name];\n                    for (const nodeData of currentUnprocessedNodesForLayer) {\n                        processNode(layer, nodeData);\n                    }\n                }\n            }\n        }\n        const inputTensors = [];\n        const outputTensors = [];\n        const inputLayersFromConfig = config['inputLayers'];\n        for (const layerData of inputLayersFromConfig) {\n            const layerName = layerData[0];\n            const nodeIndex = layerData[1];\n            const tensorIndex = layerData[2];\n            generic_utils.assert(layerName in createdLayers);\n            const layer = createdLayers[layerName];\n            const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;\n            inputTensors.push(layerOutputTensors[tensorIndex]);\n        }\n        const outputLayersFromConfig = config['outputLayers'];\n        for (const layerData of outputLayersFromConfig) {\n            const layerName = layerData[0];\n            const nodeIndex = layerData[1];\n            const tensorIndex = layerData[2];\n            generic_utils.assert(layerName in createdLayers);\n            const layer = createdLayers[layerName];\n            const layerOutputTensors = layer.inboundNodes[nodeIndex].outputTensors;\n            outputTensors.push(layerOutputTensors[tensorIndex]);\n        }\n        return new cls({ inputs: inputTensors, outputs: outputTensors, name });\n    }\n    /**\n     * Determine whether the container is stateful.\n     *\n     * Porting Note: this is the equivalent of the stateful @property of\n     *   the Container class in PyKeras.\n     */\n    get stateful() {\n        // Porting Note: This check is to prevent inadvertent setting of the\n        //   _stateful property of the Container instance.\n        if (this._stateful) {\n            throw new ValueError('Container instance unexpectedly has _stateful = true. The ' +\n                'statefulness of a Container is determined by the Layers it ' +\n                'contains. Its _stateful property must remain the default false.');\n        }\n        for (const layer of this.layers) {\n            if (layer.stateful) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Reset the state of all stateful constituent layers (if any).\n     *\n     * Examples of stateful layers include RNN layers whose `stateful` property\n     * is set as `true`.\n     */\n    resetStates() {\n        tidy(() => {\n            this.layers.forEach(layer => {\n                // tslint:disable:no-any\n                if (layer.stateful) {\n                    layer.resetStates();\n                }\n                // tslint:enable:no-any\n            });\n        });\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGFpbmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2VuZ2luZS9jb250YWluZXIudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFFSCwrQ0FBK0M7QUFFL0MsT0FBTyxFQUFnRCxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUxRixPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sa0JBQWtCLENBQUM7QUFDeEMsT0FBTyxFQUFDLG1CQUFtQixFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFJeEUsT0FBTyxFQUFDLFdBQVcsSUFBSSxnQkFBZ0IsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBRXhFLE9BQU8sS0FBSyxhQUFhLE1BQU0sd0JBQXdCLENBQUM7QUFDeEQsT0FBTyxFQUFDLG1CQUFtQixFQUFDLE1BQU0sOEJBQThCLENBQUM7QUFDakUsT0FBTyxLQUFLLFdBQVcsTUFBTSxzQkFBc0IsQ0FBQztBQUNwRCxPQUFPLEVBQUMsYUFBYSxFQUFnQixNQUFNLGNBQWMsQ0FBQztBQUMxRCxPQUFPLEVBQUMsT0FBTyxJQUFJLGFBQWEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUVwRCxPQUFPLEVBQUMsT0FBTyxFQUFFLFFBQVEsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUM3QyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQ3pDLE9BQU8sRUFBZ0IsS0FBSyxFQUFFLElBQUksRUFBaUIsTUFBTSxZQUFZLENBQUM7QUFTdEU7Ozs7OztHQU1HO0FBQ0gsTUFBTSxPQUFnQixTQUFVLFNBQVEsS0FBSztJQW9DM0MsWUFBWSxJQUFtQjtRQUM3Qix5Q0FBeUM7UUFDekMsS0FBSyxDQUFDLEVBQUUsQ0FBQyxDQUFDO1FBcEJaLG1CQUFjLEdBQUcsSUFBSSxHQUFHLEVBQVUsQ0FBQztRQXFCakMsSUFBSSxDQUFDLElB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Z2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyogT3JpZ2luYWwgc291cmNlOiBrZXJhcy9lbmdpbmUvdG9wb2xvZ3kucHkgKi9cblxuaW1wb3J0IHtOYW1lZFRlbnNvck1hcCwgU2NhbGFyLCBzZXJpYWxpemF0aW9uLCBUZW5zb3IsIHRpZHl9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuLi9iYWNrZW5kL3N0YXRlJztcbmltcG9ydCB7Tm90SW1wbGVtZW50ZWRFcnJvciwgUnVudGltZUVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge1RlbnNvcktleVdpdGhBcmdzQXJyYXl9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9ub2RlX2NvbmZpZyc7XG5pbXBvcnQge1B5SnNvbkRpY3R9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC90eXBlcyc7XG5pbXBvcnQge2Rlc2VyaWFsaXplIGFzIGRlc2VyaWFsaXplTGF5ZXJ9IGZyb20gJy4uL2xheWVycy9zZXJpYWxpemF0aW9uJztcbmltcG9ydCB7S3dhcmdzfSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyBnZW5lcmljX3V0aWxzIGZyb20gJy4uL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuaW1wb3J0IHtjb252ZXJ0VHNUb1B5dGhvbmljfSBmcm9tICcuLi91dGlscy9zZXJpYWxpemF0aW9uX3V0aWxzJztcbmltcG9ydCAqIGFzIHR5cGVzX3V0aWxzIGZyb20gJy4uL3V0aWxzL3R5cGVzX3V0aWxzJztcbmltcG9ydCB7YmF0Y2hTZXRWYWx1ZSwgTGF5ZXJWYXJpYWJsZX0gZnJvbSAnLi4vdmFyaWFibGVzJztcbmltcG9ydCB7dmVyc2lvbiBhcyBsYXllcnNWZXJzaW9ufSBmcm9tICcuLi92ZXJzaW9uJztcblxuaW1wb3J0IHtleGVjdXRlLCBGZWVkRGljdH0gZnJvbSAnLi9leGVjdXRvcic7XG5pbXBvcnQge0lucHV0TGF5ZXJ9IGZyb20gJy4vaW5wdXRfbGF5ZXInO1xuaW1wb3J0IHtEaXNwb3NlUmVzdWx0LCBMYXllciwgTm9kZSwgU3ltYm9saWNUZW5zb3J9IGZyb20gJy4vdG9wb2xvZ3knO1xuXG4vKiogQ29uc3RydWN0b3IgY29uZmlnIGZvciBDb250YWluZXIuICovXG5leHBvcnQgaW50ZXJmYWNlIENvbnRhaW5lckFyZ3Mge1xuICBpbnB1dHM6IFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW107XG4gIG91dHB1dHM6IFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW107XG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBDb250YWluZXIgaXMgYSBkaXJlY3RlZCBhY3ljbGljIGdyYXBoIG9mIGxheWVycy5cbiAqXG4gKiBJdCBpcyB0aGUgdG9wb2xvZ2ljYWwgZm9ybSBvZiBhIFwibW9kZWxcIi4gQSBMYXllcnNNb2RlbFxuICogaXMgc2ltcGx5IGEgQ29udGFpbmVyIHdpdGggYWRkZWQgdHJhaW5pbmcgcm91dGluZXMuXG4gKlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQ29udGFpbmVyIGV4dGVuZHMgTGF5ZXIge1xuICBpbnB1dHM6IFN5bWJvbGljVGVuc29yW107XG4gIG91dHB1dHM6IFN5bWJvbGljVGVuc29yW107XG5cbiAgaW5wdXRMYXllcnM6IExheWVyW107XG4gIGlucHV0TGF5ZXJzTm9kZUluZGljZXM6IG51bWJlcltdO1xuICBpbnB1dExheWVyc1RlbnNvckluZGljZXM6IG51bWJlcltdO1xuXG4gIG91dHB1dExheWVyczogTGF5ZXJbXTtcbiAgb3V0cHV0TGF5ZXJzTm9kZUluZGljZXM6IG51bWJlcltdO1xuICBvdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzOiBudW1iZXJbXTtcblxuICBsYXllcnM6IExheWVyW107XG4gIGxheWVyc0J5RGVwdGg6IHtbZGVwdGg6IHN0cmluZ106IExheWVyW119O1xuICBub2Rlc0J5RGVwdGg6IHtbZGVwdGg6IHN0cmluZ106IE5vZGVbXX07XG5cbiAgaW50ZXJuYWxDb250YWluZXJSZWZzOiBDb250YWluZXJbXTtcblxuICBjb250YWluZXJOb2RlcyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuXG4gIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIGNhY2hlIHN1cHBvcnRcbiAgLy8gcHJpdmF0ZSBvdXRwdXRNYXNrQ2FjaGU6IGFueTtcbiAgLy8gcHJpdmF0ZSBvdXRwdXRUZW5zb3JDYWNoZTogYW55O1xuICAvLyBwcml2YXRlIG91dHB1dFNoYXBlQ2FjaGU6IGFueTtcblxuICBpbnB1dE5hbWVzOiBzdHJpbmdbXTtcbiAgb3V0cHV0TmFtZXM6IHN0cmluZ1tdO1xuICBmZWVkSW5wdXRTaGFwZXM6IFNoYXBlW107XG5cbiAgcHJvdGVjdGVkIGludGVybmFsSW5wdXRTaGFwZXM6IFNoYXBlW107XG4gIHByb3RlY3RlZCBpbnRlcm5hbE91dHB1dFNoYXBlczogU2hhcGVbXTtcbiAgLy8gVE9ETyhjYWlzKTogTWF5YmUgJ2ZlZWQnIHNob3VsZCBub3QgaW4gdGhlIG5hbWVzIG9mIHRoZXNlIHZhcmlhYmxlcyxcbiAgLy8gICBkdWUgdG8gdGhlIGZhY3QgdGhhdCBvdXIgYmFja2VuZCBpcyBub3Qgc3ltYm9saWMuXG4gIHByb3RlY3RlZCBmZWVkSW5wdXROYW1lczogc3RyaW5nW107XG4gIHByb3RlY3RlZCBmZWVkT3V0cHV0TmFtZXM6IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IENvbnRhaW5lckFyZ3MpIHtcbiAgICAvLyBObyBhcmdzIHBhc3NlZCB0byBzdXBlcidzIGNvbnN0cnVjdG9yLlxuICAgIHN1cGVyKHt9KTtcbiAgICB0aGlzLm5hbWUgPSBhcmdzLm5hbWU7XG4gICAgaWYgKHRoaXMubmFtZSA9PSBudWxsKSB7XG4gICAgICBjb25zdCBwcmVmaXggPSB0aGlzLmdldENsYXNzTmFtZSgpLnRvTG93ZXJDYXNlKCk7XG4gICAgICB0aGlzLm5hbWUgPSBnZXRVaWQocHJlZml4KTtcbiAgICB9XG5cbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IGZhbHNlO1xuICAgIHRoaXMudHJhaW5hYmxlXyA9IHRydWU7XG5cbiAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IEluaXRpYWxpemUgcGVySW5wdXRMb3NzZXMvVXBkYXRlcyBoZXJlLlxuXG4gICAgLy8gQ29udGFpbmVyLXNwZWNpZmljIHByb3BlcnRpZXMuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncy5pbnB1dHMpKSB7XG4gICAgICB0aGlzLmlucHV0cyA9IGFyZ3MuaW5wdXRzLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuaW5wdXRzID0gW2FyZ3MuaW5wdXRzXTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncy5vdXRwdXRzKSkge1xuICAgICAgdGhpcy5vdXRwdXRzID0gYXJncy5vdXRwdXRzLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMub3V0cHV0cyA9IFthcmdzLm91dHB1dHNdO1xuICAgIH1cblxuICAgIC8vIENoZWNrIGZvciByZWR1bmRhbmN5IGluIGlucHV0cy5cbiAgICBpZiAoZ2VuZXJpY191dGlscy51bmlxdWUodGhpcy5pbnB1dHMpLmxlbmd0aCAhPT0gdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnVGhlIGxpc3Qgb2YgaW5wdXRzIHBhc3NlZCB0byB0aGUgbW9kZWwgaXMgJyArXG4gICAgICAgICAgJ3JlZHVuZGFudC4gQWxsIGlucHV0cyBzaG91bGQgb25seSBhcHBlYXIgb25jZS4gRm91bmQ6ICcgK1xuICAgICAgICAgIGAke3RoaXMuaW5wdXRzLm1hcCh4ID0+IHgubmFtZSl9YCk7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIHJlZHVuZGFuY3kgaW4gb3V0cHV0cy5cbiAgICBpZiAoZ2VuZXJpY191dGlscy51bmlxdWUodGhpcy5vdXRwdXRzKS5sZW5ndGggIT09IHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnVGhlIGxpc3Qgb2Ygb3V0cHV0cyBwYXNzZWQgdG8gdGhlIG1vZGVsIGlzIHJlZHVuZGFudC4gJyArXG4gICAgICAgICAgJ0FsbCBvdXRwdXRzIHNob3VsZCBvbmx5IGFwcGVhciBvbmNlLiBGb3VuZDogJyArXG4gICAgICAgICAgYCR7dGhpcy5vdXRwdXRzLm1hcCh4ID0+IHgubmFtZSl9YCk7XG4gICAgfVxuXG4gICAgLypcbiAgICAgIExpc3Qgb2YgaW5pdGlhbCBsYXllcnMgKDEgdG8gMSBtYXBwaW5nIHdpdGggdGhpcy5pbnB1dHMsIGhlbmNlIHRoZSBzYW1lXG4gICAgICBsYXllciBtaWdodCBhcHBlYXIgdHdpY2UpXG4gICAgKi9cbiAgICB0aGlzLmlucHV0TGF5ZXJzID0gW107XG4gICAgdGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzID0gW107XG4gICAgdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXMgPSBbXTtcbiAgICAvKlxuICAgICAgTGlzdCBvZiBsYXllcnMgKDEgdG8gMSBtYXBwaW5nIHdpdGggdGhpcy5vdXRwdXRzLCBoZW5jZSB0aGUgc2FtZSBsYXllclxuICAgICAgbWlnaHQgYXBwZWFyIHR3aWNlKVxuICAgICovXG4gICAgdGhpcy5vdXRwdXRMYXllcnMgPSBbXTtcbiAgICB0aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzID0gW107XG4gICAgdGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzID0gW107XG4gICAgLypcbiAgICAgIEFsbCBsYXllcnMgaW4gb3JkZXIgb2YgaG9yaXpvbnRhbCBncmFwaCB0cmF2ZXJzYWwuIEVudHJpZXMgYXJlIHVuaXF1ZS5cbiAgICAgIEluY2x1ZGVzIGlucHV0IGFuZCBvdXRwdXQgbGF5ZXJzLlxuICAgICovXG4gICAgdGhpcy5sYXllcnMgPSBbXTtcblxuICAgIC8qXG4gICAgICBSZWZlcmVuY2VzIHRvIGNvbnRhaW5lciBsYXllcnMgdGhhdCB3ZXJlIGNvbnN0cnVjdGVkIGludGVybmFsbHkuIFdlIG5lZWRcbiAgICAgIHRoZXNlIHRvIHByb3Blcmx5IGRpc3Bvc2Ugb2YgdGVuc29ycyBmcm9tIG5lc3RlZCBjb250YWluZXJzLlxuICAgICovXG4gICAgdGhpcy5pbnRlcm5hbENvbnRhaW5lclJlZnMgPSBbXTtcblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogRGV0ZXJtaW5lIGlmIGNhY2hpbmcgc3RpbGwgbmVlZGVkIHdpdGggZWFnZXJcbiAgICAvLyBiYWNrZW5kLlxuICAgIC8qXG4gICAgICBUaGlzIGlzIGZvciBwZXJmb3JtYW5jZSBvcHRpbWl6YXRpb24gd2hlbiBjYWxsaW5nIHRoZSBDb250YWluZXIgb24gbmV3XG4gICAgICBpbnB1dHMuIEV2ZXJ5IHRpbWUgdGhlIENvbnRhaW5lciBpcyBjYWxsZWQgb24gYSBzZXQgb24gaW5wdXQgdGVuc29ycyxcbiAgICAgIHdlIGNvbXB1dGUgdGhlIG91dHB1dCB0ZW5zb3JzLCBvdXRwdXQgbWFza3MgYW5kIG91dHB1dCBzaGFwZXMgaW4gb25lIHBhc3MsXG4gICAgICB0aGVuIGNhY2hlIHRoZW0gaGVyZS4gV2hlbiBvbmUgb2YgdGhlc2Ugb3V0cHV0cyBpcyBxdWVyaWVkIGxhdGVyLFxuICAgICAgd2UgcmV0cmlldmUgaXQgZnJvbSB0aGVyZSBpbnN0ZWFkIG9mIHJlY29tcHV0aW5nIGl0LlxuICAgICovXG4gICAgLy8gdGhpcy5vdXRwdXRUZW5zb3JDYWNoZSA9IHt9O1xuICAgIC8vIHRoaXMub3V0cHV0U2hhcGVDYWNoZSA9IHt9O1xuXG4gICAgLy8gQnVpbGQgdGhpcy5vdXRwdXRMYXllcnM6XG4gICAgZm9yIChjb25zdCB4IG9mIHRoaXMub3V0cHV0cykge1xuICAgICAgY29uc3QgbGF5ZXIgPSB4LnNvdXJjZUxheWVyO1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0geC5ub2RlSW5kZXg7XG4gICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IHgudGVuc29ySW5kZXg7XG4gICAgICB0aGlzLm91dHB1dExheWVycy5wdXNoKGxheWVyKTtcbiAgICAgIHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMucHVzaChub2RlSW5kZXgpO1xuICAgICAgdGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzLnB1c2godGVuc29ySW5kZXgpO1xuICAgIH1cblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIG91dHB1dCBtYXNrIGNhY2hlIGNvZGUuXG5cbiAgICAvLyBCdWlsZCB0aGlzLmlucHV0TGF5ZXJzOlxuICAgIGZvciAoY29uc3QgeCBvZiB0aGlzLmlucHV0cykge1xuICAgICAgY29uc3QgbGF5ZXIgPSB4LnNvdXJjZUxheWVyO1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0geC5ub2RlSW5kZXg7XG4gICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IHgudGVuc29ySW5kZXg7XG4gICAgICAvKlxuICAgICAgICBJdCdzIHN1cHBvc2VkIHRvIGJlIGFuIGlucHV0IGxheWVyLCBzbyBvbmx5IG9uZSBub2RlXG4gICAgICAgIGFuZCBvbmUgdGVuc29yIG91dHB1dC5cbiAgICAgICovXG4gICAgICBnZW5lcmljX3V0aWxzLmFzc2VydChub2RlSW5kZXggPT09IDAsICdpbnB1dCBsYXllciBoYXMgPjEgbm9kZXMnKTtcbiAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KHRlbnNvckluZGV4ID09PSAwLCAnaW5wdXQgbGF5ZXIgaGFzID4xIHRlbnNvcnMnKTtcbiAgICAgIHRoaXMuaW5wdXRMYXllcnMucHVzaChsYXllcik7XG4gICAgICB0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXMucHVzaChub2RlSW5kZXgpO1xuICAgICAgdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXMucHVzaCh0ZW5zb3JJbmRleCk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgdGhpcy5pbnB1dE5hbWVzIGFuZCB0aGlzLm91dHB1dE5hbWVzLlxuICAgIHRoaXMuaW5wdXROYW1lcyA9IFtdO1xuICAgIHRoaXMub3V0cHV0TmFtZXMgPSBbXTtcbiAgICB0aGlzLmZlZWRJbnB1dFNoYXBlcyA9IFtdO1xuICAgIHRoaXMuZmVlZElucHV0TmFtZXMgPSBbXTtcbiAgICB0aGlzLmZlZWRPdXRwdXROYW1lcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnB1dExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmlucHV0TGF5ZXJzW2ldO1xuICAgICAgLy8gQ2hlY2sgdGhhdCBsYXllciBpcyBhbiBJbnB1dExheWVyLlxuICAgICAgaWYgKCEobGF5ZXIgaW5zdGFuY2VvZiBJbnB1dExheWVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0lucHV0IGxheWVycyB0byBhIExheWVyc01vZGVsIG11c3QgYmUgSW5wdXRMYXllciBvYmplY3RzLiAnICtcbiAgICAgICAgICAgIGBSZWNlaXZlZCBpbnB1dHM6ICR7YXJncy5pbnB1dHN9LiBgICtcbiAgICAgICAgICAgIGBJbnB1dCAke2l9ICgwLWJhc2VkKSBvcmlnaW5hdGVzIGAgK1xuICAgICAgICAgICAgYGZyb20gbGF5ZXIgdHlwZSAke2xheWVyLmdldENsYXNzTmFtZSgpfS5gKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuaW5wdXROYW1lcy5wdXNoKGxheWVyLm5hbWUpO1xuICAgICAgdGhpcy5mZWVkSW5wdXRTaGFwZXMucHVzaChsYXllci5iYXRjaElucHV0U2hhcGUpO1xuXG4gICAgICB0aGlzLmZlZWRJbnB1dE5hbWVzLnB1c2gobGF5ZXIubmFtZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5vdXRwdXRMYXllcnMpIHtcbiAgICAgIHRoaXMub3V0cHV0TmFtZXMucHVzaChsYXllci5uYW1lKTtcbiAgICB9XG5cbiAgICB0aGlzLmludGVybmFsSW5wdXRTaGFwZXMgPSB0aGlzLmlucHV0cy5tYXAoeCA9PiB4LnNoYXBlKTtcbiAgICB0aGlzLmludGVybmFsT3V0cHV0U2hhcGVzID0gdGhpcy5vdXRwdXRzLm1hcCh4ID0+IHguc2hhcGUpO1xuXG4gICAgLypcbiAgICAgIENvbnRhaW5lcl9ub2Rlczogc2V0IG9mIG5vZGVzIGluY2x1ZGVkIGluIHRoZSBncmFwaCAobm90IGFsbCBub2Rlc1xuICAgICAgaW5jbHVkZWQgaW4gdGhlIGxheWVycyBhcmUgcmVsZXZhbnQgdG8gdGhlIGN1cnJlbnQgZ3JhcGgpLlxuICAgICovXG4gICAgLy8gaWRzIG9mIGFsbCBub2RlcyByZWxldmFudCB0byB0aGUgQ29udGFpbmVyOlxuICAgIGNvbnN0IG5vZGVzRGVwdGhzOiB7W25vZGVJRDogc3RyaW5nXTogbnVtYmVyfSA9IHt9O1xuICAgIC8vIFRvIHJlY292ZXIgbm9kZXMgZnJvbSB0aGVpciBJRC5cbiAgICBjb25zdCBub2RlSURUb05vZGU6IHtbbm9kZUlEOiBzdHJpbmddOiBOb2RlfSA9IHt9O1xuICAgIGNvbnN0IGxheWVyc0RlcHRoczoge1tsYXllcklEOiBzdHJpbmddOiBudW1iZXJ9ID0ge307XG4gICAgLy8gVG8gbGF5ZXJzIGZyb20gdGhlaXIgSUQuXG4gICAgY29uc3QgbGF5ZXJJRFRvTGF5ZXI6IHtbbGF5ZXJJRDogc3RyaW5nXTogTGF5ZXJ9ID0ge307XG4gICAgY29uc3QgbGF5ZXJJbmRpY2VzOiB7W2xheWVySUQ6IHN0cmluZ106IG51bWJlcn0gPSB7fTtcbiAgICBjb25zdCBub2Rlc0luRGVjcmVhc2luZ0RlcHRoOiBOb2RlW10gPSBbXTtcblxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIG1hcCBvZiB0aGUgZ3JhcGggb2YgbGF5ZXJzLlxuICAgICAqXG4gICAgICogVGhpcyByZWN1cnNpdmVseSB1cGRhdGVzIHRoZSBtYXAgYGxheWVySW5kaWNlc2AsXG4gICAgICogdGhlIGxpc3QgYG5vZGVzSW5EZWNyZWFzaW5nRGVwdGhgIGFuZCB0aGUgc2V0IGBjb250YWluZXJOb2Rlc2AuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdGVuc29yIFNvbWUgdGVuc29yIGluIGEgZ3JhcGguXG4gICAgICogQHBhcmFtIGZpbmlzaGVkTm9kZXMgU2V0IG9mIG5vZGVzIHdob3NlIHN1YmdyYXBocyBoYXZlIGJlZW4gdHJhdmVyc2VkXG4gICAgICogICAgICAgICBjb21wbGV0ZWx5LiBVc2VmdWwgdG8gcHJldmVudCBkdXBsaWNhdGVkIHdvcmsuXG4gICAgICogQHBhcmFtIG5vZGVzSW5Qcm9ncmVzcyBTZXQgb2Ygbm9kZXMgdGhhdCBhcmUgY3VycmVudGx5IGFjdGl2ZSBvbiB0aGVcbiAgICAgKiAgICAgICAgIHJlY3Vyc2lvbiBzdGFjay4gVXNlZnVsIHRvIGRldGVjdCBjeWNsZXMuXG4gICAgICogQHBhcmFtIGxheWVyIExheWVyIGZyb20gd2hpY2ggYHRlbnNvcmAgY29tZXMgZnJvbS4gSWYgbm90IHByb3ZpZGVkLFxuICAgICAqICAgd2lsbCBiZSBvYnRhaW5lZCBmcm9tIHRlbnNvci5zb3VyY2VMYXllci5cbiAgICAgKiBAcGFyYW0gbm9kZUluZGV4IE5vZGUgaW5kZXggZnJvbSB3aGljaCBgdGVuc29yYCBjb21lcyBmcm9tLlxuICAgICAqIEBwYXJhbSB0ZW5zb3JJbmRleCBUZW5zb3JJbmRleCBmcm9tIHdoaWNoIGB0ZW5zb3JgIGNvbWVzIGZyb20uXG4gICAgICpcbiAgICAgKiBAZXhjZXB0aW9uIFJ1bnRpbWVFcnJvciBpZiBhIGN5Y2xlIGlzIGRldGVjdGVkLlxuICAgICAqL1xuICAgIGNvbnN0IGJ1aWxkTWFwT2ZHcmFwaCA9XG4gICAgICAgICh0ZW5zb3I6IFN5bWJvbGljVGVuc29yLCBmaW5pc2hlZE5vZGVzOiBOb2RlW10sIG5vZGVzSW5Qcm9ncmVzczogTm9kZVtdLFxuICAgICAgICAgbGF5ZXI/OiBMYXllciwgbm9kZUluZGV4PzogbnVtYmVyLCB0ZW5zb3JJbmRleD86IG51bWJlcikgPT4ge1xuICAgICAgICAgIGlmIChsYXllciA9PSBudWxsIHx8IG5vZGVJbmRleCA9PSBudWxsIHx8IHRlbnNvckluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgIGxheWVyID0gdGVuc29yLnNvdXJjZUxheWVyO1xuICAgICAgICAgICAgbm9kZUluZGV4ID0gdGVuc29yLm5vZGVJbmRleDtcbiAgICAgICAgICAgIHRlbnNvckluZGV4ID0gdGVuc29yLnRlbnNvckluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBub2RlID0gbGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF07XG5cbiAgICAgICAgICAvLyBQcmV2ZW50IGN5Y2xlcy5cbiAgICAgICAgICBpZiAobm9kZXNJblByb2dyZXNzLmluZGV4T2Yobm9kZSkgIT09IC0xKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFxuICAgICAgICAgICAgICAgIGBUaGUgdGVuc29yICR7dGVuc29yLm5hbWV9IGF0IGxheWVyIFwiJHtsYXllci5uYW1lfVwiIGAgK1xuICAgICAgICAgICAgICAgICdpcyBwYXJ0IG9mIGEgY3ljbGUuJyk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgLy8gRG9uJ3QgcmVwZWF0IHdvcmsgZm9yIHNoYXJlZCBzdWJncmFwaHNcbiAgICAgICAgICBpZiAoZmluaXNoZWROb2Rlcy5pbmRleE9mKG5vZGUpICE9PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFVwZGF0ZSBjb250YWluZXJOb2Rlcy5cbiAgICAgICAgICB0aGlzLmNvbnRhaW5lck5vZGVzLmFkZChDb250YWluZXIubm9kZUtleShsYXllciwgbm9kZUluZGV4KSk7XG5cbiAgICAgICAgICAvLyBTdG9yZSB0aGUgdHJhdmVyc2FsIG9yZGVyIGZvciBsYXllciBzb3J0aW5nLlxuICAgICAgICAgIGlmICghKGxheWVyLmlkIGluIGxheWVySW5kaWNlcykpIHtcbiAgICAgICAgICAgIGxheWVySW5kaWNlc1tsYXllci5pZF0gPSBPYmplY3Qua2V5cyhsYXllckluZGljZXMpLmxlbmd0aDtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobm9kZXNJblByb2dyZXNzLmluZGV4T2Yobm9kZSkgPT09IC0xKSB7XG4gICAgICAgICAgICBub2Rlc0luUHJvZ3Jlc3MucHVzaChub2RlKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBQcm9wYWdhdGUgdG8gYWxsIHByZXZpb3VzIHRlbnNvcnMgY29ubmVjdGVkIHRvIHRoaXMgbm9kZS5cbiAgICAgICAgICBjb25zdCBudW1JbmJvdW5kTGF5ZXJzID0gbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG51bUluYm91bmRMYXllcnM7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgeCA9IG5vZGUuaW5wdXRUZW5zb3JzW2ldO1xuICAgICAgICAgICAgY29uc3QgbGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBub2RlSW5kZXggPSBub2RlLm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgY29uc3QgdGVuc29ySW5kZXggPSBub2RlLnRlbnNvckluZGljZXNbaV07XG4gICAgICAgICAgICBidWlsZE1hcE9mR3JhcGgoXG4gICAgICAgICAgICAgICAgeCwgZmluaXNoZWROb2Rlcywgbm9kZXNJblByb2dyZXNzLCBsYXllciwgbm9kZUluZGV4LFxuICAgICAgICAgICAgICAgIHRlbnNvckluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZmluaXNoZWROb2Rlcy5wdXNoKG5vZGUpO1xuICAgICAgICAgIHdoaWxlIChub2Rlc0luUHJvZ3Jlc3MuaW5kZXhPZihub2RlKSA+PSAwKSB7XG4gICAgICAgICAgICBub2Rlc0luUHJvZ3Jlc3Muc3BsaWNlKG5vZGVzSW5Qcm9ncmVzcy5pbmRleE9mKG5vZGUpLCAxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbm9kZXNJbkRlY3JlYXNpbmdEZXB0aC5wdXNoKG5vZGUpO1xuICAgICAgICB9O1xuXG4gICAgY29uc3QgZmluaXNoZWROb2RlczogTm9kZVtdID0gW107XG4gICAgY29uc3Qgbm9kZXNJblByb2dyZXNzOiBOb2RlW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHggb2YgdGhpcy5vdXRwdXRzKSB7XG4gICAgICBidWlsZE1hcE9mR3JhcGgoeCwgZmluaXNoZWROb2Rlcywgbm9kZXNJblByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBjb25zdCByZXZlcnNlZE5vZGVzSW5EZWNyZWFzaW5nRGVwdGggPVxuICAgICAgICBub2Rlc0luRGVjcmVhc2luZ0RlcHRoLnNsaWNlKCkucmV2ZXJzZSgpO1xuICAgIGZvciAoY29uc3Qgbm9kZSBvZiByZXZlcnNlZE5vZGVzSW5EZWNyZWFzaW5nRGVwdGgpIHtcbiAgICAgIG5vZGVJRFRvTm9kZVtub2RlLmlkXSA9IG5vZGU7XG4gICAgICAvLyBJZiB0aGUgZGVwdGggaXMgbm90IHNldCwgdGhlIG5vZGUgaGFzIG5vIG91dGJvdW5kIG5vZGVzIChkZXB0aCAwKS5cbiAgICAgIGlmICghKG5vZGUuaWQgaW4gbm9kZXNEZXB0aHMpKSB7XG4gICAgICAgIG5vZGVzRGVwdGhzW25vZGUuaWRdID0gMDtcbiAgICAgIH1cbiAgICAgIGxldCBkZXB0aCA9IG5vZGVzRGVwdGhzW25vZGUuaWRdO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGRlcHRoIG9mIHRoZSBjb3JyZXNwb25kaW5nIGxheWVyXG4gICAgICBjb25zdCBwcmV2aW91c0RlcHRoID1cbiAgICAgICAgICAobGF5ZXJzRGVwdGhzW25vZGUub3V0Ym91bmRMYXllci5pZF0gPT0gbnVsbCA/XG4gICAgICAgICAgICAgICAwIDpcbiAgICAgICAgICAgICAgIGxheWVyc0RlcHRoc1tub2RlLm91dGJvdW5kTGF5ZXIuaWRdKTtcblxuICAgICAgLypcbiAgICAgICAgSWYgd2UndmUgc2VlbiB0aGlzIGxheWVyIGJlZm9yZSBhdCBhIGhpZ2hlciBkZXB0aCwgd2Ugc2hvdWxkIHVzZSB0aGF0XG4gICAgICAgIGRlcHRoIGluc3RlYWQgb2YgdGhlIG5vZGUgZGVwdGguICBUaGlzIGlzIG5lY2Vzc2FyeSBmb3Igc2hhcmVkIGxheWVyc1xuICAgICAgICB0aGF0IGhhdmUgaW5wdXRzIGF0IGRpZmZlcmVudCBkZXB0aCBsZXZlbHMgaW4gdGhlIGdyYXBoLlxuICAgICAgKi9cbiAgICAgIGRlcHRoID0gTWF0aC5tYXgoZGVwdGgsIHByZXZpb3VzRGVwdGgpO1xuICAgICAgbGF5ZXJzRGVwdGhzW25vZGUub3V0Ym91bmRMYXllci5pZF0gPSBkZXB0aDtcbiAgICAgIGxheWVySURUb0xheWVyW25vZGUub3V0Ym91bmRMYXllci5pZF0gPSBub2RlLm91dGJvdW5kTGF5ZXI7XG4gICAgICBub2Rlc0RlcHRoc1tub2RlLmlkXSA9IGRlcHRoO1xuXG4gICAgICAvLyBVcGRhdGUgdGhlIGRlcHRoIG9mIGluYm91bmQgbm9kZXMuXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBpbmJvdW5kTGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbaV07XG4gICAgICAgIGNvbnN0IG5vZGVJbmRleCA9IG5vZGUubm9kZUluZGljZXNbaV07XG4gICAgICAgIGNvbnN0IGluYm91bmROb2RlID0gaW5ib3VuZExheWVyLmluYm91bmROb2Rlc1tub2RlSW5kZXhdO1xuICAgICAgICBjb25zdCBwcmV2aW91c0RlcHRoID1cbiAgICAgICAgICAgIChub2Rlc0RlcHRoc1tpbmJvdW5kTm9kZS5pZF0gPT0gbnVsbCA/IDAgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZXNEZXB0aHNbaW5ib3VuZE5vZGUuaWRdKTtcbiAgICAgICAgbm9kZXNEZXB0aHNbaW5ib3VuZE5vZGUuaWRdID0gTWF0aC5tYXgoZGVwdGggKyAxLCBwcmV2aW91c0RlcHRoKTtcbiAgICAgICAgbm9kZUlEVG9Ob2RlW2luYm91bmROb2RlLmlkXSA9IGluYm91bmROb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEJ1aWxkIGEgZGljdCB7ZGVwdGg6IGxpc3Qgb2Ygbm9kZXMgd2l0aCB0aGlzIGRlcHRofVxuICAgIGNvbnN0IG5vZGVzQnlEZXB0aDoge1tkZXB0aDogc3RyaW5nXTogTm9kZVtdfSA9IHt9O1xuICAgIGZvciAoY29uc3Qgbm9kZUlEIGluIG5vZGVzRGVwdGhzKSB7XG4gICAgICBjb25zdCBkZXB0aCA9IG5vZGVzRGVwdGhzW25vZGVJRF07XG4gICAgICBpZiAoIShkZXB0aCBpbiBub2Rlc0J5RGVwdGgpKSB7XG4gICAgICAgIG5vZGVzQnlEZXB0aFtkZXB0aF0gPSBbXTtcbiAgICAgIH1cbiAgICAgIG5vZGVzQnlEZXB0aFtkZXB0aF0ucHVzaChub2RlSURUb05vZGVbbm9kZUlEXSk7XG4gICAgfVxuXG4gICAgLy8gQnVpbGQgYSBkaWN0IHtkZXB0aDogbGlzdCBvZiBsYXllcnMgd2l0aCB0aGlzIGRlcHRofVxuICAgIGNvbnN0IGxheWVyc0J5RGVwdGg6IHtbZGVwdGg6IHN0cmluZ106IExheWVyW119ID0ge307XG4gICAgZm9yIChjb25zdCBsYXllcklEIGluIGxheWVyc0RlcHRocykge1xuICAgICAgY29uc3QgZGVwdGggPSBsYXllcnNEZXB0aHNbbGF5ZXJJRF07XG4gICAgICBpZiAoIShkZXB0aCBpbiBsYXllcnNCeURlcHRoKSkge1xuICAgICAgICBsYXllcnNCeURlcHRoW2RlcHRoXSA9IFtdO1xuICAgICAgfVxuICAgICAgbGF5ZXJzQnlEZXB0aFtkZXB0aF0ucHVzaChsYXllcklEVG9MYXllcltsYXllcklEXSk7XG4gICAgfVxuXG4gICAgLy8gR2V0IHNvcnRlZCBsaXN0IG9mIGxheWVyIGRlcHRocy5cbiAgICBsZXQgZGVwdGhLZXlzID0gT2JqZWN0LmtleXMobGF5ZXJzQnlEZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoeCA9PiBwYXJzZUludCh4LCAxMCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAuc29ydChnZW5lcmljX3V0aWxzLnJldmVyc2VOdW1iZXJDb21wYXJlKTtcblxuICAgIC8vIFNldCB0aGlzLmxheWVycyBhbmQgdGhpcy5sYXllcnNCeURlcHRoLlxuICAgIHRoaXMubGF5ZXJzID0gW107XG4gICAgZm9yIChjb25zdCBkZXB0aCBvZiBkZXB0aEtleXMpIHtcbiAgICAgIGNvbnN0IGxheWVyc0ZvckRlcHRoID0gbGF5ZXJzQnlEZXB0aFtkZXB0aF07XG4gICAgICAvLyBDb250YWluZXIubGF5ZXJzIG5lZWRzIHRvIGhhdmUgYSBkZXRlcm1pbmlzdGljIG9yZGVyOlxuICAgICAgLy8gaGVyZSB3ZSBvcmRlciB0aGVtIGJ5IHRyYXZlcnNhbCBvcmRlci5cbiAgICAgIGxheWVyc0ZvckRlcHRoLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgY29uc3QgYUluZGV4ID0gbGF5ZXJJbmRpY2VzW2EuaWRdO1xuICAgICAgICBjb25zdCBiSW5kZXggPSBsYXllckluZGljZXNbYi5pZF07XG4gICAgICAgIGlmIChhSW5kZXggPCBiSW5kZXgpIHtcbiAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFJbmRleCA+IGJJbmRleCkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIGxheWVyc0ZvckRlcHRoKSB7XG4gICAgICAgIGlmIChsYXllciBpbnN0YW5jZW9mIENvbnRhaW5lcikge1xuICAgICAgICAgIHRoaXMuaW50ZXJuYWxDb250YWluZXJSZWZzLnB1c2gobGF5ZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMubGF5ZXJzLnB1c2gobGF5ZXIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxheWVyc0J5RGVwdGggPSBsYXllcnNCeURlcHRoO1xuXG4gICAgLy8gR2V0IHNvcnRlZCBsaXN0IG9mIG5vZGUgZGVwdGhzO1xuICAgIGRlcHRoS2V5cyA9IE9iamVjdC5rZXlzKG5vZGVzQnlEZXB0aClcbiAgICAgICAgICAgICAgICAgICAgLm1hcCh4ID0+IHBhcnNlSW50KHgsIDEwKSlcbiAgICAgICAgICAgICAgICAgICAgLnNvcnQoZ2VuZXJpY191dGlscy5yZXZlcnNlTnVtYmVyQ29tcGFyZSk7XG5cbiAgICAvLyBDaGVjayB0aGF0IGFsbCB0ZW5zb3JzIHJlcXVpcmVkIGFyZSBjb21wdXRhYmxlLlxuICAgIC8vIGNvbXB1dGFibGVfdGVuc29yczogYWxsIHRlbnNvcnMgaW4gdGhlIGdyYXBoXG4gICAgLy8gdGhhdCBjYW4gYmUgY29tcHV0ZWQgZnJvbSB0aGUgaW5wdXRzIHByb3ZpZGVkLlxuICAgIGNvbnN0IGNvbXB1dGFibGVUZW5zb3JzID0gdGhpcy5pbnB1dHMuc2xpY2UoKTtcblxuICAgIC8vIFRvIHByb3ZpZGUgYSBiZXR0ZXIgZXJyb3IgbXNnLlxuICAgIGNvbnN0IGxheWVyc1dpdGhDb21wbGV0ZUlucHV0OiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgZGVwdGggb2YgZGVwdGhLZXlzKSB7XG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXNCeURlcHRoW2RlcHRoXSkge1xuICAgICAgICBjb25zdCBsYXllciA9IG5vZGUub3V0Ym91bmRMYXllcjtcbiAgICAgICAgaWYgKGxheWVyICE9IG51bGwpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IHggb2Ygbm9kZS5pbnB1dFRlbnNvcnMpIHtcbiAgICAgICAgICAgIGlmIChjb21wdXRhYmxlVGVuc29ycy5pbmRleE9mKHgpID09PSAtMSkge1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFxuICAgICAgICAgICAgICAgICAgYEdyYXBoIGRpc2Nvbm5lY3RlZDogY2Fubm90IG9idGFpbiB2YWx1ZSBmb3IgdGVuc29yICR7eH1gICtcbiAgICAgICAgICAgICAgICAgIGAgYXQgbGF5ZXIgXCIke2xheWVyLm5hbWV9XCIuIGAgK1xuICAgICAgICAgICAgICAgICAgJ1RoZSBmb2xsb3dpbmcgcHJldmlvdXMgbGF5ZXJzIHdlcmUgYWNjZXNzZWQgd2l0aG91dCAnICtcbiAgICAgICAgICAgICAgICAgIGBpc3N1ZTogJHtsYXllcnNXaXRoQ29tcGxldGVJbnB1dH1gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChjb25zdCB4IG9mIG5vZGUub3V0cHV0VGVuc29ycykge1xuICAgICAgICAgICAgY29tcHV0YWJsZVRlbnNvcnMucHVzaCh4KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgbGF5ZXJzV2l0aENvbXBsZXRlSW5wdXQucHVzaChsYXllci5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFNldCB0aGlzLmNvbnRhaW5lck5vZGVzIGFuZCB0aGlzLm5vZGVzQnlEZXB0aC5cbiAgICB0aGlzLm5vZGVzQnlEZXB0aCA9IG5vZGVzQnlEZXB0aDtcblxuICAgIC8vIEVuc3VyZSBuYW1lIHVuaWNpdHksIHdoaWNoIHdpbGwgYmUgY3J1Y2lhbCBmb3Igc2VyaWFsaXphdGlvblxuICAgIC8vIChzaW5jZSBzZXJpYWxpemVkIG5vZGVzIHJlZmVyIHRvIGxheWVycyBieSB0aGVpciBuYW1lKS5cbiAgICBjb25zdCBhbGxOYW1lcyA9IHRoaXMubGF5ZXJzLm1hcCh4ID0+IHgubmFtZSk7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIGFsbE5hbWVzKSB7XG4gICAgICBjb25zdCBudW1PY2N1cnJlbmNlcyA9IGFsbE5hbWVzLmZpbHRlcih4ID0+IHggPT09IG5hbWUpLmxlbmd0aDtcbiAgICAgIGlmIChudW1PY2N1cnJlbmNlcyAhPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFxuICAgICAgICAgICAgYFRoZSBuYW1lIFwiJHtuYW1lfVwiIGlzIHVzZWQgJHtudW1PY2N1cnJlbmNlc30gdGltZXMgYCArXG4gICAgICAgICAgICAnaW4gdGhlIG1vZGVsLiBBbGwgbGF5ZXIgbmFtZXMgc2hvdWxkIGJlIHVuaXF1ZS4gTGF5ZXIgbmFtZXM6ICcgK1xuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoYWxsTmFtZXMpKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBMYXllciBwYXJhbWV0ZXJzLlxuICAgIC8vIFRoZSBuZXcgY29udGFpbmVyIHN0YXJ0cyB3aXRoIGEgc2luZ2xlIGluYm91bmQgbm9kZVxuICAgIC8vIGZvciBpdHMgaW5wdXRzLCBhbmQgbm8gb3V0Ym91bmQgbm9kZXMuXG4gICAgLy8gV2lsbCBiZSBhcHBlbmRlZCB0byBieSBmdXR1cmUgY2FsbHMgdG8gYXBwbHkoKS5cbiAgICB0aGlzLm91dGJvdW5kTm9kZXMgPSBbXTtcbiAgICAvLyBXaWxsIGJlIGFwcGVuZGVkIHRvIGJlbG93LCBhbmQgYnkgZnV0dXJlIGNhbGxzIHRvIGFwcGx5KCkuXG4gICAgdGhpcy5pbmJvdW5kTm9kZXMgPSBbXTtcblxuICAgIC8vIENyZWF0ZSB0aGUgbm9kZSBsaW5raW5nIGludGVybmFsIGlucHV0cyB0byBpbnRlcm5hbCBvdXRwdXRzLlxuICAgIC8vIChUaGlzIGNhbGwgaGFzIHNpZGUgZWZmZWN0cy4pXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgbmV3IE5vZGUoe1xuICAgICAgb3V0Ym91bmRMYXllcjogdGhpcyxcbiAgICAgIGluYm91bmRMYXllcnM6IFtdLFxuICAgICAgbm9kZUluZGljZXM6IFtdLFxuICAgICAgdGVuc29ySW5kaWNlczogW10sXG4gICAgICBpbnB1dFRlbnNvcnM6IHRoaXMuaW5wdXRzLFxuICAgICAgb3V0cHV0VGVuc29yczogdGhpcy5vdXRwdXRzLFxuICAgICAgaW5wdXRNYXNrczogdGhpcy5pbnB1dHMubWFwKHggPT4gbnVsbCksXG4gICAgICBvdXRwdXRNYXNrczogdGhpcy5vdXRwdXRzLm1hcCh4ID0+IG51bGwpLFxuICAgICAgaW5wdXRTaGFwZXM6IHRoaXMuaW5wdXRzLm1hcCh4ID0+IHguc2hhcGUpLFxuICAgICAgb3V0cHV0U2hhcGVzOiB0aGlzLm91dHB1dHMubWFwKHggPT4geC5zaGFwZSlcbiAgICB9KTtcbiAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgICB0aGlzLl9yZWZDb3VudCA9IDE7ICAvLyBUaGUgcmVmIGNvdW50IG9mIGEgY29udGFpbmVyIGFsd2F5cyBzdGFydCBhdCAxLlxuICB9XG5cbiAgcHJvdGVjdGVkIGFzc2VydE5vdERpc3Bvc2VkKCkge1xuICAgIGlmICh0aGlzLl9yZWZDb3VudCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDb250YWluZXIgJyR7dGhpcy5uYW1lfScgaXMgYWxyZWFkeSBkaXNwb3NlZC5gKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0ZW1wdCB0byBkaXNwb3NlIGEgTGF5ZXJzTW9kZWwncyB3ZWlnaHRzLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkZWNyZWFzZSB0aGUgcmVmZXJlbmNlIGNvdW50IG9mIHRoZSBMYXllcnNNb2RlbCBvYmplY3QgYnkgMS5cbiAgICpcbiAgICogQSBMYXllcnNNb2RlbCBpcyByZWZlcmVuY2UtY291bnRlZC4gSXRzIHJlZmVyZW5jZSBjb3VudCBpcyBpbmNyZW1lbnRlZCBieSAxXG4gICAqIHdoZW4gaXQgaXMgZmlyc3QgY29uc3RydWN0ZWQgYW5kIHdoZW4gaXQgaXMgdXNlZCBhcyBhIExheWVyIG9mIGFub3RoZXJcbiAgICogTGF5ZXJzTW9kZWwuXG4gICAqXG4gICAqIElmIHRoZSByZWZlcmVuY2UgY291bnQgb2YgYSBMYXllcnNNb2RlbCBiZWNvbWVzIDAsIHRoZSBgZGlzcG9zZWAgbWV0aG9kIG9mXG4gICAqIGFsbCBpdHMgY29uc3RpdHVlbnQgYExheWVyYHMgd2lsbCBiZSBjYWxsZWQuXG4gICAqXG4gICAqIE5vdGU6IElmIHRoZSByZWZlcmVuY2UgY291bnQgaXMgZ3JlYXRlciB0aGFuIDAgYWZ0ZXIgdGhlIGRlY3JlbWVudCwgdGhlXG4gICAqIGBkaXNwb3NlYCBtZXRob2Qgb2YgaXRzIGNvbnN0aXR1ZW50IGBMYXllcmBzIHdpbGwgKm5vdCogYmUgY2FsbGVkLlxuICAgKlxuICAgKiBBZnRlciBhIExheWVyc01vZGVsIGlzIGRpc3Bvc2VkLCBpdCBjYW5ub3QgYmUgdXNlZCBpbiBjYWxscyBzdWNoIGFzXG4gICAqICdwcmVkaWN0YCwgYGV2YWx1YXRlYCBvciBgZml0YCBhbnltb3JlLlxuICAgKlxuICAgKiBAcmV0dXJucyBBIERpc3Bvc2VSZXN1bHQgT2JqZWN0IHdpdGggdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gICAqICAgLSByZWZDb3VudEFmdGVyRGlzcG9zZTogVGhlIHJlZmVyZW5jZSBjb3VudCBvZiB0aGUgTGF5ZXJzTW9kZWwgYWZ0ZXIgdGhpc1xuICAgKiAgICAgYGRpc3Bvc2UoKWAgY2FsbC5cbiAgICogICAtIG51bURpc3Bvc2VkVmFyaWFibGVzOiBOdW1iZXIgb2YgYHRmLlZhcmlhYmxlYHMgKGkuZS4sIHdlaWdodHMpIGRpc3Bvc2VkXG4gICAqICAgICBkdXJpbmcgdGhpcyBgZGlzcG9zZSgpYCBjYWxsLlxuICAgKiBAdGhyb3dzIHtFcnJvcn0gSWYgdGhlIGxheWVyIGlzIG5vdCBidWlsdCB5ZXQsIG9yIGlmIHRoZSBMYXllcnNNb2RlbCBoYXNcbiAgICogICBhbHJlYWR5IGJlZW4gZGlzcG9zZWQuXG4gICAqL1xuICBkaXNwb3NlKCk6IERpc3Bvc2VSZXN1bHQge1xuICAgIHRoaXMuYXNzZXJ0Tm90RGlzcG9zZWQoKTtcbiAgICBjb25zdCByZXN1bHQ6XG4gICAgICAgIERpc3Bvc2VSZXN1bHQgPSB7cmVmQ291bnRBZnRlckRpc3Bvc2U6IG51bGwsIG51bURpc3Bvc2VkVmFyaWFibGVzOiAwfTtcbiAgICBpZiAoLS10aGlzLl9yZWZDb3VudCA9PT0gMCkge1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgICByZXN1bHQubnVtRGlzcG9zZWRWYXJpYWJsZXMgKz0gbGF5ZXIuZGlzcG9zZSgpLm51bURpc3Bvc2VkVmFyaWFibGVzO1xuICAgICAgfVxuXG4gICAgICAvLyBDYWxsIGRpc3Bvc2Ugb24gZWFjaCBpbnRlcm5hbGx5IGNyZWF0ZWQgY29udGFpbmVyIGxheWVyIGFnYWluIHRvIGVuc3VyZVxuICAgICAgLy8gdGhlaXIgcmVmQ291bnRzIGhpdCB6ZXJvIGFuZCB0aGVpciB0ZW5zb3JzIGFyZSBzdWJzZXF1ZW50bHkgZGVsZXRlZC5cbiAgICAgIGZvciAoY29uc3QgY29udGFpbmVyIG9mIHRoaXMuaW50ZXJuYWxDb250YWluZXJSZWZzKSB7XG4gICAgICAgIHJlc3VsdC5udW1EaXNwb3NlZFZhcmlhYmxlcyArPSBjb250YWluZXIuZGlzcG9zZSgpLm51bURpc3Bvc2VkVmFyaWFibGVzO1xuICAgICAgfVxuICAgIH1cbiAgICByZXN1bHQucmVmQ291bnRBZnRlckRpc3Bvc2UgPSB0aGlzLl9yZWZDb3VudDtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgZ2V0IHRyYWluYWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFpbmFibGVfO1xuICB9XG5cbiAgc2V0IHRyYWluYWJsZSh0cmFpbmFibGU6IGJvb2xlYW4pIHtcbiAgICB0aGlzLmxheWVycy5mb3JFYWNoKGxheWVyID0+IHtcbiAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICAgICgobGF5ZXIgYXMgYW55KS5fdHJhaW5hYmxlV2VpZ2h0cyBhcyBMYXllclZhcmlhYmxlW10pXG4gICAgICAgICAgLmZvckVhY2godyA9PiB3LnRyYWluYWJsZSA9IHRyYWluYWJsZSk7XG4gICAgfSk7XG4gICAgdGhpcy50cmFpbmFibGVfID0gdHJhaW5hYmxlO1xuICB9XG5cbiAgZ2V0IHRyYWluYWJsZVdlaWdodHMoKTogTGF5ZXJWYXJpYWJsZVtdIHtcbiAgICAvLyBQb3J0aW5nIE5vdGU6IFRoaXMgY2hlY2sgYmVsb3cgaXMgdG8gcHJldmVudCBlcnJvcnMgd2hlcmUgdGhlXG4gICAgLy8gICBfdHJhaW5hYmxlV2VpZ2h0cyBpbmhlcml0ZWQgZnJvbSB0aGUgcGFyZW50IGNsYXNzIChMYXllcikgZ2V0c1xuICAgIC8vICAgaW5hZHZlcnRlbnRseSB1c2VkLlxuICAgIGlmICh0aGlzLl90cmFpbmFibGVXZWlnaHRzLmxlbmd0aCA+IDApIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdDb250YWluZXIgaW5zdGFuY2UgdW5leHBlY3RlZGx5IGNvbnRhaW5zIF90cmFpbmFibGVXZWlnaHRzLicgK1xuICAgICAgICAgICdUaGUgdHJhaW5hYmxlIHdlaWdodHMgb2YgYSBDb250YWluZXIgYXJlIGEgdW5pb24gb2YgdGhlICcgK1xuICAgICAgICAgICd0cmFpbmFibGUgd2VpZ2h0cyBvZiBpdHMgY29uc2l0dWVudCBMYXllcnMuIEl0cyBvd24gJyArXG4gICAgICAgICAgJ190cmFpbmFibGVXZWlnaHRzIG11c3QgcmVtYWluIGFuIGVtcHR5IEFycmF5LicpO1xuICAgIH1cblxuICAgIGlmICghdGhpcy50cmFpbmFibGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgbGV0IHdlaWdodHM6IExheWVyVmFyaWFibGVbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIHdlaWdodHMgPSB3ZWlnaHRzLmNvbmNhdChsYXllci50cmFpbmFibGVXZWlnaHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHdlaWdodHM7XG4gIH1cblxuICBnZXQgbm9uVHJhaW5hYmxlV2VpZ2h0cygpOiBMYXllclZhcmlhYmxlW10ge1xuICAgIGNvbnN0IHdlaWdodHM6IExheWVyVmFyaWFibGVbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIHdlaWdodHMucHVzaCguLi5sYXllci5ub25UcmFpbmFibGVXZWlnaHRzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgY29uc3QgdHJhaW5hYmxlV2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdID0gW107XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICAgIHRyYWluYWJsZVdlaWdodHMucHVzaCguLi5sYXllci50cmFpbmFibGVXZWlnaHRzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cmFpbmFibGVXZWlnaHRzLmNvbmNhdCh3ZWlnaHRzKTtcbiAgICB9XG4gICAgcmV0dXJuIHdlaWdodHM7XG4gIH1cblxuICBnZXQgd2VpZ2h0cygpOiBMYXllclZhcmlhYmxlW10ge1xuICAgIHJldHVybiB0aGlzLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KHRoaXMubm9uVHJhaW5hYmxlV2VpZ2h0cyk7XG4gIH1cblxuICAvKipcbiAgICogTG9hZHMgYWxsIGxheWVyIHdlaWdodHMgZnJvbSBhIEpTT04gb2JqZWN0LlxuICAgKlxuICAgKiBQb3J0aW5nIE5vdGU6IEhERjUgd2VpZ2h0IGZpbGVzIGNhbm5vdCBiZSBkaXJlY3RseSBsb2FkZWQgaW4gSmF2YVNjcmlwdCAvXG4gICAqICAgVHlwZVNjcmlwdC4gVGhlIHV0aWxpdHkgc2NyaXB0IGF0IGBzY3JpcHRzL3B5a2VyYXMucHlgIG9mZmVycyBtZWFuc1xuICAgKiAgIHRvIGNvbnZlcnQgdGhlbSBpbnRvIEpTT04gc3RyaW5ncyBjb21wYXRpYmxlIHdpdGggdGhpcyBtZXRob2QuXG4gICAqIFBvcnRpbmcgTm90ZTogVGVuc29yRmxvdy5qcyBMYXllcnMgc3VwcG9ydHMgb25seSBsb2FkaW5nIGJ5IG5hbWUgY3VycmVudGx5LlxuICAgKlxuICAgKiBAcGFyYW0gd2VpZ2h0cyBBIEpTT04gbWFwcGluZyB3ZWlnaHQgbmFtZXMgdG8gd2VpZ2h0IHZhbHVlcyBhcyBuZXN0ZWRcbiAgICogICBhcnJheXMgb2YgbnVtYmVycywgb3IgYSBgTmFtZWRUZW5zb3JNYXBgLCBpLmUuLCBhIEpTT04gbWFwcGluZyB3ZWlnaHRcbiAgICogICBuYW1lcyB0byBgdGYuVGVuc29yYCBvYmplY3RzLlxuICAgKiBAcGFyYW0gc3RyaWN0IFJlcXVpcmUgdGhhdCB0aGUgcHJvdmlkZWQgd2VpZ2h0cyBleGFjdGx5IG1hdGNoIHRob3NlXG4gICAqICAgcmVxdWlyZWQgYnkgdGhlIGNvbnRhaW5lci4gIERlZmF1bHQ6IGB0cnVlYC4gIFBhc3NpbmcgYGZhbHNlYCBtZWFucyB0aGF0XG4gICAqICAgZXh0cmEgd2VpZ2h0cyBhbmQgbWlzc2luZyB3ZWlnaHRzIHdpbGwgYmUgc2lsZW50bHkgaWdub3JlZC5cbiAgICovXG4gIGxvYWRXZWlnaHRzKHdlaWdodHM6IE5hbWVkVGVuc29yTWFwLCBzdHJpY3QgPSB0cnVlKSB7XG4gICAgY29uc3QgbmFtZVRvV2VpZ2h0OiB7W25hbWU6IHN0cmluZ106IExheWVyVmFyaWFibGV9ID0ge307XG4gICAgbGV0IHRvdGFsV2VpZ2h0c0NvdW50ID0gMDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICBmb3IgKGNvbnN0IHdlaWdodCBvZiBsYXllci53ZWlnaHRzKSB7XG4gICAgICAgIGlmIChuYW1lVG9XZWlnaHRbd2VpZ2h0Lm9yaWdpbmFsTmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBEdXBsaWNhdGUgd2VpZ2h0IG5hbWU6ICR7d2VpZ2h0Lm9yaWdpbmFsTmFtZX1gKTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lVG9XZWlnaHRbd2VpZ2h0Lm9yaWdpbmFsTmFtZV0gPSB3ZWlnaHQ7XG4gICAgICAgIHRvdGFsV2VpZ2h0c0NvdW50Kys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3Qgd2VpZ2h0VmFsdWVUdXBsZXM6IEFycmF5PFtMYXllclZhcmlhYmxlLCBUZW5zb3JdPiA9IFtdO1xuICAgIGZvciAoY29uc3QgbmFtZSBpbiB3ZWlnaHRzKSB7XG4gICAgICAvLyBURiAyLjIuMCBhZGRlZCBjZWxsIG5hbWUgdG8gdGhlIHdlaWdodCBuYW1lIGluIHRoZSBmb3JtYXQgb2ZcbiAgICAgIC8vIGxheWVyX25hbWUvY2VsbF9uYW1lL3dlaWdodF9uYW1lLCB3ZSBuZWVkIHRvIHJlbW92ZVxuICAgICAgLy8gdGhlIGlubmVyIGNlbGwgbmFtZS5cbiAgICAgIGxldCB2YWxpZGF0ZWROYW1lID0gbmFtZTtcbiAgICAgIGlmIChuYW1lVG9XZWlnaHRbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICBjb25zdCB0b2tlbnMgPSBuYW1lLnNwbGl0KCcvJyk7XG4gICAgICAgIGNvbnN0IHNob3J0ZW5OYW1lQXJyYXkgPVxuICAgICAgICAgICAgdG9rZW5zLnNsaWNlKDAsIC0yKS5jb25jYXQoW3Rva2Vuc1t0b2tlbnMubGVuZ3RoIC0gMV1dKTtcbiAgICAgICAgdmFsaWRhdGVkTmFtZSA9IHNob3J0ZW5OYW1lQXJyYXkuam9pbignLycpO1xuICAgICAgfVxuICAgICAgaWYgKG5hbWVUb1dlaWdodFt2YWxpZGF0ZWROYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHdlaWdodFZhbHVlVHVwbGVzLnB1c2goW25hbWVUb1dlaWdodFt2YWxpZGF0ZWROYW1lXSwgd2VpZ2h0c1tuYW1lXV0pO1xuICAgICAgfSBlbHNlIGlmIChzdHJpY3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgUHJvdmlkZWQgd2VpZ2h0IGRhdGEgaGFzIG5vIHRhcmdldCB2YXJpYWJsZTogJHtuYW1lfWApO1xuICAgICAgfVxuICAgICAgZGVsZXRlIG5hbWVUb1dlaWdodFt2YWxpZGF0ZWROYW1lXTtcbiAgICB9XG5cbiAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAvLyBDaGVjayB0aGF0IGFsbCB3ZWlnaHRzIGFyZSBzZXQuXG4gICAgICBjb25zdCB1bnNldE5hbWVzOiBzdHJpbmdbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBuYW1lIGluIG5hbWVUb1dlaWdodCkge1xuICAgICAgICB1bnNldE5hbWVzLnB1c2gobmFtZSk7XG4gICAgICB9XG4gICAgICBpZiAodW5zZXROYW1lcy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYCR7dW5zZXROYW1lcy5sZW5ndGh9IG9mICR7XG4gICAgICAgICAgICAgICAgdG90YWxXZWlnaHRzQ291bnR9IHdlaWdodHMgYXJlIG5vdCBzZXQ6IGAgK1xuICAgICAgICAgICAgYCR7dW5zZXROYW1lc31gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBiYXRjaFNldFZhbHVlKHdlaWdodFZhbHVlVHVwbGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVdGlsIHNoYXJlZCBiZXR3ZWVuIGRpZmZlcmVudCBzZXJpYWxpemF0aW9uIG1ldGhvZHMuXG4gICAqIEByZXR1cm5zIExheWVyc01vZGVsIGNvbmZpZyB3aXRoIEtlcmFzIHZlcnNpb24gaW5mb3JtYXRpb24gYWRkZWQuXG4gICAqL1xuICBwcm90ZWN0ZWQgdXBkYXRlZENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IHRoZUNvbmZpZyA9IHRoaXMuZ2V0Q29uZmlnKCk7XG4gICAgY29uc3QgbW9kZWxDb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt9O1xuICAgIG1vZGVsQ29uZmlnWydjbGFzc05hbWUnXSA9IHRoaXMuZ2V0Q2xhc3NOYW1lKCk7XG4gICAgbW9kZWxDb25maWdbJ2NvbmZpZyddID0gdGhlQ29uZmlnO1xuICAgIG1vZGVsQ29uZmlnWydrZXJhc1ZlcnNpb24nXSA9IGB0ZmpzLWxheWVycyAke2xheWVyc1ZlcnNpb259YDtcbiAgICAvLyBUT0RPKG5pZWxzZW5lKTogUmVwbGFjZSBzb21ldGhpbmcgbGlrZSBLLmJhY2tlbmQoKSBvbmNlXG4gICAgLy8gcG9zc2libGUuXG4gICAgbW9kZWxDb25maWdbJ2JhY2tlbmQnXSA9ICdUZW5zb3JGbG93LmpzJztcbiAgICByZXR1cm4gbW9kZWxDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBhIEpTT04gc3RyaW5nIGNvbnRhaW5pbmcgdGhlIG5ldHdvcmsgY29uZmlndXJhdGlvbi5cbiAgICpcbiAgICogVG8gbG9hZCBhIG5ldHdvcmsgZnJvbSBhIEpTT04gc2F2ZSBmaWxlLCB1c2VcbiAgICogbW9kZWxzLm1vZGVsRnJvbUpTT04oanNvblN0cmluZyk7XG4gICAqIEBwYXJhbSBleHRyYUpzb25BcmdzIFVudXNlZCBpbiB0ZmpzLWxheWVycywgbWFpbnRhaW5lZCBmb3IgUHlLZXJhc1xuICAgKiBAcGFyYW0gcmV0dXJuU3RyaW5nIFdoZXRoZXIgdGhlIHJldHVybiB2YWx1ZSBzaG91bGQgYmUgc3RyaW5naWZpZWRcbiAgICogICAgKGRlZmF1bHQ6IGB0cnVlYCkuXG4gICAqIEByZXR1cm5zIGEgSlNPTiBzdHJpbmcgaWYgYHJldHVyblN0cmluZ2AgKGRlZmF1bHQpLCBvciBhIEpTT04gb2JqZWN0IGlmXG4gICAqICAgYCFyZXR1cm5TdHJpbmdgLlxuICAgKi9cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICB0b0pTT04odW51c2VkPzogYW55LCByZXR1cm5TdHJpbmcgPSB0cnVlKTogc3RyaW5nfFB5SnNvbkRpY3Qge1xuICAgIGNvbnN0IG1vZGVsQ29uZmlnID0gY29udmVydFRzVG9QeXRob25pYyh0aGlzLnVwZGF0ZWRDb25maWcoKSkgYXMgUHlKc29uRGljdDtcbiAgICByZXR1cm4gcmV0dXJuU3RyaW5nID8gSlNPTi5zdHJpbmdpZnkobW9kZWxDb25maWcpIDogbW9kZWxDb25maWc7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbCB0aGUgbW9kZWwgb24gbmV3IGlucHV0cy5cbiAgICpcbiAgICogSW4gdGhpcyBjYXNlIGBjYWxsYCBqdXN0IHJlYXBwbGllcyBhbGwgb3BzIGluIHRoZSBncmFwaCB0byB0aGUgbmV3IGlucHV0c1xuICAgKiAoZS5nLiBidWlsZCBhIG5ldyBjb21wdXRhdGlvbmFsIGdyYXBoIGZyb20gdGhlIHByb3ZpZGVkIGlucHV0cykuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dHMgQSB0ZW5zb3Igb3IgbGlzdCBvZiB0ZW5zb3JzLlxuICAgKiBAcGFyYW0gbWFzayBBIG1hc2sgb3IgbGlzdCBvZiBtYXNrcy4gQSBtYXNrIGNhbiBiZSBlaXRoZXIgYSB0ZW5zb3Igb3IgbnVsbFxuICAgKiAgIChubyBtYXNrKS5cbiAgICpcbiAgICogQHJldHVybiBBIHRlbnNvciBpZiB0aGVyZSBpcyBhIHNpbmdsZSBvdXRwdXQsIG9yIGEgbGlzdCBvZiB0ZW5zb3JzIGlmIHRoZXJlXG4gICAqICAgYXJlIG1vcmUgdGhhbiBvbmUgb3V0cHV0cy5cbiAgICovXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpbnB1dHMgPSBnZW5lcmljX3V0aWxzLnRvTGlzdChpbnB1dHMpO1xuICAgICAgY29uc3QgZmVlZERpY3QgPSBuZXcgRmVlZERpY3QoKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZmVlZERpY3QuYWRkKHRoaXMuaW5wdXRzW2ldLCBpbnB1dHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGV4ZWN1dGUodGhpcy5vdXRwdXRzLCBmZWVkRGljdCwga3dhcmdzKSBhcyBUZW5zb3IgfCBUZW5zb3JbXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBhbiBvdXRwdXQgbWFzayB0ZW5zb3IuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dHMgVGVuc29yIG9yIGxpc3Qgb2YgdGVuc29ycy5cbiAgICogQHBhcmFtIG1hc2sgVGVuc29yIG9yIGxpc3Qgb2YgdGVuc29ycy5cbiAgICpcbiAgICogQHJldHVybiBudWxsIG9yIGEgdGVuc29yIChvciBsaXN0IG9mIHRlbnNvcnMsIG9uZSBwZXIgb3V0cHV0IHRlbnNvciBvZiB0aGVcbiAgICogbGF5ZXIpLlxuICAgKi9cbiAgY29tcHV0ZU1hc2soaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIG1hc2s/OiBUZW5zb3J8VGVuc29yW10pOiBUZW5zb3JcbiAgICAgIHxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgaW5wdXRzID0gZ2VuZXJpY191dGlscy50b0xpc3QoaW5wdXRzKTtcbiAgICAgIGxldCBtYXNrczogVGVuc29yW107XG4gICAgICBpZiAobWFzayA9PSBudWxsKSB7XG4gICAgICAgIG1hc2tzID0gZ2VuZXJpY191dGlscy5weUxpc3RSZXBlYXQobnVsbCwgaW5wdXRzLmxlbmd0aCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXNrcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KG1hc2spO1xuICAgICAgfVxuICAgICAgLy8gVE9ETyhtaWNoYWVsdGVycnkpOiBBZGQgc3VwcG9ydCBmb3IgbWFzayBjYWNoaW5nLlxuICAgICAgcmV0dXJuIHRoaXMucnVuSW50ZXJuYWxHcmFwaChpbnB1dHMsIG1hc2tzKVsxXTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgb3V0cHV0IHNoYXBlIG9mIHRoZSBsYXllci5cbiAgICpcbiAgICogQXNzdW1lcyB0aGF0IHRoZSBsYXllciB3aWxsIGJlIGJ1aWx0IHRvIG1hdGNoIHRoYXQgaW5wdXQgc2hhcGUgcHJvdmlkZWQuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dFNoYXBlIEEgc2hhcGUgKHR1cGxlIG9mIGludGVnZXJzKSBvciBhIGxpc3Qgb2Ygc2hhcGUgdHVwbGVzXG4gICAqICAgKG9uZSBwZXIgb3V0cHV0IHRlbnNvciBvZiB0aGUgbGF5ZXIpLiBTaGFwZSB0dXBsZXMgY2FuIGluY2x1ZGUgbnVsbCBmb3JcbiAgICogICBmcmVlIGRpbWVuc2lvbnMsIGluc3RlYWQgb2YgYW4gaW50ZWdlci5cbiAgICovXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgY29uc3QgaW5wdXRTaGFwZXMgPSB0eXBlc191dGlscy5ub3JtYWxpemVTaGFwZUxpc3QoaW5wdXRTaGFwZSk7XG4gICAgaWYgKGlucHV0U2hhcGVzLmxlbmd0aCAhPT0gdGhpcy5pbnB1dExheWVycy5sZW5ndGgpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBJbnZhbGlkIGlucHV0U2hhcGUgYXJndW1lbnQgJHtpbnB1dFNoYXBlfTogYCArXG4gICAgICAgICAgYG1vZGVsIGhhcyAke3RoaXMuaW5wdXRMYXllcnMubGVuZ3RofSB0ZW5zb3IgaW5wdXRzLmApO1xuICAgIH1cblxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIGNhY2hpbmdcbiAgICBjb25zdCBsYXllcnNUb091dHB1dFNoYXBlczoge1tzaGFwZUtleTogc3RyaW5nXTogU2hhcGV9ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlcy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmlucHV0TGF5ZXJzW2ldO1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGVzW2ldO1xuICAgICAgLy8gSXQncyBhbiBpbnB1dCBsYXllcjogY29tcHV0ZU91dHB1dFNoYXBlIGlzIGlkZW50aXR5LFxuICAgICAgLy8gYW5kIHRoZXJlIGlzIG9ubHkgb25lIG5vZGUgYW5kIG9uZSB0ZW5zb3Igb3V0cHV0LlxuICAgICAgY29uc3Qgc2hhcGVLZXkgPSBsYXllci5uYW1lICsgJ18wXzAnO1xuICAgICAgbGF5ZXJzVG9PdXRwdXRTaGFwZXNbc2hhcGVLZXldID0gaW5wdXRTaGFwZTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXB0aEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh4ID0+IHBhcnNlSW50KHgsIDEwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoZ2VuZXJpY191dGlscy5yZXZlcnNlTnVtYmVyQ29tcGFyZSk7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG5vZGVzLCBieSBkZXB0aCBsZXZlbC5cbiAgICBpZiAoZGVwdGhLZXlzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGZvciAoY29uc3QgZGVwdGggb2YgZGVwdGhLZXlzKSB7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5ub2Rlc0J5RGVwdGhbZGVwdGhdO1xuICAgICAgICBmb3IgKGNvbnN0IG5vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgICAvLyBUaGlzIGlzIGFsd2F5cyBhIHNpbmdsZSBsYXllciwgbmV2ZXIgYSBsaXN0LlxuICAgICAgICAgIGNvbnN0IGxheWVyID0gbm9kZS5vdXRib3VuZExheWVyO1xuICAgICAgICAgIGlmICh0aGlzLmlucHV0TGF5ZXJzLm1hcCh4ID0+IHguaWQpLmluZGV4T2YobGF5ZXIuaWQpICE9PSAtMSkge1xuICAgICAgICAgICAgLy8gV2UndmUgYWxyZWFkeSBjb3ZlcmVkIHRoZSBpbnB1dCBsYXllcnMgYSBmZXcgbGluZXMgYWJvdmUuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gUG90ZW50aWFsbHkgcmVkdW5kYW50IGxpc3QsIHNhbWUgc2l6ZSBvZiBub2RlLmlucHV0VGVuc29ycy5cbiAgICAgICAgICBjb25zdCBpbnB1dFNoYXBlczogU2hhcGVbXSA9IFtdO1xuICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5pbmJvdW5kTGF5ZXJzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBpbmJvdW5kTGF5ZXIgPSBub2RlLmluYm91bmRMYXllcnNbal07XG4gICAgICAgICAgICBjb25zdCBub2RlSW5kZXggPSBub2RlLm5vZGVJbmRpY2VzW2pdO1xuICAgICAgICAgICAgY29uc3QgdGVuc29ySW5kZXggPSBub2RlLnRlbnNvckluZGljZXNbal07XG4gICAgICAgICAgICBjb25zdCBzaGFwZUtleSA9IGAke2luYm91bmRMYXllci5uYW1lfV8ke25vZGVJbmRleH1fJHt0ZW5zb3JJbmRleH1gO1xuICAgICAgICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGxheWVyc1RvT3V0cHV0U2hhcGVzW3NoYXBlS2V5XTtcbiAgICAgICAgICAgIGlucHV0U2hhcGVzLnB1c2goaW5wdXRTaGFwZSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBsYXllci5jb21wdXRlT3V0cHV0U2hhcGUoXG4gICAgICAgICAgICAgIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShpbnB1dFNoYXBlcykpO1xuXG4gICAgICAgICAgY29uc3Qgb3V0cHV0U2hhcGVzID0gdHlwZXNfdXRpbHMubm9ybWFsaXplU2hhcGVMaXN0KG91dHB1dFNoYXBlKTtcbiAgICAgICAgICBjb25zdCBub2RlSW5kZXggPSBsYXllci5pbmJvdW5kTm9kZXMuaW5kZXhPZihub2RlKTtcbiAgICAgICAgICBmb3IgKGxldCBqID0gMDsgaiA8IG91dHB1dFNoYXBlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgY29uc3Qgc2hhcGVLZXkgPSBgJHtsYXllci5uYW1lfV8ke25vZGVJbmRleH1fJHtqfWA7XG4gICAgICAgICAgICBsYXllcnNUb091dHB1dFNoYXBlc1tzaGFwZUtleV0gPSBvdXRwdXRTaGFwZXNbal07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmVhZCBmaW5hbCBvdXRwdXQgc2hhcGVzIGZyb20gbGF5ZXJzVG9PdXRwdXRTaGFwZXMuXG4gICAgY29uc3Qgb3V0cHV0U2hhcGVzOiBTaGFwZVtdID0gW107XG4gICAgY29uc3Qgb3V0cHV0U2hhcGVLZXlzOiBzdHJpbmdbXSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5vdXRwdXRMYXllcnNbaV07XG4gICAgICBjb25zdCBub2RlSW5kZXggPSB0aGlzLm91dHB1dExheWVyc05vZGVJbmRpY2VzW2ldO1xuICAgICAgY29uc3QgdGVuc29ySW5kZXggPSB0aGlzLm91dHB1dExheWVyc1RlbnNvckluZGljZXNbaV07XG4gICAgICBjb25zdCBzaGFwZUtleSA9IGAke2xheWVyLm5hbWV9XyR7bm9kZUluZGV4fV8ke3RlbnNvckluZGV4fWA7XG4gICAgICBvdXRwdXRTaGFwZUtleXMucHVzaChzaGFwZUtleSk7XG4gICAgfVxuXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvdXRwdXRTaGFwZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGtleSA9IG91dHB1dFNoYXBlS2V5c1tpXTtcbiAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KGtleSBpbiBsYXllcnNUb091dHB1dFNoYXBlcyk7XG4gICAgICBvdXRwdXRTaGFwZXMucHVzaChsYXllcnNUb091dHB1dFNoYXBlc1trZXldKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IFVwZGF0ZSBjYWNoZVxuICAgIHJldHVybiBnZW5lcmljX3V0aWxzLnNpbmdsZXRvbk9yQXJyYXkob3V0cHV0U2hhcGVzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyBvdXRwdXQgdGVuc29ycyBmb3IgbmV3IGlucHV0cy5cbiAgICpcbiAgICogTm90ZTpcbiAgICogICAtIEV4cGVjdHMgYGlucHV0c2AgdG8gYmUgYSBsaXN0IChwb3RlbnRpYWxseSB3aXRoIDEgZWxlbWVudCkuXG4gICAqXG4gICAqIEBwYXJhbSBpbnB1dHMgTGlzdCBvZiB0ZW5zb3JzXG4gICAqIEBwYXJhbSBtYXNrcyBMaXN0IG9mIG1hc2tzICh0ZW5zb3JzIG9yIG51bGwpLlxuICAgKiBAcmV0dXJuIFRocmVlIGxpc3RzOiBvdXRwdXRUZW5zb3JzLCBvdXRwdXRNYXNrcywgb3V0cHV0U2hhcGVzXG4gICAqL1xuICBwcm90ZWN0ZWQgcnVuSW50ZXJuYWxHcmFwaChpbnB1dHM6IFRlbnNvcltdLCBtYXNrcz86IFRlbnNvcltdKTpcbiAgICAgIFtUZW5zb3JbXSwgVGVuc29yW10sIFNoYXBlW11dIHtcbiAgICBpZiAobWFza3MgPT0gbnVsbCkge1xuICAgICAgbWFza3MgPSBnZW5lcmljX3V0aWxzLnB5TGlzdFJlcGVhdChudWxsLCBpbnB1dHMubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvLyBEaWN0aW9uYXJ5IG1hcHBpbmcgcmVmZXJlbmNlIHRlbnNvcnMgdG8gdHVwbGVzXG4gICAgLy8gKGNvbXB1dGVkIHRlbnNvciwgY29tcHV0ZSBtYXNrKVxuICAgIC8vIHdlIGFzc3VtZSBhIDE6MSBtYXBwaW5nIGZyb20gdGVuc29yIHRvIG1hc2tcbiAgICAvLyBUT0RPOiByYWlzZSBleGNlcHRpb24gd2hlbiBhIGAuY29tcHV0ZU1hc2soKWAgY2FsbFxuICAgIC8vIGRvZXMgbm90IHJldHVybiBhIGxpc3QgdGhlIHNhbWUgc2l6ZSBhcyBgY2FsbGBcbiAgICBjb25zdCB0ZW5zb3JNYXA6IHtbdGVuc29ySUQ6IHN0cmluZ106IFtUZW5zb3IsIFRlbnNvcl19ID0ge307XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgeCA9IHRoaXMuaW5wdXRzW2ldO1xuICAgICAgY29uc3QgeSA9IGlucHV0c1tpXTtcbiAgICAgIGNvbnN0IG1hc2sgPSBtYXNrc1tpXTtcbiAgICAgIHRlbnNvck1hcFt4LmlkXSA9IFt5LCBtYXNrXTtcbiAgICB9XG5cbiAgICBjb25zdCBkZXB0aEtleXMgPSBPYmplY3Qua2V5cyh0aGlzLm5vZGVzQnlEZXB0aClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCh4ID0+IHBhcnNlSW50KHgsIDEwKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLnNvcnQoZ2VuZXJpY191dGlscy5yZXZlcnNlTnVtYmVyQ29tcGFyZSk7XG4gICAgZm9yIChjb25zdCBkZXB0aCBvZiBkZXB0aEtleXMpIHtcbiAgICAgIGNvbnN0IG5vZGVzID0gdGhpcy5ub2Rlc0J5RGVwdGhbZGVwdGhdO1xuICAgICAgZm9yIChjb25zdCBub2RlIG9mIG5vZGVzKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgYWx3YXlzIGEgc2luZ2xlIGxheWVyLCBuZXZlciBhIGxpc3QuXG4gICAgICAgIGNvbnN0IGxheWVyID0gbm9kZS5vdXRib3VuZExheWVyO1xuICAgICAgICBjb25zdCByZWZlcmVuY2VJbnB1dFRlbnNvcnMgPSBub2RlLmlucHV0VGVuc29ycztcbiAgICAgICAgY29uc3QgcmVmZXJlbmNlT3V0cHV0VGVuc29ycyA9IG5vZGUub3V0cHV0VGVuc29ycztcblxuICAgICAgICAvLyBJZiBhbGwgcHJldmlvdXMgaW5wdXQgdGVuc29ycyBhcmUgYXZhaWxhYmxlIGluIHRlbnNvck1hcCxcbiAgICAgICAgLy8gdGhlbiBjYWxsIG5vZGUuaW5ib3VuZExheWVyIG9uIHRoZW0uXG4gICAgICAgIC8vIExpc3Qgb2YgdHVwbGVzIFtpbnB1dCwgbWFza106XG4gICAgICAgIGNvbnN0IGNvbXB1dGVkRGF0YSA9IG5ldyBBcnJheTxbVGVuc29yLCBUZW5zb3JdPigpO1xuICAgICAgICBmb3IgKGNvbnN0IHggb2YgcmVmZXJlbmNlSW5wdXRUZW5zb3JzKSB7XG4gICAgICAgICAgaWYgKHguaWQgaW4gdGVuc29yTWFwKSB7XG4gICAgICAgICAgICBjb21wdXRlZERhdGEucHVzaCh0ZW5zb3JNYXBbeC5pZF0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tcHV0ZWREYXRhLmxlbmd0aCA9PT0gcmVmZXJlbmNlSW5wdXRUZW5zb3JzLmxlbmd0aCkge1xuICAgICAgICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIEsubmFtZV9zY29wZSBoZXJlLCBpZiB3ZSBuZWVkIGl0LlxuICAgICAgICAgIGxldCBrd2FyZ3M6IEt3YXJncyA9IHt9O1xuICAgICAgICAgIGxldCBjb21wdXRlZFRlbnNvcnM6IFRlbnNvcltdO1xuICAgICAgICAgIGxldCBjb21wdXRlZE1hc2tzOiBUZW5zb3JbXTtcbiAgICAgICAgICBsZXQgb3V0cHV0VGVuc29yczogVGVuc29yW107XG4gICAgICAgICAgbGV0IG91dHB1dE1hc2tzOiBUZW5zb3JbXTtcbiAgICAgICAgICAvLyBjYWxsIGxheWVyXG4gICAgICAgICAgaWYgKG5vZGUuY2FsbEFyZ3MgIT0gbnVsbCkge1xuICAgICAgICAgICAga3dhcmdzID0gbm9kZS5jYWxsQXJncztcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGNvbXB1dGVkRGF0YS5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IFtjb21wdXRlZFRlbnNvciwgY29tcHV0ZWRNYXNrXSA9IGNvbXB1dGVkRGF0YVswXTtcbiAgICAgICAgICAgIGlmIChrd2FyZ3NbJ21hc2snXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGt3YXJnc1snbWFzayddID0gY29tcHV0ZWRNYXNrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgb3V0cHV0VGVuc29ycyA9XG4gICAgICAgICAgICAgICAgZ2VuZXJpY191dGlscy50b0xpc3QobGF5ZXIuY2FsbChjb21wdXRlZFRlbnNvciwga3dhcmdzKSk7XG4gICAgICAgICAgICBvdXRwdXRNYXNrcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KFxuICAgICAgICAgICAgICAgIGxheWVyLmNvbXB1dGVNYXNrKGNvbXB1dGVkVGVuc29yLCBjb21wdXRlZE1hc2spKTtcbiAgICAgICAgICAgIGNvbXB1dGVkVGVuc29ycyA9IFtjb21wdXRlZFRlbnNvcl07XG4gICAgICAgICAgICBjb21wdXRlZE1hc2tzID0gW2NvbXB1dGVkTWFza107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbXB1dGVkVGVuc29ycyA9IGNvbXB1dGVkRGF0YS5tYXAoeCA9PiB4WzBdKTtcbiAgICAgICAgICAgIGNvbXB1dGVkTWFza3MgPSBjb21wdXRlZERhdGEubWFwKHggPT4geFsxXSk7XG4gICAgICAgICAgICBpZiAoa3dhcmdzWydtYXNrJ10gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBrd2FyZ3NbJ21hc2snXSA9IGNvbXB1dGVkTWFza3M7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvdXRwdXRUZW5zb3JzID1cbiAgICAgICAgICAgICAgICBnZW5lcmljX3V0aWxzLnRvTGlzdChsYXllci5jYWxsKGNvbXB1dGVkVGVuc29ycywga3dhcmdzKSk7XG4gICAgICAgICAgICBvdXRwdXRNYXNrcyA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KFxuICAgICAgICAgICAgICAgIGxheWVyLmNvbXB1dGVNYXNrKGNvbXB1dGVkVGVuc29ycywgY29tcHV0ZWRNYXNrcykpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYXllci5hY3Rpdml0eVJlZ3VsYXJpemVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAgICAgICAnTGF5ZXJzTW9kZWwgaW52b2NhdGlvbiB3aXRoIGNvbmNyZXRlIFRlbnNvciB2YWx1ZShzKSBpbiB0aGUgJyArXG4gICAgICAgICAgICAgICAgJ3ByZXNlbmNlIG9mIGFjdGl2aXR5IHJlZ3VsYXJpemVyKHMpIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IEFkZCBtb2RlbCB1cGRhdGVzIGFuZCBsb3NzZXNcblxuICAgICAgICAgIC8vIFVwZGF0ZSB0ZW5zb3IgbWFwLlxuICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVmZXJlbmNlT3V0cHV0VGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgeCA9IHJlZmVyZW5jZU91dHB1dFRlbnNvcnNbaV07XG4gICAgICAgICAgICBjb25zdCB5ID0gb3V0cHV0VGVuc29yc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IG1hc2sgPSBvdXRwdXRNYXNrc1tpXTtcbiAgICAgICAgICAgIHRlbnNvck1hcFt4LmlkXSA9IFt5LCBtYXNrXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRUZW5zb3JzOiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IG91dHB1dE1hc2tzOiBUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlczogU2hhcGVbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgeCBvZiB0aGlzLm91dHB1dHMpIHtcbiAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KFxuICAgICAgICAgIHguaWQgaW4gdGVuc29yTWFwLCBgQ291bGQgbm90IGNvbXB1dGUgb3V0cHV0ICR7eC5uYW1lfSA6ICR7eC5pZH1gKTtcbiAgICAgIGNvbnN0IFt0ZW5zb3IsIG1hc2tdID0gdGVuc29yTWFwW3guaWRdO1xuICAgICAgb3V0cHV0U2hhcGVzLnB1c2godGVuc29yLnNoYXBlKTtcbiAgICAgIG91dHB1dFRlbnNvcnMucHVzaCh0ZW5zb3IpO1xuICAgICAgb3V0cHV0TWFza3MucHVzaChtYXNrKTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IEFkZCBzdXBwb3J0IGZvciBjYWNoZXMuXG4gICAgcmV0dXJuIFtvdXRwdXRUZW5zb3JzLCBvdXRwdXRNYXNrcywgb3V0cHV0U2hhcGVzXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCdWlsZHMgYSBtYXAgb2YgaW50ZXJuYWwgbm9kZSBrZXlzIHRvIG5vZGUgb3JkZXJpbmcuXG4gICAqIFVzZWQgaW4gc2VyaWFsaXphaW9uIGEgbm9kZSBvcmRlcmluZ3MgbWF5IGNoYW5nZSBhcyB1bnVzZWQgbm9kZXMgYXJlXG4gICAqIGRyb3BwZWQuIFBvcnRpbmcgTm90ZTogIFRoaXMgaGVscGVyIG1ldGhvZCB3YXMgcHVsbGVkIG91dCBvZiBnZXRDb25maWcgdG9cbiAgICogaW1wcm92ZSByZWFkYWJpbGl0eS5cbiAgICogQHBhcmFtIGxheWVycyBBbiBhcnJheSBvZiBMYXllcnMgaW4gdGhlIG1vZGVsLlxuICAgKiBAcmV0dXJucyBNYXAgb2YgTm9kZSBLZXlzIHRvIGluZGV4IG9yZGVyIHdpdGhpbiB0aGUgbGF5ZXIuXG4gICAqL1xuICBwcml2YXRlIGJ1aWxkTm9kZUNvbnZlcnNpb25NYXAobGF5ZXJzOiBMYXllcltdKToge1tub2RlS2V5OiBzdHJpbmddOiBudW1iZXJ9IHtcbiAgICBjb25zdCBub2RlQ29udmVyc2lvbk1hcDoge1tub2RlS2V5OiBzdHJpbmddOiBudW1iZXJ9ID0ge307XG4gICAgbGV0IGtlcHROb2RlczogbnVtYmVyO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGtlcHROb2RlcyA9IGxheWVyIGluc3RhbmNlb2YgQ29udGFpbmVyID8gMSA6IDA7XG4gICAgICBmb3IgKGxldCBvcmlnaW5hbE5vZGVJbmRleCA9IDA7XG4gICAgICAgICAgIG9yaWdpbmFsTm9kZUluZGV4IDwgbGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aDsgb3JpZ2luYWxOb2RlSW5kZXgrKykge1xuICAgICAgICBjb25zdCBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG9yaWdpbmFsTm9kZUluZGV4KTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgICAgLy8gaS5lLiB3ZSBtYXJrIGl0IHRvIGJlIHNhdmVkXG4gICAgICAgICAgbm9kZUNvbnZlcnNpb25NYXBbbm9kZUtleV0gPSBrZXB0Tm9kZXM7XG4gICAgICAgICAga2VwdE5vZGVzICs9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG5vZGVDb252ZXJzaW9uTWFwO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyBhIGxheWVyIGJhc2VkIG9uIGVpdGhlciBpdHMgbmFtZSAodW5pcXVlKSBvciBpbmRleC5cbiAgICpcbiAgICogSW5kaWNlcyBhcmUgYmFzZWQgb24gb3JkZXIgb2YgaG9yaXpvbnRhbCBncmFwaCB0cmF2ZXJzYWwgKGJvdHRvbS11cCkuXG4gICAqXG4gICAqIElmIGJvdGggYG5hbWVgIGFuZCBgaW5kZXhgIGFyZSBzcGVjaWZpZWQsIGBpbmRleGAgdGFrZXMgcHJlY2VkZW5jZS5cbiAgICpcbiAgICogQHBhcmFtIG5hbWUgTmFtZSBvZiBsYXllci5cbiAgICogQHBhcmFtIGluZGV4IEluZGV4IG9mIGxheWVyLlxuICAgKiBAcmV0dXJucyBBIExheWVyIGluc3RhbmNlLlxuICAgKiBAdGhyb3dzIFZhbHVlRXJyb3I6IEluIGNhc2Ugb2YgaW52YWxpZCBsYXllciBuYW1lIG9yIGluZGV4LlxuICAgKlxuICAgKiBAZG9jIHtcbiAgICogICAgaGVhZGluZzogJ0xheWVycycsXG4gICAqICAgIHN1YmhlYWRpbmc6ICdDbGFzc2VzJyxcbiAgICogICAgbmFtZXNwYWNlOiAnbGF5ZXJzJyxcbiAgICogICAgc3ViY2xhc3NlczogWydMYXllcnNNb2RlbCddXG4gICAqIH1cbiAgICovXG4gIGdldExheWVyKG5hbWU/OiBzdHJpbmcsIGluZGV4PzogbnVtYmVyKTogTGF5ZXIge1xuICAgIGlmIChpbmRleCAhPSBudWxsKSB7XG4gICAgICBpZiAodGhpcy5sYXllcnMubGVuZ3RoIDw9IGluZGV4KSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYFdhcyBhc2tlZCB0byByZXRyaWV2ZSBsYXllciBhdCBpbmRleCAke2luZGV4fSwgYnV0IG1vZGVsIG9ubHkgYCArXG4gICAgICAgICAgICBgaGFzICR7dGhpcy5sYXllcnMubGVuZ3RofSBsYXllcihzKS5gKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLmxheWVyc1tpbmRleF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChuYW1lID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ1Byb3ZpZGUgZWl0aGVyIGEgbGF5ZXIgbmFtZSBvciBsYXllciBpbmRleCcpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGlmIChsYXllci5uYW1lID09PSBuYW1lKSB7XG4gICAgICAgIHJldHVybiBsYXllcjtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYE5vIHN1Y2ggbGF5ZXI6ICR7bmFtZX1gKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIENvbnRhaW5lcidzIGN1cnJlbnQgbG9zcyB2YWx1ZXMuXG4gICAqXG4gICAqIFVzZWQgZm9yIHJlZ3VsYXJpemVycyBkdXJpbmcgdHJhaW5pbmcuXG4gICAqL1xuICBjYWxjdWxhdGVMb3NzZXMoKTogU2NhbGFyW10ge1xuICAgIC8vIFBvcnRpbmcgTm9kZTogVGhpcyBpcyBhbiBhdWdtZW50YXRpb24gdG8gQ29udGFpbmVyLmxvc3MgaW4gUHlLZXJhcy5cbiAgICAvLyAgIEluIFB5S2VyYXMsIENvbnRhaW5lci5sb3NzIHJldHVybnMgc3ltYm9saWMgdGVuc29ycy4gSGVyZSBhIGNvbmNyZXRlXG4gICAgLy8gICBUZW5zb3IgKHNwZWNpZmljYWxseSBTY2FsYXIpIHZhbHVlcyBhcmUgcmV0dXJuZWQuIFRoaXMgaXMgZHVlIHRvIHRoZVxuICAgIC8vICAgaW1wZXJhdGl2ZSBiYWNrZW5kLlxuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IGxvc3NlczogU2NhbGFyW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgICAgZm9yIChsZXQgbm9kZUluZGV4ID0gMDsgbm9kZUluZGV4IDwgbGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aDtcbiAgICAgICAgICAgICArK25vZGVJbmRleCkge1xuICAgICAgICAgIGNvbnN0IG5vZGVLZXkgPSBDb250YWluZXIubm9kZUtleShsYXllciwgbm9kZUluZGV4KTtcbiAgICAgICAgICBpZiAodGhpcy5jb250YWluZXJOb2Rlcy5oYXMobm9kZUtleSkpIHtcbiAgICAgICAgICAgIGxvc3Nlcy5wdXNoKC4uLmxheWVyLmNhbGN1bGF0ZUxvc3NlcygpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBhbnkgdW5jb25kaXRpb25hbCBtb2RlbC1sZXZlbCBsb3NzZXM/XG4gICAgICByZXR1cm4gbG9zc2VzO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7bmFtZTogdGhpcy5uYW1lfTtcblxuICAgIC8vIEJ1aWxkIGEgbWFwIGZyb20gbGF5ZXIgdW5pcXVlIG5hbWUgKHNlbGYuX25vZGVfa2V5KVxuICAgIC8vIHRvIHRoZSBpbmRleCBvZiB0aGUgbm9kZXMgdGhhdCBhcmUgc2F2ZWQgaW4gdGhlIGNvbmZpZy5cbiAgICAvLyBPbmx5IG5vZGVzIGluIGNvbnRhaW5lcl9ub2RlcyBhcmUgc2F2ZWQuXG4gICAgY29uc3Qgbm9kZUNvbnZlcnNpb25NYXA6IHtbbm9kZUtleTogc3RyaW5nXTogbnVtYmVyfSA9XG4gICAgICAgIHRoaXMuYnVpbGROb2RlQ29udmVyc2lvbk1hcCh0aGlzLmxheWVycyk7XG5cbiAgICAvLyBTZXJpYWxpemUgYW5kIHNhdmUgdGhlIGxheWVycyBpbiBsYXllckNvbmZpZ3NcbiAgICBjb25zdCBsYXllckNvbmZpZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMubGF5ZXJzKSB7XG4gICAgICBjb25zdCBsYXllckNsYXNzTmFtZSA9IGxheWVyLmdldENsYXNzTmFtZSgpO1xuICAgICAgY29uc3QgbGF5ZXJDb25maWcgPSBsYXllci5nZXRDb25maWcoKTtcbiAgICAgIGNvbnN0IGZpbHRlcmVkSW5ib3VuZE5vZGVzID0gW107XG4gICAgICBmb3IgKGxldCBvcmlnaW5hbE5vZGVJbmRleCA9IDA7XG4gICAgICAgICAgIG9yaWdpbmFsTm9kZUluZGV4IDwgbGF5ZXIuaW5ib3VuZE5vZGVzLmxlbmd0aDsgb3JpZ2luYWxOb2RlSW5kZXgrKykge1xuICAgICAgICBjb25zdCBub2RlID0gbGF5ZXIuaW5ib3VuZE5vZGVzW29yaWdpbmFsTm9kZUluZGV4XTtcbiAgICAgICAgY29uc3Qgbm9kZUtleSA9IENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBvcmlnaW5hbE5vZGVJbmRleCk7XG4gICAgICAgIGxldCBrd2FyZ3MgPSB7fTtcbiAgICAgICAgaWYgKHRoaXMuY29udGFpbmVyTm9kZXMuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgICAgLy8gVGhlIG5vZGUgaXMgcmVsZXZhbnQgdG8gdGhlIG1vZGVsOlxuICAgICAgICAgIC8vIGFkZCB0byBmaWx0ZXJlZEluYm91bmROb2Rlcy5cbiAgICAgICAgICBpZiAobm9kZS5jYWxsQXJncykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkobm9kZS5jYWxsQXJncyk7XG4gICAgICAgICAgICAgIGt3YXJncyA9IG5vZGUuY2FsbEFyZ3M7XG4gICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgICAgYExheWVyICR7bGF5ZXIubmFtZX0gd2FzIHBhc3NlZCBgICtcbiAgICAgICAgICAgICAgICAgIGBub24tc2VyaWFsaXphYmxlIGtleXdvcmQgYXJndW1lbnRzOiBgICtcbiAgICAgICAgICAgICAgICAgIGAke25vZGUuY2FsbEFyZ3N9LiBUaGV5IHdpbGwgbm90IGJlIGluY2x1ZGVkIGAgK1xuICAgICAgICAgICAgICAgICAgYGluIHRoZSBzZXJpYWxpemVkIG1vZGVsIChhbmQgdGh1cyB3aWxsIGJlIGAgK1xuICAgICAgICAgICAgICAgICAgYG1pc3NpbmcgYXQgZGVzZXJpYWxpemF0aW9uIHRpbWUpLmApO1xuICAgICAgICAgICAgICBrd2FyZ3MgPSB7fTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG5vZGUuaW5ib3VuZExheWVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBjb25zdCBub2RlRGF0YSA9IFtdO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBub2RlLmluYm91bmRMYXllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgY29uc3QgaW5ib3VuZExheWVyID0gbm9kZS5pbmJvdW5kTGF5ZXJzW2ldO1xuICAgICAgICAgICAgICBjb25zdCBub2RlSW5kZXggPSBub2RlLm5vZGVJbmRpY2VzW2ldO1xuICAgICAgICAgICAgICBjb25zdCB0ZW5zb3JJbmRleCA9IG5vZGUudGVuc29ySW5kaWNlc1tpXTtcbiAgICAgICAgICAgICAgY29uc3Qgbm9kZUtleSA9IENvbnRhaW5lci5ub2RlS2V5KGluYm91bmRMYXllciwgbm9kZUluZGV4KTtcbiAgICAgICAgICAgICAgbGV0IG5ld05vZGVJbmRleCA9IG5vZGVDb252ZXJzaW9uTWFwW25vZGVLZXldO1xuICAgICAgICAgICAgICBpZiAobmV3Tm9kZUluZGV4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2RlSW5kZXggPSAwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIG5vZGVEYXRhLnB1c2goXG4gICAgICAgICAgICAgICAgICBbaW5ib3VuZExheWVyLm5hbWUsIG5ld05vZGVJbmRleCwgdGVuc29ySW5kZXgsIGt3YXJnc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyZWRJbmJvdW5kTm9kZXMucHVzaChub2RlRGF0YSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBjb25zdCBkaWN0OiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7fTtcbiAgICAgIGRpY3RbJ25hbWUnXSA9IGxheWVyLm5hbWU7XG4gICAgICBkaWN0WydjbGFzc05hbWUnXSA9IGxheWVyQ2xhc3NOYW1lO1xuICAgICAgZGljdFsnY29uZmlnJ10gPSBsYXllckNvbmZpZztcbiAgICAgIGRpY3RbJ2luYm91bmROb2RlcyddID0gZmlsdGVyZWRJbmJvdW5kTm9kZXM7XG4gICAgICBsYXllckNvbmZpZ3MucHVzaChkaWN0KTtcbiAgICB9XG4gICAgY29uZmlnWydsYXllcnMnXSA9IGxheWVyQ29uZmlncztcbiAgICAvLyBHYXRoZXIgaW5mbyBhYm91dCBpbnB1dHMgYW5kIG91dHB1dHNcbiAgICBjb25zdCBtb2RlbElucHV0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnB1dExheWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgbGF5ZXIgPSB0aGlzLmlucHV0TGF5ZXJzW2ldO1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0gdGhpcy5pbnB1dExheWVyc05vZGVJbmRpY2VzW2ldO1xuXG4gICAgICBjb25zdCBub2RlS2V5ID0gQ29udGFpbmVyLm5vZGVLZXkobGF5ZXIsIG5vZGVJbmRleCk7XG4gICAgICBpZiAoIXRoaXMuY29udGFpbmVyTm9kZXMuaGFzKG5vZGVLZXkpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGV0IG5ld05vZGVJbmRleCA9IG5vZGVDb252ZXJzaW9uTWFwW25vZGVLZXldO1xuICAgICAgaWYgKG5ld05vZGVJbmRleCA9PT0gbnVsbCB8fCBuZXdOb2RlSW5kZXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBuZXdOb2RlSW5kZXggPSAwO1xuICAgICAgfVxuICAgICAgY29uc3QgdGVuc29ySW5kZXggPSB0aGlzLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlc1tpXTtcbiAgICAgIG1vZGVsSW5wdXRzLnB1c2goW2xheWVyLm5hbWUsIG5ld05vZGVJbmRleCwgdGVuc29ySW5kZXhdKTtcbiAgICB9XG4gICAgY29uZmlnWydpbnB1dExheWVycyddID0gbW9kZWxJbnB1dHM7XG5cbiAgICBjb25zdCBtb2RlbE91dHB1dHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMub3V0cHV0TGF5ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBsYXllciA9IHRoaXMub3V0cHV0TGF5ZXJzW2ldO1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0gdGhpcy5vdXRwdXRMYXllcnNOb2RlSW5kaWNlc1tpXTtcblxuICAgICAgY29uc3Qgbm9kZUtleSA9IENvbnRhaW5lci5ub2RlS2V5KGxheWVyLCBub2RlSW5kZXgpO1xuICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lck5vZGVzLmhhcyhub2RlS2V5KSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCBuZXdOb2RlSW5kZXggPSBub2RlQ29udmVyc2lvbk1hcFtub2RlS2V5XTtcbiAgICAgIGlmIChuZXdOb2RlSW5kZXggPT09IG51bGwgfHwgbmV3Tm9kZUluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgbmV3Tm9kZUluZGV4ID0gMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0gdGhpcy5vdXRwdXRMYXllcnNUZW5zb3JJbmRpY2VzW2ldO1xuICAgICAgbW9kZWxPdXRwdXRzLnB1c2goW2xheWVyLm5hbWUsIG5ld05vZGVJbmRleCwgdGVuc29ySW5kZXhdKTtcbiAgICB9XG4gICAgY29uZmlnWydvdXRwdXRMYXllcnMnXSA9IG1vZGVsT3V0cHV0cztcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgLyoqXG4gICAqIEluc3RhbnRpYXRlcyBhIExheWVyc01vZGVsIGZyb20gaXRzIGNvbmZpZyAob3V0cHV0IG9mIGBnZXRfY29uZmlnKClgKS5cbiAgICogQHBhcmFtIGNscyB0aGUgY2xhc3MgdG8gY3JlYXRlXG4gICAqIEBwYXJhbSBjb25maWcgTGF5ZXJzTW9kZWwgY29uZmlnIGRpY3Rpb25hcnkuXG4gICAqIEBwYXJhbSBjdXN0b21PYmplY3RzIEFuIG9wdGlvbmFsIGRpY3Rpb25hcnkgb2YgY3VzdG9tIG9iamVjdHMuXG4gICAqIEBwYXJhbSBmYXN0V2VpZ2h0SW5pdCBPcHRpb25hbCBmbGFnIHRvIHVzZSBmYXN0IHdlaWdodCBpbml0aWFsaXphdGlvblxuICAgKiAgIGR1cmluZyBkZXNlcmlhbGl6YXRpb24uIFRoaXMgaXMgYXBwbGljYWJsZSB0byBjYXNlcyBpbiB3aGljaFxuICAgKiAgIHRoZSBpbml0aWFsaXphdGlvbiB3aWxsIGJlIGltbWVkaWF0ZWx5IG92ZXJ3cml0dGVuIGJ5IGxvYWRlZCB3ZWlnaHRcbiAgICogICB2YWx1ZXMuIERlZmF1bHQ6IGBmYWxzZWAuXG4gICAqIEByZXR1cm5zIEEgTGF5ZXJzTW9kZWwgaW5zdGFuY2UuXG4gICAqIEB0aHJvd3MgVmFsdWVFcnJvcjogSW4gY2FzZSBvZiBpbXByb3Blcmx5IGZvcm1hdHRlZCBjb25maWcgZGljdC5cbiAgICovXG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgZnJvbUNvbmZpZzxUIGV4dGVuZHMgc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGU+KFxuICAgICAgY2xzOiBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZUNvbnN0cnVjdG9yPFQ+LFxuICAgICAgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QsXG4gICAgICBjdXN0b21PYmplY3RzID0ge30gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0LFxuICAgICAgZmFzdFdlaWdodEluaXQgPSBmYWxzZSk6IFQge1xuICAgIC8vIExheWVyIGluc3RhbmNlcyBjcmVhdGVkIGR1cmluZ1xuICAgIC8vIHRoZSBncmFwaCByZWNvbnN0cnVjdGlvbiBwcm9jZXNzXG4gICAgY29uc3QgY3JlYXRlZExheWVyczoge1tsYXllck5hbWU6IHN0cmluZ106IExheWVyfSA9IHt9O1xuXG4gICAgLy8gRGljdGlvbmFyeSBtYXBwaW5nIGxheWVyIGluc3RhbmNlcyB0b1xuICAgIC8vIG5vZGUgZGF0YSB0aGF0IHNwZWNpZmllcyBhIGxheWVyIGNhbGwuXG4gICAgLy8gSXQgYWN0cyBhcyBhIHF1ZXVlIHRoYXQgbWFpbnRhaW5zIGFueSB1bnByb2Nlc3NlZFxuICAgIC8vIGxheWVyIGNhbGwgdW50aWwgaXQgYmVjb21lcyBwb3NzaWJsZSB0byBwcm9jZXNzIGl0XG4gICAgLy8gKGkuZS4gdW50aWwgdGhlIGlucHV0IHRlbnNvcnMgdG8gdGhlIGNhbGwgYWxsIGV4aXN0KS5cbiAgICBjb25zdCB1bnByb2Nlc3NlZE5vZGVzOiB7W2xheWVyOiBzdHJpbmddOiBUZW5zb3JLZXlXaXRoQXJnc0FycmF5W11bXX0gPSB7fTtcbiAgICBmdW5jdGlvbiBhZGRVbnByb2Nlc3NlZE5vZGUoXG4gICAgICAgIGxheWVyOiBMYXllciwgbm9kZURhdGE6IFRlbnNvcktleVdpdGhBcmdzQXJyYXlbXSkge1xuICAgICAgaWYgKCEobGF5ZXIubmFtZSBpbiB1bnByb2Nlc3NlZE5vZGVzKSkge1xuICAgICAgICB1bnByb2Nlc3NlZE5vZGVzW2xheWVyLm5hbWVdID0gW25vZGVEYXRhXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVucHJvY2Vzc2VkTm9kZXNbbGF5ZXIubmFtZV0ucHVzaChub2RlRGF0YSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcHJvY2Vzc05vZGUobGF5ZXI6IExheWVyLCBub2RlRGF0YTogVGVuc29yS2V5V2l0aEFyZ3NBcnJheVtdKSB7XG4gICAgICBjb25zdCBpbnB1dFRlbnNvcnM6IFN5bWJvbGljVGVuc29yW10gPSBbXTtcbiAgICAgIGxldCBrd2FyZ3M7XG4gICAgICBmb3IgKGNvbnN0IGlucHV0RGF0YSBvZiBub2RlRGF0YSkge1xuICAgICAgICBjb25zdCBpbmJvdW5kTGF5ZXJOYW1lID0gaW5wdXREYXRhWzBdO1xuICAgICAgICBjb25zdCBpbmJvdW5kTm9kZUluZGV4ID0gaW5wdXREYXRhWzFdO1xuICAgICAgICBjb25zdCBpbmJvdW5kVGVuc29ySW5kZXggPSBpbnB1dERhdGFbMl07XG5cbiAgICAgICAga3dhcmdzID0gaW5wdXREYXRhWzNdID09IG51bGwgP1xuICAgICAgICAgICAge30gOlxuICAgICAgICAgICAgaW5wdXREYXRhWzNdIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdDtcbiAgICAgICAgaWYgKCEoaW5ib3VuZExheWVyTmFtZSBpbiBjcmVhdGVkTGF5ZXJzKSkge1xuICAgICAgICAgIGFkZFVucHJvY2Vzc2VkTm9kZShsYXllciwgbm9kZURhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmJvdW5kTGF5ZXIgPSBjcmVhdGVkTGF5ZXJzW2luYm91bmRMYXllck5hbWVdO1xuICAgICAgICBpZiAoaW5ib3VuZExheWVyLmluYm91bmROb2Rlcy5sZW5ndGggPD0gaW5ib3VuZE5vZGVJbmRleCkge1xuICAgICAgICAgIGFkZFVucHJvY2Vzc2VkTm9kZShsYXllciwgbm9kZURhdGEpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmJvdW5kTm9kZSA9IGluYm91bmRMYXllci5pbmJvdW5kTm9kZXNbaW5ib3VuZE5vZGVJbmRleF07XG4gICAgICAgIGlucHV0VGVuc29ycy5wdXNoKGluYm91bmROb2RlLm91dHB1dFRlbnNvcnNbaW5ib3VuZFRlbnNvckluZGV4XSk7XG4gICAgICB9XG4gICAgICAvLyBDYWxsIGxheWVyIG9uIGl0cyBpbnB1dHMsIHRodXMgY3JlYXRpbmcgdGhlIG5vZGVcbiAgICAgIC8vIGFuZCBidWlsZGluZyB0aGUgbGF5ZXIgaWYgbmVlZGVkLlxuICAgICAgLy8gTm90ZTogVGhpcyBoYXMgRWFnZXIgdnMgR3JhcGggSW1wbGljYXRpb25zLlxuICAgICAgaWYgKGlucHV0VGVuc29ycy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGxheWVyLmFwcGx5KFxuICAgICAgICAgICAgZ2VuZXJpY191dGlscy5zaW5nbGV0b25PckFycmF5KGlucHV0VGVuc29ycyksXG4gICAgICAgICAgICBrd2FyZ3MpOyAgLy8gd2FzICoqIGt3YXJnc1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlc2VyaWFsaXplIGEgbGF5ZXIsIHRoZW4gY2FsbCBpdCBvbiBhcHByb3ByaWF0ZSBpbnB1dHMuXG4gICAgICogQHBhcmFtIGxheWVyRGF0YTogbGF5ZXIgY29uZmlnIGRpY3QuXG4gICAgICogQHRocm93cyBWYWx1ZUVycm9yOiBJbiBjYXNlIG9mIGltcHJvcGVybHkgZm9ybWF0dGVkIGBsYXllcl9kYXRhYFxuICAgICAqIGRpY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvY2Vzc0xheWVyKGxheWVyRGF0YTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0fG51bGwpIHtcbiAgICAgIGNvbnN0IGxheWVyTmFtZSA9IGxheWVyRGF0YVsnbmFtZSddIGFzIHN0cmluZztcbiAgICAgIC8vIEluc3RhbnRpYXRlIGxheWVyLlxuICAgICAgY29uc3QgbGF5ZXIgPVxuICAgICAgICAgIGRlc2VyaWFsaXplTGF5ZXIoXG4gICAgICAgICAgICAgIGxheWVyRGF0YSxcbiAgICAgICAgICAgICAgY29uZmlnWydjdXN0b21PYmplY3RzJ10gIT0gbnVsbCA/XG4gICAgICAgICAgICAgICAgICBjb25maWdbJ2N1c3RvbU9iamVjdHMnXSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgOlxuICAgICAgICAgICAgICAgICAge30pIGFzIExheWVyO1xuICAgICAgbGF5ZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZChmYXN0V2VpZ2h0SW5pdCk7XG4gICAgICBjcmVhdGVkTGF5ZXJzW2xheWVyTmFtZV0gPSBsYXllcjtcbiAgICAgIC8vIEdhdGhlciBsYXllciBpbnB1dHMuXG4gICAgICBjb25zdCBpbmJvdW5kTm9kZXNEYXRhID1cbiAgICAgICAgICBsYXllckRhdGFbJ2luYm91bmROb2RlcyddIGFzIFRlbnNvcktleVdpdGhBcmdzQXJyYXlbXVtdO1xuICAgICAgaW5ib3VuZE5vZGVzRGF0YS5mb3JFYWNoKG5vZGVEYXRhID0+IHtcbiAgICAgICAgaWYgKCEobm9kZURhdGEgaW5zdGFuY2VvZiBBcnJheSkpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgYENvcnJ1cHRlZCBjb25maWd1cmF0aW9uLCBleHBlY3RlZCBhcnJheSBmb3Igbm9kZURhdGE6ICR7XG4gICAgICAgICAgICAgICAgICBub2RlRGF0YX1gKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBXZSBkb24ndCBwcm9jZXNzIG5vZGVzIChpLmUuIG1ha2UgbGF5ZXIgY2FsbHMpXG4gICAgICAgIC8vIG9uIHRoZSBmbHkgYmVjYXVzZSB0aGUgaW5ib3VuZCBub2RlIG1heSBub3QgeWV0IGV4aXN0LFxuICAgICAgICAvLyBpbiBjYXNlIG9mIGxheWVyIHNoYXJlZCBhdCBkaWZmZXJlbnQgdG9wb2xvZ2ljYWwgZGVwdGhzXG4gICAgICAgIC8vIChlLmcuYSBtb2RlbCBzdWNoIGFzIEEoQihBKEIoeCkpKSkpXG4gICAgICAgIGFkZFVucHJvY2Vzc2VkTm9kZShsYXllciwgbm9kZURhdGEpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRmlyc3QsIHdlIGNyZWF0ZSBhbGwgbGF5ZXJzIGFuZCBlbnF1ZXVlIG5vZGVzIHRvIGJlIHByb2Nlc3NlZC5cbiAgICBjb25zdCBuYW1lID0gY29uZmlnWyduYW1lJ107XG4gICAgY29uc3QgbGF5ZXJzRnJvbUNvbmZpZyA9IGNvbmZpZ1snbGF5ZXJzJ10gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0W107XG4gICAgZm9yIChjb25zdCBsYXllckRhdGEgb2YgbGF5ZXJzRnJvbUNvbmZpZykge1xuICAgICAgcHJvY2Vzc0xheWVyKGxheWVyRGF0YSk7XG4gICAgfVxuXG4gICAgLy8gVGhlbiB3ZSBwcm9jZXNzIG5vZGVzIGluIG9yZGVyIG9mIGxheWVyIGRlcHRoLlxuICAgIC8vIE5vZGVzIHRoYXQgY2Fubm90IHlldCBiZSBwcm9jZXNzZWQoaWYgdGhlIGluYm91bmQgbm9kZVxuICAgIC8vIGRvZXMgbm90IHlldCBleGlzdCkgYXJlIHJlIC0gZW5xdWV1ZWQsIGFuZCB0aGUgcHJvY2Vzc1xuICAgIC8vIGlzIHJlcGVhdGVkIHVudGlsIGFsbCBub2RlcyBhcmUgcHJvY2Vzc2VkLlxuICAgIHdoaWxlICghZ2VuZXJpY191dGlscy5pc09iamVjdEVtcHR5KHVucHJvY2Vzc2VkTm9kZXMpKSB7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyRGF0YSBvZiBsYXllcnNGcm9tQ29uZmlnKSB7XG4gICAgICAgIGNvbnN0IGxheWVyID0gY3JlYXRlZExheWVyc1tsYXllckRhdGFbJ25hbWUnXSBhcyBzdHJpbmddO1xuICAgICAgICBpZiAobGF5ZXIubmFtZSBpbiB1bnByb2Nlc3NlZE5vZGVzKSB7XG4gICAgICAgICAgY29uc3QgY3VycmVudFVucHJvY2Vzc2VkTm9kZXNGb3JMYXllciA9IHVucHJvY2Vzc2VkTm9kZXNbbGF5ZXIubmFtZV07XG4gICAgICAgICAgZGVsZXRlIHVucHJvY2Vzc2VkTm9kZXNbbGF5ZXIubmFtZV07XG4gICAgICAgICAgZm9yIChjb25zdCBub2RlRGF0YSBvZiBjdXJyZW50VW5wcm9jZXNzZWROb2Rlc0ZvckxheWVyKSB7XG4gICAgICAgICAgICBwcm9jZXNzTm9kZShsYXllciwgbm9kZURhdGEpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IGlucHV0VGVuc29yczogU3ltYm9saWNUZW5zb3JbXSA9IFtdO1xuICAgIGNvbnN0IG91dHB1dFRlbnNvcnM6IFN5bWJvbGljVGVuc29yW10gPSBbXTtcbiAgICBjb25zdCBpbnB1dExheWVyc0Zyb21Db25maWcgPVxuICAgICAgICBjb25maWdbJ2lucHV0TGF5ZXJzJ10gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0W107XG4gICAgZm9yIChjb25zdCBsYXllckRhdGEgb2YgaW5wdXRMYXllcnNGcm9tQ29uZmlnKSB7XG4gICAgICBjb25zdCBsYXllck5hbWUgPSBsYXllckRhdGFbMF0gYXMgc3RyaW5nO1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0gbGF5ZXJEYXRhWzFdIGFzIG51bWJlcjtcbiAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0gbGF5ZXJEYXRhWzJdIGFzIG51bWJlcjtcbiAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KGxheWVyTmFtZSBpbiBjcmVhdGVkTGF5ZXJzKTtcbiAgICAgIGNvbnN0IGxheWVyID0gY3JlYXRlZExheWVyc1tsYXllck5hbWVdO1xuICAgICAgY29uc3QgbGF5ZXJPdXRwdXRUZW5zb3JzID0gbGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF0ub3V0cHV0VGVuc29ycztcbiAgICAgIGlucHV0VGVuc29ycy5wdXNoKGxheWVyT3V0cHV0VGVuc29yc1t0ZW5zb3JJbmRleF0pO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRMYXllcnNGcm9tQ29uZmlnID1cbiAgICAgICAgY29uZmlnWydvdXRwdXRMYXllcnMnXSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RbXTtcbiAgICBmb3IgKGNvbnN0IGxheWVyRGF0YSBvZiBvdXRwdXRMYXllcnNGcm9tQ29uZmlnKSB7XG4gICAgICBjb25zdCBsYXllck5hbWUgPSBsYXllckRhdGFbMF0gYXMgc3RyaW5nO1xuICAgICAgY29uc3Qgbm9kZUluZGV4ID0gbGF5ZXJEYXRhWzFdIGFzIG51bWJlcjtcbiAgICAgIGNvbnN0IHRlbnNvckluZGV4ID0gbGF5ZXJEYXRhWzJdIGFzIG51bWJlcjtcbiAgICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0KGxheWVyTmFtZSBpbiBjcmVhdGVkTGF5ZXJzKTtcbiAgICAgIGNvbnN0IGxheWVyID0gY3JlYXRlZExheWVyc1tsYXllck5hbWVdO1xuICAgICAgY29uc3QgbGF5ZXJPdXRwdXRUZW5zb3JzID0gbGF5ZXIuaW5ib3VuZE5vZGVzW25vZGVJbmRleF0ub3V0cHV0VGVuc29ycztcbiAgICAgIG91dHB1dFRlbnNvcnMucHVzaChsYXllck91dHB1dFRlbnNvcnNbdGVuc29ySW5kZXhdKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjbHMoe2lucHV0czogaW5wdXRUZW5zb3JzLCBvdXRwdXRzOiBvdXRwdXRUZW5zb3JzLCBuYW1lfSk7XG4gIH1cblxuICAvKipcbiAgICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGNvbnRhaW5lciBpcyBzdGF0ZWZ1bC5cbiAgICpcbiAgICogUG9ydGluZyBOb3RlOiB0aGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIHRoZSBzdGF0ZWZ1bCBAcHJvcGVydHkgb2ZcbiAgICogICB0aGUgQ29udGFpbmVyIGNsYXNzIGluIFB5S2VyYXMuXG4gICAqL1xuICBnZXQgc3RhdGVmdWwoKTogYm9vbGVhbiB7XG4gICAgLy8gUG9ydGluZyBOb3RlOiBUaGlzIGNoZWNrIGlzIHRvIHByZXZlbnQgaW5hZHZlcnRlbnQgc2V0dGluZyBvZiB0aGVcbiAgICAvLyAgIF9zdGF0ZWZ1bCBwcm9wZXJ0eSBvZiB0aGUgQ29udGFpbmVyIGluc3RhbmNlLlxuICAgIGlmICh0aGlzLl9zdGF0ZWZ1bCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ0NvbnRhaW5lciBpbnN0YW5jZSB1bmV4cGVjdGVkbHkgaGFzIF9zdGF0ZWZ1bCA9IHRydWUuIFRoZSAnICtcbiAgICAgICAgICAnc3RhdGVmdWxuZXNzIG9mIGEgQ29udGFpbmVyIGlzIGRldGVybWluZWQgYnkgdGhlIExheWVycyBpdCAnICtcbiAgICAgICAgICAnY29udGFpbnMuIEl0cyBfc3RhdGVmdWwgcHJvcGVydHkgbXVzdCByZW1haW4gdGhlIGRlZmF1bHQgZmFsc2UuJyk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGlmIChsYXllci5zdGF0ZWZ1bCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlc2V0IHRoZSBzdGF0ZSBvZiBhbGwgc3RhdGVmdWwgY29uc3RpdHVlbnQgbGF5ZXJzIChpZiBhbnkpLlxuICAgKlxuICAgKiBFeGFtcGxlcyBvZiBzdGF0ZWZ1bCBsYXllcnMgaW5jbHVkZSBSTk4gbGF5ZXJzIHdob3NlIGBzdGF0ZWZ1bGAgcHJvcGVydHlcbiAgICogaXMgc2V0IGFzIGB0cnVlYC5cbiAgICovXG4gIHJlc2V0U3RhdGVzKCkge1xuICAgIHRpZHkoKCkgPT4ge1xuICAgICAgdGhpcy5sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWFueVxuICAgICAgICBpZiAobGF5ZXIuc3RhdGVmdWwpIHtcbiAgICAgICAgICBsYXllci5yZXNldFN0YXRlcygpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHRzbGludDplbmFibGU6bm8tYW55XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { argMax, clone, dispose, mul, reshape, tensor1d, tidy } from '@tensorflow/tfjs-core';\nfunction standardizeSampleOrClassWeights(xWeight, outputNames, weightType) {\n    const numOutputs = outputNames.length;\n    if (xWeight == null || (Array.isArray(xWeight) && xWeight.length === 0)) {\n        return outputNames.map(name => null);\n    }\n    if (numOutputs === 1) {\n        if (Array.isArray(xWeight) && xWeight.length === 1) {\n            return xWeight;\n        }\n        else if (typeof xWeight === 'object' && outputNames[0] in xWeight) {\n            return [xWeight[outputNames[0]]];\n        }\n        else {\n            return [xWeight];\n        }\n    }\n    if (Array.isArray(xWeight)) {\n        if (xWeight.length !== numOutputs) {\n            throw new Error(`Provided ${weightType} is an array of ${xWeight.length} ` +\n                `element(s), but the model has ${numOutputs} outputs. ` +\n                `Make sure a set of weights is provided for each model output.`);\n        }\n        return xWeight;\n    }\n    else if (typeof xWeight === 'object' && Object.keys(xWeight).length > 0 &&\n        typeof xWeight[Object.keys(xWeight)[0]] ===\n            'object') {\n        const output = [];\n        outputNames.forEach(outputName => {\n            if (outputName in xWeight) {\n                output.push(xWeight[outputName]);\n            }\n            else {\n                output.push(null);\n            }\n        });\n        return output;\n    }\n    else {\n        throw new Error(`The model has multiple (${numOutputs}) outputs, ` +\n            `so ${weightType} must be either an array with ` +\n            `${numOutputs} elements or an object with ${outputNames} keys. ` +\n            `Provided ${weightType} not understood: ${JSON.stringify(xWeight)}`);\n    }\n}\n/**\n * Standardize class weighting objects.\n *\n * This function takes a single class-weighting object, an array of them,\n * or a map from output name to class-weighting object. It compares it to the\n * output name(s) of the model, base on which it outputs an array of\n * class-weighting objects of which the length matches the number of outputs.\n *\n * @param classWeight Input class-weighting object(s).\n * @param outputNames All output name(s) of the model.\n * @return An array of class-weighting objects. The length of the array matches\n *   the model's number of outputs.\n */\nexport function standardizeClassWeights(classWeight, outputNames) {\n    return standardizeSampleOrClassWeights(classWeight, outputNames, 'classWeight');\n}\nexport function standardizeSampleWeights(classWeight, outputNames) {\n    return standardizeSampleOrClassWeights(classWeight, outputNames, 'sampleWeight');\n}\n/**\n * Standardize by-sample and/or by-class weights for training.\n *\n * Note that this function operates on one model output at a time. For a model\n * with multiple outputs, you must call this function multiple times.\n *\n * @param y The target tensor that the by-sample and/or by-class weight is for.\n *     The values of y are assumed to encode the classes, either directly\n *     as an integer index, or as one-hot encoding.\n * @param sampleWeight By-sample weights.\n * @param classWeight By-class weights: an object mapping class indices\n *     (integers) to a weight (float) to apply to the model's loss for the\n *     samples from this class during training. This can be useful to tell the\n *     model to \"pay more attention\" to samples from an under-represented class.\n * @param sampleWeightMode The mode for the sample weights.\n * @return A Promise of weight tensor, of which the size of the first dimension\n *     matches that of `y`.\n */\nexport async function standardizeWeights(y, sampleWeight, classWeight, sampleWeightMode) {\n    if (sampleWeight != null || sampleWeightMode != null) {\n        // TODO(cais): Once 'temporal' mode is implemented, document it in the doc\n        // string.\n        throw new Error('Support sampleWeight is not implemented yet');\n    }\n    if (classWeight != null) {\n        // Apply class weights per sample.\n        const yClasses = tidy(() => {\n            if (y.shape.length === 1) {\n                // Assume class indices.\n                return clone(y);\n            }\n            else if (y.shape.length === 2) {\n                if (y.shape[1] > 1) {\n                    // Assume one-hot encoding of classes.\n                    const axis = 1;\n                    return argMax(y, axis);\n                }\n                else if (y.shape[1] === 1) {\n                    // Class index.\n                    return reshape(y, [y.shape[0]]);\n                }\n                else {\n                    throw new Error(`Encountered unexpected last-dimension size (${y.shape[1]}) ` +\n                        `during handling of class weights. The size is expected to be ` +\n                        `>= 1.`);\n                }\n            }\n            else {\n                throw new Error(`Unexpected rank of target (y) tensor (${y.rank}) during ` +\n                    `handling of class weights. The rank is expected to be 1 or 2.`);\n            }\n        });\n        const yClassIndices = Array.from(await yClasses.data());\n        dispose(yClasses);\n        const classSampleWeight = [];\n        yClassIndices.forEach(classIndex => {\n            if (classWeight[classIndex] == null) {\n                throw new Error(`classWeight must contain all classes in the training data. ` +\n                    `The class ${classIndex} exists in the data but not in ` +\n                    `classWeight`);\n            }\n            else {\n                classSampleWeight.push(classWeight[classIndex]);\n            }\n        });\n        return tensor1d(classSampleWeight, 'float32');\n    }\n    else {\n        return null;\n    }\n}\n/**\n * Apply per-sample weights on the loss values from a number of samples.\n *\n * @param losses Loss tensor of shape `[batchSize]`.\n * @param sampleWeights Per-sample weight tensor of shape `[batchSize]`.\n * @returns Tensor of the same shape as`losses`.\n */\nexport function computeWeightedLoss(losses, sampleWeights) {\n    return mul(losses, sampleWeights);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmdfdXRpbHMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvZW5naW5lL3RyYWluaW5nX3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFDLE1BQU0sRUFBRSxLQUFLLEVBQUUsT0FBTyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQW9CLFFBQVEsRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQXVCN0csU0FBUywrQkFBK0IsQ0FDcEMsT0FBaUQsRUFBRSxXQUFxQixFQUN4RSxVQUF3QztJQUMxQyxNQUFNLFVBQVUsR0FBRyxXQUFXLENBQUMsTUFBTSxDQUFDO0lBQ3RDLElBQUksT0FBTyxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLENBQUMsRUFBRTtRQUN2RSxPQUFPLFdBQVcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUN0QztJQUNELElBQUksVUFBVSxLQUFLLENBQUMsRUFBRTtRQUNwQixJQUFJLEtBQUssQ0FBQyxPQUFPLENBQUMsT0FBTyxDQUFDLElBQUksT0FBTyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDbEQsT0FBTyxPQUFPLENBQUM7U0FDaEI7YUFBTSxJQUFJLE9BQU8sT0FBTyxLQUFLLFFBQVEsSUFBSSxXQUFXLENBQUMsQ0FBQyxDQUFDLElBQUksT0FBTyxFQUFFO1lBQ25FLE9BQU8sQ0FBRSxPQUEwQixDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDdEQ7YUFBTTtZQUNMLE9BQU8sQ0FBQyxPQUFzQixDQUFDLENBQUM7U0FDakM7S0FDRjtJQUNELElBQUksS0FBSyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENB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dXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7YXJnTWF4LCBjbG9uZSwgZGlzcG9zZSwgbXVsLCByZXNoYXBlLCBUZW5zb3IsIFRlbnNvcjFELCB0ZW5zb3IxZCwgdGlkeX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuLyoqXG4gKiBGb3IgbXVsdGktY2xhc3MgY2xhc3NpZmljYXRpb24gcHJvYmxlbXMsIHRoaXMgb2JqZWN0IGlzIGRlc2lnbmVkIHRvIHN0b3JlIGFcbiAqIG1hcHBpbmcgZnJvbSBjbGFzcyBpbmRleCB0byB0aGUgXCJ3ZWlnaHRcIiBvZiB0aGUgY2xhc3MsIHdoZXJlIGhpZ2hlciB3ZWlnaHRlZFxuICogY2xhc3NlcyBoYXZlIGxhcmdlciBpbXBhY3Qgb24gbG9zcywgYWNjdXJhY3ksIGFuZCBvdGhlciBtZXRyaWNzLlxuICpcbiAqIFRoaXMgaXMgdXNlZnVsIGZvciBjYXNlcyBpbiB3aGljaCB5b3Ugd2FudCB0aGUgbW9kZWwgdG8gXCJwYXkgbW9yZSBhdHRlbnRpb25cIlxuICogdG8gZXhhbXBsZXMgZnJvbSBhbiB1bmRlci1yZXByZXNlbnRlZCBjbGFzcywgZS5nLiwgaW4gdW5iYWxhbmNlZCBkYXRhc2V0cy5cbiAqL1xuZXhwb3J0IHR5cGUgQ2xhc3NXZWlnaHQgPSB7XG4gIFtjbGFzc0luZGV4OiBudW1iZXJdOiBudW1iZXJcbn07XG5cbi8qKlxuICogQ2xhc3Mgd2VpZ2h0aW5nIGZvciBhIG1vZGVsIHdpdGggbXVsdGlwbGUgb3V0cHV0cy5cbiAqXG4gKiBUaGlzIG9iamVjdCBtYXBzIGVhY2ggb3V0cHV0IG5hbWUgdG8gYSBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0LlxuICovXG5leHBvcnQgdHlwZSBDbGFzc1dlaWdodE1hcCA9IHtcbiAgW291dHB1dE5hbWU6IHN0cmluZ106IENsYXNzV2VpZ2h0XG59O1xuXG5mdW5jdGlvbiBzdGFuZGFyZGl6ZVNhbXBsZU9yQ2xhc3NXZWlnaHRzKFxuICAgIHhXZWlnaHQ6IENsYXNzV2VpZ2h0fENsYXNzV2VpZ2h0W118Q2xhc3NXZWlnaHRNYXAsIG91dHB1dE5hbWVzOiBzdHJpbmdbXSxcbiAgICB3ZWlnaHRUeXBlOiAnc2FtcGxlV2VpZ2h0J3wnY2xhc3NXZWlnaHQnKTogQ2xhc3NXZWlnaHRbXSB7XG4gIGNvbnN0IG51bU91dHB1dHMgPSBvdXRwdXROYW1lcy5sZW5ndGg7XG4gIGlmICh4V2VpZ2h0ID09IG51bGwgfHwgKEFycmF5LmlzQXJyYXkoeFdlaWdodCkgJiYgeFdlaWdodC5sZW5ndGggPT09IDApKSB7XG4gICAgcmV0dXJuIG91dHB1dE5hbWVzLm1hcChuYW1lID0+IG51bGwpO1xuICB9XG4gIGlmIChudW1PdXRwdXRzID09PSAxKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoeFdlaWdodCkgJiYgeFdlaWdodC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHJldHVybiB4V2VpZ2h0O1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHhXZWlnaHQgPT09ICdvYmplY3QnICYmIG91dHB1dE5hbWVzWzBdIGluIHhXZWlnaHQpIHtcbiAgICAgIHJldHVybiBbKHhXZWlnaHQgYXMgQ2xhc3NXZWlnaHRNYXApW291dHB1dE5hbWVzWzBdXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbeFdlaWdodCBhcyBDbGFzc1dlaWdodF07XG4gICAgfVxuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHhXZWlnaHQpKSB7XG4gICAgaWYgKHhXZWlnaHQubGVuZ3RoICE9PSBudW1PdXRwdXRzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgYFByb3ZpZGVkICR7d2VpZ2h0VHlwZX0gaXMgYW4gYXJyYXkgb2YgJHt4V2VpZ2h0Lmxlbmd0aH0gYCArXG4gICAgICAgICAgYGVsZW1lbnQocyksIGJ1dCB0aGUgbW9kZWwgaGFzICR7bnVtT3V0cHV0c30gb3V0cHV0cy4gYCArXG4gICAgICAgICAgYE1ha2Ugc3VyZSBhIHNldCBvZiB3ZWlnaHRzIGlzIHByb3ZpZGVkIGZvciBlYWNoIG1vZGVsIG91dHB1dC5gKTtcbiAgICB9XG4gICAgcmV0dXJuIHhXZWlnaHQ7XG4gIH0gZWxzZSBpZiAoXG4gICAgICB0eXBlb2YgeFdlaWdodCA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LmtleXMoeFdlaWdodCkubGVuZ3RoID4gMCAmJlxuICAgICAgdHlwZW9mICh4V2VpZ2h0IGFzIENsYXNzV2VpZ2h0TWFwKVtPYmplY3Qua2V5cyh4V2VpZ2h0KVswXV0gPT09XG4gICAgICAgICAgJ29iamVjdCcpIHtcbiAgICBjb25zdCBvdXRwdXQ6IENsYXNzV2VpZ2h0W10gPSBbXTtcbiAgICBvdXRwdXROYW1lcy5mb3JFYWNoKG91dHB1dE5hbWUgPT4ge1xuICAgICAgaWYgKG91dHB1dE5hbWUgaW4geFdlaWdodCkge1xuICAgICAgICBvdXRwdXQucHVzaCgoeFdlaWdodCBhcyBDbGFzc1dlaWdodE1hcClbb3V0cHV0TmFtZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0LnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGBUaGUgbW9kZWwgaGFzIG11bHRpcGxlICgke251bU91dHB1dHN9KSBvdXRwdXRzLCBgICtcbiAgICAgICAgYHNvICR7d2VpZ2h0VHlwZX0gbXVzdCBiZSBlaXRoZXIgYW4gYXJyYXkgd2l0aCBgICtcbiAgICAgICAgYCR7bnVtT3V0cHV0c30gZWxlbWVudHMgb3IgYW4gb2JqZWN0IHdpdGggJHtvdXRwdXROYW1lc30ga2V5cy4gYCArXG4gICAgICAgIGBQcm92aWRlZCAke3dlaWdodFR5cGV9IG5vdCB1bmRlcnN0b29kOiAke0pTT04uc3RyaW5naWZ5KHhXZWlnaHQpfWApO1xuICB9XG59XG5cbi8qKlxuICogU3RhbmRhcmRpemUgY2xhc3Mgd2VpZ2h0aW5nIG9iamVjdHMuXG4gKlxuICogVGhpcyBmdW5jdGlvbiB0YWtlcyBhIHNpbmdsZSBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0LCBhbiBhcnJheSBvZiB0aGVtLFxuICogb3IgYSBtYXAgZnJvbSBvdXRwdXQgbmFtZSB0byBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0LiBJdCBjb21wYXJlcyBpdCB0byB0aGVcbiAqIG91dHB1dCBuYW1lKHMpIG9mIHRoZSBtb2RlbCwgYmFzZSBvbiB3aGljaCBpdCBvdXRwdXRzIGFuIGFycmF5IG9mXG4gKiBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0cyBvZiB3aGljaCB0aGUgbGVuZ3RoIG1hdGNoZXMgdGhlIG51bWJlciBvZiBvdXRwdXRzLlxuICpcbiAqIEBwYXJhbSBjbGFzc1dlaWdodCBJbnB1dCBjbGFzcy13ZWlnaHRpbmcgb2JqZWN0KHMpLlxuICogQHBhcmFtIG91dHB1dE5hbWVzIEFsbCBvdXRwdXQgbmFtZShzKSBvZiB0aGUgbW9kZWwuXG4gKiBAcmV0dXJuIEFuIGFycmF5IG9mIGNsYXNzLXdlaWdodGluZyBvYmplY3RzLiBUaGUgbGVuZ3RoIG9mIHRoZSBhcnJheSBtYXRjaGVzXG4gKiAgIHRoZSBtb2RlbCdzIG51bWJlciBvZiBvdXRwdXRzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc3RhbmRhcmRpemVDbGFzc1dlaWdodHMoXG4gICAgY2xhc3NXZWlnaHQ6IENsYXNzV2VpZ2h0fENsYXNzV2VpZ2h0W118Q2xhc3NXZWlnaHRNYXAsXG4gICAgb3V0cHV0TmFtZXM6IHN0cmluZ1tdKTogQ2xhc3NXZWlnaHRbXSB7XG4gIHJldHVybiBzdGFuZGFyZGl6ZVNhbXBsZU9yQ2xhc3NXZWlnaHRzKFxuICAgICAgY2xhc3NXZWlnaHQsIG91dHB1dE5hbWVzLCAnY2xhc3NXZWlnaHQnKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHN0YW5kYXJkaXplU2FtcGxlV2VpZ2h0cyhcbiAgICBjbGFzc1dlaWdodDogQ2xhc3NXZWlnaHR8Q2xhc3NXZWlnaHRbXXxDbGFzc1dlaWdodE1hcCxcbiAgICBvdXRwdXROYW1lczogc3RyaW5nW10pOiBDbGFzc1dlaWdodFtdIHtcbiAgcmV0dXJuIHN0YW5kYXJkaXplU2FtcGxlT3JDbGFzc1dlaWdodHMoXG4gICAgICBjbGFzc1dlaWdodCwgb3V0cHV0TmFtZXMsICdzYW1wbGVXZWlnaHQnKTtcbn1cblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSBieS1zYW1wbGUgYW5kL29yIGJ5LWNsYXNzIHdlaWdodHMgZm9yIHRyYWluaW5nLlxuICpcbiAqIE5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIG9wZXJhdGVzIG9uIG9uZSBtb2RlbCBvdXRwdXQgYXQgYSB0aW1lLiBGb3IgYSBtb2RlbFxuICogd2l0aCBtdWx0aXBsZSBvdXRwdXRzLCB5b3UgbXVzdCBjYWxsIHRoaXMgZnVuY3Rpb24gbXVsdGlwbGUgdGltZXMuXG4gKlxuICogQHBhcmFtIHkgVGhlIHRhcmdldCB0ZW5zb3IgdGhhdCB0aGUgYnktc2FtcGxlIGFuZC9vciBieS1jbGFzcyB3ZWlnaHQgaXMgZm9yLlxuICogICAgIFRoZSB2YWx1ZXMgb2YgeSBhcmUgYXNzdW1lZCB0byBlbmNvZGUgdGhlIGNsYXNzZXMsIGVpdGhlciBkaXJlY3RseVxuICogICAgIGFzIGFuIGludGVnZXIgaW5kZXgsIG9yIGFzIG9uZS1ob3QgZW5jb2RpbmcuXG4gKiBAcGFyYW0gc2FtcGxlV2VpZ2h0IEJ5LXNhbXBsZSB3ZWlnaHRzLlxuICogQHBhcmFtIGNsYXNzV2VpZ2h0IEJ5LWNsYXNzIHdlaWdodHM6IGFuIG9iamVjdCBtYXBwaW5nIGNsYXNzIGluZGljZXNcbiAqICAgICAoaW50ZWdlcnMpIHRvIGEgd2VpZ2h0IChmbG9hdCkgdG8gYXBwbHkgdG8gdGhlIG1vZGVsJ3MgbG9zcyBmb3IgdGhlXG4gKiAgICAgc2FtcGxlcyBmcm9tIHRoaXMgY2xhc3MgZHVyaW5nIHRyYWluaW5nLiBUaGlzIGNhbiBiZSB1c2VmdWwgdG8gdGVsbCB0aGVcbiAqICAgICBtb2RlbCB0byBcInBheSBtb3JlIGF0dGVudGlvblwiIHRvIHNhbXBsZXMgZnJvbSBhbiB1bmRlci1yZXByZXNlbnRlZCBjbGFzcy5cbiAqIEBwYXJhbSBzYW1wbGVXZWlnaHRNb2RlIFRoZSBtb2RlIGZvciB0aGUgc2FtcGxlIHdlaWdodHMuXG4gKiBAcmV0dXJuIEEgUHJvbWlzZSBvZiB3ZWlnaHQgdGVuc29yLCBvZiB3aGljaCB0aGUgc2l6ZSBvZiB0aGUgZmlyc3QgZGltZW5zaW9uXG4gKiAgICAgbWF0Y2hlcyB0aGF0IG9mIGB5YC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHN0YW5kYXJkaXplV2VpZ2h0cyhcbiAgICB5OiBUZW5zb3IsIHNhbXBsZVdlaWdodD86IFRlbnNvciwgY2xhc3NXZWlnaHQ/OiBDbGFzc1dlaWdodCxcbiAgICBzYW1wbGVXZWlnaHRNb2RlPzogJ3RlbXBvcmFsJyk6IFByb21pc2U8VGVuc29yPiB7XG4gIGlmIChzYW1wbGVXZWlnaHQgIT0gbnVsbCB8fCBzYW1wbGVXZWlnaHRNb2RlICE9IG51bGwpIHtcbiAgICAvLyBUT0RPKGNhaXMpOiBPbmNlICd0ZW1wb3JhbCcgbW9kZSBpcyBpbXBsZW1lbnRlZCwgZG9jdW1lbnQgaXQgaW4gdGhlIGRvY1xuICAgIC8vIHN0cmluZy5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1cHBvcnQgc2FtcGxlV2VpZ2h0IGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQnKTtcbiAgfVxuXG4gIGlmIChjbGFzc1dlaWdodCAhPSBudWxsKSB7XG4gICAgLy8gQXBwbHkgY2xhc3Mgd2VpZ2h0cyBwZXIgc2FtcGxlLlxuICAgIGNvbnN0IHlDbGFzc2VzOiBUZW5zb3IxRCA9IHRpZHkoKCkgPT4ge1xuICAgICAgaWYgKHkuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIC8vIEFzc3VtZSBjbGFzcyBpbmRpY2VzLlxuICAgICAgICByZXR1cm4gY2xvbmUoeSkgYXMgVGVuc29yMUQ7XG4gICAgICB9IGVsc2UgaWYgKHkuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIGlmICh5LnNoYXBlWzFdID4gMSkge1xuICAgICAgICAgIC8vIEFzc3VtZSBvbmUtaG90IGVuY29kaW5nIG9mIGNsYXNzZXMuXG4gICAgICAgICAgY29uc3QgYXhpcyA9IDE7XG4gICAgICAgICAgcmV0dXJuIGFyZ01heCh5LCBheGlzKTtcbiAgICAgICAgfSBlbHNlIGlmICh5LnNoYXBlWzFdID09PSAxKSB7XG4gICAgICAgICAgLy8gQ2xhc3MgaW5kZXguXG4gICAgICAgICAgcmV0dXJuIHJlc2hhcGUoeSwgW3kuc2hhcGVbMF1dKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBFbmNvdW50ZXJlZCB1bmV4cGVjdGVkIGxhc3QtZGltZW5zaW9uIHNpemUgKCR7eS5zaGFwZVsxXX0pIGAgK1xuICAgICAgICAgICAgICBgZHVyaW5nIGhhbmRsaW5nIG9mIGNsYXNzIHdlaWdodHMuIFRoZSBzaXplIGlzIGV4cGVjdGVkIHRvIGJlIGAgK1xuICAgICAgICAgICAgICBgPj0gMS5gKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgYFVuZXhwZWN0ZWQgcmFuayBvZiB0YXJnZXQgKHkpIHRlbnNvciAoJHt5LnJhbmt9KSBkdXJpbmcgYCArXG4gICAgICAgICAgICBgaGFuZGxpbmcgb2YgY2xhc3Mgd2VpZ2h0cy4gVGhlIHJhbmsgaXMgZXhwZWN0ZWQgdG8gYmUgMSBvciAyLmApO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgY29uc3QgeUNsYXNzSW5kaWNlcyA9IEFycmF5LmZyb20oYXdhaXQgeUNsYXNzZXMuZGF0YSgpKTtcbiAgICBkaXNwb3NlKHlDbGFzc2VzKTtcbiAgICBjb25zdCBjbGFzc1NhbXBsZVdlaWdodDogbnVtYmVyW10gPSBbXTtcbiAgICB5Q2xhc3NJbmRpY2VzLmZvckVhY2goY2xhc3NJbmRleCA9PiB7XG4gICAgICBpZiAoY2xhc3NXZWlnaHRbY2xhc3NJbmRleF0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgY2xhc3NXZWlnaHQgbXVzdCBjb250YWluIGFsbCBjbGFzc2VzIGluIHRoZSB0cmFpbmluZyBkYXRhLiBgICtcbiAgICAgICAgICAgIGBUaGUgY2xhc3MgJHtjbGFzc0luZGV4fSBleGlzdHMgaW4gdGhlIGRhdGEgYnV0IG5vdCBpbiBgICtcbiAgICAgICAgICAgIGBjbGFzc1dlaWdodGApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2xhc3NTYW1wbGVXZWlnaHQucHVzaChjbGFzc1dlaWdodFtjbGFzc0luZGV4XSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGVuc29yMWQoY2xhc3NTYW1wbGVXZWlnaHQsICdmbG9hdDMyJyk7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbn1cblxuLyoqXG4gKiBBcHBseSBwZXItc2FtcGxlIHdlaWdodHMgb24gdGhlIGxvc3MgdmFsdWVzIGZyb20gYSBudW1iZXIgb2Ygc2FtcGxlcy5cbiAqXG4gKiBAcGFyYW0gbG9zc2VzIExvc3MgdGVuc29yIG9mIHNoYXBlIGBbYmF0Y2hTaXplXWAuXG4gKiBAcGFyYW0gc2FtcGxlV2VpZ2h0cyBQZXItc2FtcGxlIHdlaWdodCB0ZW5zb3Igb2Ygc2hhcGUgYFtiYXRjaFNpemVdYC5cbiAqIEByZXR1cm5zIFRlbnNvciBvZiB0aGUgc2FtZSBzaGFwZSBhc2Bsb3NzZXNgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzZXM6IFRlbnNvciwgc2FtcGxlV2VpZ2h0czogVGVuc29yKSB7XG4gIHJldHVybiBtdWwobG9zc2VzLCBzYW1wbGVXZWlnaHRzKTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Interfaces and methods for training models using TensorFlow.js datasets.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { scalar } from '@tensorflow/tfjs-core';\nimport { configureCallbacks, standardizeCallbacks } from '../base_callbacks';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { disposeTensorsInLogs } from '../logs';\nimport { singletonOrArray, toList } from '../utils/generic_utils';\nimport { standardizeClassWeights, standardizeWeights } from './training_utils';\n// Default batch size used during tensor-based validation.\nconst DEFAULT_VALIDATION_BATCH_SIZE = 32;\n/**\n * Standardize the output of a dataset iterator for use by\n * LayersModel.fitDataset().\n *\n * @param model: A `tf.LayersModel` object.\n * @param iteratorOut The output of a dataset iterator. It is required to be\n *   an object of the form `{xs: TensorOrArrayOrMap, ys:\n * TensorOrArrayOrMap}`, where `TensorOrArrayOrMap` is a single `tf.Tensor`,\n * a `tf.Tensor[]`, or a flat map from string names to `tf.Tensor`s.\n * @returns A flat array of `tf.Tensor` objects: the input `tf.Tensor`s\n *   followed by the target `tf.Tensor`s.  When `tf.Tensor`s are provided\n *   as a map, the order in the resulting array is taken from the `inputNames`\n *   and `outputNames` of the model.\n */\nfunction standardizeDataIteratorOutput(\n// Type `model` as `any` here to avoid circular dependency w/\n// training.ts.\n// tslint:disable-next-line:no-any\nmodel, iteratorOut) {\n    let xs;\n    let ys;\n    const iteratorOutObj = iteratorOut;\n    xs = iteratorOutObj['xs'];\n    ys = iteratorOutObj['ys'];\n    tfc.util.assert(xs != null && ys != null, () => 'A Dataset iterator for fitDataset() is expected to generate ' +\n        'objects of the form `{xs: xVal, ys: yVal}`, where the two ' +\n        'values may be `tf.Tensor`, an array of Tensors, or a map of ' +\n        'string to Tensor.  The provided Dataset instead generates ' +\n        `${iteratorOut}`);\n    const flattenedXs = flattenTensorOrArrayOrMap('input', model.inputNames, xs);\n    const flattenedYs = flattenTensorOrArrayOrMap('output', model.outputNames, ys);\n    const batchSize = flattenedXs[0].shape[0];\n    tfc.util.assert(flattenedXs.length === model.inputs.length, () => `LayersModel has ${model.inputs.length} inputs, but the dataset ` +\n        `provides ${flattenedXs.length} inputs.  (Expected input keys: ` +\n        `${JSON.stringify(model.inputNames)})`);\n    tfc.util.assert(flattenedYs.length === model.outputs.length, () => `LayersModel has ${model.outputs.length} outputs, but the dataset ` +\n        `provides ${flattenedYs.length} outputs.  (Expected output keys: ` +\n        `${JSON.stringify(model.outputNames)})`);\n    for (let xIndex = 0; xIndex < flattenedXs.length; xIndex++) {\n        tfc.util.assert(flattenedXs[xIndex].shape[0] === batchSize, () => `Batch size mismatch: input ` +\n            `${model.inputNames[xIndex]} has ${flattenedXs[xIndex].shape[0]}; ` +\n            `expected  ${batchSize} based on input ${model.inputNames[0]}.`);\n    }\n    for (let yIndex = 0; yIndex < flattenedYs.length; yIndex++) {\n        tfc.util.assert(flattenedYs[yIndex].shape[0] === batchSize, () => `Batch size mismatch: output ` +\n            `${model.outputNames[yIndex]} has ${flattenedYs[yIndex].shape[0]}; ` +\n            `expected  ${batchSize} based on input ${model.inputNames[0]}.`);\n    }\n    return { xs: flattenedXs, ys: flattenedYs };\n}\nfunction flattenTensorOrArrayOrMap(inputOrOutput, names, values) {\n    if (values instanceof tfc.Tensor) {\n        return [values];\n    }\n    else if (Array.isArray(values)) {\n        tfc.util.assert(values.length === names.length, () => `Received an array of ${values.length} Tensors, but expected ${names.length} to match the ${inputOrOutput} keys ${names}.`);\n        return values;\n    }\n    else {\n        const result = [];\n        // Check that all the required keys are available.\n        for (const name of names) {\n            if (values[name] == null) {\n                throw new ValueError(`The feature data generated by the dataset lacks the required ` +\n                    `${inputOrOutput} key '${name}'.`);\n            }\n            result.push(values[name]);\n        }\n        return result;\n    }\n}\nfunction standardizeTensorValidationData(data) {\n    if (data.length === 3) {\n        throw new NotImplementedError('Validation with sample weights is not implemented yet.');\n    }\n    return { xs: data[0], ys: data[1] };\n}\nexport async function fitDataset(\n// Type `model` as `any` here to avoid circular dependency w/\n// training.ts.\n// tslint:disable-next-line:no-any\nmodel, dataset, args) {\n    const hasBatchesPerEpoch = args.batchesPerEpoch != null;\n    tfc.util.assert(model.optimizer != null, () => 'You must compile a model before training/testing. Use ' +\n        'LayersModel.compile(modelCompileConfig).');\n    tfc.util.assert(args != null, () => `For fitDataset(), the 2nd argument (config) is required, ` +\n        `but it is not provided in this call.`);\n    tfc.util.assert(args.epochs != null && args.epochs > 0 && Number.isInteger(args.epochs), () => `For fitDataset(), config.epochs is expected to be a positive ` +\n        `integer, but got ${args.epochs}`);\n    tfc.util.assert(!hasBatchesPerEpoch ||\n        (args.batchesPerEpoch > 0 && Number.isInteger(args.batchesPerEpoch)), () => `For fitDataset(), config.batchesPerEpoch is expected to be a ` +\n        `positive integer if specified, but got ${args.batchesPerEpoch}`);\n    tfc.util.assert(\n    // tslint:disable-next-line:no-any\n    args['validationSplit'] == null, () => '`validationSplit` is not supported by `fitDataset()`. ' +\n        'Use validationData instead.');\n    if (model.isTraining) {\n        throw new Error('Cannot start training because another fit() call is ongoing.');\n    }\n    model.isTraining = true;\n    try {\n        const doValidation = args.validationData != null;\n        let valXs;\n        let valYs;\n        if (doValidation) {\n            if (isDatasetObject(args.validationData)) {\n                tfc.util.assert(args.validationBatches == null ||\n                    (args.validationBatches > 0 &&\n                        Number.isInteger(args.validationBatches)), () => `For fitDataset() with dataset-based validation, ` +\n                    `config.validationBatches is expected not to be provided, ` +\n                    `or to be a positive integer, ` +\n                    `but got ${args.validationBatches}`);\n            }\n            else {\n                const validationData = standardizeTensorValidationData(args.validationData);\n                valXs = validationData.xs;\n                valYs = validationData.ys;\n            }\n        }\n        const trainFunction = model.makeTrainFunction();\n        const outLabels = model.getDedupedMetricsNames();\n        let callbackMetrics;\n        if (doValidation) {\n            callbackMetrics =\n                outLabels.slice().concat(outLabels.map(n => 'val_' + n));\n        }\n        else {\n            callbackMetrics = outLabels.slice();\n        }\n        const callbacks = standardizeCallbacks(args.callbacks, args.yieldEvery);\n        const verbose = args.verbose == null ? 1 : args.verbose;\n        const { callbackList, history } = configureCallbacks(callbacks, verbose, args.epochs, null, null, getStepsPerEpoch(dataset, args), null, // Batch size determined by the dataset itself.\n        doValidation, callbackMetrics);\n        callbackList.setModel(model);\n        model.history = history;\n        await callbackList.onTrainBegin();\n        model.stopTraining_ = false;\n        let epoch = args.initialEpoch == null ? 0 : args.initialEpoch;\n        let dataIterator = await dataset.iterator();\n        while (epoch < args.epochs) {\n            const epochLogs = {};\n            await callbackList.onEpochBegin(epoch);\n            let stepsDone = 0;\n            let batchIndex = 0;\n            if (!hasBatchesPerEpoch) {\n                dataIterator = await dataset.iterator();\n            }\n            while (hasBatchesPerEpoch ? stepsDone < args.batchesPerEpoch : true) {\n                const iteratorOut = await dataIterator.next();\n                // If `batchesPerEpoch` is specified, the dataset should not be\n                // exhausted until all epoches are done.\n                if (hasBatchesPerEpoch && iteratorOut.done) {\n                    console.warn('You provided `batchesPerEpoch` as ' +\n                        `${args.batchesPerEpoch}, ` +\n                        'but your dataset iterator ran out of data after ' +\n                        `${stepsDone} batches; ` +\n                        'interrupting training. Make sure that your ' +\n                        'dataset can generate at least `batchesPerEpoch * epochs` ' +\n                        'batches (in this case, ' +\n                        `${args.batchesPerEpoch * args.epochs} batches). ` +\n                        'You may need to use the repeat() function when building ' +\n                        'your dataset.');\n                    break;\n                }\n                if (iteratorOut.value != null) {\n                    const { xs, ys } = standardizeDataIteratorOutput(model, iteratorOut.value);\n                    const batchLogs = {};\n                    batchLogs['batch'] = batchIndex;\n                    batchLogs['size'] = xs[0].shape[0];\n                    await callbackList.onBatchBegin(batchIndex, batchLogs);\n                    const sampleWeights = [];\n                    if (args.classWeight != null) {\n                        const standardClassWeights = standardizeClassWeights(args.classWeight, model.outputNames);\n                        for (let i = 0; i < standardClassWeights.length; ++i) {\n                            sampleWeights.push(await standardizeWeights(ys[i], null, standardClassWeights[i]));\n                        }\n                    }\n                    // Train on batch.\n                    const ins = xs.concat(ys).concat(sampleWeights);\n                    const outs = trainFunction(ins);\n                    tfc.dispose(ins);\n                    for (let i = 0; i < outLabels.length; ++i) {\n                        const label = outLabels[i];\n                        const out = outs[i];\n                        batchLogs[label] = out;\n                        tfc.keep(out);\n                    }\n                    await callbackList.onBatchEnd(batchIndex, batchLogs);\n                    disposeTensorsInLogs(batchLogs);\n                    batchIndex++;\n                    stepsDone++;\n                }\n                if (hasBatchesPerEpoch ? stepsDone >= args.batchesPerEpoch :\n                    iteratorOut.done) {\n                    // Epoch finished. Perform validation.\n                    if (doValidation) {\n                        let valOuts;\n                        if (isDatasetObject(args.validationData)) {\n                            valOuts = toList(await model.evaluateDataset(args.validationData, { batches: args.validationBatches }));\n                        }\n                        else {\n                            valOuts = toList(model.evaluate(valXs, valYs, {\n                                batchSize: args.validationBatchSize == null ?\n                                    DEFAULT_VALIDATION_BATCH_SIZE :\n                                    args.validationBatchSize,\n                                verbose: 0\n                            }));\n                        }\n                        for (let i = 0; i < model.metricsNames.length; ++i) {\n                            epochLogs[`val_${model.metricsNames[i]}`] = valOuts[i];\n                        }\n                    }\n                    // Call `break` to exit one epoch lopp after validation is done. If\n                    // config.batchesPerEpoch is specified, an epoch while loop will\n                    // stop when `stepsDone >= config.batchesPerEpoch`. When\n                    // config.batchesPerEpoch is not provided, the following `break` is\n                    // required to exit the while lopp after dataset is exhausted.\n                    break;\n                }\n                if (model.stopTraining_) {\n                    break;\n                }\n            }\n            await callbackList.onEpochEnd(epoch, epochLogs);\n            epoch++;\n            if (model.stopTraining_) {\n                break;\n            }\n        }\n        await callbackList.onTrainEnd();\n        await model.history.syncData();\n        return model.history;\n    }\n    finally {\n        model.isTraining = false;\n    }\n}\n/** Helper function that determines number of steps (batches) per epoch. */\nfunction getStepsPerEpoch(dataset, args) {\n    // Attempt to determine # of batches in an epoch.\n    let stepsPerEpoch = null;\n    if (args.batchesPerEpoch != null) {\n        stepsPerEpoch = args.batchesPerEpoch;\n    }\n    else if (Number.isFinite(dataset.size)) {\n        stepsPerEpoch = dataset.size;\n    }\n    return stepsPerEpoch;\n}\n// Check if provided object is a Dataset object by checking its .iterator\n// element.\nfunction isDatasetObject(dataset) {\n    return (typeof dataset.iterator === 'function');\n}\n// Check if provided object is a LazyIterator object by checking it's .next\n// element.\nfunction isLazyIteratorObject(iterator) {\n    return (typeof iterator.next === 'function');\n}\nexport async function evaluateDataset(\n// Type `model` as `any` here to avoid circular dependency w/\n// training.ts.\n// tslint:disable-next-line:no-any\nmodel, dataset, args) {\n    args = args || {};\n    const hasBatches = args.batches != null;\n    const f = model.testFunction;\n    let outs = [];\n    if (args.verbose > 0) {\n        throw new NotImplementedError('Verbose mode is not implemented yet.');\n    }\n    tfc.util.assert(!hasBatches || (args.batches > 0 && Number.isInteger(args.batches)), () => 'Test loop expects `batches` to be a positive integer, but ' +\n        `received ${JSON.stringify(args.batches)}`);\n    const dataIterator = isLazyIteratorObject(dataset) ?\n        dataset :\n        await dataset.iterator();\n    // Keeps track of number of examples used in this evaluation.\n    let numExamples = 0;\n    let batch = 0;\n    while (hasBatches ? batch < args.batches : true) {\n        const iteratorOut = await dataIterator.next();\n        outs = tfc.tidy(() => {\n            if (iteratorOut.value) {\n                // TODO(cais): Once real dataset is available, use\n                //   `map(x => standardizeDataIteratorOutput(model, x).map(f)`.\n                const { xs, ys } = standardizeDataIteratorOutput(model, iteratorOut.value);\n                const xsAndYs = xs.concat(ys);\n                const batchOuts = tfc.tidy(() => f(xsAndYs));\n                tfc.dispose(xsAndYs);\n                if (batch === 0) {\n                    for (let i = 0; i < batchOuts.length; ++i) {\n                        outs.push(scalar(0));\n                    }\n                }\n                const batchSize = xsAndYs[0].shape[0];\n                for (let i = 0; i < batchOuts.length; ++i) {\n                    const batchOut = batchOuts[i];\n                    const oldScalar = outs[i];\n                    outs[i] =\n                        tfc.tidy(() => tfc.add(outs[i], tfc.mul(batchSize, batchOut)));\n                    if (batch > 0) {\n                        tfc.dispose(oldScalar);\n                    }\n                }\n                tfc.dispose(batchOuts);\n                numExamples += batchSize;\n                ++batch;\n            }\n            return outs;\n        });\n        if (iteratorOut.done) {\n            if (hasBatches) {\n                console.warn('Your dataset iterator ran out of data during evaluateDataset(). ' +\n                    'Interrupting evalution. Make sure that your ' +\n                    'dataset can generate at least `batches` ' +\n                    `batches (in this case, ${args.batches} batches). ` +\n                    'You may need to use the repeat() function when building ' +\n                    'your dataset.');\n            }\n            break;\n        }\n    }\n    for (let i = 0; i < outs.length; ++i) {\n        const oldScalar = outs[i];\n        outs[i] = tfc.div(outs[i], numExamples);\n        tfc.dispose(oldScalar);\n    }\n    return singletonOrArray(outs);\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmdfZGF0YXNldC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9lbmdpbmUvdHJhaW5pbmdfZGF0YXNldC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDN0MsT0FBTyxFQUFlLGtCQUFrQixFQUFzRCxvQkFBb0IsRUFBb0IsTUFBTSxtQkFBbUIsQ0FBQztBQUNoSyxPQUFPLEVBQUMsbUJBQW1CLEVBQUUsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQzFELE9BQU8sRUFBQyxvQkFBb0IsRUFBaUIsTUFBTSxTQUFTLENBQUM7QUFFN0QsT0FBTyxFQUFDLGdCQUFnQixFQUFFLE1BQU0sRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBR2hFLE9BQU8sRUFBOEIsdUJBQXVCLEVBQUUsa0JBQWtCLEVBQUMsTUFBTSxrQkFBa0IsQ0FBQztBQWlLMUcsMERBQTBEO0FBQzFELE1BQU0sNkJBQTZCLEdBQUcsRUFBRSxDQUFDO0FBRXpDOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxTQUFTLDZCQUE2QjtBQUNsQyw2REFBNkQ7QUFDN0QsZUFBZTtBQUNmLGtDQUFrQztBQUNsQyxLQUFVLEVBQUUsV0FBZTtJQUM3QixJQUFJLEVBQXNCLENBQUM7SUFDM0IsSUFBSSxFQUFzQixDQUFDO0lBRTNCLE1BQU0sY0FBYyxHQUFHLFdBQWdDLENBQUM7SUFDeEQsRUFBRSxHQUFHLGNBQWMsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUMxQixFQUFFLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzFCLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUNYLEVBQUUsSUFBSSxJQUFJLElBQUksRUFBRSxJQUFJ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YixHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO3FCQUN4QjtpQkFDRjtnQkFDRCxHQUFHLENBQUMsT0FBTyxDQUFDLFNBQVMsQ0FBQyxDQUFDO2dCQUN2QixXQUFXLElBQUksU0FBUyxDQUFDO2dCQUV6QixFQUFFLEtBQUssQ0FBQzthQUNUO1lBQ0QsT0FBTyxJQUFJLENBQUM7UUFDZCxDQUFDLENBQUMsQ0FBQztRQUVILElBQUksV0FBVyxDQUFDLElBQUksRUFBRTtZQUNwQixJQUFJLFVBQVUsRUFBRTtnQkFDZCxPQUFPLENBQUMsSUFBSSxDQUNSLGtFQUFrRTtvQkFDbEUsOENBQThDO29CQUM5QywwQ0FBMEM7b0JBQzFDLDBCQUEwQixJQUFJLENBQUMsT0FBTyxhQUFhO29CQUNuRCwwREFBMEQ7b0JBQzFELGVBQWUsQ0FBQyxDQUFDO2FBQ3RCO1lBQ0QsTUFBTTtTQUNQO0tBQ0Y7SUFFRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsSUFBSSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtRQUNwQyxNQUFNLFNBQVMsR0FBRyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDMUIsSUFBSSxDQUFDLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ3hDLEdBQUcsQ0FBQyxPQUFPLENBQUMsU0FBUyxDQUFDLENBQUM7S0FDeEI7SUFFRCxPQUFPLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ2hDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIEludGVyZmFjZXMgYW5kIG1ldGhvZHMgZm9yIHRyYWluaW5nIG1vZGVscyB1c2luZyBUZW5zb3JGbG93LmpzIGRhdGFzZXRzLlxuICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtzY2FsYXJ9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0Jhc2VDYWxsYmFjaywgY29uZmlndXJlQ2FsbGJhY2tzLCBDdXN0b21DYWxsYmFja0FyZ3MsIEhpc3RvcnksIE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eSwgc3RhbmRhcmRpemVDYWxsYmFja3MsIFlpZWxkRXZlcnlPcHRpb25zfSBmcm9tICcuLi9iYXNlX2NhbGxiYWNrcyc7XG5pbXBvcnQge05vdEltcGxlbWVudGVkRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2Rpc3Bvc2VUZW5zb3JzSW5Mb2dzLCBVbnJlc29sdmVkTG9nc30gZnJvbSAnLi4vbG9ncyc7XG5pbXBvcnQge1RlbnNvck9yQXJyYXlPck1hcH0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtzaW5nbGV0b25PckFycmF5LCB0b0xpc3R9IGZyb20gJy4uL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuXG5pbXBvcnQge0RhdGFzZXQsIExhenlJdGVyYXRvcn0gZnJvbSAnLi9kYXRhc2V0X3N0dWInO1xuaW1wb3J0IHtDbGFzc1dlaWdodCwgQ2xhc3NXZWlnaHRNYXAsIHN0YW5kYXJkaXplQ2xhc3NXZWlnaHRzLCBzdGFuZGFyZGl6ZVdlaWdodHN9IGZyb20gJy4vdHJhaW5pbmdfdXRpbHMnO1xuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgY29uZmlndXJpbmcgbW9kZWwgdHJhaW5pbmcgYmFzZWQgb24gYSBkYXRhc2V0IG9iamVjdC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlbEZpdERhdGFzZXRBcmdzPFQ+IHtcbiAgLyoqXG4gICAqIChPcHRpb25hbCkgVG90YWwgbnVtYmVyIG9mIHN0ZXBzIChiYXRjaGVzIG9mIHNhbXBsZXMpIGJlZm9yZVxuICAgKiBkZWNsYXJpbmcgb25lIGVwb2NoIGZpbmlzaGVkIGFuZCBzdGFydGluZyB0aGUgbmV4dCBlcG9jaC4gSXQgc2hvdWxkXG4gICAqIHR5cGljYWxseSBiZSBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIHNhbXBsZXMgb2YgeW91ciBkYXRhc2V0IGRpdmlkZWQgYnlcbiAgICogdGhlIGJhdGNoIHNpemUsIHNvIHRoYXQgYGZpdERhdGFzZXRgKCkgY2FsbCBjYW4gdXRpbGl6ZSB0aGUgZW50aXJlIGRhdGFzZXQuXG4gICAqIElmIGl0IGlzIG5vdCBwcm92aWRlZCwgdXNlIGBkb25lYCByZXR1cm4gdmFsdWUgaW4gYGl0ZXJhdG9yLm5leHQoKWAgYXNcbiAgICogc2lnbmFsIHRvIGZpbmlzaCBhbiBlcG9jaC5cbiAgICovXG4gIGJhdGNoZXNQZXJFcG9jaD86IG51bWJlcjtcblxuICAvKipcbiAgICogSW50ZWdlciBudW1iZXIgb2YgdGltZXMgdG8gaXRlcmF0ZSBvdmVyIHRoZSB0cmFpbmluZyBkYXRhc2V0LlxuICAgKi9cbiAgZXBvY2hzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFZlcmJvc2l0eSBsZXZlbC5cbiAgICpcbiAgICogRXhwZWN0ZWQgdG8gYmUgMCwgMSwgb3IgMi4gRGVmYXVsdDogMS5cbiAgICpcbiAgICogMCAtIE5vIHByaW50ZWQgbWVzc2FnZSBkdXJpbmcgZml0KCkgY2FsbC5cbiAgICogMSAtIEluIE5vZGUuanMgKHRmanMtbm9kZSksIHByaW50cyB0aGUgcHJvZ3Jlc3MgYmFyLCB0b2dldGhlciB3aXRoXG4gICAqICAgICByZWFsLXRpbWUgdXBkYXRlcyBvZiBsb3NzIGFuZCBtZXRyaWMgdmFsdWVzIGFuZCB0cmFpbmluZyBzcGVlZC5cbiAgICogICAgIEluIHRoZSBicm93c2VyOiBubyBhY3Rpb24uIFRoaXMgaXMgdGhlIGRlZmF1bHQuXG4gICAqIDIgLSBOb3QgaW1wbGVtZW50ZWQgeWV0LlxuICAgKi9cbiAgdmVyYm9zZT86IE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eTtcblxuICAvKipcbiAgICogTGlzdCBvZiBjYWxsYmFja3MgdG8gYmUgY2FsbGVkIGR1cmluZyB0cmFpbmluZy5cbiAgICogQ2FuIGhhdmUgb25lIG9yIG1vcmUgb2YgdGhlIGZvbGxvd2luZyBjYWxsYmFja3M6XG4gICAqICAgLSBgb25UcmFpbkJlZ2luKGxvZ3MpYDogY2FsbGVkIHdoZW4gdHJhaW5pbmcgc3RhcnRzLlxuICAgKiAgIC0gYG9uVHJhaW5FbmQobG9ncylgOiBjYWxsZWQgd2hlbiB0cmFpbmluZyBlbmRzLlxuICAgKiAgIC0gYG9uRXBvY2hCZWdpbihlcG9jaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIHN0YXJ0IG9mIGV2ZXJ5IGVwb2NoLlxuICAgKiAgIC0gYG9uRXBvY2hFbmQoZXBvY2gsIGxvZ3MpYDogY2FsbGVkIGF0IHRoZSBlbmQgb2YgZXZlcnkgZXBvY2guXG4gICAqICAgLSBgb25CYXRjaEJlZ2luKGJhdGNoLCBsb2dzKWA6IGNhbGxlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgYmF0Y2guXG4gICAqICAgLSBgb25CYXRjaEVuZChiYXRjaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBiYXRjaC5cbiAgICogICAtIGBvbllpZWxkKGVwb2NoLCBiYXRjaCwgbG9ncylgOiBjYWxsZWQgZXZlcnkgYHlpZWxkRXZlcnlgIG1pbGxpc2Vjb25kc1xuICAgKiAgICAgIHdpdGggdGhlIGN1cnJlbnQgZXBvY2gsIGJhdGNoIGFuZCBsb2dzLiBUaGUgbG9ncyBhcmUgdGhlIHNhbWVcbiAgICogICAgICBhcyBpbiBgb25CYXRjaEVuZCgpYC4gTm90ZSB0aGF0IGBvbllpZWxkYCBjYW4gc2tpcCBiYXRjaGVzIG9yXG4gICAqICAgICAgZXBvY2hzLiBTZWUgYWxzbyBkb2NzIGZvciBgeWllbGRFdmVyeWAgYmVsb3cuXG4gICAqL1xuICBjYWxsYmFja3M/OiBCYXNlQ2FsbGJhY2tbXXxDdXN0b21DYWxsYmFja0FyZ3N8Q3VzdG9tQ2FsbGJhY2tBcmdzW107XG5cbiAgLyoqXG4gICAqIERhdGEgb24gd2hpY2ggdG8gZXZhbHVhdGUgdGhlIGxvc3MgYW5kIGFueSBtb2RlbFxuICAgKiBtZXRyaWNzIGF0IHRoZSBlbmQgb2YgZWFjaCBlcG9jaC4gVGhlIG1vZGVsIHdpbGwgbm90IGJlIHRyYWluZWQgb24gdGhpc1xuICAgKiBkYXRhLiBUaGlzIGNvdWxkIGJlIGFueSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKlxuICAgKiAgIC0gQW4gYXJyYXkgYFt4VmFsLCB5VmFsXWAsIHdoZXJlIHRoZSB0d28gdmFsdWVzIG1heSBiZSBgdGYuVGVuc29yYCxcbiAgICogICAgIGFuIGFycmF5IG9mIFRlbnNvcnMsIG9yIGEgbWFwIG9mIHN0cmluZyB0byBUZW5zb3IuXG4gICAqICAgLSBTaW1pbGFybHksIGFuIGFycmF5IGAgW3hWYWwsIHlWYWwsIHZhbFNhbXBsZVdlaWdodHNdYFxuICAgKiAgICAgKG5vdCBpbXBsZW1lbnRlZCB5ZXQpLlxuICAgKiAgIC0gYSBgRGF0YXNldGAgb2JqZWN0IHdpdGggZWxlbWVudHMgb2YgdGhlIGZvcm0gYHt4czogeFZhbCwgeXM6IHlWYWx9YCxcbiAgICogICAgIHdoZXJlIGB4c2AgYW5kIGB5c2AgYXJlIHRoZSBmZWF0dXJlIGFuZCBsYWJlbCB0ZW5zb3JzLCByZXNwZWN0aXZlbHkuXG4gICAqXG4gICAqIElmIGB2YWxpZGF0aW9uRGF0YWAgaXMgYW4gQXJyYXkgb2YgVGVuc29yIG9iamVjdHMsIGVhY2ggYHRmLlRlbnNvcmAgd2lsbCBiZVxuICAgKiBzbGljZWQgaW50byBiYXRjaGVzIGR1cmluZyB2YWxpZGF0aW9uLCB1c2luZyB0aGUgcGFyYW1ldGVyXG4gICAqIGB2YWxpZGF0aW9uQmF0Y2hTaXplYCAod2hpY2ggZGVmYXVsdHMgdG8gMzIpLiBUaGUgZW50aXJldHkgb2YgdGhlXG4gICAqIGB0Zi5UZW5zb3JgIG9iamVjdHMgd2lsbCBiZSB1c2VkIGluIHRoZSB2YWxpZGF0aW9uLlxuICAgKlxuICAgKiBJZiBgdmFsaWRhdGlvbkRhdGFgIGlzIGEgZGF0YXNldCBvYmplY3QsIGFuZCB0aGUgYHZhbGlkYXRpb25CYXRjaGVzYFxuICAgKiBwYXJhbWV0ZXIgaXMgc3BlY2lmaWVkLCB0aGUgdmFsaWRhdGlvbiB3aWxsIHVzZSBgdmFsaWRhdGlvbkJhdGNoZXNgIGJhdGNoZXNcbiAgICogZHJhd24gZnJvbSB0aGUgZGF0YXNldCBvYmplY3QuIElmIGB2YWxpZGF0aW9uQmF0Y2hlc2AgcGFyYW1ldGVyIGlzIG5vdFxuICAgKiBzcGVjaWZpZWQsIHRoZSB2YWxpZGF0aW9uIHdpbGwgc3RvcCB3aGVuIHRoZSBkYXRhc2V0IGlzIGV4aGF1c3RlZC5cbiAgICpcbiAgICogVGhlIG1vZGVsIHdpbGwgbm90IGJlIHRyYWluZWQgb24gdGhpcyBkYXRhLlxuICAgKi9cbiAgdmFsaWRhdGlvbkRhdGE/OiBbXG4gICAgVGVuc29yT3JBcnJheU9yTWFwLCBUZW5zb3JPckFycmF5T3JNYXBcbiAgXXxbVGVuc29yT3JBcnJheU9yTWFwLCBUZW5zb3JPckFycmF5T3JNYXAsIFRlbnNvck9yQXJyYXlPck1hcF18RGF0YXNldDxUPjtcblxuICAvKipcbiAgICogT3B0aW9uYWwgYmF0Y2ggc2l6ZSBmb3IgdmFsaWRhdGlvbi5cbiAgICpcbiAgICogVXNlZCBvbmx5IGlmIGB2YWxpZGF0aW9uRGF0YWAgaXMgYW4gYXJyYXkgb2YgYHRmLlRlbnNvcmAgb2JqZWN0cywgaS5lLiwgbm90XG4gICAqIGEgZGF0YXNldCBvYmplY3QuXG4gICAqXG4gICAqIElmIG5vdCBzcGVjaWZpZWQsIGl0cyB2YWx1ZSBkZWZhdWx0cyB0byAzMi5cbiAgICovXG4gIHZhbGlkYXRpb25CYXRjaFNpemU/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIChPcHRpb25hbCkgT25seSByZWxldmFudCBpZiBgdmFsaWRhdGlvbkRhdGFgIGlzIHNwZWNpZmllZCBhbmQgaXMgYSBkYXRhc2V0XG4gICAqIG9iamVjdC5cbiAgICpcbiAgICogVG90YWwgbnVtYmVyIG9mIGJhdGNoZXMgb2Ygc2FtcGxlcyB0byBkcmF3IGZyb20gYHZhbGlkYXRpb25EYXRhYCBmb3JcbiAgICogdmFsaWRhdGlvbiBwdXJwb3NlIGJlZm9yZSBzdG9wcGluZyBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGVwb2NoLiBJZiBub3RcbiAgICogc3BlY2lmaWVkLCBgZXZhbHVhdGVEYXRhc2V0YCB3aWxsIHVzZSBgaXRlcmF0b3IubmV4dCgpLmRvbmVgIGFzIHNpZ25hbCB0b1xuICAgKiBzdG9wIHZhbGlkYXRpb24uXG4gICAqL1xuICB2YWxpZGF0aW9uQmF0Y2hlcz86IG51bWJlcjtcblxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGUgZnJlcXVlbmN5IG9mIHlpZWxkaW5nIHRoZSBtYWluIHRocmVhZCB0byBvdGhlciB0YXNrcy5cbiAgICpcbiAgICogSW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQsIHlpZWxkaW5nIHRoZSBtYWluIHRocmVhZCBjYW4gaW1wcm92ZSB0aGVcbiAgICogcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIHBhZ2UgZHVyaW5nIHRyYWluaW5nLiBJbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudCxcbiAgICogaXQgY2FuIGVuc3VyZSB0YXNrcyBxdWV1ZWQgaW4gdGhlIGV2ZW50IGxvb3AgY2FuIGJlIGhhbmRsZWQgaW4gYSB0aW1lbHlcbiAgICogbWFubmVyLlxuICAgKlxuICAgKiBUaGUgdmFsdWUgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAgIC0gYCdhdXRvJ2A6IFRoZSB5aWVsZGluZyBoYXBwZW5zIGF0IGEgY2VydGFpbiBmcmFtZSByYXRlIChjdXJyZW50bHkgc2V0XG4gICAqICAgICAgICAgICAgICAgYXQgMTI1bXMpLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICAgKiAgIC0gYCdiYXRjaCdgOiB5aWVsZCBldmVyeSBiYXRjaC5cbiAgICogICAtIGAnZXBvY2gnYDogeWllbGQgZXZlcnkgZXBvY2guXG4gICAqICAgLSBhIGBudW1iZXJgOiBXaWxsIHlpZWxkIGV2ZXJ5IGBudW1iZXJgIG1pbGxpc2Vjb25kcy5cbiAgICogICAtIGAnbmV2ZXInYDogbmV2ZXIgeWllbGQuIChCdXQgeWllbGRpbmcgY2FuIHN0aWxsIGhhcHBlbiB0aHJvdWdoIGBhd2FpdFxuICAgKiAgICAgIG5leHRGcmFtZSgpYCBjYWxscyBpbiBjdXN0b20gY2FsbGJhY2tzLilcbiAgICovXG4gIHlpZWxkRXZlcnk/OiBZaWVsZEV2ZXJ5T3B0aW9ucztcblxuICAvKipcbiAgICogRXBvY2ggYXQgd2hpY2ggdG8gc3RhcnQgdHJhaW5pbmcgKHVzZWZ1bCBmb3IgcmVzdW1pbmcgYSBwcmV2aW91cyB0cmFpbmluZ1xuICAgKiBydW4pLiBXaGVuIHRoaXMgaXMgdXNlZCwgYGVwb2Noc2AgaXMgdGhlIGluZGV4IG9mIHRoZSBcImZpbmFsIGVwb2NoXCIuXG4gICAqIFRoZSBtb2RlbCBpcyBub3QgdHJhaW5lZCBmb3IgYSBudW1iZXIgb2YgaXRlcmF0aW9ucyBnaXZlbiBieSBgZXBvY2hzYCxcbiAgICogYnV0IG1lcmVseSB1bnRpbCB0aGUgZXBvY2ggb2YgaW5kZXggYGVwb2Noc2AgaXMgcmVhY2hlZC5cbiAgICovXG4gIGluaXRpYWxFcG9jaD86IG51bWJlcjtcblxuICAvKipcbiAgICogT3B0aW9uYWwgb2JqZWN0IG1hcHBpbmcgY2xhc3MgaW5kaWNlcyAoaW50ZWdlcnMpIHRvXG4gICAqIGEgd2VpZ2h0IChmbG9hdCkgdG8gYXBwbHkgdG8gdGhlIG1vZGVsJ3MgbG9zcyBmb3IgdGhlIHNhbXBsZXMgZnJvbSB0aGlzXG4gICAqIGNsYXNzIGR1cmluZyB0cmFpbmluZy4gVGhpcyBjYW4gYmUgdXNlZnVsIHRvIHRlbGwgdGhlIG1vZGVsIHRvIFwicGF5IG1vcmVcbiAgICogYXR0ZW50aW9uXCIgdG8gc2FtcGxlcyBmcm9tIGFuIHVuZGVyLXJlcHJlc2VudGVkIGNsYXNzLlxuICAgKlxuICAgKiBJZiB0aGUgbW9kZWwgaGFzIG11bHRpcGxlIG91dHB1dHMsIGEgY2xhc3Mgd2VpZ2h0IGNhbiBiZSBzcGVjaWZpZWQgZm9yXG4gICAqIGVhY2ggb2YgdGhlIG91dHB1dHMgYnkgc2V0dGluZyB0aGlzIGZpZWxkIGFuIGFycmF5IG9mIHdlaWdodCBvYmplY3RcbiAgICogb3IgYSBvYmplY3QgdGhhdCBtYXBzIG1vZGVsIG91dHB1dCBuYW1lcyAoZS5nLiwgYG1vZGVsLm91dHB1dE5hbWVzWzBdYClcbiAgICogdG8gd2VpZ2h0IG9iamVjdHMuXG4gICAqL1xuICBjbGFzc1dlaWdodD86IENsYXNzV2VpZ2h0fENsYXNzV2VpZ2h0W118Q2xhc3NXZWlnaHRNYXA7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgRml0RGF0YXNldEVsZW1lbnQge1xuICB4czogVGVuc29yT3JBcnJheU9yTWFwO1xuICB5czogVGVuc29yT3JBcnJheU9yTWFwO1xufVxuXG4vKipcbiAqIEludGVyZmFjZSBmb3IgY29uZmlndXJpbmcgbW9kZWwgZXZhbHVhdGlvbiBiYXNlZCBvbiBhIGRhdGFzZXQgb2JqZWN0LlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsRXZhbHVhdGVEYXRhc2V0QXJncyB7XG4gIC8qKlxuICAgKiBOdW1iZXIgb2YgYmF0Y2hlcyB0byBkcmF3IGZyb20gdGhlIGRhdGFzZXQgb2JqZWN0IGJlZm9yZSBlbmRpbmcgdGhlXG4gICAqIGV2YWx1YXRpb24uXG4gICAqL1xuICBiYXRjaGVzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBWZXJib3NpdHkgbW9kZS5cbiAgICovXG4gIHZlcmJvc2U/OiBNb2RlbExvZ2dpbmdWZXJib3NpdHk7XG59XG5cbi8vIERlZmF1bHQgYmF0Y2ggc2l6ZSB1c2VkIGR1cmluZyB0ZW5zb3ItYmFzZWQgdmFsaWRhdGlvbi5cbmNvbnN0IERFRkFVTFRfVkFMSURBVElPTl9CQVRDSF9TSVpFID0gMzI7XG5cbi8qKlxuICogU3RhbmRhcmRpemUgdGhlIG91dHB1dCBvZiBhIGRhdGFzZXQgaXRlcmF0b3IgZm9yIHVzZSBieVxuICogTGF5ZXJzTW9kZWwuZml0RGF0YXNldCgpLlxuICpcbiAqIEBwYXJhbSBtb2RlbDogQSBgdGYuTGF5ZXJzTW9kZWxgIG9iamVjdC5cbiAqIEBwYXJhbSBpdGVyYXRvck91dCBUaGUgb3V0cHV0IG9mIGEgZGF0YXNldCBpdGVyYXRvci4gSXQgaXMgcmVxdWlyZWQgdG8gYmVcbiAqICAgYW4gb2JqZWN0IG9mIHRoZSBmb3JtIGB7eHM6IFRlbnNvck9yQXJyYXlPck1hcCwgeXM6XG4gKiBUZW5zb3JPckFycmF5T3JNYXB9YCwgd2hlcmUgYFRlbnNvck9yQXJyYXlPck1hcGAgaXMgYSBzaW5nbGUgYHRmLlRlbnNvcmAsXG4gKiBhIGB0Zi5UZW5zb3JbXWAsIG9yIGEgZmxhdCBtYXAgZnJvbSBzdHJpbmcgbmFtZXMgdG8gYHRmLlRlbnNvcmBzLlxuICogQHJldHVybnMgQSBmbGF0IGFycmF5IG9mIGB0Zi5UZW5zb3JgIG9iamVjdHM6IHRoZSBpbnB1dCBgdGYuVGVuc29yYHNcbiAqICAgZm9sbG93ZWQgYnkgdGhlIHRhcmdldCBgdGYuVGVuc29yYHMuICBXaGVuIGB0Zi5UZW5zb3JgcyBhcmUgcHJvdmlkZWRcbiAqICAgYXMgYSBtYXAsIHRoZSBvcmRlciBpbiB0aGUgcmVzdWx0aW5nIGFycmF5IGlzIHRha2VuIGZyb20gdGhlIGBpbnB1dE5hbWVzYFxuICogICBhbmQgYG91dHB1dE5hbWVzYCBvZiB0aGUgbW9kZWwuXG4gKi9cbmZ1bmN0aW9uIHN0YW5kYXJkaXplRGF0YUl0ZXJhdG9yT3V0cHV0KFxuICAgIC8vIFR5cGUgYG1vZGVsYCBhcyBgYW55YCBoZXJlIHRvIGF2b2lkIGNpcmN1bGFyIGRlcGVuZGVuY3kgdy9cbiAgICAvLyB0cmFpbmluZy50cy5cbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgbW9kZWw6IGFueSwgaXRlcmF0b3JPdXQ6IHt9KToge3hzOiB0ZmMuVGVuc29yW10sIHlzOiB0ZmMuVGVuc29yW119IHtcbiAgbGV0IHhzOiBUZW5zb3JPckFycmF5T3JNYXA7XG4gIGxldCB5czogVGVuc29yT3JBcnJheU9yTWFwO1xuXG4gIGNvbnN0IGl0ZXJhdG9yT3V0T2JqID0gaXRlcmF0b3JPdXQgYXMgRml0RGF0YXNldEVsZW1lbnQ7XG4gIHhzID0gaXRlcmF0b3JPdXRPYmpbJ3hzJ107XG4gIHlzID0gaXRlcmF0b3JPdXRPYmpbJ3lzJ107XG4gIHRmYy51dGlsLmFzc2VydChcbiAgICAgIHhzICE9IG51bGwgJiYgeXMgIT0gbnVsbCxcbiAgICAgICgpID0+ICdBIERhdGFzZXQgaXRlcmF0b3IgZm9yIGZpdERhdGFzZXQoKSBpcyBleHBlY3RlZCB0byBnZW5lcmF0ZSAnICtcbiAgICAgICAgICAnb2JqZWN0cyBvZiB0aGUgZm9ybSBge3hzOiB4VmFsLCB5czogeVZhbH1gLCB3aGVyZSB0aGUgdHdvICcgK1xuICAgICAgICAgICd2YWx1ZXMgbWF5IGJlIGB0Zi5UZW5zb3JgLCBhbiBhcnJheSBvZiBUZW5zb3JzLCBvciBhIG1hcCBvZiAnICtcbiAgICAgICAgICAnc3RyaW5nIHRvIFRlbnNvci4gIFRoZSBwcm92aWRlZCBEYXRhc2V0IGluc3RlYWQgZ2VuZXJhdGVzICcgK1xuICAgICAgICAgIGAke2l0ZXJhdG9yT3V0fWApO1xuXG4gIGNvbnN0IGZsYXR0ZW5lZFhzOiB0ZmMuVGVuc29yW10gPVxuICAgICAgZmxhdHRlblRlbnNvck9yQXJyYXlPck1hcCgnaW5wdXQnLCBtb2RlbC5pbnB1dE5hbWVzLCB4cyk7XG4gIGNvbnN0IGZsYXR0ZW5lZFlzOiB0ZmMuVGVuc29yW10gPVxuICAgICAgZmxhdHRlblRlbnNvck9yQXJyYXlPck1hcCgnb3V0cHV0JywgbW9kZWwub3V0cHV0TmFtZXMsIHlzKTtcblxuICBjb25zdCBiYXRjaFNpemU6IG51bWJlciA9IGZsYXR0ZW5lZFhzWzBdLnNoYXBlWzBdO1xuXG4gIHRmYy51dGlsLmFzc2VydChcbiAgICAgIGZsYXR0ZW5lZFhzLmxlbmd0aCA9PT0gbW9kZWwuaW5wdXRzLmxlbmd0aCxcbiAgICAgICgpID0+IGBMYXllcnNNb2RlbCBoYXMgJHttb2RlbC5pbnB1dHMubGVuZ3RofSBpbnB1dHMsIGJ1dCB0aGUgZGF0YXNldCBgICtcbiAgICAgICAgICBgcHJvdmlkZXMgJHtmbGF0dGVuZWRYcy5sZW5ndGh9IGlucHV0cy4gIChFeHBlY3RlZCBpbnB1dCBrZXlzOiBgICtcbiAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeShtb2RlbC5pbnB1dE5hbWVzKX0pYCk7XG5cbiAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgZmxhdHRlbmVkWXMubGVuZ3RoID09PSBtb2RlbC5vdXRwdXRzLmxlbmd0aCxcbiAgICAgICgpID0+XG4gICAgICAgICAgYExheWVyc01vZGVsIGhhcyAke21vZGVsLm91dHB1dHMubGVuZ3RofSBvdXRwdXRzLCBidXQgdGhlIGRhdGFzZXQgYCArXG4gICAgICAgICAgYHByb3ZpZGVzICR7ZmxhdHRlbmVkWXMubGVuZ3RofSBvdXRwdXRzLiAgKEV4cGVjdGVkIG91dHB1dCBrZXlzOiBgICtcbiAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeShtb2RlbC5vdXRwdXROYW1lcyl9KWApO1xuXG4gIGZvciAobGV0IHhJbmRleCA9IDA7IHhJbmRleCA8IGZsYXR0ZW5lZFhzLmxlbmd0aDsgeEluZGV4KyspIHtcbiAgICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICAgIGZsYXR0ZW5lZFhzW3hJbmRleF0uc2hhcGVbMF0gPT09IGJhdGNoU2l6ZSxcbiAgICAgICAgKCkgPT4gYEJhdGNoIHNpemUgbWlzbWF0Y2g6IGlucHV0IGAgK1xuICAgICAgICAgICAgYCR7bW9kZWwuaW5wdXROYW1lc1t4SW5kZXhdfSBoYXMgJHtcbiAgICAgICAgICAgICAgICAgIGZsYXR0ZW5lZFhzW3hJbmRleF0uc2hhcGVbMF19OyBgICtcbiAgICAgICAgICAgIGBleHBlY3RlZCAgJHtiYXRjaFNpemV9IGJhc2VkIG9uIGlucHV0ICR7bW9kZWwuaW5wdXROYW1lc1swXX0uYCk7XG4gIH1cblxuICBmb3IgKGxldCB5SW5kZXggPSAwOyB5SW5kZXggPCBmbGF0dGVuZWRZcy5sZW5ndGg7IHlJbmRleCsrKSB7XG4gICAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgICBmbGF0dGVuZWRZc1t5SW5kZXhdLnNoYXBlWzBdID09PSBiYXRjaFNpemUsXG4gICAgICAgICgpID0+IGBCYXRjaCBzaXplIG1pc21hdGNoOiBvdXRwdXQgYCArXG4gICAgICAgICAgICBgJHttb2RlbC5vdXRwdXROYW1lc1t5SW5kZXhdfSBoYXMgJHtcbiAgICAgICAgICAgICAgICAgIGZsYXR0ZW5lZFlzW3lJbmRleF0uc2hhcGVbMF19OyBgICtcbiAgICAgICAgICAgIGBleHBlY3RlZCAgJHtiYXRjaFNpemV9IGJhc2VkIG9uIGlucHV0ICR7bW9kZWwuaW5wdXROYW1lc1swXX0uYCk7XG4gIH1cblxuICByZXR1cm4ge3hzOiBmbGF0dGVuZWRYcywgeXM6IGZsYXR0ZW5lZFlzfTtcbn1cblxuZnVuY3Rpb24gZmxhdHRlblRlbnNvck9yQXJyYXlPck1hcChcbiAgICBpbnB1dE9yT3V0cHV0OiBzdHJpbmcsIG5hbWVzOiBzdHJpbmdbXSwgdmFsdWVzOiBUZW5zb3JPckFycmF5T3JNYXApIHtcbiAgaWYgKHZhbHVlcyBpbnN0YW5jZW9mIHRmYy5UZW5zb3IpIHtcbiAgICByZXR1cm4gW3ZhbHVlc107XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZXMpKSB7XG4gICAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgICB2YWx1ZXMubGVuZ3RoID09PSBuYW1lcy5sZW5ndGgsXG4gICAgICAgICgpID0+IGBSZWNlaXZlZCBhbiBhcnJheSBvZiAke3ZhbHVlcy5sZW5ndGh9IFRlbnNvcnMsIGJ1dCBleHBlY3RlZCAke1xuICAgICAgICAgICAgbmFtZXMubGVuZ3RofSB0byBtYXRjaCB0aGUgJHtpbnB1dE9yT3V0cHV0fSBrZXlzICR7bmFtZXN9LmApO1xuICAgIHJldHVybiB2YWx1ZXM7XG4gIH0gZWxzZSB7XG4gICAgY29uc3QgcmVzdWx0OiB0ZmMuVGVuc29yW10gPSBbXTtcbiAgICAvLyBDaGVjayB0aGF0IGFsbCB0aGUgcmVxdWlyZWQga2V5cyBhcmUgYXZhaWxhYmxlLlxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgaWYgKHZhbHVlc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYFRoZSBmZWF0dXJlIGRhdGEgZ2VuZXJhdGVkIGJ5IHRoZSBkYXRhc2V0IGxhY2tzIHRoZSByZXF1aXJlZCBgICtcbiAgICAgICAgICAgIGAke2lucHV0T3JPdXRwdXR9IGtleSAnJHtuYW1lfScuYCk7XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaCh2YWx1ZXNbbmFtZV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHN0YW5kYXJkaXplVGVuc29yVmFsaWRhdGlvbkRhdGE8VD4oXG4gICAgZGF0YTpcbiAgICAgICAgW1xuICAgICAgICAgIHRmYy5UZW5zb3J8dGZjLlRlbnNvcltdLCB0ZmMuVGVuc29yfHRmYy5UZW5zb3JbXVxuICAgICAgICBdfFt0ZmMuVGVuc29yIHwgdGZjLlRlbnNvcltdLCB0ZmMuVGVuc29yIHwgdGZjLlRlbnNvcltdLFxuICAgICAgICAgICB0ZmMuVGVuc29yIHwgdGZjLlRlbnNvcltdXSk6XG4gICAge3hzOiB0ZmMuVGVuc29yfHRmYy5UZW5zb3JbXSwgeXM6IHRmYy5UZW5zb3J8dGZjLlRlbnNvcltdfSB7XG4gIGlmIChkYXRhLmxlbmd0aCA9PT0gMykge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAnVmFsaWRhdGlvbiB3aXRoIHNhbXBsZSB3ZWlnaHRzIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gIH1cbiAgcmV0dXJuIHt4czogZGF0YVswXSwgeXM6IGRhdGFbMV19O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZml0RGF0YXNldDxUPihcbiAgICAvLyBUeXBlIGBtb2RlbGAgYXMgYGFueWAgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IHcvXG4gICAgLy8gdHJhaW5pbmcudHMuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIG1vZGVsOiBhbnksIGRhdGFzZXQ6IERhdGFzZXQ8VD4sXG4gICAgYXJnczogTW9kZWxGaXREYXRhc2V0QXJnczxUPik6IFByb21pc2U8SGlzdG9yeT4ge1xuICBjb25zdCBoYXNCYXRjaGVzUGVyRXBvY2ggPSBhcmdzLmJhdGNoZXNQZXJFcG9jaCAhPSBudWxsO1xuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICBtb2RlbC5vcHRpbWl6ZXIgIT0gbnVsbCxcbiAgICAgICgpID0+ICdZb3UgbXVzdCBjb21waWxlIGEgbW9kZWwgYmVmb3JlIHRyYWluaW5nL3Rlc3RpbmcuIFVzZSAnICtcbiAgICAgICAgICAnTGF5ZXJzTW9kZWwuY29tcGlsZShtb2RlbENvbXBpbGVDb25maWcpLicpO1xuXG4gIHRmYy51dGlsLmFzc2VydChcbiAgICAgIGFyZ3MgIT0gbnVsbCxcbiAgICAgICgpID0+IGBGb3IgZml0RGF0YXNldCgpLCB0aGUgMm5kIGFyZ3VtZW50IChjb25maWcpIGlzIHJlcXVpcmVkLCBgICtcbiAgICAgICAgICBgYnV0IGl0IGlzIG5vdCBwcm92aWRlZCBpbiB0aGlzIGNhbGwuYCk7XG4gIHRmYy51dGlsLmFzc2VydChcbiAgICAgIGFyZ3MuZXBvY2hzICE9IG51bGwgJiYgYXJncy5lcG9jaHMgPiAwICYmIE51bWJlci5pc0ludGVnZXIoYXJncy5lcG9jaHMpLFxuICAgICAgKCkgPT4gYEZvciBmaXREYXRhc2V0KCksIGNvbmZpZy5lcG9jaHMgaXMgZXhwZWN0ZWQgdG8gYmUgYSBwb3NpdGl2ZSBgICtcbiAgICAgICAgICBgaW50ZWdlciwgYnV0IGdvdCAke2FyZ3MuZXBvY2hzfWApO1xuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICAhaGFzQmF0Y2hlc1BlckVwb2NoIHx8XG4gICAgICAgICAgKGFyZ3MuYmF0Y2hlc1BlckVwb2NoID4gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3MuYmF0Y2hlc1BlckVwb2NoKSksXG4gICAgICAoKSA9PiBgRm9yIGZpdERhdGFzZXQoKSwgY29uZmlnLmJhdGNoZXNQZXJFcG9jaCBpcyBleHBlY3RlZCB0byBiZSBhIGAgK1xuICAgICAgICAgIGBwb3NpdGl2ZSBpbnRlZ2VyIGlmIHNwZWNpZmllZCwgYnV0IGdvdCAke2FyZ3MuYmF0Y2hlc1BlckVwb2NofWApO1xuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAoYXJncyBhcyBhbnkpWyd2YWxpZGF0aW9uU3BsaXQnXSA9PSBudWxsLFxuICAgICAgKCkgPT4gJ2B2YWxpZGF0aW9uU3BsaXRgIGlzIG5vdCBzdXBwb3J0ZWQgYnkgYGZpdERhdGFzZXQoKWAuICcgK1xuICAgICAgICAgICdVc2UgdmFsaWRhdGlvbkRhdGEgaW5zdGVhZC4nKTtcblxuICBpZiAobW9kZWwuaXNUcmFpbmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBzdGFydCB0cmFpbmluZyBiZWNhdXNlIGFub3RoZXIgZml0KCkgY2FsbCBpcyBvbmdvaW5nLicpO1xuICB9XG4gIG1vZGVsLmlzVHJhaW5pbmcgPSB0cnVlO1xuXG4gIHRyeSB7XG4gICAgY29uc3QgZG9WYWxpZGF0aW9uID0gYXJncy52YWxpZGF0aW9uRGF0YSAhPSBudWxsO1xuICAgIGxldCB2YWxYczogdGZjLlRlbnNvcnx0ZmMuVGVuc29yW107XG4gICAgbGV0IHZhbFlzOiB0ZmMuVGVuc29yfHRmYy5UZW5zb3JbXTtcbiAgICBpZiAoZG9WYWxpZGF0aW9uKSB7XG4gICAgICBpZiAoaXNEYXRhc2V0T2JqZWN0KGFyZ3MudmFsaWRhdGlvbkRhdGEpKSB7XG4gICAgICAgIHRmYy51dGlsLmFzc2VydChcbiAgICAgICAgICAgIGFyZ3MudmFsaWRhdGlvbkJhdGNoZXMgPT0gbnVsbCB8fFxuICAgICAgICAgICAgICAgIChhcmdzLnZhbGlkYXRpb25CYXRjaGVzID4gMCAmJlxuICAgICAgICAgICAgICAgICBOdW1iZXIuaXNJbnRlZ2VyKGFyZ3MudmFsaWRhdGlvbkJhdGNoZXMpKSxcbiAgICAgICAgICAgICgpID0+IGBGb3IgZml0RGF0YXNldCgpIHdpdGggZGF0YXNldC1iYXNlZCB2YWxpZGF0aW9uLCBgICtcbiAgICAgICAgICAgICAgICBgY29uZmlnLnZhbGlkYXRpb25CYXRjaGVzIGlzIGV4cGVjdGVkIG5vdCB0byBiZSBwcm92aWRlZCwgYCArXG4gICAgICAgICAgICAgICAgYG9yIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYCArXG4gICAgICAgICAgICAgICAgYGJ1dCBnb3QgJHthcmdzLnZhbGlkYXRpb25CYXRjaGVzfWApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbkRhdGEgPSBzdGFuZGFyZGl6ZVRlbnNvclZhbGlkYXRpb25EYXRhKFxuICAgICAgICAgICAgYXJncy52YWxpZGF0aW9uRGF0YSBhc1xuICAgICAgICAgICAgICAgICAgICBbdGZjLlRlbnNvciB8IHRmYy5UZW5zb3JbXSwgdGZjLlRlbnNvciB8IHRmYy5UZW5zb3JbXV0gfFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICB0ZmMuVGVuc29yIHwgdGZjLlRlbnNvcltdLCB0ZmMuVGVuc29yIHwgdGZjLlRlbnNvcltdLFxuICAgICAgICAgICAgICB0ZmMuVGVuc29yIHwgdGZjLlRlbnNvcltdXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgdmFsWHMgPSB2YWxpZGF0aW9uRGF0YS54cztcbiAgICAgICAgdmFsWXMgPSB2YWxpZGF0aW9uRGF0YS55cztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjb25zdCB0cmFpbkZ1bmN0aW9uID0gbW9kZWwubWFrZVRyYWluRnVuY3Rpb24oKTtcbiAgICBjb25zdCBvdXRMYWJlbHMgPSBtb2RlbC5nZXREZWR1cGVkTWV0cmljc05hbWVzKCkgYXMgc3RyaW5nW107XG5cbiAgICBsZXQgY2FsbGJhY2tNZXRyaWNzOiBzdHJpbmdbXTtcbiAgICBpZiAoZG9WYWxpZGF0aW9uKSB7XG4gICAgICBjYWxsYmFja01ldHJpY3MgPVxuICAgICAgICAgIG91dExhYmVscy5zbGljZSgpLmNvbmNhdChvdXRMYWJlbHMubWFwKG4gPT4gJ3ZhbF8nICsgbikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjYWxsYmFja01ldHJpY3MgPSBvdXRMYWJlbHMuc2xpY2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFja3MgPSBzdGFuZGFyZGl6ZUNhbGxiYWNrcyhhcmdzLmNhbGxiYWNrcywgYXJncy55aWVsZEV2ZXJ5KTtcbiAgICBjb25zdCB2ZXJib3NlID0gYXJncy52ZXJib3NlID09IG51bGwgPyAxIDogYXJncy52ZXJib3NlO1xuICAgIGNvbnN0IHtjYWxsYmFja0xpc3QsIGhpc3Rvcnl9ID0gY29uZmlndXJlQ2FsbGJhY2tzKFxuICAgICAgICBjYWxsYmFja3MsIHZlcmJvc2UsIGFyZ3MuZXBvY2hzLCBudWxsLCBudWxsLFxuICAgICAgICBnZXRTdGVwc1BlckVwb2NoKGRhdGFzZXQsIGFyZ3MpLFxuICAgICAgICBudWxsLCAgLy8gQmF0Y2ggc2l6ZSBkZXRlcm1pbmVkIGJ5IHRoZSBkYXRhc2V0IGl0c2VsZi5cbiAgICAgICAgZG9WYWxpZGF0aW9uLCBjYWxsYmFja01ldHJpY3MpO1xuICAgIGNhbGxiYWNrTGlzdC5zZXRNb2RlbChtb2RlbCk7XG4gICAgbW9kZWwuaGlzdG9yeSA9IGhpc3Rvcnk7XG5cbiAgICBhd2FpdCBjYWxsYmFja0xpc3Qub25UcmFpbkJlZ2luKCk7XG4gICAgbW9kZWwuc3RvcFRyYWluaW5nXyA9IGZhbHNlO1xuICAgIGxldCBlcG9jaCA9IGFyZ3MuaW5pdGlhbEVwb2NoID09IG51bGwgPyAwIDogYXJncy5pbml0aWFsRXBvY2g7XG5cbiAgICBsZXQgZGF0YUl0ZXJhdG9yID0gYXdhaXQgZGF0YXNldC5pdGVyYXRvcigpO1xuICAgIHdoaWxlIChlcG9jaCA8IGFyZ3MuZXBvY2hzKSB7XG4gICAgICBjb25zdCBlcG9jaExvZ3M6IFVucmVzb2x2ZWRMb2dzID0ge307XG4gICAgICBhd2FpdCBjYWxsYmFja0xpc3Qub25FcG9jaEJlZ2luKGVwb2NoKTtcbiAgICAgIGxldCBzdGVwc0RvbmUgPSAwO1xuICAgICAgbGV0IGJhdGNoSW5kZXggPSAwO1xuICAgICAgaWYgKCFoYXNCYXRjaGVzUGVyRXBvY2gpIHtcbiAgICAgICAgZGF0YUl0ZXJhdG9yID0gYXdhaXQgZGF0YXNldC5pdGVyYXRvcigpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGhhc0JhdGNoZXNQZXJFcG9jaCA/IHN0ZXBzRG9uZSA8IGFyZ3MuYmF0Y2hlc1BlckVwb2NoIDogdHJ1ZSkge1xuICAgICAgICBjb25zdCBpdGVyYXRvck91dCA9IGF3YWl0IGRhdGFJdGVyYXRvci5uZXh0KCk7XG5cbiAgICAgICAgLy8gSWYgYGJhdGNoZXNQZXJFcG9jaGAgaXMgc3BlY2lmaWVkLCB0aGUgZGF0YXNldCBzaG91bGQgbm90IGJlXG4gICAgICAgIC8vIGV4aGF1c3RlZCB1bnRpbCBhbGwgZXBvY2hlcyBhcmUgZG9uZS5cbiAgICAgICAgaWYgKGhhc0JhdGNoZXNQZXJFcG9jaCAmJiBpdGVyYXRvck91dC5kb25lKSB7XG4gICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAnWW91IHByb3ZpZGVkIGBiYXRjaGVzUGVyRXBvY2hgIGFzICcgK1xuICAgICAgICAgICAgICBgJHthcmdzLmJhdGNoZXNQZXJFcG9jaH0sIGAgK1xuICAgICAgICAgICAgICAnYnV0IHlvdXIgZGF0YXNldCBpdGVyYXRvciByYW4gb3V0IG9mIGRhdGEgYWZ0ZXIgJyArXG4gICAgICAgICAgICAgIGAke3N0ZXBzRG9uZX0gYmF0Y2hlczsgYCArXG4gICAgICAgICAgICAgICdpbnRlcnJ1cHRpbmcgdHJhaW5pbmcuIE1ha2Ugc3VyZSB0aGF0IHlvdXIgJyArXG4gICAgICAgICAgICAgICdkYXRhc2V0IGNhbiBnZW5lcmF0ZSBhdCBsZWFzdCBgYmF0Y2hlc1BlckVwb2NoICogZXBvY2hzYCAnICtcbiAgICAgICAgICAgICAgJ2JhdGNoZXMgKGluIHRoaXMgY2FzZSwgJyArXG4gICAgICAgICAgICAgIGAke2FyZ3MuYmF0Y2hlc1BlckVwb2NoICogYXJncy5lcG9jaHN9IGJhdGNoZXMpLiBgICtcbiAgICAgICAgICAgICAgJ1lvdSBtYXkgbmVlZCB0byB1c2UgdGhlIHJlcGVhdCgpIGZ1bmN0aW9uIHdoZW4gYnVpbGRpbmcgJyArXG4gICAgICAgICAgICAgICd5b3VyIGRhdGFzZXQuJyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXRlcmF0b3JPdXQudmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgIGNvbnN0IHt4cywgeXN9ID1cbiAgICAgICAgICAgICAgc3RhbmRhcmRpemVEYXRhSXRlcmF0b3JPdXRwdXQobW9kZWwsIGl0ZXJhdG9yT3V0LnZhbHVlKTtcbiAgICAgICAgICBjb25zdCBiYXRjaExvZ3M6IFVucmVzb2x2ZWRMb2dzID0ge307XG4gICAgICAgICAgYmF0Y2hMb2dzWydiYXRjaCddID0gYmF0Y2hJbmRleDtcbiAgICAgICAgICBiYXRjaExvZ3NbJ3NpemUnXSA9IHhzWzBdLnNoYXBlWzBdO1xuXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uQmF0Y2hCZWdpbihiYXRjaEluZGV4LCBiYXRjaExvZ3MpO1xuXG4gICAgICAgICAgY29uc3Qgc2FtcGxlV2VpZ2h0czogdGZjLlRlbnNvcltdID0gW107XG4gICAgICAgICAgaWYgKGFyZ3MuY2xhc3NXZWlnaHQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgc3RhbmRhcmRDbGFzc1dlaWdodHMgPVxuICAgICAgICAgICAgICAgIHN0YW5kYXJkaXplQ2xhc3NXZWlnaHRzKGFyZ3MuY2xhc3NXZWlnaHQsIG1vZGVsLm91dHB1dE5hbWVzKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RhbmRhcmRDbGFzc1dlaWdodHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgc2FtcGxlV2VpZ2h0cy5wdXNoKGF3YWl0IHN0YW5kYXJkaXplV2VpZ2h0cyhcbiAgICAgICAgICAgICAgICAgIHlzW2ldLCBudWxsLCBzdGFuZGFyZENsYXNzV2VpZ2h0c1tpXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIC8vIFRyYWluIG9uIGJhdGNoLlxuICAgICAgICAgIGNvbnN0IGlucyA9IHhzLmNvbmNhdCh5cykuY29uY2F0KHNhbXBsZVdlaWdodHMpO1xuICAgICAgICAgIGNvbnN0IG91dHMgPSB0cmFpbkZ1bmN0aW9uKGlucyk7XG4gICAgICAgICAgdGZjLmRpc3Bvc2UoaW5zKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBvdXRMYWJlbHNbaV07XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBvdXRzW2ldO1xuICAgICAgICAgICAgYmF0Y2hMb2dzW2xhYmVsXSA9IG91dDtcbiAgICAgICAgICAgIHRmYy5rZWVwKG91dCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uQmF0Y2hFbmQoYmF0Y2hJbmRleCwgYmF0Y2hMb2dzKTtcbiAgICAgICAgICBkaXNwb3NlVGVuc29yc0luTG9ncyhiYXRjaExvZ3MpO1xuXG4gICAgICAgICAgYmF0Y2hJbmRleCsrO1xuICAgICAgICAgIHN0ZXBzRG9uZSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGhhc0JhdGNoZXNQZXJFcG9jaCA/IHN0ZXBzRG9uZSA+PSBhcmdzLmJhdGNoZXNQZXJFcG9jaCA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVyYXRvck91dC5kb25lKSB7XG4gICAgICAgICAgLy8gRXBvY2ggZmluaXNoZWQuIFBlcmZvcm0gdmFsaWRhdGlvbi5cbiAgICAgICAgICBpZiAoZG9WYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICBsZXQgdmFsT3V0czogdGZjLlNjYWxhcltdO1xuICAgICAgICAgICAgaWYgKGlzRGF0YXNldE9iamVjdChhcmdzLnZhbGlkYXRpb25EYXRhKSkge1xuICAgICAgICAgICAgICB2YWxPdXRzID0gdG9MaXN0KGF3YWl0IG1vZGVsLmV2YWx1YXRlRGF0YXNldChcbiAgICAgICAgICAgICAgICAgIGFyZ3MudmFsaWRhdGlvbkRhdGEsIHtiYXRjaGVzOiBhcmdzLnZhbGlkYXRpb25CYXRjaGVzfSkpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgdmFsT3V0cyA9IHRvTGlzdChtb2RlbC5ldmFsdWF0ZSh2YWxYcywgdmFsWXMsIHtcbiAgICAgICAgICAgICAgICBiYXRjaFNpemU6IGFyZ3MudmFsaWRhdGlvbkJhdGNoU2l6ZSA9PSBudWxsID9cbiAgICAgICAgICAgICAgICAgICAgREVGQVVMVF9WQUxJREFUSU9OX0JBVENIX1NJWkUgOlxuICAgICAgICAgICAgICAgICAgICBhcmdzLnZhbGlkYXRpb25CYXRjaFNpemUsXG4gICAgICAgICAgICAgICAgdmVyYm9zZTogMFxuICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG1vZGVsLm1ldHJpY3NOYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBlcG9jaExvZ3NbYHZhbF8ke21vZGVsLm1ldHJpY3NOYW1lc1tpXX1gXSA9IHZhbE91dHNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIENhbGwgYGJyZWFrYCB0byBleGl0IG9uZSBlcG9jaCBsb3BwIGFmdGVyIHZhbGlkYXRpb24gaXMgZG9uZS4gSWZcbiAgICAgICAgICAvLyBjb25maWcuYmF0Y2hlc1BlckVwb2NoIGlzIHNwZWNpZmllZCwgYW4gZXBvY2ggd2hpbGUgbG9vcCB3aWxsXG4gICAgICAgICAgLy8gc3RvcCB3aGVuIGBzdGVwc0RvbmUgPj0gY29uZmlnLmJhdGNoZXNQZXJFcG9jaGAuIFdoZW5cbiAgICAgICAgICAvLyBjb25maWcuYmF0Y2hlc1BlckVwb2NoIGlzIG5vdCBwcm92aWRlZCwgdGhlIGZvbGxvd2luZyBgYnJlYWtgIGlzXG4gICAgICAgICAgLy8gcmVxdWlyZWQgdG8gZXhpdCB0aGUgd2hpbGUgbG9wcCBhZnRlciBkYXRhc2V0IGlzIGV4aGF1c3RlZC5cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtb2RlbC5zdG9wVHJhaW5pbmdfKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGF3YWl0IGNhbGxiYWNrTGlzdC5vbkVwb2NoRW5kKGVwb2NoLCBlcG9jaExvZ3MpO1xuICAgICAgZXBvY2grKztcbiAgICAgIGlmIChtb2RlbC5zdG9wVHJhaW5pbmdfKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBhd2FpdCBjYWxsYmFja0xpc3Qub25UcmFpbkVuZCgpO1xuICAgIGF3YWl0IG1vZGVsLmhpc3Rvcnkuc3luY0RhdGEoKTtcbiAgICByZXR1cm4gbW9kZWwuaGlzdG9yeTtcbiAgfSBmaW5hbGx5IHtcbiAgICBtb2RlbC5pc1RyYWluaW5nID0gZmFsc2U7XG4gIH1cbn1cblxuLyoqIEhlbHBlciBmdW5jdGlvbiB0aGF0IGRldGVybWluZXMgbnVtYmVyIG9mIHN0ZXBzIChiYXRjaGVzKSBwZXIgZXBvY2guICovXG5mdW5jdGlvbiBnZXRTdGVwc1BlckVwb2NoPFQ+KFxuICAgIGRhdGFzZXQ6IERhdGFzZXQ8VD4sIGFyZ3M6IE1vZGVsRml0RGF0YXNldEFyZ3M8VD4pOiBudW1iZXIge1xuICAvLyBBdHRlbXB0IHRvIGRldGVybWluZSAjIG9mIGJhdGNoZXMgaW4gYW4gZXBvY2guXG4gIGxldCBzdGVwc1BlckVwb2NoOiBudW1iZXIgPSBudWxsO1xuICBpZiAoYXJncy5iYXRjaGVzUGVyRXBvY2ggIT0gbnVsbCkge1xuICAgIHN0ZXBzUGVyRXBvY2ggPSBhcmdzLmJhdGNoZXNQZXJFcG9jaDtcbiAgfSBlbHNlIGlmIChOdW1iZXIuaXNGaW5pdGUoZGF0YXNldC5zaXplKSkge1xuICAgIHN0ZXBzUGVyRXBvY2ggPSBkYXRhc2V0LnNpemU7XG4gIH1cbiAgcmV0dXJuIHN0ZXBzUGVyRXBvY2g7XG59XG5cbi8vIENoZWNrIGlmIHByb3ZpZGVkIG9iamVjdCBpcyBhIERhdGFzZXQgb2JqZWN0IGJ5IGNoZWNraW5nIGl0cyAuaXRlcmF0b3Jcbi8vIGVsZW1lbnQuXG5mdW5jdGlvbiBpc0RhdGFzZXRPYmplY3Q8VD4oXG4gICAgZGF0YXNldDpcbiAgICAgICAgW1xuICAgICAgICAgIFRlbnNvck9yQXJyYXlPck1hcCwgVGVuc29yT3JBcnJheU9yTWFwXG4gICAgICAgIF18W1RlbnNvck9yQXJyYXlPck1hcCwgVGVuc29yT3JBcnJheU9yTWFwLCBUZW5zb3JPckFycmF5T3JNYXBdfFxuICAgIERhdGFzZXQ8VD4pOiBib29sZWFuIHtcbiAgcmV0dXJuICh0eXBlb2YgKGRhdGFzZXQgYXMgRGF0YXNldDxUPikuaXRlcmF0b3IgPT09ICdmdW5jdGlvbicpO1xufVxuXG4vLyBDaGVjayBpZiBwcm92aWRlZCBvYmplY3QgaXMgYSBMYXp5SXRlcmF0b3Igb2JqZWN0IGJ5IGNoZWNraW5nIGl0J3MgLm5leHRcbi8vIGVsZW1lbnQuXG5mdW5jdGlvbiBpc0xhenlJdGVyYXRvck9iamVjdDxUPihpdGVyYXRvcjogRGF0YXNldDxUPnxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIExhenlJdGVyYXRvcjxUPik6IGJvb2xlYW4ge1xuICByZXR1cm4gKHR5cGVvZiAoaXRlcmF0b3IgYXMgTGF6eUl0ZXJhdG9yPFQ+KS5uZXh0ID09PSAnZnVuY3Rpb24nKTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGV2YWx1YXRlRGF0YXNldDxUPihcbiAgICAvLyBUeXBlIGBtb2RlbGAgYXMgYGFueWAgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IHcvXG4gICAgLy8gdHJhaW5pbmcudHMuXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgIG1vZGVsOiBhbnksIGRhdGFzZXQ6IERhdGFzZXQ8VD58TGF6eUl0ZXJhdG9yPFQ+LFxuICAgIGFyZ3M6IE1vZGVsRXZhbHVhdGVEYXRhc2V0QXJncyk6IFByb21pc2U8dGZjLlNjYWxhcnx0ZmMuU2NhbGFyW10+IHtcbiAgYXJncyA9IGFyZ3MgfHwge307XG4gIGNvbnN0IGhhc0JhdGNoZXMgPSBhcmdzLmJhdGNoZXMgIT0gbnVsbDtcbiAgY29uc3QgZiA9IG1vZGVsLnRlc3RGdW5jdGlvbjtcbiAgbGV0IG91dHM6IHRmYy5TY2FsYXJbXSA9IFtdO1xuICBpZiAoYXJncy52ZXJib3NlID4gMCkge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCdWZXJib3NlIG1vZGUgaXMgbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgfVxuXG4gIHRmYy51dGlsLmFzc2VydChcbiAgICAgICFoYXNCYXRjaGVzIHx8IChhcmdzLmJhdGNoZXMgPiAwICYmIE51bWJlci5pc0ludGVnZXIoYXJncy5iYXRjaGVzKSksXG4gICAgICAoKSA9PiAnVGVzdCBsb29wIGV4cGVjdHMgYGJhdGNoZXNgIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0ICcgK1xuICAgICAgICAgIGByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGFyZ3MuYmF0Y2hlcyl9YCk7XG4gIGNvbnN0IGRhdGFJdGVyYXRvciA9IGlzTGF6eUl0ZXJhdG9yT2JqZWN0KGRhdGFzZXQpID9cbiAgICAgIGRhdGFzZXQgYXMgTGF6eUl0ZXJhdG9yPFQ+OlxuICAgICAgYXdhaXQgKGRhdGFzZXQgYXMgRGF0YXNldDxUPikuaXRlcmF0b3IoKTtcbiAgLy8gS2VlcHMgdHJhY2sgb2YgbnVtYmVyIG9mIGV4YW1wbGVzIHVzZWQgaW4gdGhpcyBldmFsdWF0aW9uLlxuICBsZXQgbnVtRXhhbXBsZXMgPSAwO1xuICBsZXQgYmF0Y2ggPSAwO1xuXG4gIHdoaWxlIChoYXNCYXRjaGVzID8gYmF0Y2ggPCBhcmdzLmJhdGNoZXMgOiB0cnVlKSB7XG4gICAgY29uc3QgaXRlcmF0b3JPdXQgPSBhd2FpdCBkYXRhSXRlcmF0b3IubmV4dCgpO1xuICAgIG91dHMgPSB0ZmMudGlkeSgoKSA9PiB7XG4gICAgICBpZiAoaXRlcmF0b3JPdXQudmFsdWUpIHtcbiAgICAgICAgLy8gVE9ETyhjYWlzKTogT25jZSByZWFsIGRhdGFzZXQgaXMgYXZhaWxhYmxlLCB1c2VcbiAgICAgICAgLy8gICBgbWFwKHggPT4gc3RhbmRhcmRpemVEYXRhSXRlcmF0b3JPdXRwdXQobW9kZWwsIHgpLm1hcChmKWAuXG4gICAgICAgIGNvbnN0IHt4cywgeXN9ID1cbiAgICAgICAgICAgIHN0YW5kYXJkaXplRGF0YUl0ZXJhdG9yT3V0cHV0KG1vZGVsLCBpdGVyYXRvck91dC52YWx1ZSk7XG4gICAgICAgIGNvbnN0IHhzQW5kWXMgPSB4cy5jb25jYXQoeXMpO1xuICAgICAgICBjb25zdCBiYXRjaE91dHMgPSB0ZmMudGlkeSgoKSA9PiBmKHhzQW5kWXMpKTtcbiAgICAgICAgdGZjLmRpc3Bvc2UoeHNBbmRZcyk7XG5cbiAgICAgICAgaWYgKGJhdGNoID09PSAwKSB7XG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBiYXRjaE91dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIG91dHMucHVzaChzY2FsYXIoMCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IHhzQW5kWXNbMF0uc2hhcGVbMF07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hPdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgYmF0Y2hPdXQgPSBiYXRjaE91dHNbaV07XG4gICAgICAgICAgY29uc3Qgb2xkU2NhbGFyID0gb3V0c1tpXTtcbiAgICAgICAgICBvdXRzW2ldID1cbiAgICAgICAgICAgICAgdGZjLnRpZHkoKCkgPT4gdGZjLmFkZChvdXRzW2ldLCB0ZmMubXVsKGJhdGNoU2l6ZSwgYmF0Y2hPdXQpKSk7XG4gICAgICAgICAgaWYgKGJhdGNoID4gMCkge1xuICAgICAgICAgICAgdGZjLmRpc3Bvc2Uob2xkU2NhbGFyKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGZjLmRpc3Bvc2UoYmF0Y2hPdXRzKTtcbiAgICAgICAgbnVtRXhhbXBsZXMgKz0gYmF0Y2hTaXplO1xuXG4gICAgICAgICsrYmF0Y2g7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cztcbiAgICB9KTtcblxuICAgIGlmIChpdGVyYXRvck91dC5kb25lKSB7XG4gICAgICBpZiAoaGFzQmF0Y2hlcykge1xuICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAnWW91ciBkYXRhc2V0IGl0ZXJhdG9yIHJhbiBvdXQgb2YgZGF0YSBkdXJpbmcgZXZhbHVhdGVEYXRhc2V0KCkuICcgK1xuICAgICAgICAgICAgJ0ludGVycnVwdGluZyBldmFsdXRpb24uIE1ha2Ugc3VyZSB0aGF0IHlvdXIgJyArXG4gICAgICAgICAgICAnZGF0YXNldCBjYW4gZ2VuZXJhdGUgYXQgbGVhc3QgYGJhdGNoZXNgICcgK1xuICAgICAgICAgICAgYGJhdGNoZXMgKGluIHRoaXMgY2FzZSwgJHthcmdzLmJhdGNoZXN9IGJhdGNoZXMpLiBgICtcbiAgICAgICAgICAgICdZb3UgbWF5IG5lZWQgdG8gdXNlIHRoZSByZXBlYXQoKSBmdW5jdGlvbiB3aGVuIGJ1aWxkaW5nICcgK1xuICAgICAgICAgICAgJ3lvdXIgZGF0YXNldC4nKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgb3V0cy5sZW5ndGg7ICsraSkge1xuICAgIGNvbnN0IG9sZFNjYWxhciA9IG91dHNbaV07XG4gICAgb3V0c1tpXSA9IHRmYy5kaXYob3V0c1tpXSwgbnVtRXhhbXBsZXMpO1xuICAgIHRmYy5kaXNwb3NlKG9sZFNjYWxhcik7XG4gIH1cblxuICByZXR1cm4gc2luZ2xldG9uT3JBcnJheShvdXRzKTtcbn1cbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Interfaces and methods for training models using tf.Tensor objects.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { Tensor, tensor1d, util } from '@tensorflow/tfjs-core';\nimport { expandDims, gather, sliceAlongFirstAxis } from '../backend/tfjs_backend';\nimport { configureCallbacks, standardizeCallbacks } from '../base_callbacks';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { disposeTensorsInLogs } from '../logs';\nimport { range } from '../utils/math_utils';\nexport function checkBatchSize(batchSize) {\n    tfc.util.assert(batchSize > 0 && Number.isInteger(batchSize), () => `batchSize is required to be a positive integer, but got ${batchSize}`);\n}\n/**\n * Slice a Tensor or an Array of Tensors, by start and stop indices.\n *\n * Porting Note: The `_slice_arrays` function in PyKeras is covered by this\n *   function and `sliceArraysByIndices()` together.\n *\n * @param arrays: the input.\n * @param start: the starting index (inclusive).\n * @param stop: the stopping index (exclusive).\n * @returns The result of the slicing. If `arrays` is an `Array` of\n *   `tf.Tensor`s, the slicing will be applied to all elements of the `Array`\n *   in the same way.\n */\nexport function sliceArrays(arrays, start, stop) {\n    if (arrays == null) {\n        return [null];\n    }\n    else if (Array.isArray(arrays)) {\n        return arrays.map(array => sliceAlongFirstAxis(array, start, stop - start));\n    }\n    else { // Tensor.\n        return sliceAlongFirstAxis(arrays, start, stop - start);\n    }\n}\n/**\n * Slice a Tensor or an Array of Tensors, by random-order indices.\n *\n * Porting Note: The `_slice_arrays` function in PyKeras is covered by this\n *   function and `sliceArrays()` together.\n *\n * @param arrays The input `tf.Tensor` or `Array` of `tf.Tensor`s to slice.\n *   If an `Array` of `tf.Tensor`s, all `tf.Tensor`s will be sliced in the\n *   same fashion.\n * @param indices The indices to use for slicing along the first (batch)\n *   dimension.\n * @returns Result(s) of the slicing.\n */\nexport function sliceArraysByIndices(arrays, indices) {\n    return tfc.tidy(() => {\n        if (arrays == null) {\n            return null;\n        }\n        else if (Array.isArray(arrays)) {\n            return arrays.map(array => sliceArraysByIndices(array, indices));\n        }\n        else {\n            // TODO(cais): indices should be a pre-constructed Tensor1D to avoid\n            //   tensor1d() calls.\n            return gather(arrays, indices.dtype === 'int32' ? indices : tfc.cast(indices, 'int32'));\n        }\n    });\n}\n/**\n * Returns a list of batch indices (tuples of indices).\n * @param size: Integer, total size of the data to slice into batches.\n * @param batchSize: Integer, batch size.\n * @returns An Array of [batchStart, batchEnd] tuples. batchStart is\n *   inclusive; batchEnd is exclusive. I.e., each batch consists of indices x\n *   that satisfy batchStart <= x < batchEnd.\n */\nexport function makeBatches(size, batchSize) {\n    const output = [];\n    let batchStart = 0;\n    let batchEnd = null;\n    while (batchStart < size) {\n        batchEnd = batchStart + batchSize;\n        if (batchEnd >= size) {\n            batchEnd = size;\n        }\n        output.push([batchStart, batchEnd]);\n        batchStart = batchEnd;\n    }\n    return output;\n}\n/**\n * Abstract fit function for `f(ins)`.\n * @param f A Function returning a list of tensors. For training, this\n *   function is expected to perform the updates to the variables.\n * @param ins List of tensors to be fed to `f`.\n * @param outLabels List of strings, display names of the outputs of `f`.\n * @param batchSize Integer batch size or `== null` if unknown. Default : 32.\n * @param epochs Number of times to iterate over the data. Default : 1.\n * @param verbose Verbosity mode: 0, 1, or 2. Default: 1.\n * @param callbacks List of callbacks to be called during training.\n * @param valF Function to call for validation.\n * @param valIns List of tensors to be fed to `valF`.\n * @param shuffle Whether to shuffle the data at the beginning of every\n * epoch. Default : true.\n * @param callbackMetrics List of strings, the display names of the metrics\n *   passed to the callbacks. They should be the concatenation of the\n *   display names of the outputs of `f` and the list of display names\n *   of the outputs of `valF`.\n * @param initialEpoch Epoch at which to start training (useful for\n *   resuming a previous training run). Default : 0.\n * @param stepsPerEpoch Total number of steps (batches on samples) before\n *   declaring one epoch finished and starting the next epoch. Ignored with\n *   the default value of `undefined` or `null`.\n * @param validationSteps Number of steps to run validation for (only if\n *   doing validation from data tensors). Not applicable for tfjs-layers.\n * @returns A `History` object.\n */\nasync function fitLoop(\n// Type `model` as `any` here to avoid circular dependency w/ training.ts.\n// tslint:disable-next-line:no-any\nmodel, f, ins, outLabels, batchSize, epochs, verbose, callbacks, valF, valIns, shuffle, callbackMetrics, initialEpoch, stepsPerEpoch, validationSteps) {\n    if (batchSize == null) {\n        batchSize = 32;\n    }\n    if (epochs == null) {\n        epochs = 1;\n    }\n    if (shuffle == null) {\n        shuffle = true;\n    }\n    if (initialEpoch == null) {\n        initialEpoch = 0;\n    }\n    // TODO(cais): Change const to let below when implementing validation.\n    let doValidation = false;\n    if (valF != null && valIns != null) {\n        doValidation = true;\n        // TODO(cais): verbose message.\n    }\n    if (validationSteps != null) {\n        doValidation = true;\n        if (stepsPerEpoch == null) {\n            throw new ValueError('Can only use `validationSteps` when doing step-wise training, ' +\n                'i.e., `stepsPerEpoch` must be set.');\n        }\n    }\n    const numTrainSamples = model.checkNumSamples(ins, batchSize, stepsPerEpoch, 'steps_per_epoch');\n    let indexArray;\n    if (numTrainSamples != null) {\n        indexArray = range(0, numTrainSamples);\n    }\n    if (verbose == null) {\n        verbose = 1;\n    }\n    const { callbackList, history } = configureCallbacks(callbacks, verbose, epochs, initialEpoch, numTrainSamples, stepsPerEpoch, batchSize, doValidation, callbackMetrics);\n    callbackList.setModel(model);\n    model.history = history;\n    await callbackList.onTrainBegin();\n    model.stopTraining_ = false;\n    // TODO(cais): Take care of callbacks.validation_data as in PyKeras.\n    // TODO(cais): Pre-convert feeds for performance as in PyKeras.\n    for (let epoch = initialEpoch; epoch < epochs; ++epoch) {\n        await callbackList.onEpochBegin(epoch);\n        const epochLogs = {};\n        if (stepsPerEpoch != null) {\n            throw new NotImplementedError('stepsPerEpoch mode is not implemented yet.');\n        }\n        else {\n            if (shuffle === 'batch') {\n                throw new NotImplementedError('batch shuffling is not implemneted yet');\n            }\n            else if (shuffle) {\n                util.shuffle(indexArray);\n            }\n            // Convert the potentially shuffled indices to Tensor1D, to avoid the\n            // cost of repeated creation of Array1Ds later on.\n            const epochIndexArray1D = tensor1d(indexArray);\n            const batches = makeBatches(numTrainSamples, batchSize);\n            for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {\n                const batchLogs = {};\n                await callbackList.onBatchBegin(batchIndex, batchLogs);\n                tfc.tidy(() => {\n                    const batchStart = batches[batchIndex][0];\n                    const batchEnd = batches[batchIndex][1];\n                    const batchIds = sliceAlongFirstAxis(epochIndexArray1D, batchStart, batchEnd - batchStart);\n                    batchLogs['batch'] = batchIndex;\n                    batchLogs['size'] = batchEnd - batchStart;\n                    // TODO(cais): In ins, train flag can be a number, instead of an\n                    //   Tensor? Do we need to handle this in tfjs-layers?\n                    const insBatch = sliceArraysByIndices(ins, batchIds);\n                    const outs = f(insBatch);\n                    for (let i = 0; i < outLabels.length; ++i) {\n                        const label = outLabels[i];\n                        const out = outs[i];\n                        batchLogs[label] = out;\n                        tfc.keep(out);\n                        // TODO(cais): Use scope() to avoid ownership.\n                    }\n                    if (batchIndex === batches.length - 1) { // Last batch.\n                        if (doValidation) {\n                            const valOuts = model.testLoop(valF, valIns, batchSize);\n                            // Porting Notes: In tfjs-layers, valOuts is always an Array.\n                            for (let i = 0; i < outLabels.length; ++i) {\n                                const label = outLabels[i];\n                                const out = valOuts[i];\n                                tfc.keep(out);\n                                // TODO(cais): Use scope() to avoid ownership.\n                                epochLogs['val_' + label] = out;\n                            }\n                        }\n                    }\n                });\n                await callbackList.onBatchEnd(batchIndex, batchLogs);\n                disposeTensorsInLogs(batchLogs);\n                if (model.stopTraining_) {\n                    break;\n                }\n                // TODO(cais): return outs as list of Tensor.\n            }\n            epochIndexArray1D.dispose();\n        }\n        // TODO(cais): Run validation at the end of the epoch.\n        await callbackList.onEpochEnd(epoch, epochLogs);\n        if (model.stopTraining_) {\n            break;\n        }\n    }\n    await callbackList.onTrainEnd();\n    await model.history.syncData();\n    return model.history;\n}\nexport async function fitTensors(\n// Type `model` as `any` here to avoid circular dependency w/ training.ts.\n// tslint:disable-next-line:no-any\nmodel, x, y, args = {}) {\n    if (model.isTraining) {\n        throw new Error('Cannot start training because another fit() call is ongoing.');\n    }\n    model.isTraining = true;\n    let inputs;\n    let targets;\n    let originalInputs;\n    let originalTargets;\n    let inputValX;\n    let inputValY;\n    let valX;\n    let valY;\n    let sampleWeights;\n    try {\n        const batchSize = args.batchSize == null ? 32 : args.batchSize;\n        checkBatchSize(batchSize);\n        // Validate user data.\n        // TODO(cais): Support sampleWeight.\n        const checkBatchAxis = false;\n        const standardizedOuts = await model.standardizeUserData(x, y, args.sampleWeight, args.classWeight, checkBatchAxis, batchSize);\n        inputs = standardizedOuts[0];\n        targets = standardizedOuts[1];\n        sampleWeights = standardizedOuts[2];\n        // Prepare validation data.\n        let doValidation = false;\n        let valIns;\n        if (args.validationData != null && args.validationData.length > 0) {\n            doValidation = true;\n            if (args.validationData.length === 2) {\n                // config.validationData consists of valX and valY.\n                inputValX = args.validationData[0];\n                inputValY = args.validationData[1];\n            }\n            else if (args.validationData.length === 3) {\n                throw new NotImplementedError('validationData including sample weights is not supported yet.');\n            }\n            else {\n                throw new ValueError(`When passing validation data, it must contain 2 (valX, valY) ` +\n                    `or 3 (valX, valY, valSampleWeight) items; ` +\n                    `${args.validationData} is invalid.`);\n            }\n            const checkBatchAxis = true;\n            const valStandardized = await model.standardizeUserData(inputValX, inputValY, null, /** Unused sample weights. */ null, /** Unused class weights. */ checkBatchAxis, batchSize);\n            valX = valStandardized[0];\n            valY = valStandardized[1];\n            valIns = valX.concat(valY);\n            // TODO(cais): Add useLearningPhase data properly.\n        }\n        else if (args.validationSplit != null && args.validationSplit > 0 &&\n            args.validationSplit < 1) {\n            doValidation = true;\n            // Porting Note: In tfjs-layers, inputs[0] is always a Tensor.\n            const splitAt = Math.floor(inputs[0].shape[0] * (1 - args.validationSplit));\n            const originalBatchSize = inputs[0].shape[0];\n            valX = sliceArrays(inputs, splitAt, originalBatchSize);\n            originalInputs = inputs;\n            inputs = sliceArrays(inputs, 0, splitAt);\n            valY = sliceArrays(targets, splitAt, originalBatchSize);\n            originalTargets = targets;\n            targets = sliceArrays(targets, 0, splitAt);\n            // TODO(cais): Once sampleWeights becomes available, slice it to get\n            //   valSampleWeights.\n            valIns = valX.concat(valY);\n            // TODO(cais): Add useLearningPhase data properly.\n        }\n        else if (args.validationSteps != null) {\n            doValidation = true;\n            // TODO(cais): Add useLearningPhase.\n        }\n        const ins = inputs.concat(targets).concat(sampleWeights);\n        model.checkTrainableWeightsConsistency();\n        // TODO(cais): Handle use_learning_phase and learning_phase?\n        // Porting Note: Here we see a key deviation of tfjs-layers from\n        // Keras.\n        //  Due to the imperative nature of tfjs-layers' backend (tfjs-core),\n        //  we do not construct symbolic computation graphs to embody the\n        //  training process. Instead, we define a function that performs the\n        //  training action. In PyKeras, the data (inputs and targets) are fed\n        //  through graph placeholders. In tfjs-layers, the data are fed as\n        //  function arguments. Since the function are defined below in the\n        //  scope, we don't have equivalents of PyKeras's\n        //  `_make_train_funciton`.\n        const trainFunction = model.makeTrainFunction();\n        const outLabels = model.getDedupedMetricsNames();\n        let valFunction;\n        let callbackMetrics;\n        if (doValidation) {\n            model.makeTestFunction();\n            valFunction = model.testFunction;\n            callbackMetrics =\n                outLabels.slice().concat(outLabels.map(n => 'val_' + n));\n        }\n        else {\n            valFunction = null;\n            valIns = [];\n            callbackMetrics = outLabels.slice();\n        }\n        const callbacks = standardizeCallbacks(args.callbacks, args.yieldEvery);\n        const out = await fitLoop(model, trainFunction, ins, outLabels, batchSize, args.epochs, args.verbose, callbacks, valFunction, valIns, args.shuffle, callbackMetrics, args.initialEpoch, null, null);\n        return out;\n    }\n    finally {\n        model.isTraining = false;\n        // Memory clean up.\n        disposeNewTensors(inputs, x);\n        disposeNewTensors(targets, y);\n        disposeNewTensors(originalInputs, x);\n        disposeNewTensors(originalTargets, y);\n        disposeNewTensors(valX, inputValX);\n        disposeNewTensors(valY, inputValY);\n        if (sampleWeights != null) {\n            tfc.dispose(sampleWeights);\n        }\n    }\n    // TODO(cais): Add value to outLabels.\n}\n/**\n * Ensure tensors all have a rank of at least 2.\n *\n * If a tensor has a rank of 1, it is dimension-expanded to rank 2.\n * If any tensor has a rank of 0 (i.e., is a scalar), an error will be thrown.\n */\nexport function ensureTensorsRank2OrHigher(tensors) {\n    const outs = [];\n    if (tensors instanceof Tensor) {\n        tensors = [tensors];\n    }\n    // Make Tensors at least 2D.\n    for (let i = 0; i < tensors.length; ++i) {\n        const tensor = tensors[i];\n        if (tensor.rank === 1) {\n            outs.push(expandDims(tensor, 1));\n        }\n        else if (tensor.rank === 0) {\n            throw new Error('Expected tensor to be at least 1D, but received a 0D tensor ' +\n                '(scalar).');\n        }\n        else {\n            outs.push(tensor);\n        }\n    }\n    return outs;\n}\n/**\n * Compare a set of tensors with a reference (old) set, discard the ones\n * in the new set that are not present in the reference set.\n *\n * This method is used for memory clenaup during calls such as\n * LayersModel.fit().\n *\n * @param tensors New set which may contain Tensors not present in\n *   `refTensors`.\n * @param refTensors Reference Tensor set.\n */\n// TODO(cais, kangyizhang): Deduplicate with tfjs-data.\nexport function disposeNewTensors(tensors, refTensors) {\n    if (tensors == null) {\n        return;\n    }\n    const oldTensorIds = [];\n    if (refTensors instanceof Tensor) {\n        oldTensorIds.push(refTensors.id);\n    }\n    else if (Array.isArray(refTensors)) {\n        refTensors.forEach(t => oldTensorIds.push(t.id));\n    }\n    else if (refTensors != null) {\n        // `oldTensors` is a map from string name to Tensor.\n        for (const name in refTensors) {\n            const oldTensor = refTensors[name];\n            oldTensorIds.push(oldTensor.id);\n        }\n    }\n    const tensorsToDispose = [];\n    if (tensors instanceof Tensor) {\n        if (oldTensorIds.indexOf(tensors.id) === -1) {\n            tensorsToDispose.push(tensors);\n        }\n    }\n    else if (Array.isArray(tensors)) {\n        tensors.forEach(t => {\n            if (oldTensorIds.indexOf(t.id) === -1) {\n                tensorsToDispose.push(t);\n            }\n        });\n    }\n    else if (tensors != null) {\n        // `oldTensors` is a map from string name to Tensor.\n        for (const name in tensors) {\n            const tensor = tensors[name];\n            if (oldTensorIds.indexOf(tensor.id) === -1) {\n                tensorsToDispose.push(tensor);\n            }\n        }\n    }\n    tensorsToDispose.forEach(t => {\n        if (!t.isDisposed) {\n            t.dispose();\n        }\n    });\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmdfdGVuc29ycy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9lbmdpbmUvdHJhaW5pbmdfdGVuc29ycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQVMsTUFBTSxFQUFZLFFBQVEsRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUvRSxPQUFPLEVBQUMsVUFBVSxFQUFFLE1BQU0sRUFBRSxtQkFBbUIsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBQ2hGLE9BQU8sRUFBZSxrQkFBa0IsRUFBc0Qsb0JBQW9CLEVBQW9CLE1BQU0sbUJBQW1CLENBQUM7QUFDaEssT0FBTyxFQUFDLG1CQUFtQixFQUFFLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUMxRCxPQUFPLEVBQUMsb0JBQW9CLEVBQWlCLE1BQU0sU0FBUyxDQUFDO0FBQzdELE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQTRJMUMsTUFBTSxVQUFVLGNBQWMsQ0FBQyxTQUFpQjtJQUM5QyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FDWCxTQUFTLEdBQUcsQ0FBQyxJQUFJLE1BQU0sQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLEVBQzVDLEdBQUcsRUFBRSxDQUFDLDJEQUNGLFNBQVMsRUFBRSxDQUFDLENBQUM7QUFDdkIsQ0FBQztBQUVEOzs7Ozs7Ozs7Ozs7R0FZRztBQUNILE1BQU0sVUFBVSxXQUFXLENBQ3ZCLE1BQXVCLEVBQUUsS0FBYSxFQUFFLElBQVk7SUFDdEQsSUFBSSxNQUFNLElBQUksSUFBSSxFQUFFO1FBQ2xCLE9BQU8sQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUNmO1NBQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLE1BQU0s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RjtLQUNGO0lBRUQsZ0JBQWdCLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxFQUFFO1FBQzNCLElBQUksQ0FBQyxDQUFDLENBQUMsVUFBVSxFQUFFO1lBQ2pCLENBQUMsQ0FBQyxPQUFPLEVBQUUsQ0FBQztTQUNiO0lBQ0gsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyoqXG4gKiBJbnRlcmZhY2VzIGFuZCBtZXRob2RzIGZvciB0cmFpbmluZyBtb2RlbHMgdXNpbmcgdGYuVGVuc29yIG9iamVjdHMuXG4gKi9cblxuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge1NjYWxhciwgVGVuc29yLCBUZW5zb3IxRCwgdGVuc29yMWQsIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7ZXhwYW5kRGltcywgZ2F0aGVyLCBzbGljZUFsb25nRmlyc3RBeGlzfSBmcm9tICcuLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge0Jhc2VDYWxsYmFjaywgY29uZmlndXJlQ2FsbGJhY2tzLCBDdXN0b21DYWxsYmFja0FyZ3MsIEhpc3RvcnksIE1vZGVsTG9nZ2luZ1ZlcmJvc2l0eSwgc3RhbmRhcmRpemVDYWxsYmFja3MsIFlpZWxkRXZlcnlPcHRpb25zfSBmcm9tICcuLi9iYXNlX2NhbGxiYWNrcyc7XG5pbXBvcnQge05vdEltcGxlbWVudGVkRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2Rpc3Bvc2VUZW5zb3JzSW5Mb2dzLCBVbnJlc29sdmVkTG9nc30gZnJvbSAnLi4vbG9ncyc7XG5pbXBvcnQge3JhbmdlfSBmcm9tICcuLi91dGlscy9tYXRoX3V0aWxzJztcbmltcG9ydCB7Q2xhc3NXZWlnaHQsIENsYXNzV2VpZ2h0TWFwfSBmcm9tICcuL3RyYWluaW5nX3V0aWxzJztcblxuLyoqXG4gKiBJbnRlcmZhY2UgY29uZmlndXJhdGlvbiBtb2RlbCB0cmFpbmluZyBiYXNlZCBvbiBkYXRhIGFzIGB0Zi5UZW5zb3Jgcy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBNb2RlbEZpdEFyZ3Mge1xuICAvKipcbiAgICogTnVtYmVyIG9mIHNhbXBsZXMgcGVyIGdyYWRpZW50IHVwZGF0ZS4gSWYgdW5zcGVjaWZpZWQsIGl0XG4gICAqIHdpbGwgZGVmYXVsdCB0byAzMi5cbiAgICovXG4gIGJhdGNoU2l6ZT86IG51bWJlcjtcblxuICAvKipcbiAgICogSW50ZWdlciBudW1iZXIgb2YgdGltZXMgdG8gaXRlcmF0ZSBvdmVyIHRoZSB0cmFpbmluZyBkYXRhIGFycmF5cy5cbiAgICovXG4gIGVwb2Nocz86IG51bWJlcjtcblxuICAvKipcbiAgICogVmVyYm9zaXR5IGxldmVsLlxuICAgKlxuICAgKiBFeHBlY3RlZCB0byBiZSAwLCAxLCBvciAyLiBEZWZhdWx0OiAxLlxuICAgKlxuICAgKiAwIC0gTm8gcHJpbnRlZCBtZXNzYWdlIGR1cmluZyBmaXQoKSBjYWxsLlxuICAgKiAxIC0gSW4gTm9kZS5qcyAodGZqcy1ub2RlKSwgcHJpbnRzIHRoZSBwcm9ncmVzcyBiYXIsIHRvZ2V0aGVyIHdpdGhcbiAgICogICAgIHJlYWwtdGltZSB1cGRhdGVzIG9mIGxvc3MgYW5kIG1ldHJpYyB2YWx1ZXMgYW5kIHRyYWluaW5nIHNwZWVkLlxuICAgKiAgICAgSW4gdGhlIGJyb3dzZXI6IG5vIGFjdGlvbi4gVGhpcyBpcyB0aGUgZGVmYXVsdC5cbiAgICogMiAtIE5vdCBpbXBsZW1lbnRlZCB5ZXQuXG4gICAqL1xuICB2ZXJib3NlPzogTW9kZWxMb2dnaW5nVmVyYm9zaXR5O1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIGNhbGxiYWNrcyB0byBiZSBjYWxsZWQgZHVyaW5nIHRyYWluaW5nLlxuICAgKiBDYW4gaGF2ZSBvbmUgb3IgbW9yZSBvZiB0aGUgZm9sbG93aW5nIGNhbGxiYWNrczpcbiAgICogICAtIGBvblRyYWluQmVnaW4obG9ncylgOiBjYWxsZWQgd2hlbiB0cmFpbmluZyBzdGFydHMuXG4gICAqICAgLSBgb25UcmFpbkVuZChsb2dzKWA6IGNhbGxlZCB3aGVuIHRyYWluaW5nIGVuZHMuXG4gICAqICAgLSBgb25FcG9jaEJlZ2luKGVwb2NoLCBsb2dzKWA6IGNhbGxlZCBhdCB0aGUgc3RhcnQgb2YgZXZlcnkgZXBvY2guXG4gICAqICAgLSBgb25FcG9jaEVuZChlcG9jaCwgbG9ncylgOiBjYWxsZWQgYXQgdGhlIGVuZCBvZiBldmVyeSBlcG9jaC5cbiAgICogICAtIGBvbkJhdGNoQmVnaW4oYmF0Y2gsIGxvZ3MpYDogY2FsbGVkIGF0IHRoZSBzdGFydCBvZiBldmVyeSBiYXRjaC5cbiAgICogICAtIGBvbkJhdGNoRW5kKGJhdGNoLCBsb2dzKWA6IGNhbGxlZCBhdCB0aGUgZW5kIG9mIGV2ZXJ5IGJhdGNoLlxuICAgKiAgIC0gYG9uWWllbGQoZXBvY2gsIGJhdGNoLCBsb2dzKWA6IGNhbGxlZCBldmVyeSBgeWllbGRFdmVyeWAgbWlsbGlzZWNvbmRzXG4gICAqICAgICAgd2l0aCB0aGUgY3VycmVudCBlcG9jaCwgYmF0Y2ggYW5kIGxvZ3MuIFRoZSBsb2dzIGFyZSB0aGUgc2FtZVxuICAgKiAgICAgIGFzIGluIGBvbkJhdGNoRW5kKClgLiBOb3RlIHRoYXQgYG9uWWllbGRgIGNhbiBza2lwIGJhdGNoZXMgb3JcbiAgICogICAgICBlcG9jaHMuIFNlZSBhbHNvIGRvY3MgZm9yIGB5aWVsZEV2ZXJ5YCBiZWxvdy5cbiAgICovXG4gIGNhbGxiYWNrcz86IEJhc2VDYWxsYmFja1tdfEN1c3RvbUNhbGxiYWNrQXJnc3xDdXN0b21DYWxsYmFja0FyZ3NbXTtcblxuICAvKipcbiAgICogRmxvYXQgYmV0d2VlbiAwIGFuZCAxOiBmcmFjdGlvbiBvZiB0aGUgdHJhaW5pbmcgZGF0YVxuICAgKiB0byBiZSB1c2VkIGFzIHZhbGlkYXRpb24gZGF0YS4gVGhlIG1vZGVsIHdpbGwgc2V0IGFwYXJ0IHRoaXMgZnJhY3Rpb24gb2ZcbiAgICogdGhlIHRyYWluaW5nIGRhdGEsIHdpbGwgbm90IHRyYWluIG9uIGl0LCBhbmQgd2lsbCBldmFsdWF0ZSB0aGUgbG9zcyBhbmRcbiAgICogYW55IG1vZGVsIG1ldHJpY3Mgb24gdGhpcyBkYXRhIGF0IHRoZSBlbmQgb2YgZWFjaCBlcG9jaC5cbiAgICogVGhlIHZhbGlkYXRpb24gZGF0YSBpcyBzZWxlY3RlZCBmcm9tIHRoZSBsYXN0IHNhbXBsZXMgaW4gdGhlIGB4YCBhbmQgYHlgXG4gICAqIGRhdGEgcHJvdmlkZWQsIGJlZm9yZSBzaHVmZmxpbmcuXG4gICAqL1xuICB2YWxpZGF0aW9uU3BsaXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIERhdGEgb24gd2hpY2ggdG8gZXZhbHVhdGUgdGhlIGxvc3MgYW5kIGFueSBtb2RlbFxuICAgKiBtZXRyaWNzIGF0IHRoZSBlbmQgb2YgZWFjaCBlcG9jaC4gVGhlIG1vZGVsIHdpbGwgbm90IGJlIHRyYWluZWQgb24gdGhpc1xuICAgKiBkYXRhLiBUaGlzIGNvdWxkIGJlIGEgdHVwbGUgW3hWYWwsIHlWYWxdIG9yIGEgdHVwbGUgW3hWYWwsIHlWYWwsXG4gICAqIHZhbFNhbXBsZVdlaWdodHNdLiBUaGUgbW9kZWwgd2lsbCBub3QgYmUgdHJhaW5lZCBvbiB0aGlzIGRhdGEuXG4gICAqIGB2YWxpZGF0aW9uRGF0YWAgd2lsbCBvdmVycmlkZSBgdmFsaWRhdGlvblNwbGl0YC5cbiAgICovXG4gIHZhbGlkYXRpb25EYXRhPzogW1xuICAgIFRlbnNvcnxUZW5zb3JbXSwgVGVuc29yfFRlbnNvcltdXG4gIF18W1RlbnNvciB8IFRlbnNvcltdLCBUZW5zb3J8VGVuc29yW10sIFRlbnNvcnxUZW5zb3JbXV07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gc2h1ZmZsZSB0aGUgdHJhaW5pbmcgZGF0YSBiZWZvcmUgZWFjaCBlcG9jaC4gSGFzXG4gICAqIG5vIGVmZmVjdCB3aGVuIGBzdGVwc1BlckVwb2NoYCBpcyBub3QgYG51bGxgLlxuICAgKi9cbiAgc2h1ZmZsZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIE9wdGlvbmFsIG9iamVjdCBtYXBwaW5nIGNsYXNzIGluZGljZXMgKGludGVnZXJzKSB0b1xuICAgKiBhIHdlaWdodCAoZmxvYXQpIHRvIGFwcGx5IHRvIHRoZSBtb2RlbCdzIGxvc3MgZm9yIHRoZSBzYW1wbGVzIGZyb20gdGhpc1xuICAgKiBjbGFzcyBkdXJpbmcgdHJhaW5pbmcuIFRoaXMgY2FuIGJlIHVzZWZ1bCB0byB0ZWxsIHRoZSBtb2RlbCB0byBcInBheSBtb3JlXG4gICAqIGF0dGVudGlvblwiIHRvIHNhbXBsZXMgZnJvbSBhbiB1bmRlci1yZXByZXNlbnRlZCBjbGFzcy5cbiAgICpcbiAgICogSWYgdGhlIG1vZGVsIGhhcyBtdWx0aXBsZSBvdXRwdXRzLCBhIGNsYXNzIHdlaWdodCBjYW4gYmUgc3BlY2lmaWVkIGZvclxuICAgKiBlYWNoIG9mIHRoZSBvdXRwdXRzIGJ5IHNldHRpbmcgdGhpcyBmaWVsZCBhbiBhcnJheSBvZiB3ZWlnaHQgb2JqZWN0XG4gICAqIG9yIGEgb2JqZWN0IHRoYXQgbWFwcyBtb2RlbCBvdXRwdXQgbmFtZXMgKGUuZy4sIGBtb2RlbC5vdXRwdXROYW1lc1swXWApXG4gICAqIHRvIHdlaWdodCBvYmplY3RzLlxuICAgKi9cbiAgY2xhc3NXZWlnaHQ/OiBDbGFzc1dlaWdodHxDbGFzc1dlaWdodFtdfENsYXNzV2VpZ2h0TWFwO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbCBhcnJheSBvZiB0aGUgc2FtZSBsZW5ndGggYXMgeCwgY29udGFpbmluZ1xuICAgKiB3ZWlnaHRzIHRvIGFwcGx5IHRvIHRoZSBtb2RlbCdzIGxvc3MgZm9yIGVhY2ggc2FtcGxlLiBJbiB0aGUgY2FzZSBvZlxuICAgKiB0ZW1wb3JhbCBkYXRhLCB5b3UgY2FuIHBhc3MgYSAyRCBhcnJheSB3aXRoIHNoYXBlIChzYW1wbGVzLFxuICAgKiBzZXF1ZW5jZUxlbmd0aCksIHRvIGFwcGx5IGEgZGlmZmVyZW50IHdlaWdodCB0byBldmVyeSB0aW1lc3RlcCBvZiBldmVyeVxuICAgKiBzYW1wbGUuIEluIHRoaXMgY2FzZSB5b3Ugc2hvdWxkIG1ha2Ugc3VyZSB0byBzcGVjaWZ5XG4gICAqIHNhbXBsZVdlaWdodE1vZGU9XCJ0ZW1wb3JhbFwiIGluIGNvbXBpbGUoKS5cbiAgICovXG4gIHNhbXBsZVdlaWdodD86IFRlbnNvcjtcblxuICAvKipcbiAgICogRXBvY2ggYXQgd2hpY2ggdG8gc3RhcnQgdHJhaW5pbmcgKHVzZWZ1bCBmb3IgcmVzdW1pbmcgYSBwcmV2aW91cyB0cmFpbmluZ1xuICAgKiBydW4pLiBXaGVuIHRoaXMgaXMgdXNlZCwgYGVwb2Noc2AgaXMgdGhlIGluZGV4IG9mIHRoZSBcImZpbmFsIGVwb2NoXCIuXG4gICAqIFRoZSBtb2RlbCBpcyBub3QgdHJhaW5lZCBmb3IgYSBudW1iZXIgb2YgaXRlcmF0aW9ucyBnaXZlbiBieSBgZXBvY2hzYCxcbiAgICogYnV0IG1lcmVseSB1bnRpbCB0aGUgZXBvY2ggb2YgaW5kZXggYGVwb2Noc2AgaXMgcmVhY2hlZC5cbiAgICovXG4gIGluaXRpYWxFcG9jaD86IG51bWJlcjtcblxuICAvKipcbiAgICogVG90YWwgbnVtYmVyIG9mIHN0ZXBzIChiYXRjaGVzIG9mIHNhbXBsZXMpIGJlZm9yZVxuICAgKiBkZWNsYXJpbmcgb25lIGVwb2NoIGZpbmlzaGVkIGFuZCBzdGFydGluZyB0aGUgbmV4dCBlcG9jaC4gV2hlbiB0cmFpbmluZ1xuICAgKiB3aXRoIElucHV0IFRlbnNvcnMgc3VjaCBhcyBUZW5zb3JGbG93IGRhdGEgdGVuc29ycywgdGhlIGRlZmF1bHQgYG51bGxgIGlzXG4gICAqIGVxdWFsIHRvIHRoZSBudW1iZXIgb2YgdW5pcXVlIHNhbXBsZXMgaW4geW91ciBkYXRhc2V0IGRpdmlkZWQgYnkgdGhlXG4gICAqIGJhdGNoIHNpemUsIG9yIDEgaWYgdGhhdCBjYW5ub3QgYmUgZGV0ZXJtaW5lZC5cbiAgICovXG4gIHN0ZXBzUGVyRXBvY2g/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIE9ubHkgcmVsZXZhbnQgaWYgYHN0ZXBzUGVyRXBvY2hgIGlzIHNwZWNpZmllZC4gVG90YWwgbnVtYmVyIG9mIHN0ZXBzXG4gICAqIChiYXRjaGVzIG9mIHNhbXBsZXMpIHRvIHZhbGlkYXRlIGJlZm9yZSBzdG9wcGluZy5cbiAgICovXG4gIHZhbGlkYXRpb25TdGVwcz86IG51bWJlcjtcblxuICAvKipcbiAgICogQ29uZmlndXJlcyB0aGUgZnJlcXVlbmN5IG9mIHlpZWxkaW5nIHRoZSBtYWluIHRocmVhZCB0byBvdGhlciB0YXNrcy5cbiAgICpcbiAgICogSW4gdGhlIGJyb3dzZXIgZW52aXJvbm1lbnQsIHlpZWxkaW5nIHRoZSBtYWluIHRocmVhZCBjYW4gaW1wcm92ZSB0aGVcbiAgICogcmVzcG9uc2l2ZW5lc3Mgb2YgdGhlIHBhZ2UgZHVyaW5nIHRyYWluaW5nLiBJbiB0aGUgTm9kZS5qcyBlbnZpcm9ubWVudCxcbiAgICogaXQgY2FuIGVuc3VyZSB0YXNrcyBxdWV1ZWQgaW4gdGhlIGV2ZW50IGxvb3AgY2FuIGJlIGhhbmRsZWQgaW4gYSB0aW1lbHlcbiAgICogbWFubmVyLlxuICAgKlxuICAgKiBUaGUgdmFsdWUgY2FuIGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nOlxuICAgKiAgIC0gYCdhdXRvJ2A6IFRoZSB5aWVsZGluZyBoYXBwZW5zIGF0IGEgY2VydGFpbiBmcmFtZSByYXRlIChjdXJyZW50bHkgc2V0XG4gICAqICAgICAgICAgICAgICAgYXQgMTI1bXMpLiBUaGlzIGlzIHRoZSBkZWZhdWx0LlxuICAgKiAgIC0gYCdiYXRjaCdgOiB5aWVsZCBldmVyeSBiYXRjaC5cbiAgICogICAtIGAnZXBvY2gnYDogeWllbGQgZXZlcnkgZXBvY2guXG4gICAqICAgLSBhbnkgYG51bWJlcmA6IHlpZWxkIGV2ZXJ5IGBudW1iZXJgIG1pbGxpc2Vjb25kcy5cbiAgICogICAtIGAnbmV2ZXInYDogbmV2ZXIgeWllbGQuICh5aWVsZGluZyBjYW4gc3RpbGwgaGFwcGVuIHRocm91Z2ggYGF3YWl0XG4gICAqICAgICAgbmV4dEZyYW1lKClgIGNhbGxzIGluIGN1c3RvbSBjYWxsYmFja3MuKVxuICAgKi9cbiAgeWllbGRFdmVyeT86IFlpZWxkRXZlcnlPcHRpb25zO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tCYXRjaFNpemUoYmF0Y2hTaXplOiBudW1iZXIpIHtcbiAgdGZjLnV0aWwuYXNzZXJ0KFxuICAgICAgYmF0Y2hTaXplID4gMCAmJiBOdW1iZXIuaXNJbnRlZ2VyKGJhdGNoU2l6ZSksXG4gICAgICAoKSA9PiBgYmF0Y2hTaXplIGlzIHJlcXVpcmVkIHRvIGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgYnV0IGdvdCAke1xuICAgICAgICAgIGJhdGNoU2l6ZX1gKTtcbn1cblxuLyoqXG4gKiBTbGljZSBhIFRlbnNvciBvciBhbiBBcnJheSBvZiBUZW5zb3JzLCBieSBzdGFydCBhbmQgc3RvcCBpbmRpY2VzLlxuICpcbiAqIFBvcnRpbmcgTm90ZTogVGhlIGBfc2xpY2VfYXJyYXlzYCBmdW5jdGlvbiBpbiBQeUtlcmFzIGlzIGNvdmVyZWQgYnkgdGhpc1xuICogICBmdW5jdGlvbiBhbmQgYHNsaWNlQXJyYXlzQnlJbmRpY2VzKClgIHRvZ2V0aGVyLlxuICpcbiAqIEBwYXJhbSBhcnJheXM6IHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBzdGFydDogdGhlIHN0YXJ0aW5nIGluZGV4IChpbmNsdXNpdmUpLlxuICogQHBhcmFtIHN0b3A6IHRoZSBzdG9wcGluZyBpbmRleCAoZXhjbHVzaXZlKS5cbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIHNsaWNpbmcuIElmIGBhcnJheXNgIGlzIGFuIGBBcnJheWAgb2ZcbiAqICAgYHRmLlRlbnNvcmBzLCB0aGUgc2xpY2luZyB3aWxsIGJlIGFwcGxpZWQgdG8gYWxsIGVsZW1lbnRzIG9mIHRoZSBgQXJyYXlgXG4gKiAgIGluIHRoZSBzYW1lIHdheS5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHNsaWNlQXJyYXlzKFxuICAgIGFycmF5czogVGVuc29yfFRlbnNvcltdLCBzdGFydDogbnVtYmVyLCBzdG9wOiBudW1iZXIpOiBUZW5zb3J8VGVuc29yW10ge1xuICBpZiAoYXJyYXlzID09IG51bGwpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJyYXlzKSkge1xuICAgIHJldHVybiBhcnJheXMubWFwKGFycmF5ID0+IHNsaWNlQWxvbmdGaXJzdEF4aXMoYXJyYXksIHN0YXJ0LCBzdG9wIC0gc3RhcnQpKTtcbiAgfSBlbHNlIHsgIC8vIFRlbnNvci5cbiAgICByZXR1cm4gc2xpY2VBbG9uZ0ZpcnN0QXhpcyhhcnJheXMsIHN0YXJ0LCBzdG9wIC0gc3RhcnQpO1xuICB9XG59XG5cbi8qKlxuICogU2xpY2UgYSBUZW5zb3Igb3IgYW4gQXJyYXkgb2YgVGVuc29ycywgYnkgcmFuZG9tLW9yZGVyIGluZGljZXMuXG4gKlxuICogUG9ydGluZyBOb3RlOiBUaGUgYF9zbGljZV9hcnJheXNgIGZ1bmN0aW9uIGluIFB5S2VyYXMgaXMgY292ZXJlZCBieSB0aGlzXG4gKiAgIGZ1bmN0aW9uIGFuZCBgc2xpY2VBcnJheXMoKWAgdG9nZXRoZXIuXG4gKlxuICogQHBhcmFtIGFycmF5cyBUaGUgaW5wdXQgYHRmLlRlbnNvcmAgb3IgYEFycmF5YCBvZiBgdGYuVGVuc29yYHMgdG8gc2xpY2UuXG4gKiAgIElmIGFuIGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzLCBhbGwgYHRmLlRlbnNvcmBzIHdpbGwgYmUgc2xpY2VkIGluIHRoZVxuICogICBzYW1lIGZhc2hpb24uXG4gKiBAcGFyYW0gaW5kaWNlcyBUaGUgaW5kaWNlcyB0byB1c2UgZm9yIHNsaWNpbmcgYWxvbmcgdGhlIGZpcnN0IChiYXRjaClcbiAqICAgZGltZW5zaW9uLlxuICogQHJldHVybnMgUmVzdWx0KHMpIG9mIHRoZSBzbGljaW5nLlxuICovXG5leHBvcnQgZnVuY3Rpb24gc2xpY2VBcnJheXNCeUluZGljZXMoXG4gICAgYXJyYXlzOiBUZW5zb3J8VGVuc29yW10sIGluZGljZXM6IFRlbnNvcjFEKTogVGVuc29yfFRlbnNvcltdIHtcbiAgcmV0dXJuIHRmYy50aWR5KCgpID0+IHtcbiAgICBpZiAoYXJyYXlzID09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcnJheXMpKSB7XG4gICAgICByZXR1cm4gYXJyYXlzLm1hcChcbiAgICAgICAgICBhcnJheSA9PiAoc2xpY2VBcnJheXNCeUluZGljZXMoYXJyYXksIGluZGljZXMpIGFzIFRlbnNvcikpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBpbmRpY2VzIHNob3VsZCBiZSBhIHByZS1jb25zdHJ1Y3RlZCBUZW5zb3IxRCB0byBhdm9pZFxuICAgICAgLy8gICB0ZW5zb3IxZCgpIGNhbGxzLlxuICAgICAgcmV0dXJuIGdhdGhlcihcbiAgICAgICAgICBhcnJheXMsXG4gICAgICAgICAgaW5kaWNlcy5kdHlwZSA9PT0gJ2ludDMyJyA/IGluZGljZXMgOiB0ZmMuY2FzdChpbmRpY2VzLCAnaW50MzInKSk7XG4gICAgfVxuICB9KTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgbGlzdCBvZiBiYXRjaCBpbmRpY2VzICh0dXBsZXMgb2YgaW5kaWNlcykuXG4gKiBAcGFyYW0gc2l6ZTogSW50ZWdlciwgdG90YWwgc2l6ZSBvZiB0aGUgZGF0YSB0byBzbGljZSBpbnRvIGJhdGNoZXMuXG4gKiBAcGFyYW0gYmF0Y2hTaXplOiBJbnRlZ2VyLCBiYXRjaCBzaXplLlxuICogQHJldHVybnMgQW4gQXJyYXkgb2YgW2JhdGNoU3RhcnQsIGJhdGNoRW5kXSB0dXBsZXMuIGJhdGNoU3RhcnQgaXNcbiAqICAgaW5jbHVzaXZlOyBiYXRjaEVuZCBpcyBleGNsdXNpdmUuIEkuZS4sIGVhY2ggYmF0Y2ggY29uc2lzdHMgb2YgaW5kaWNlcyB4XG4gKiAgIHRoYXQgc2F0aXNmeSBiYXRjaFN0YXJ0IDw9IHggPCBiYXRjaEVuZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG1ha2VCYXRjaGVzKFxuICAgIHNpemU6IG51bWJlciwgYmF0Y2hTaXplOiBudW1iZXIpOiBBcnJheTxbbnVtYmVyLCBudW1iZXJdPiB7XG4gIGNvbnN0IG91dHB1dDogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbXTtcbiAgbGV0IGJhdGNoU3RhcnQgPSAwO1xuICBsZXQgYmF0Y2hFbmQ6IG51bWJlciA9IG51bGw7XG4gIHdoaWxlIChiYXRjaFN0YXJ0IDwgc2l6ZSkge1xuICAgIGJhdGNoRW5kID0gYmF0Y2hTdGFydCArIGJhdGNoU2l6ZTtcbiAgICBpZiAoYmF0Y2hFbmQgPj0gc2l6ZSkge1xuICAgICAgYmF0Y2hFbmQgPSBzaXplO1xuICAgIH1cbiAgICBvdXRwdXQucHVzaChbYmF0Y2hTdGFydCwgYmF0Y2hFbmRdKTtcbiAgICBiYXRjaFN0YXJ0ID0gYmF0Y2hFbmQ7XG4gIH1cbiAgcmV0dXJuIG91dHB1dDtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBmaXQgZnVuY3Rpb24gZm9yIGBmKGlucylgLlxuICogQHBhcmFtIGYgQSBGdW5jdGlvbiByZXR1cm5pbmcgYSBsaXN0IG9mIHRlbnNvcnMuIEZvciB0cmFpbmluZywgdGhpc1xuICogICBmdW5jdGlvbiBpcyBleHBlY3RlZCB0byBwZXJmb3JtIHRoZSB1cGRhdGVzIHRvIHRoZSB2YXJpYWJsZXMuXG4gKiBAcGFyYW0gaW5zIExpc3Qgb2YgdGVuc29ycyB0byBiZSBmZWQgdG8gYGZgLlxuICogQHBhcmFtIG91dExhYmVscyBMaXN0IG9mIHN0cmluZ3MsIGRpc3BsYXkgbmFtZXMgb2YgdGhlIG91dHB1dHMgb2YgYGZgLlxuICogQHBhcmFtIGJhdGNoU2l6ZSBJbnRlZ2VyIGJhdGNoIHNpemUgb3IgYD09IG51bGxgIGlmIHVua25vd24uIERlZmF1bHQgOiAzMi5cbiAqIEBwYXJhbSBlcG9jaHMgTnVtYmVyIG9mIHRpbWVzIHRvIGl0ZXJhdGUgb3ZlciB0aGUgZGF0YS4gRGVmYXVsdCA6IDEuXG4gKiBAcGFyYW0gdmVyYm9zZSBWZXJib3NpdHkgbW9kZTogMCwgMSwgb3IgMi4gRGVmYXVsdDogMS5cbiAqIEBwYXJhbSBjYWxsYmFja3MgTGlzdCBvZiBjYWxsYmFja3MgdG8gYmUgY2FsbGVkIGR1cmluZyB0cmFpbmluZy5cbiAqIEBwYXJhbSB2YWxGIEZ1bmN0aW9uIHRvIGNhbGwgZm9yIHZhbGlkYXRpb24uXG4gKiBAcGFyYW0gdmFsSW5zIExpc3Qgb2YgdGVuc29ycyB0byBiZSBmZWQgdG8gYHZhbEZgLlxuICogQHBhcmFtIHNodWZmbGUgV2hldGhlciB0byBzaHVmZmxlIHRoZSBkYXRhIGF0IHRoZSBiZWdpbm5pbmcgb2YgZXZlcnlcbiAqIGVwb2NoLiBEZWZhdWx0IDogdHJ1ZS5cbiAqIEBwYXJhbSBjYWxsYmFja01ldHJpY3MgTGlzdCBvZiBzdHJpbmdzLCB0aGUgZGlzcGxheSBuYW1lcyBvZiB0aGUgbWV0cmljc1xuICogICBwYXNzZWQgdG8gdGhlIGNhbGxiYWNrcy4gVGhleSBzaG91bGQgYmUgdGhlIGNvbmNhdGVuYXRpb24gb2YgdGhlXG4gKiAgIGRpc3BsYXkgbmFtZXMgb2YgdGhlIG91dHB1dHMgb2YgYGZgIGFuZCB0aGUgbGlzdCBvZiBkaXNwbGF5IG5hbWVzXG4gKiAgIG9mIHRoZSBvdXRwdXRzIG9mIGB2YWxGYC5cbiAqIEBwYXJhbSBpbml0aWFsRXBvY2ggRXBvY2ggYXQgd2hpY2ggdG8gc3RhcnQgdHJhaW5pbmcgKHVzZWZ1bCBmb3JcbiAqICAgcmVzdW1pbmcgYSBwcmV2aW91cyB0cmFpbmluZyBydW4pLiBEZWZhdWx0IDogMC5cbiAqIEBwYXJhbSBzdGVwc1BlckVwb2NoIFRvdGFsIG51bWJlciBvZiBzdGVwcyAoYmF0Y2hlcyBvbiBzYW1wbGVzKSBiZWZvcmVcbiAqICAgZGVjbGFyaW5nIG9uZSBlcG9jaCBmaW5pc2hlZCBhbmQgc3RhcnRpbmcgdGhlIG5leHQgZXBvY2guIElnbm9yZWQgd2l0aFxuICogICB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgdW5kZWZpbmVkYCBvciBgbnVsbGAuXG4gKiBAcGFyYW0gdmFsaWRhdGlvblN0ZXBzIE51bWJlciBvZiBzdGVwcyB0byBydW4gdmFsaWRhdGlvbiBmb3IgKG9ubHkgaWZcbiAqICAgZG9pbmcgdmFsaWRhdGlvbiBmcm9tIGRhdGEgdGVuc29ycykuIE5vdCBhcHBsaWNhYmxlIGZvciB0ZmpzLWxheWVycy5cbiAqIEByZXR1cm5zIEEgYEhpc3RvcnlgIG9iamVjdC5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gZml0TG9vcChcbiAgICAvLyBUeXBlIGBtb2RlbGAgYXMgYGFueWAgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IHcvIHRyYWluaW5nLnRzLlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBtb2RlbDogYW55LCBmOiAoZGF0YTogVGVuc29yW10pID0+IFNjYWxhcltdLCBpbnM6IFRlbnNvcltdLFxuICAgIG91dExhYmVscz86IHN0cmluZ1tdLCBiYXRjaFNpemU/OiBudW1iZXIsIGVwb2Nocz86IG51bWJlciwgdmVyYm9zZT86IG51bWJlcixcbiAgICBjYWxsYmFja3M/OiBCYXNlQ2FsbGJhY2tbXSwgdmFsRj86IChkYXRhOiBUZW5zb3JbXSkgPT4gU2NhbGFyW10sXG4gICAgdmFsSW5zPzogVGVuc29yW10sIHNodWZmbGU/OiBib29sZWFufHN0cmluZywgY2FsbGJhY2tNZXRyaWNzPzogc3RyaW5nW10sXG4gICAgaW5pdGlhbEVwb2NoPzogbnVtYmVyLCBzdGVwc1BlckVwb2NoPzogbnVtYmVyLFxuICAgIHZhbGlkYXRpb25TdGVwcz86IG51bWJlcik6IFByb21pc2U8SGlzdG9yeT4ge1xuICBpZiAoYmF0Y2hTaXplID09IG51bGwpIHtcbiAgICBiYXRjaFNpemUgPSAzMjtcbiAgfVxuICBpZiAoZXBvY2hzID09IG51bGwpIHtcbiAgICBlcG9jaHMgPSAxO1xuICB9XG4gIGlmIChzaHVmZmxlID09IG51bGwpIHtcbiAgICBzaHVmZmxlID0gdHJ1ZTtcbiAgfVxuICBpZiAoaW5pdGlhbEVwb2NoID09IG51bGwpIHtcbiAgICBpbml0aWFsRXBvY2ggPSAwO1xuICB9XG5cbiAgLy8gVE9ETyhjYWlzKTogQ2hhbmdlIGNvbnN0IHRvIGxldCBiZWxvdyB3aGVuIGltcGxlbWVudGluZyB2YWxpZGF0aW9uLlxuICBsZXQgZG9WYWxpZGF0aW9uID0gZmFsc2U7XG4gIGlmICh2YWxGICE9IG51bGwgJiYgdmFsSW5zICE9IG51bGwpIHtcbiAgICBkb1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgIC8vIFRPRE8oY2Fpcyk6IHZlcmJvc2UgbWVzc2FnZS5cbiAgfVxuICBpZiAodmFsaWRhdGlvblN0ZXBzICE9IG51bGwpIHtcbiAgICBkb1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgIGlmIChzdGVwc1BlckVwb2NoID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdDYW4gb25seSB1c2UgYHZhbGlkYXRpb25TdGVwc2Agd2hlbiBkb2luZyBzdGVwLXdpc2UgdHJhaW5pbmcsICcgK1xuICAgICAgICAgICdpLmUuLCBgc3RlcHNQZXJFcG9jaGAgbXVzdCBiZSBzZXQuJyk7XG4gICAgfVxuICB9XG5cbiAgY29uc3QgbnVtVHJhaW5TYW1wbGVzID1cbiAgICAgIG1vZGVsLmNoZWNrTnVtU2FtcGxlcyhpbnMsIGJhdGNoU2l6ZSwgc3RlcHNQZXJFcG9jaCwgJ3N0ZXBzX3Blcl9lcG9jaCcpO1xuICBsZXQgaW5kZXhBcnJheTogbnVtYmVyW107XG4gIGlmIChudW1UcmFpblNhbXBsZXMgIT0gbnVsbCkge1xuICAgIGluZGV4QXJyYXkgPSByYW5nZSgwLCBudW1UcmFpblNhbXBsZXMpO1xuICB9XG5cbiAgaWYgKHZlcmJvc2UgPT0gbnVsbCkge1xuICAgIHZlcmJvc2UgPSAxO1xuICB9XG5cbiAgY29uc3Qge2NhbGxiYWNrTGlzdCwgaGlzdG9yeX0gPSBjb25maWd1cmVDYWxsYmFja3MoXG4gICAgICBjYWxsYmFja3MsIHZlcmJvc2UsIGVwb2NocywgaW5pdGlhbEVwb2NoLCBudW1UcmFpblNhbXBsZXMsIHN0ZXBzUGVyRXBvY2gsXG4gICAgICBiYXRjaFNpemUsIGRvVmFsaWRhdGlvbiwgY2FsbGJhY2tNZXRyaWNzKTtcbiAgY2FsbGJhY2tMaXN0LnNldE1vZGVsKG1vZGVsKTtcbiAgbW9kZWwuaGlzdG9yeSA9IGhpc3Rvcnk7XG4gIGF3YWl0IGNhbGxiYWNrTGlzdC5vblRyYWluQmVnaW4oKTtcbiAgbW9kZWwuc3RvcFRyYWluaW5nXyA9IGZhbHNlO1xuICAvLyBUT0RPKGNhaXMpOiBUYWtlIGNhcmUgb2YgY2FsbGJhY2tzLnZhbGlkYXRpb25fZGF0YSBhcyBpbiBQeUtlcmFzLlxuICAvLyBUT0RPKGNhaXMpOiBQcmUtY29udmVydCBmZWVkcyBmb3IgcGVyZm9ybWFuY2UgYXMgaW4gUHlLZXJhcy5cblxuICBmb3IgKGxldCBlcG9jaCA9IGluaXRpYWxFcG9jaDsgZXBvY2ggPCBlcG9jaHM7ICsrZXBvY2gpIHtcbiAgICBhd2FpdCBjYWxsYmFja0xpc3Qub25FcG9jaEJlZ2luKGVwb2NoKTtcbiAgICBjb25zdCBlcG9jaExvZ3M6IFVucmVzb2x2ZWRMb2dzID0ge307XG4gICAgaWYgKHN0ZXBzUGVyRXBvY2ggIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ3N0ZXBzUGVyRXBvY2ggbW9kZSBpcyBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoc2h1ZmZsZSA9PT0gJ2JhdGNoJykge1xuICAgICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignYmF0Y2ggc2h1ZmZsaW5nIGlzIG5vdCBpbXBsZW1uZXRlZCB5ZXQnKTtcbiAgICAgIH0gZWxzZSBpZiAoc2h1ZmZsZSkge1xuICAgICAgICB1dGlsLnNodWZmbGUoaW5kZXhBcnJheSk7XG4gICAgICB9XG4gICAgICAvLyBDb252ZXJ0IHRoZSBwb3RlbnRpYWxseSBzaHVmZmxlZCBpbmRpY2VzIHRvIFRlbnNvcjFELCB0byBhdm9pZCB0aGVcbiAgICAgIC8vIGNvc3Qgb2YgcmVwZWF0ZWQgY3JlYXRpb24gb2YgQXJyYXkxRHMgbGF0ZXIgb24uXG4gICAgICBjb25zdCBlcG9jaEluZGV4QXJyYXkxRCA9IHRlbnNvcjFkKGluZGV4QXJyYXkpO1xuXG4gICAgICBjb25zdCBiYXRjaGVzID0gbWFrZUJhdGNoZXMobnVtVHJhaW5TYW1wbGVzLCBiYXRjaFNpemUpO1xuICAgICAgZm9yIChsZXQgYmF0Y2hJbmRleCA9IDA7IGJhdGNoSW5kZXggPCBiYXRjaGVzLmxlbmd0aDsgKytiYXRjaEluZGV4KSB7XG4gICAgICAgIGNvbnN0IGJhdGNoTG9nczogVW5yZXNvbHZlZExvZ3MgPSB7fTtcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uQmF0Y2hCZWdpbihiYXRjaEluZGV4LCBiYXRjaExvZ3MpO1xuXG4gICAgICAgIHRmYy50aWR5KCgpID0+IHtcbiAgICAgICAgICBjb25zdCBiYXRjaFN0YXJ0ID0gYmF0Y2hlc1tiYXRjaEluZGV4XVswXTtcbiAgICAgICAgICBjb25zdCBiYXRjaEVuZCA9IGJhdGNoZXNbYmF0Y2hJbmRleF1bMV07XG4gICAgICAgICAgY29uc3QgYmF0Y2hJZHMgPSBzbGljZUFsb25nRmlyc3RBeGlzKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVwb2NoSW5kZXhBcnJheTFELCBiYXRjaFN0YXJ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhdGNoRW5kIC0gYmF0Y2hTdGFydCkgYXMgVGVuc29yMUQ7XG4gICAgICAgICAgYmF0Y2hMb2dzWydiYXRjaCddID0gYmF0Y2hJbmRleDtcbiAgICAgICAgICBiYXRjaExvZ3NbJ3NpemUnXSA9IGJhdGNoRW5kIC0gYmF0Y2hTdGFydDtcblxuICAgICAgICAgIC8vIFRPRE8oY2Fpcyk6IEluIGlucywgdHJhaW4gZmxhZyBjYW4gYmUgYSBudW1iZXIsIGluc3RlYWQgb2YgYW5cbiAgICAgICAgICAvLyAgIFRlbnNvcj8gRG8gd2UgbmVlZCB0byBoYW5kbGUgdGhpcyBpbiB0ZmpzLWxheWVycz9cbiAgICAgICAgICBjb25zdCBpbnNCYXRjaCA9IHNsaWNlQXJyYXlzQnlJbmRpY2VzKGlucywgYmF0Y2hJZHMpIGFzIFRlbnNvcltdO1xuICAgICAgICAgIGNvbnN0IG91dHMgPSBmKGluc0JhdGNoKTtcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgbGFiZWwgPSBvdXRMYWJlbHNbaV07XG4gICAgICAgICAgICBjb25zdCBvdXQgPSBvdXRzW2ldO1xuICAgICAgICAgICAgYmF0Y2hMb2dzW2xhYmVsXSA9IG91dDtcbiAgICAgICAgICAgIHRmYy5rZWVwKG91dCk7XG4gICAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBVc2Ugc2NvcGUoKSB0byBhdm9pZCBvd25lcnNoaXAuXG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGJhdGNoSW5kZXggPT09IGJhdGNoZXMubGVuZ3RoIC0gMSkgeyAgLy8gTGFzdCBiYXRjaC5cbiAgICAgICAgICAgIGlmIChkb1ZhbGlkYXRpb24pIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsT3V0cyA9IG1vZGVsLnRlc3RMb29wKHZhbEYsIHZhbElucywgYmF0Y2hTaXplKTtcbiAgICAgICAgICAgICAgLy8gUG9ydGluZyBOb3RlczogSW4gdGZqcy1sYXllcnMsIHZhbE91dHMgaXMgYWx3YXlzIGFuIEFycmF5LlxuICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhYmVsID0gb3V0TGFiZWxzW2ldO1xuICAgICAgICAgICAgICAgIGNvbnN0IG91dCA9IHZhbE91dHNbaV07XG4gICAgICAgICAgICAgICAgdGZjLmtlZXAob3V0KTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBVc2Ugc2NvcGUoKSB0byBhdm9pZCBvd25lcnNoaXAuXG4gICAgICAgICAgICAgICAgZXBvY2hMb2dzWyd2YWxfJyArIGxhYmVsXSA9IG91dDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uQmF0Y2hFbmQoYmF0Y2hJbmRleCwgYmF0Y2hMb2dzKTtcbiAgICAgICAgZGlzcG9zZVRlbnNvcnNJbkxvZ3MoYmF0Y2hMb2dzKTtcblxuICAgICAgICBpZiAobW9kZWwuc3RvcFRyYWluaW5nXykge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oY2Fpcyk6IHJldHVybiBvdXRzIGFzIGxpc3Qgb2YgVGVuc29yLlxuICAgICAgfVxuXG4gICAgICBlcG9jaEluZGV4QXJyYXkxRC5kaXNwb3NlKCk7XG4gICAgfVxuICAgIC8vIFRPRE8oY2Fpcyk6IFJ1biB2YWxpZGF0aW9uIGF0IHRoZSBlbmQgb2YgdGhlIGVwb2NoLlxuICAgIGF3YWl0IGNhbGxiYWNrTGlzdC5vbkVwb2NoRW5kKGVwb2NoLCBlcG9jaExvZ3MpO1xuICAgIGlmIChtb2RlbC5zdG9wVHJhaW5pbmdfKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgYXdhaXQgY2FsbGJhY2tMaXN0Lm9uVHJhaW5FbmQoKTtcblxuICBhd2FpdCBtb2RlbC5oaXN0b3J5LnN5bmNEYXRhKCk7XG4gIHJldHVybiBtb2RlbC5oaXN0b3J5O1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZml0VGVuc29ycyhcbiAgICAvLyBUeXBlIGBtb2RlbGAgYXMgYGFueWAgaGVyZSB0byBhdm9pZCBjaXJjdWxhciBkZXBlbmRlbmN5IHcvIHRyYWluaW5nLnRzLlxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBtb2RlbDogYW55LCB4OiBUZW5zb3J8VGVuc29yW118e1tpbnB1dE5hbWU6IHN0cmluZ106IFRlbnNvcn0sXG4gICAgeTogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LFxuICAgIGFyZ3M6IE1vZGVsRml0QXJncyA9IHt9KTogUHJvbWlzZTxIaXN0b3J5PiB7XG4gIGlmIChtb2RlbC5pc1RyYWluaW5nKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnQ2Fubm90IHN0YXJ0IHRyYWluaW5nIGJlY2F1c2UgYW5vdGhlciBmaXQoKSBjYWxsIGlzIG9uZ29pbmcuJyk7XG4gIH1cbiAgbW9kZWwuaXNUcmFpbmluZyA9IHRydWU7XG4gIGxldCBpbnB1dHM6IFRlbnNvcltdO1xuICBsZXQgdGFyZ2V0czogVGVuc29yW107XG4gIGxldCBvcmlnaW5hbElucHV0czogVGVuc29yW107XG4gIGxldCBvcmlnaW5hbFRhcmdldHM6IFRlbnNvcltdO1xuICBsZXQgaW5wdXRWYWxYOiBUZW5zb3J8VGVuc29yW107XG4gIGxldCBpbnB1dFZhbFk6IFRlbnNvcnxUZW5zb3JbXTtcbiAgbGV0IHZhbFg6IFRlbnNvcnxUZW5zb3JbXTtcbiAgbGV0IHZhbFk6IFRlbnNvcnxUZW5zb3JbXTtcbiAgbGV0IHNhbXBsZVdlaWdodHM6IFRlbnNvcltdO1xuICB0cnkge1xuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGFyZ3MuYmF0Y2hTaXplID09IG51bGwgPyAzMiA6IGFyZ3MuYmF0Y2hTaXplO1xuICAgIGNoZWNrQmF0Y2hTaXplKGJhdGNoU2l6ZSk7XG5cbiAgICAvLyBWYWxpZGF0ZSB1c2VyIGRhdGEuXG4gICAgLy8gVE9ETyhjYWlzKTogU3VwcG9ydCBzYW1wbGVXZWlnaHQuXG4gICAgY29uc3QgY2hlY2tCYXRjaEF4aXMgPSBmYWxzZTtcbiAgICBjb25zdCBzdGFuZGFyZGl6ZWRPdXRzID1cbiAgICAgICAgYXdhaXQgbW9kZWwuc3RhbmRhcmRpemVVc2VyRGF0YShcbiAgICAgICAgICAgIHgsIHksIGFyZ3Muc2FtcGxlV2VpZ2h0LCBhcmdzLmNsYXNzV2VpZ2h0LCBjaGVja0JhdGNoQXhpcyxcbiAgICAgICAgICAgIGJhdGNoU2l6ZSkgYXMgW1RlbnNvcltdLCBUZW5zb3JbXSwgVGVuc29yW11dO1xuICAgIGlucHV0cyA9IHN0YW5kYXJkaXplZE91dHNbMF07XG4gICAgdGFyZ2V0cyA9IHN0YW5kYXJkaXplZE91dHNbMV07XG4gICAgc2FtcGxlV2VpZ2h0cyA9IHN0YW5kYXJkaXplZE91dHNbMl07XG5cbiAgICAvLyBQcmVwYXJlIHZhbGlkYXRpb24gZGF0YS5cbiAgICBsZXQgZG9WYWxpZGF0aW9uID0gZmFsc2U7XG4gICAgbGV0IHZhbEluczogVGVuc29yW107XG4gICAgaWYgKGFyZ3MudmFsaWRhdGlvbkRhdGEgIT0gbnVsbCAmJiBhcmdzLnZhbGlkYXRpb25EYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgIGRvVmFsaWRhdGlvbiA9IHRydWU7XG4gICAgICBpZiAoYXJncy52YWxpZGF0aW9uRGF0YS5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgLy8gY29uZmlnLnZhbGlkYXRpb25EYXRhIGNvbnNpc3RzIG9mIHZhbFggYW5kIHZhbFkuXG4gICAgICAgIGlucHV0VmFsWCA9IGFyZ3MudmFsaWRhdGlvbkRhdGFbMF07XG4gICAgICAgIGlucHV0VmFsWSA9IGFyZ3MudmFsaWRhdGlvbkRhdGFbMV07XG4gICAgICB9IGVsc2UgaWYgKGFyZ3MudmFsaWRhdGlvbkRhdGEubGVuZ3RoID09PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgICAgJ3ZhbGlkYXRpb25EYXRhIGluY2x1ZGluZyBzYW1wbGUgd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYFdoZW4gcGFzc2luZyB2YWxpZGF0aW9uIGRhdGEsIGl0IG11c3QgY29udGFpbiAyICh2YWxYLCB2YWxZKSBgICtcbiAgICAgICAgICAgIGBvciAzICh2YWxYLCB2YWxZLCB2YWxTYW1wbGVXZWlnaHQpIGl0ZW1zOyBgICtcbiAgICAgICAgICAgIGAke2FyZ3MudmFsaWRhdGlvbkRhdGF9IGlzIGludmFsaWQuYCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGNoZWNrQmF0Y2hBeGlzID0gdHJ1ZTtcbiAgICAgIGNvbnN0IHZhbFN0YW5kYXJkaXplZCA9XG4gICAgICAgICAgYXdhaXQgbW9kZWwuc3RhbmRhcmRpemVVc2VyRGF0YShcbiAgICAgICAgICAgICAgaW5wdXRWYWxYLCBpbnB1dFZhbFksIG51bGwsIC8qKiBVbnVzZWQgc2FtcGxlIHdlaWdodHMuICovXG4gICAgICAgICAgICAgIG51bGwsICAgICAgICAgICAgICAgICAgICAgICAvKiogVW51c2VkIGNsYXNzIHdlaWdodHMuICovXG4gICAgICAgICAgICAgIGNoZWNrQmF0Y2hBeGlzLCBiYXRjaFNpemUpIGFzIFtUZW5zb3JbXSwgVGVuc29yW10sIFRlbnNvcltdXTtcbiAgICAgIHZhbFggPSB2YWxTdGFuZGFyZGl6ZWRbMF07XG4gICAgICB2YWxZID0gdmFsU3RhbmRhcmRpemVkWzFdO1xuICAgICAgdmFsSW5zID0gdmFsWC5jb25jYXQodmFsWSk7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgdXNlTGVhcm5pbmdQaGFzZSBkYXRhIHByb3Blcmx5LlxuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGFyZ3MudmFsaWRhdGlvblNwbGl0ICE9IG51bGwgJiYgYXJncy52YWxpZGF0aW9uU3BsaXQgPiAwICYmXG4gICAgICAgIGFyZ3MudmFsaWRhdGlvblNwbGl0IDwgMSkge1xuICAgICAgZG9WYWxpZGF0aW9uID0gdHJ1ZTtcbiAgICAgIC8vIFBvcnRpbmcgTm90ZTogSW4gdGZqcy1sYXllcnMsIGlucHV0c1swXSBpcyBhbHdheXMgYSBUZW5zb3IuXG4gICAgICBjb25zdCBzcGxpdEF0ID1cbiAgICAgICAgICBNYXRoLmZsb29yKGlucHV0c1swXS5zaGFwZVswXSAqICgxIC0gYXJncy52YWxpZGF0aW9uU3BsaXQpKTtcbiAgICAgIGNvbnN0IG9yaWdpbmFsQmF0Y2hTaXplID0gaW5wdXRzWzBdLnNoYXBlWzBdO1xuICAgICAgdmFsWCA9IHNsaWNlQXJyYXlzKGlucHV0cywgc3BsaXRBdCwgb3JpZ2luYWxCYXRjaFNpemUpIGFzIFRlbnNvcltdO1xuICAgICAgb3JpZ2luYWxJbnB1dHMgPSBpbnB1dHM7XG4gICAgICBpbnB1dHMgPSBzbGljZUFycmF5cyhpbnB1dHMsIDAsIHNwbGl0QXQpIGFzIFRlbnNvcltdO1xuICAgICAgdmFsWSA9IHNsaWNlQXJyYXlzKHRhcmdldHMsIHNwbGl0QXQsIG9yaWdpbmFsQmF0Y2hTaXplKSBhcyBUZW5zb3JbXTtcbiAgICAgIG9yaWdpbmFsVGFyZ2V0cyA9IHRhcmdldHM7XG4gICAgICB0YXJnZXRzID0gc2xpY2VBcnJheXModGFyZ2V0cywgMCwgc3BsaXRBdCkgYXMgVGVuc29yW107XG4gICAgICAvLyBUT0RPKGNhaXMpOiBPbmNlIHNhbXBsZVdlaWdodHMgYmVjb21lcyBhdmFpbGFibGUsIHNsaWNlIGl0IHRvIGdldFxuICAgICAgLy8gICB2YWxTYW1wbGVXZWlnaHRzLlxuICAgICAgdmFsSW5zID0gdmFsWC5jb25jYXQodmFsWSk7XG5cbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCB1c2VMZWFybmluZ1BoYXNlIGRhdGEgcHJvcGVybHkuXG4gICAgfSBlbHNlIGlmIChhcmdzLnZhbGlkYXRpb25TdGVwcyAhPSBudWxsKSB7XG4gICAgICBkb1ZhbGlkYXRpb24gPSB0cnVlO1xuICAgICAgLy8gVE9ETyhjYWlzKTogQWRkIHVzZUxlYXJuaW5nUGhhc2UuXG4gICAgfVxuXG4gICAgY29uc3QgaW5zID0gaW5wdXRzLmNvbmNhdCh0YXJnZXRzKS5jb25jYXQoc2FtcGxlV2VpZ2h0cyk7XG5cbiAgICBtb2RlbC5jaGVja1RyYWluYWJsZVdlaWdodHNDb25zaXN0ZW5jeSgpO1xuXG4gICAgLy8gVE9ETyhjYWlzKTogSGFuZGxlIHVzZV9sZWFybmluZ19waGFzZSBhbmQgbGVhcm5pbmdfcGhhc2U/XG5cbiAgICAvLyBQb3J0aW5nIE5vdGU6IEhlcmUgd2Ugc2VlIGEga2V5IGRldmlhdGlvbiBvZiB0ZmpzLWxheWVycyBmcm9tXG4gICAgLy8gS2VyYXMuXG4gICAgLy8gIER1ZSB0byB0aGUgaW1wZXJhdGl2ZSBuYXR1cmUgb2YgdGZqcy1sYXllcnMnIGJhY2tlbmQgKHRmanMtY29yZSksXG4gICAgLy8gIHdlIGRvIG5vdCBjb25zdHJ1Y3Qgc3ltYm9saWMgY29tcHV0YXRpb24gZ3JhcGhzIHRvIGVtYm9keSB0aGVcbiAgICAvLyAgdHJhaW5pbmcgcHJvY2Vzcy4gSW5zdGVhZCwgd2UgZGVmaW5lIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGVcbiAgICAvLyAgdHJhaW5pbmcgYWN0aW9uLiBJbiBQeUtlcmFzLCB0aGUgZGF0YSAoaW5wdXRzIGFuZCB0YXJnZXRzKSBhcmUgZmVkXG4gICAgLy8gIHRocm91Z2ggZ3JhcGggcGxhY2Vob2xkZXJzLiBJbiB0ZmpzLWxheWVycywgdGhlIGRhdGEgYXJlIGZlZCBhc1xuICAgIC8vICBmdW5jdGlvbiBhcmd1bWVudHMuIFNpbmNlIHRoZSBmdW5jdGlvbiBhcmUgZGVmaW5lZCBiZWxvdyBpbiB0aGVcbiAgICAvLyAgc2NvcGUsIHdlIGRvbid0IGhhdmUgZXF1aXZhbGVudHMgb2YgUHlLZXJhcydzXG4gICAgLy8gIGBfbWFrZV90cmFpbl9mdW5jaXRvbmAuXG4gICAgY29uc3QgdHJhaW5GdW5jdGlvbiA9IG1vZGVsLm1ha2VUcmFpbkZ1bmN0aW9uKCk7XG4gICAgY29uc3Qgb3V0TGFiZWxzID0gbW9kZWwuZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpIGFzIHN0cmluZ1tdO1xuXG4gICAgbGV0IHZhbEZ1bmN0aW9uOiAoZGF0YTogVGVuc29yW10pID0+IFNjYWxhcltdO1xuICAgIGxldCBjYWxsYmFja01ldHJpY3M6IHN0cmluZ1tdO1xuICAgIGlmIChkb1ZhbGlkYXRpb24pIHtcbiAgICAgIG1vZGVsLm1ha2VUZXN0RnVuY3Rpb24oKTtcbiAgICAgIHZhbEZ1bmN0aW9uID0gbW9kZWwudGVzdEZ1bmN0aW9uO1xuICAgICAgY2FsbGJhY2tNZXRyaWNzID1cbiAgICAgICAgICBvdXRMYWJlbHMuc2xpY2UoKS5jb25jYXQob3V0TGFiZWxzLm1hcChuID0+ICd2YWxfJyArIG4pKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsRnVuY3Rpb24gPSBudWxsO1xuICAgICAgdmFsSW5zID0gW107XG4gICAgICBjYWxsYmFja01ldHJpY3MgPSBvdXRMYWJlbHMuc2xpY2UoKTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWxsYmFja3MgPSBzdGFuZGFyZGl6ZUNhbGxiYWNrcyhhcmdzLmNhbGxiYWNrcywgYXJncy55aWVsZEV2ZXJ5KTtcbiAgICBjb25zdCBvdXQgPSBhd2FpdCBmaXRMb29wKFxuICAgICAgICBtb2RlbCwgdHJhaW5GdW5jdGlvbiwgaW5zLCBvdXRMYWJlbHMsIGJhdGNoU2l6ZSwgYXJncy5lcG9jaHMsXG4gICAgICAgIGFyZ3MudmVyYm9zZSwgY2FsbGJhY2tzLCB2YWxGdW5jdGlvbiwgdmFsSW5zLCBhcmdzLnNodWZmbGUsXG4gICAgICAgIGNhbGxiYWNrTWV0cmljcywgYXJncy5pbml0aWFsRXBvY2gsIG51bGwsIG51bGwpO1xuICAgIHJldHVybiBvdXQ7XG4gIH0gZmluYWxseSB7XG4gICAgbW9kZWwuaXNUcmFpbmluZyA9IGZhbHNlO1xuICAgIC8vIE1lbW9yeSBjbGVhbiB1cC5cbiAgICBkaXNwb3NlTmV3VGVuc29ycyhpbnB1dHMsIHgpO1xuICAgIGRpc3Bvc2VOZXdUZW5zb3JzKHRhcmdldHMsIHkpO1xuICAgIGRpc3Bvc2VOZXdUZW5zb3JzKG9yaWdpbmFsSW5wdXRzLCB4KTtcbiAgICBkaXNwb3NlTmV3VGVuc29ycyhvcmlnaW5hbFRhcmdldHMsIHkpO1xuICAgIGRpc3Bvc2VOZXdUZW5zb3JzKHZhbFggYXMgVGVuc29yW10sIGlucHV0VmFsWCk7XG4gICAgZGlzcG9zZU5ld1RlbnNvcnModmFsWSBhcyBUZW5zb3JbXSwgaW5wdXRWYWxZKTtcbiAgICBpZiAoc2FtcGxlV2VpZ2h0cyAhPSBudWxsKSB7XG4gICAgICB0ZmMuZGlzcG9zZShzYW1wbGVXZWlnaHRzKTtcbiAgICB9XG4gIH1cbiAgLy8gVE9ETyhjYWlzKTogQWRkIHZhbHVlIHRvIG91dExhYmVscy5cbn1cblxuLyoqXG4gKiBFbnN1cmUgdGVuc29ycyBhbGwgaGF2ZSBhIHJhbmsgb2YgYXQgbGVhc3QgMi5cbiAqXG4gKiBJZiBhIHRlbnNvciBoYXMgYSByYW5rIG9mIDEsIGl0IGlzIGRpbWVuc2lvbi1leHBhbmRlZCB0byByYW5rIDIuXG4gKiBJZiBhbnkgdGVuc29yIGhhcyBhIHJhbmsgb2YgMCAoaS5lLiwgaXMgYSBzY2FsYXIpLCBhbiBlcnJvciB3aWxsIGJlIHRocm93bi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZVRlbnNvcnNSYW5rMk9ySGlnaGVyKHRlbnNvcnM6IFRlbnNvcnxUZW5zb3JbXSk6IFRlbnNvcltdIHtcbiAgY29uc3Qgb3V0czogVGVuc29yW10gPSBbXTtcbiAgaWYgKHRlbnNvcnMgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICB0ZW5zb3JzID0gW3RlbnNvcnNdO1xuICB9XG5cbiAgLy8gTWFrZSBUZW5zb3JzIGF0IGxlYXN0IDJELlxuICBmb3IgKGxldCBpID0gMDsgaSA8IHRlbnNvcnMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCB0ZW5zb3IgPSB0ZW5zb3JzW2ldO1xuICAgIGlmICh0ZW5zb3IucmFuayA9PT0gMSkge1xuICAgICAgb3V0cy5wdXNoKGV4cGFuZERpbXModGVuc29yLCAxKSk7XG4gICAgfSBlbHNlIGlmICh0ZW5zb3IucmFuayA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdFeHBlY3RlZCB0ZW5zb3IgdG8gYmUgYXQgbGVhc3QgMUQsIGJ1dCByZWNlaXZlZCBhIDBEIHRlbnNvciAnICtcbiAgICAgICAgICAnKHNjYWxhcikuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHMucHVzaCh0ZW5zb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cztcbn1cblxuLyoqXG4gKiBDb21wYXJlIGEgc2V0IG9mIHRlbnNvcnMgd2l0aCBhIHJlZmVyZW5jZSAob2xkKSBzZXQsIGRpc2NhcmQgdGhlIG9uZXNcbiAqIGluIHRoZSBuZXcgc2V0IHRoYXQgYXJlIG5vdCBwcmVzZW50IGluIHRoZSByZWZlcmVuY2Ugc2V0LlxuICpcbiAqIFRoaXMgbWV0aG9kIGlzIHVzZWQgZm9yIG1lbW9yeSBjbGVuYXVwIGR1cmluZyBjYWxscyBzdWNoIGFzXG4gKiBMYXllcnNNb2RlbC5maXQoKS5cbiAqXG4gKiBAcGFyYW0gdGVuc29ycyBOZXcgc2V0IHdoaWNoIG1heSBjb250YWluIFRlbnNvcnMgbm90IHByZXNlbnQgaW5cbiAqICAgYHJlZlRlbnNvcnNgLlxuICogQHBhcmFtIHJlZlRlbnNvcnMgUmVmZXJlbmNlIFRlbnNvciBzZXQuXG4gKi9cbi8vIFRPRE8oY2Fpcywga2FuZ3lpemhhbmcpOiBEZWR1cGxpY2F0ZSB3aXRoIHRmanMtZGF0YS5cbmV4cG9ydCBmdW5jdGlvbiBkaXNwb3NlTmV3VGVuc29ycyhcbiAgICB0ZW5zb3JzOiBUZW5zb3J8VGVuc29yW118e1tpbnB1dE5hbWU6IHN0cmluZ106IFRlbnNvcn0sXG4gICAgcmVmVGVuc29yczogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9KTogdm9pZCB7XG4gIGlmICh0ZW5zb3JzID09IG51bGwpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgb2xkVGVuc29ySWRzOiBudW1iZXJbXSA9IFtdO1xuICBpZiAocmVmVGVuc29ycyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgIG9sZFRlbnNvcklkcy5wdXNoKHJlZlRlbnNvcnMuaWQpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkocmVmVGVuc29ycykpIHtcbiAgICByZWZUZW5zb3JzLmZvckVhY2godCA9PiBvbGRUZW5zb3JJZHMucHVzaCh0LmlkKSk7XG4gIH0gZWxzZSBpZiAocmVmVGVuc29ycyAhPSBudWxsKSB7XG4gICAgLy8gYG9sZFRlbnNvcnNgIGlzIGEgbWFwIGZyb20gc3RyaW5nIG5hbWUgdG8gVGVuc29yLlxuICAgIGZvciAoY29uc3QgbmFtZSBpbiByZWZUZW5zb3JzKSB7XG4gICAgICBjb25zdCBvbGRUZW5zb3IgPSByZWZUZW5zb3JzW25hbWVdO1xuICAgICAgb2xkVGVuc29ySWRzLnB1c2gob2xkVGVuc29yLmlkKTtcbiAgICB9XG4gIH1cblxuICBjb25zdCB0ZW5zb3JzVG9EaXNwb3NlOiBUZW5zb3JbXSA9IFtdO1xuICBpZiAodGVuc29ycyBpbnN0YW5jZW9mIFRlbnNvcikge1xuICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0ZW5zb3JzLmlkKSA9PT0gLTEpIHtcbiAgICAgIHRlbnNvcnNUb0Rpc3Bvc2UucHVzaCh0ZW5zb3JzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheSh0ZW5zb3JzKSkge1xuICAgIHRlbnNvcnMuZm9yRWFjaCh0ID0+IHtcbiAgICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0LmlkKSA9PT0gLTEpIHtcbiAgICAgICAgdGVuc29yc1RvRGlzcG9zZS5wdXNoKHQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9IGVsc2UgaWYgKHRlbnNvcnMgIT0gbnVsbCkge1xuICAgIC8vIGBvbGRUZW5zb3JzYCBpcyBhIG1hcCBmcm9tIHN0cmluZyBuYW1lIHRvIFRlbnNvci5cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGVuc29ycykge1xuICAgICAgY29uc3QgdGVuc29yID0gdGVuc29yc1tuYW1lXTtcbiAgICAgIGlmIChvbGRUZW5zb3JJZHMuaW5kZXhPZih0ZW5zb3IuaWQpID09PSAtMSkge1xuICAgICAgICB0ZW5zb3JzVG9EaXNwb3NlLnB1c2godGVuc29yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICB0ZW5zb3JzVG9EaXNwb3NlLmZvckVhY2godCA9PiB7XG4gICAgaWYgKCF0LmlzRGlzcG9zZWQpIHtcbiAgICAgIHQuZGlzcG9zZSgpO1xuICAgIH1cbiAgfSk7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original Source: engine/training.py */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { io, Optimizer, scalar, serialization, Tensor, tensor1d, util } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { nameScope } from '../common';\nimport { NotImplementedError, RuntimeError, ValueError } from '../errors';\nimport { deserialize } from '../layers/serialization';\nimport * as losses from '../losses';\nimport * as Metrics from '../metrics';\nimport * as optimizers from '../optimizers';\nimport { checkUserDefinedMetadata } from '../user_defined_metadata';\nimport { count, pyListRepeat, singletonOrArray, toCamelCase, toSnakeCase, unique } from '../utils/generic_utils';\nimport { printSummary } from '../utils/layer_utils';\nimport { range } from '../utils/math_utils';\nimport { convertPythonicToTs } from '../utils/serialization_utils';\nimport { version } from '../version';\nimport { Container } from './container';\nimport { execute, FeedDict } from './executor';\nimport { evaluateDataset, fitDataset } from './training_dataset';\nimport { checkBatchSize, disposeNewTensors, ensureTensorsRank2OrHigher, fitTensors, makeBatches, sliceArrays, sliceArraysByIndices } from './training_tensors';\nimport { computeWeightedLoss, standardizeClassWeights, standardizeWeights } from './training_utils';\n/**\n * Helper function for polymorphic input data: 1. singleton Tensor.\n */\nexport function isDataTensor(x) {\n    return x instanceof Tensor;\n}\n/**\n * Helper function for polymorphic input data: 2. Array of Tensor.\n */\nexport function isDataArray(x) {\n    return Array.isArray(x);\n}\n/**\n * Helper function for polymorphic input data: 3. \"dict\" of Tensor.\n */\nexport function isDataDict(x) {\n    return !isDataTensor(x) && !isDataArray(x);\n}\n/**\n * Normalizes inputs and targets provided by users.\n * @param data User-provided input data (polymorphic).\n * @param names An Array of expected Tensor names.\n * @param shapes Optional Array of expected Tensor shapes.\n * @param checkBatchAxis Whether to check that the batch axis of the arrays\n *   match  the expected value found in `shapes`.\n * @param exceptionPrefix String prefix used for exception formatting.\n * @returns List of standardized input Tensors (one Tensor per model input).\n * @throws ValueError: in case of improperly formatted user data.\n */\nexport function standardizeInputData(data, names, shapes, checkBatchAxis = true, exceptionPrefix = '') {\n    if (names == null || names.length === 0) {\n        // Check for the case where the model expected no data, but some data got\n        // sent.\n        if (data != null) {\n            let gotUnexpectedData = false;\n            if (isDataArray(data) && data.length > 0) {\n                gotUnexpectedData = true;\n            }\n            else if (isDataDict(data)) {\n                for (const key in data) {\n                    if (data.hasOwnProperty(key)) {\n                        gotUnexpectedData = true;\n                        break;\n                    }\n                }\n            }\n            else {\n                // `data` is a singleton Tensor in this case.\n                gotUnexpectedData = true;\n            }\n            if (gotUnexpectedData) {\n                throw new ValueError(`Error when checking model ${exceptionPrefix} expected no data, ` +\n                    `but got ${data}`);\n            }\n        }\n        return [];\n    }\n    if (data == null) {\n        return names.map(name => null);\n    }\n    let arrays;\n    if (isDataDict(data)) {\n        data = data;\n        arrays = [];\n        for (const name of names) {\n            if (data[name] == null) {\n                throw new ValueError(`No data provided for \"${name}\". Need data for each key in: ` +\n                    `${names}`);\n            }\n            arrays.push(data[name]);\n        }\n    }\n    else if (isDataArray(data)) {\n        data = data;\n        if (data.length !== names.length) {\n            throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of ` +\n                `Tensors that you are passing to your model is not the size the ` +\n                `model expected. Expected to see ${names.length} Tensor(s), but ` +\n                `instead got the following list of Tensor(s): ${data}`);\n        }\n        arrays = data;\n    }\n    else {\n        data = data;\n        if (names.length > 1) {\n            throw new ValueError(`The model ${exceptionPrefix} expects ${names.length} Tensor(s), ` +\n                `but only received one Tensor. Found: Tensor with shape ${data.shape}`);\n        }\n        arrays = [data];\n    }\n    arrays = ensureTensorsRank2OrHigher(arrays);\n    // Check shape compatibility.\n    if (shapes != null) {\n        for (let i = 0; i < names.length; ++i) {\n            if (shapes[i] == null) {\n                continue;\n            }\n            const array = arrays[i];\n            if (array.shape.length !== shapes[i].length) {\n                throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} ` +\n                    `to have ${shapes[i].length} dimension(s). but got array with ` +\n                    `shape ${array.shape}`);\n            }\n            for (let j = 0; j < shapes[i].length; ++j) {\n                if (j === 0 && !checkBatchAxis) {\n                    // Skip the first (batch) axis.\n                    continue;\n                }\n                const dim = array.shape[j];\n                const refDim = shapes[i][j];\n                if (refDim != null && refDim >= 0 && dim !== refDim) {\n                    throw new ValueError(`${exceptionPrefix} expected a batch of elements where each ` +\n                        `example has shape [${shapes[i].slice(1, shapes[i].length)}] ` +\n                        `(i.e.,tensor shape [*,${shapes[i].slice(1, shapes[i].length)}])` +\n                        ` but the ${exceptionPrefix} received an input with ${array.shape[0]}` +\n                        ` examples, each with shape [${array.shape.slice(1, array.shape.length)}]` +\n                        ` (tensor shape [${array.shape}])`);\n                }\n            }\n        }\n    }\n    return arrays;\n}\n/**\n * User input validation for Tensors.\n * @param inputs `Array` of `tf.Tensor`s for inputs.\n * @param targets `Array` of `tf.Tensor`s for targets.\n * @param weights Optional `Array` of `tf.Tensor`s for sample weights.\n * @throws ValueError: in case of incorrectly formatted data.\n */\nexport function checkArrayLengths(inputs, targets, weights) {\n    const setX = unique(inputs.map(input => input.shape[0]));\n    setX.sort();\n    const setY = unique(targets.map(target => target.shape[0]));\n    setY.sort();\n    // TODO(cais): Check `weights` as well.\n    if (setX.length > 1) {\n        throw new ValueError(`All input Tensors (x) should have the same number of samples. ` +\n            `Got array shapes: ` +\n            `${JSON.stringify(inputs.map(input => input.shape))}`);\n    }\n    if (setY.length > 1) {\n        throw new ValueError(`All target Tensors (y) should have the same number of samples. ` +\n            `Got array shapes: ` +\n            `${JSON.stringify(targets.map(target => target.shape))}`);\n    }\n    if (setX.length > 0 && setY.length > 0 && !util.arraysEqual(setX, setY)) {\n        throw new ValueError(`Input Tensors should have the same number of samples as target ` +\n            `Tensors. Found ${setX[0]} input sample(s) and ${setY[0]} target ` +\n            `sample(s).`);\n    }\n}\n/**\n * Validation on the compatibility of targes and loss functions.\n *\n * This helps prevent users from using loss functions incorrectly.\n *\n * @param targets `Array` of `tf.Tensor`s of targets.\n * @param lossFns `Array` of loss functions.\n * @param outputShapes `Array` of shapes of model outputs.\n */\nfunction checkLossAndTargetCompatibility(targets, lossFns, outputShapes) {\n    // TODO(cais): Dedicated test coverage?\n    const keyLosses = [\n        losses.meanSquaredError, losses.binaryCrossentropy,\n        losses.categoricalCrossentropy\n    ];\n    for (let i = 0; i < targets.length; ++i) {\n        const y = targets[i];\n        const loss = lossFns[i];\n        const shape = outputShapes[i];\n        if (loss == null) {\n            continue;\n        }\n        if (loss === losses.categoricalCrossentropy) {\n            if (y.shape[y.shape.length - 1] === 1) {\n                throw new ValueError(`You are passing a target array of shape ${y.shape} while using ` +\n                    `a loss 'categorical_crossentropy'. 'categorical_crossentropy'` +\n                    `expects targets to be binary matrices (1s and 0s) of shape ` +\n                    `[samples, classes].`);\n                // TODO(cais): Example code in error message.\n            }\n        }\n        if (keyLosses.indexOf(loss) !== -1) {\n            const slicedYShape = y.shape.slice(1);\n            const slicedShape = shape.slice(1);\n            for (let j = 0; j < slicedYShape.length; ++j) {\n                const targetDim = slicedYShape[j];\n                const outDim = slicedShape[j];\n                if (outDim != null && targetDim !== outDim) {\n                    throw new ValueError(`A target Tensor with shape ${y.shape} was passed for an ` +\n                        `output of shape ${shape}, while using a loss function that ` +\n                        `expects targets to have the same shape as the output.`);\n                }\n            }\n        }\n    }\n}\n/**\n * Check inputs provided by the user.\n *\n * Porting Note: This corresponds to _standardize_input_data() in Python\n *   Keras. Because of the strong typing in TF.js, we do not need to convert\n *   the data. Specifically:\n *   1) in PyKeras, `data` can be `DataFrame` instances from pandas, for\n *      example. We don't need to worry about that here because there is no\n *      widely popular javascript/typesdcript equivalent of pandas (so far).\n *      If one becomes available in the future, we can add support.\n *   2) in PyKeras, inputs can be Python dict. But here we are stipulating\n * that the data is either a single `tf.Tensor` or an Array of `tf.Tensor`s. We\n * may add support for `Object` data inputs in the future when the need\n * arises.\n *\n * Instead, we perform basic checks for number of parameters and shapes.\n *\n * @param data: The input data.\n * @param names: Name for the inputs, from the model.\n * @param shapes: Expected shapes for the input data, from the model.\n * @param checkBatchAxis: Whether the size along the batch axis (i.e., the\n *   first dimension) will be checked for matching.\n * @param exceptionPrefix: Execption prefix message, used in generating error\n *   messages.\n * @throws ValueError: on incorrect number of inputs or mismatches in shapes.\n */\nfunction checkInputData(data, names, shapes, checkBatchAxis = true, exceptionPrefix = '') {\n    let arrays;\n    if (Array.isArray(data)) {\n        if (data.length !== names.length) {\n            throw new ValueError(`Error when checking model ${exceptionPrefix}: the Array of ` +\n                `Tensors that you are passing to your model is not the size the ` +\n                `the model expected. Expected to see ${names.length} Tensor(s),` +\n                ` but instead got ${data.length} Tensors(s).`);\n        }\n        arrays = data;\n    }\n    else {\n        if (names.length > 1) {\n            throw new ValueError(`The model expects ${names.length} ${exceptionPrefix} Tensors, ` +\n                `but only received one Tensor. Found: array with shape ` +\n                `${JSON.stringify(data.shape)}.`);\n        }\n        arrays = [data];\n    }\n    if (shapes != null) {\n        for (let i = 0; i < names.length; ++i) {\n            if (shapes[i] == null) {\n                continue;\n            }\n            const array = arrays[i];\n            if (array.shape.length !== shapes[i].length) {\n                throw new ValueError(`Error when checking ${exceptionPrefix}: expected ${names[i]} ` +\n                    `to have ${shapes[i].length} dimension(s), but got array with ` +\n                    `shape ${JSON.stringify(array.shape)}`);\n            }\n            for (let j = 0; j < shapes[i].length; ++j) {\n                if (j === 0 && !checkBatchAxis) {\n                    continue;\n                }\n                const dim = array.shape[j];\n                const refDim = shapes[i][j];\n                if (refDim != null) {\n                    if (refDim !== dim) {\n                        throw new ValueError(`Error when checking ${exceptionPrefix}: expected ` +\n                            `${names[i]} to have shape ${JSON.stringify(shapes[i])} but ` +\n                            `got array with shape ${JSON.stringify(array.shape)}.`);\n                    }\n                }\n            }\n        }\n    }\n}\n/**\n * Maps metric functions to model outputs.\n * @param metrics An shortcut strings name, metric function, `Array` or dict\n *   (`Object`) of metric functions.\n * @param outputNames An `Array` of the names of model outputs.\n * @returns An `Array` (one entry per model output) of `Array` of metric\n *   functions. For instance, if the model has 2 outputs, and for the first\n *   output we want to compute `binaryAccuracy` and `binaryCrossentropy`,\n *   and just `binaryAccuracy` for the second output, the `Array` would look\n *   like:\n *     `[[binaryAccuracy, binaryCrossentropy],  [binaryAccuracy]]`\n * @throws TypeError: incompatible metrics format.\n */\nexport function collectMetrics(metrics, outputNames) {\n    if (metrics == null || Array.isArray(metrics) && metrics.length === 0) {\n        return outputNames.map(name => []);\n    }\n    let wrappedMetrics;\n    if (typeof metrics === 'string' || typeof metrics === 'function') {\n        wrappedMetrics = [metrics];\n    }\n    else if (Array.isArray(metrics) || typeof metrics === 'object') {\n        wrappedMetrics = metrics;\n    }\n    else {\n        throw new TypeError('Type of metrics argument not understood. Expected an string,' +\n            `function, Array, or Object, found: ${metrics}`);\n    }\n    if (Array.isArray(wrappedMetrics)) {\n        // We then apply all metrics to all outputs.\n        return outputNames.map(name => wrappedMetrics);\n    }\n    else {\n        // In this case, metrics is a dict.\n        const nestedMetrics = [];\n        for (const name of outputNames) {\n            let outputMetrics = wrappedMetrics.hasOwnProperty(name) ? wrappedMetrics[name] : [];\n            if (!Array.isArray(outputMetrics)) {\n                outputMetrics = [outputMetrics];\n            }\n            nestedMetrics.push(outputMetrics);\n        }\n        return nestedMetrics;\n    }\n}\nconst LAYERS_MODEL_FORMAT_NAME = 'layers-model';\n/**\n * A `tf.LayersModel` is a directed, acyclic graph of `tf.Layer`s plus methods\n * for training, evaluation, prediction and saving.\n *\n * `tf.LayersModel` is the basic unit of training, inference and evaluation in\n * TensorFlow.js. To create a `tf.LayersModel`, use `tf.LayersModel`.\n *\n * See also:\n *   `tf.Sequential`, `tf.loadLayersModel`.\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nexport class LayersModel extends Container {\n    constructor(args) {\n        super(args);\n        this.isTraining = false;\n    }\n    /**\n     * Print a text summary of the model's layers.\n     *\n     * The summary includes\n     * - Name and type of all layers that comprise the model.\n     * - Output shape(s) of the layers\n     * - Number of weight parameters of each layer\n     * - If the model has non-sequential-like topology, the inputs each layer\n     *   receives\n     * - The total number of trainable and non-trainable parameters of the model.\n     *\n     * ```js\n     * const input1 = tf.input({shape: [10]});\n     * const input2 = tf.input({shape: [20]});\n     * const dense1 = tf.layers.dense({units: 4}).apply(input1);\n     * const dense2 = tf.layers.dense({units: 8}).apply(input2);\n     * const concat = tf.layers.concatenate().apply([dense1, dense2]);\n     * const output =\n     *     tf.layers.dense({units: 3, activation: 'softmax'}).apply(concat);\n     *\n     * const model = tf.model({inputs: [input1, input2], outputs: output});\n     * model.summary();\n     * ```\n     *\n     * @param lineLength Custom line length, in number of characters.\n     * @param positions Custom widths of each of the columns, as either\n     *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n     *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n     *   right-most (i.e., ending) position of a column.\n     * @param printFn Custom print function. Can be used to replace the default\n     *   `console.log`. For example, you can use `x => {}` to mute the printed\n     *   messages in the console.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    summary(lineLength, positions, printFn = console.log) {\n        if (!this.built) {\n            throw new ValueError(`This model has never been called, thus its weights have not been ` +\n                `created yet. So no summary can be displayed. Build the model ` +\n                `first (e.g., by calling it on some test data).`);\n        }\n        printSummary(this, lineLength, positions, printFn);\n    }\n    /**\n     * Configures and prepares the model for training and evaluation.  Compiling\n     * outfits the model with an optimizer, loss, and/or metrics.  Calling `fit`\n     * or `evaluate` on an un-compiled model will throw an error.\n     *\n     * @param args a `ModelCompileArgs` specifying the loss, optimizer, and\n     * metrics to be used for fitting and evaluating this model.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    compile(args) {\n        if (args.loss == null) {\n            args.loss = [];\n        }\n        this.loss = args.loss;\n        if (typeof args.optimizer === 'string') {\n            this.optimizer_ = optimizers.getOptimizer(args.optimizer);\n            this.isOptimizerOwned = true;\n        }\n        else {\n            if (!(args.optimizer instanceof Optimizer)) {\n                throw new ValueError(`User-defined optimizer must be an instance of tf.Optimizer.`);\n            }\n            this.optimizer_ = args.optimizer;\n            this.isOptimizerOwned = false;\n        }\n        // TODO(cais): Add lossWeights.\n        // TODO(cais): Add sampleWeightMode.\n        // Prepare loss functions.\n        let lossFunctions = [];\n        if (!Array.isArray(args.loss) && typeof args.loss !== 'string' &&\n            typeof args.loss !== 'function') {\n            args.loss = args.loss;\n            for (const name in args.loss) {\n                if (this.outputNames.indexOf(name) === -1) {\n                    throw new ValueError(`Unknown entry in loss dictionary: \"${name}\". ` +\n                        `Only expected the following keys: ${this.outputNames}`);\n                }\n            }\n            for (const name of this.outputNames) {\n                if (args.loss[name] == null) {\n                    console.warn(`Output \"${name}\" is missing from loss dictionary. We assume ` +\n                        `this was done on purpose, and we will not be expecting data ` +\n                        `to be passed to ${name} during training`);\n                }\n                lossFunctions.push(losses.get(args.loss[name]));\n            }\n        }\n        else if (Array.isArray(args.loss)) {\n            if (args.loss.length !== this.outputs.length) {\n                throw new ValueError(`When passing an Array as loss, it should have one entry per ` +\n                    `model output. The model has ${this.outputs.length} output(s), ` +\n                    `but you passed loss=${args.loss}.`);\n            }\n            const theLosses = args.loss;\n            lossFunctions = theLosses.map(l => losses.get(l));\n        }\n        else {\n            const lossFunction = losses.get(args.loss);\n            this.outputs.forEach(_ => {\n                lossFunctions.push(lossFunction);\n            });\n        }\n        this.lossFunctions = lossFunctions;\n        this.feedOutputNames = [];\n        this.feedOutputShapes = [];\n        this.feedLossFns = [];\n        for (let i = 0; i < this.outputs.length; ++i) {\n            // TODO(cais): Logic for skipping target(s).\n            const shape = this.internalOutputShapes[i];\n            const name = this.outputNames[i];\n            this.feedOutputNames.push(name);\n            this.feedOutputShapes.push(shape);\n            this.feedLossFns.push(this.lossFunctions[i]);\n        }\n        // TODO(cais): Add logic for output masks.\n        // TODO(cais): Add logic for sample weights.\n        const skipTargetIndices = [];\n        // Prepare metrics.\n        this.metrics = args.metrics;\n        // TODO(cais): Add weightedMetrics.\n        this.metricsNames = ['loss'];\n        this.metricsTensors = [];\n        // Compute total loss.\n        // Porting Note: In PyKeras, metrics_tensors are symbolic tensor objects.\n        //   Here, metricsTensors are TypeScript functions. This difference is due\n        //   to the difference in symbolic/imperative property of the backends.\n        nameScope('loss', () => {\n            for (let i = 0; i < this.outputs.length; ++i) {\n                if (skipTargetIndices.indexOf(i) !== -1) {\n                    continue;\n                }\n                // TODO(cais): Add weightedLoss, sampleWeight and mask.\n                //   The following line should be weightedLoss\n                const weightedLoss = this.lossFunctions[i];\n                if (this.outputs.length > 1) {\n                    this.metricsTensors.push([weightedLoss, i]);\n                    this.metricsNames.push(this.outputNames[i] + '_loss');\n                }\n            }\n            // Porting Note: Due to the imperative nature of the backend, we calculate\n            //   the regularizer penalties in the totalLossFunction, instead of here.\n        });\n        const nestedMetrics = collectMetrics(args.metrics, this.outputNames);\n        // TODO(cais): Add nestedWeightedMetrics.\n        /**\n         * Helper function used in loop below.\n         */\n        const appendMetric = (outputIndex, metricName, metricTensor) => {\n            if (this.outputNames.length > 1) {\n                metricName = this.outputNames[outputIndex] + '_' + metricName;\n            }\n            this.metricsNames.push(metricName);\n            this.metricsTensors.push([metricTensor, outputIndex]);\n        };\n        nameScope('metric', () => {\n            for (let i = 0; i < this.outputs.length; ++i) {\n                if (skipTargetIndices.indexOf(i) !== -1) {\n                    continue;\n                }\n                const outputMetrics = nestedMetrics[i];\n                // TODO(cais): Add weights and outputWeightedMetrics.\n                // TODO(cais): Add optional arg `weights` to the following function.\n                const handleMetrics = (metrics) => {\n                    const metricNamePrefix = '';\n                    let metricName;\n                    let accFn;\n                    let weightedMetricFn;\n                    //  TODO(cais): Use 'weights_' for weighted metrics.\n                    for (const metric of metrics) {\n                        if (typeof metric === 'string' &&\n                            ['accuracy', 'acc', 'crossentropy', 'ce'].indexOf(metric) !==\n                                -1) {\n                            const outputShape = this.internalOutputShapes[i];\n                            if (outputShape[outputShape.length - 1] === 1 ||\n                                this.lossFunctions[i] === losses.binaryCrossentropy) {\n                                // case: binary accuracy/crossentropy.\n                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {\n                                    accFn = Metrics.binaryAccuracy;\n                                }\n                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {\n                                    accFn = Metrics.binaryCrossentropy;\n                                }\n                            }\n                            else if (this.lossFunctions[i] ===\n                                losses.sparseCategoricalCrossentropy) {\n                                // case: categorical accuracy / crossentropy with sparse\n                                // targets.\n                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {\n                                    accFn = Metrics.sparseCategoricalAccuracy;\n                                }\n                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {\n                                    accFn = Metrics.sparseCategoricalCrossentropy;\n                                }\n                            }\n                            else {\n                                // case: categorical accuracy / crossentropy.\n                                if (['accuracy', 'acc'].indexOf(metric) !== -1) {\n                                    accFn = Metrics.categoricalAccuracy;\n                                }\n                                else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {\n                                    accFn = Metrics.categoricalCrossentropy;\n                                }\n                            }\n                            let suffix;\n                            if (['accuracy', 'acc'].indexOf(metric) !== -1) {\n                                suffix = 'acc';\n                            }\n                            else if (['crossentropy', 'ce'].indexOf(metric) !== -1) {\n                                suffix = 'ce';\n                            }\n                            // TODO(cais): Add weighting actually.\n                            weightedMetricFn = accFn;\n                            metricName = metricNamePrefix + suffix;\n                        }\n                        else {\n                            const metricFn = Metrics.get(metric);\n                            // TODO(cais): Add weighting actually.\n                            weightedMetricFn = metricFn;\n                            metricName =\n                                metricNamePrefix + Metrics.getLossOrMetricName(metric);\n                        }\n                        // TODO(cais): Add weighting and masking to metricResult.\n                        let metricResult;\n                        nameScope(metricName, () => {\n                            metricResult = weightedMetricFn;\n                        });\n                        appendMetric(i, metricName, metricResult);\n                    }\n                };\n                handleMetrics(outputMetrics);\n                // TODO(cais): Call handleMetrics with weights.\n            }\n        });\n        // Porting Notes: Given the imperative backend of tfjs-core,\n        //   there is no need for constructing the symbolic graph and placeholders.\n        this.collectedTrainableWeights = this.trainableWeights;\n    }\n    /**\n     * Check trainable weights count consistency.\n     *\n     * This will raise a warning if `this.trainableWeights` and\n     * `this.collectedTrainableWeights` are inconsistent (i.e., have different\n     * numbers of parameters).\n     * Inconsistency will typically arise when one modifies `model.trainable`\n     * without calling `model.compile()` again.\n     */\n    checkTrainableWeightsConsistency() {\n        if (this.collectedTrainableWeights == null) {\n            return;\n        }\n        if (this.trainableWeights.length !==\n            this.collectedTrainableWeights.length) {\n            console.warn('Discrepancy between trainableweights and collected trainable ' +\n                'weights. Did you set `model.trainable` without calling ' +\n                '`model.compile()` afterwards?');\n        }\n    }\n    /**\n     * Returns the loss value & metrics values for the model in test mode.\n     *\n     * Loss and metrics are specified during `compile()`, which needs to happen\n     * before calls to `evaluate()`.\n     *\n     * Computation is done in batches.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const result = model.evaluate(\n     *     tf.ones([8, 10]), tf.ones([8, 1]), {batchSize: 4});\n     * result.print();\n     * ```\n     *\n     * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple inputs.\n     * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple outputs.\n     * @param args A `ModelEvaluateArgs`, containing optional fields.\n     *\n     * @return `Scalar` test loss (if the model has a single output and no\n     *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n     *   and/or metrics). The attribute `model.metricsNames`\n     *   will give you the display labels for the scalar outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    evaluate(x, y, args = {}) {\n        const batchSize = args.batchSize == null ? 32 : args.batchSize;\n        checkBatchSize(batchSize);\n        // TODO(cais): Standardize `config.sampleWeights` as well.\n        // Validate user data.\n        const checkBatchAxis = true;\n        const standardizedOuts = this.standardizeUserDataXY(x, y, checkBatchAxis, batchSize);\n        try {\n            // TODO(cais): If uses `useLearningPhase`, set the corresponding element\n            // of the input to 0.\n            const ins = standardizedOuts[0].concat(standardizedOuts[1]);\n            this.makeTestFunction();\n            const f = this.testFunction;\n            const testOuts = this.testLoop(f, ins, batchSize, args.verbose, args.steps);\n            return singletonOrArray(testOuts);\n        }\n        finally {\n            disposeNewTensors(standardizedOuts[0], x);\n            disposeNewTensors(standardizedOuts[1], y);\n        }\n    }\n    // TODO(cais): Add code snippet below once real dataset objects are\n    //   available.\n    /**\n     * Evaluate model using a dataset object.\n     *\n     * Note: Unlike `evaluate()`, this method is asynchronous (`async`);\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected\n     *   to generate a dataset iterator object, the `next()` method of which\n     *   is expected to produce data batches for evaluation. The return value\n     *   of the `next()` call ought to contain a boolean `done` field and a\n     *   `value` field. The `value` field is expected to be an array of two\n     *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n     *   case is for models with exactly one input and one output (e.g..\n     *   a sequential model). The latter case is for models with multiple\n     *   inputs and/or multiple outputs. Of the two items in the array, the\n     *   first is the input feature(s) and the second is the output target(s).\n     * @param args A configuration object for the dataset-based evaluation.\n     * @returns Loss and metric values as an Array of `Scalar` objects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async evaluateDataset(dataset, args) {\n        this.makeTestFunction();\n        return evaluateDataset(this, dataset, args);\n    }\n    /**\n     * Get number of samples provided for training, evaluation or prediction.\n     *\n     * @param ins Input `tf.Tensor`.\n     * @param batchSize Integer batch size, optional.\n     * @param steps Total number of steps (batches of samples) before\n     * declaring loop finished. Optional.\n     * @param stepsName The public API's parameter name for `steps`.\n     * @returns Number of samples provided.\n     */\n    checkNumSamples(ins, batchSize, steps, stepsName = 'steps') {\n        let numSamples;\n        if (steps != null) {\n            numSamples = null;\n            if (batchSize != null) {\n                throw new ValueError(`If ${stepsName} is set, batchSize must be null or undefined.` +\n                    `Got batchSize = ${batchSize}`);\n            }\n        }\n        else if (ins != null) {\n            if (Array.isArray(ins)) {\n                numSamples = ins[0].shape[0];\n            }\n            else {\n                numSamples = ins.shape[0];\n            }\n        }\n        else {\n            throw new ValueError(`Either the input data should have a defined shape, or ` +\n                `${stepsName} shoud be specified.`);\n        }\n        return numSamples;\n    }\n    /**\n     * Execute internal tensors of the model with input data feed.\n     * @param inputs Input data feed. Must match the inputs of the model.\n     * @param outputs Names of the output tensors to be fetched. Must match\n     *   names of the SymbolicTensors that belong to the graph.\n     * @returns Fetched values for `outputs`.\n     */\n    execute(inputs, outputs) {\n        if (Array.isArray(outputs) && outputs.length === 0) {\n            throw new ValueError('`outputs` is an empty Array, which is not allowed.');\n        }\n        const outputsIsArray = Array.isArray(outputs);\n        const outputNames = (outputsIsArray ? outputs : [outputs]);\n        const outputSymbolicTensors = this.retrieveSymbolicTensors(outputNames);\n        // Format the input into a FeedDict.\n        const feedDict = new FeedDict();\n        if (inputs instanceof Tensor) {\n            inputs = [inputs];\n        }\n        if (Array.isArray(inputs)) {\n            if (inputs.length !== this.inputs.length) {\n                throw new ValueError(`The number of inputs provided (${inputs.length}) ` +\n                    `does not match the number of inputs of this model ` +\n                    `(${this.inputs.length}).`);\n            }\n            for (let i = 0; i < this.inputs.length; ++i) {\n                feedDict.add(this.inputs[i], inputs[i]);\n            }\n        }\n        else {\n            for (const input of this.inputs) {\n                const tensorValue = inputs[input.name];\n                if (tensorValue == null) {\n                    throw new ValueError(`No value is provided for the model's input ${input.name}`);\n                }\n                feedDict.add(input, tensorValue);\n            }\n        }\n        // Run execution.\n        const executeOutputs = execute(outputSymbolicTensors, feedDict);\n        return outputsIsArray ? executeOutputs : executeOutputs[0];\n    }\n    /**\n     * Retrieve the model's internal symbolic tensors from symbolic-tensor names.\n     */\n    retrieveSymbolicTensors(symbolicTensorNames) {\n        const outputSymbolicTensors = pyListRepeat(null, symbolicTensorNames.length);\n        let outputsRemaining = symbolicTensorNames.length;\n        for (const layer of this.layers) {\n            const layerOutputs = Array.isArray(layer.output) ? layer.output : [layer.output];\n            const layerOutputNames = layerOutputs.map(output => output.name);\n            for (let i = 0; i < symbolicTensorNames.length; ++i) {\n                const index = layerOutputNames.indexOf(symbolicTensorNames[i]);\n                if (index !== -1) {\n                    outputSymbolicTensors[i] = layerOutputs[index];\n                    outputsRemaining--;\n                }\n                if (outputsRemaining === 0) {\n                    break;\n                }\n            }\n            if (outputsRemaining === 0) {\n                break;\n            }\n        }\n        if (outputsRemaining > 0) {\n            const remainingNames = [];\n            outputSymbolicTensors.forEach((tensor, i) => {\n                if (tensor == null) {\n                    remainingNames.push(symbolicTensorNames[i]);\n                }\n            });\n            throw new ValueError(`Cannot find SymbolicTensors for output name(s): ` +\n                `${JSON.stringify(remainingNames)}`);\n        }\n        return outputSymbolicTensors;\n    }\n    /**\n     * Helper method to loop over some data in batches.\n     *\n     * Porting Note: Not using the functional approach in the Python equivalent\n     *   due to the imperative backend.\n     * Porting Note: Does not support step mode currently.\n     *\n     * @param ins: input data\n     * @param batchSize: integer batch size.\n     * @param verbose: verbosity model\n     * @returns: Predictions as `tf.Tensor` (if a single output) or an `Array` of\n     *   `tf.Tensor` (if multipe outputs).\n     */\n    predictLoop(ins, batchSize = 32, verbose = false) {\n        return tfc.tidy(() => {\n            const numSamples = this.checkNumSamples(ins);\n            if (verbose) {\n                throw new NotImplementedError('Verbose predictLoop() is not implemented yet.');\n            }\n            // Sample-based predictions.\n            // Porting Note: Tensor currently does not support sliced assignments as\n            //   in numpy, e.g., x[1:3] = y. Therefore we use concatenation while\n            //   iterating over the batches.\n            const batches = makeBatches(numSamples, batchSize);\n            const outsBatches = this.outputs.map(output => []);\n            // TODO(cais): Can the scope() be pushed down inside the for loop?\n            for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {\n                const batchOuts = tfc.tidy(() => {\n                    const batchStart = batches[batchIndex][0];\n                    const batchEnd = batches[batchIndex][1];\n                    // TODO(cais): Take care of the case of the last element is a flag for\n                    //   training/test.\n                    const insBatch = sliceArrays(ins, batchStart, batchEnd);\n                    // Construct the feeds for execute();\n                    const feeds = [];\n                    if (Array.isArray(insBatch)) {\n                        for (let i = 0; i < insBatch.length; ++i) {\n                            feeds.push({ key: this.inputs[i], value: insBatch[i] });\n                        }\n                    }\n                    else {\n                        feeds.push({ key: this.inputs[0], value: insBatch });\n                    }\n                    const feedDict = new FeedDict(feeds);\n                    return execute(this.outputs, feedDict);\n                });\n                batchOuts.forEach((batchOut, i) => outsBatches[i].push(batchOut));\n            }\n            return singletonOrArray(outsBatches.map(batches => tfc.concat(batches, 0)));\n        });\n    }\n    /**\n     * Generates output predictions for the input samples.\n     *\n     * Computation is done in batches.\n     *\n     * Note: the \"step\" mode of predict() is currently not supported.\n     *   This is because the TensorFlow.js core backend is imperative only.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.predict(tf.ones([8, 10]), {batchSize: 4}).print();\n     * ```\n     *\n     * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n     *   the model has multiple inputs.\n     * @param args A `ModelPredictArgs` object containing optional fields.\n     *\n     * @return Prediction results as a `tf.Tensor`(s).\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and the model's expectations, or in case a stateful model receives a\n     *   number of samples that is not a multiple of the batch size.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    predict(x, args = {}) {\n        const xsRank2OrHigher = ensureTensorsRank2OrHigher(x);\n        checkInputData(xsRank2OrHigher, this.inputNames, this.feedInputShapes, false);\n        try {\n            // TODO(cais): Take care of stateful models.\n            //   if (this.stateful) ...\n            // TODO(cais): Take care of the learning_phase boolean flag.\n            //   if (this.useLearningPhase) ...\n            const batchSize = args.batchSize == null ? 32 : args.batchSize;\n            checkBatchSize(batchSize);\n            return this.predictLoop(xsRank2OrHigher, batchSize);\n        }\n        finally {\n            disposeNewTensors(xsRank2OrHigher, x);\n        }\n    }\n    /**\n     * Returns predictions for a single batch of samples.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.predictOnBatch(tf.ones([8, 10])).print();\n     * ```\n     * @param x: Input samples, as a Tensor (for models with exactly one\n     *   input) or an array of Tensors (for models with more than one input).\n     * @return Tensor(s) of predictions\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    predictOnBatch(x) {\n        checkInputData(x, this.inputNames, this.feedInputShapes, true);\n        // TODO(cais): Take care of the learning_phase boolean flag.\n        //   if (this.useLearningPhase) ...\n        const batchSize = (Array.isArray(x) ? x[0] : x).shape[0];\n        return this.predictLoop(x, batchSize);\n    }\n    standardizeUserDataXY(x, y, checkBatchAxis = true, batchSize) {\n        // TODO(cais): Add sampleWeight, classWeight\n        if (this.optimizer_ == null) {\n            throw new RuntimeError('You must compile a model before training/testing. Use ' +\n                'LayersModel.compile(modelCompileArgs).');\n        }\n        const outputShapes = [];\n        for (let i = 0; i < this.feedOutputShapes.length; ++i) {\n            const outputShape = this.feedOutputShapes[i];\n            const lossFn = this.feedLossFns[i];\n            if (lossFn === losses.sparseCategoricalCrossentropy) {\n                outputShapes.push(outputShape.slice(0, outputShape.length - 1).concat([1]));\n            }\n            else {\n                // Porting Note: Because of strong typing `lossFn` must be a function.\n                outputShapes.push(outputShape);\n            }\n        }\n        x = standardizeInputData(x, this.feedInputNames, this.feedInputShapes, false, 'input');\n        y = standardizeInputData(y, this.feedOutputNames, outputShapes, false, 'target');\n        // TODO(cais): Standardize sampleWeights & classWeights.\n        checkArrayLengths(x, y, null);\n        // TODO(cais): Check sampleWeights as well.\n        checkLossAndTargetCompatibility(y, this.feedLossFns, this.feedOutputShapes);\n        if (this.stateful && batchSize != null && batchSize > 0) {\n            if (x[0].shape[0] % batchSize !== 0) {\n                throw new ValueError(`In a stateful network, you should only pass inputs with a ` +\n                    `number of samples that is divisible by the batch size ` +\n                    `${batchSize}. Found: ${x[0].shape[0]} sample(s).`);\n            }\n        }\n        return [x, y];\n    }\n    async standardizeUserData(x, y, sampleWeight, classWeight, checkBatchAxis = true, batchSize) {\n        const [standardXs, standardYs] = this.standardizeUserDataXY(x, y, checkBatchAxis, batchSize);\n        // TODO(cais): Handle sampleWeights.\n        if (sampleWeight != null) {\n            throw new Error('sample weight is not supported yet.');\n        }\n        let standardSampleWeights = null;\n        if (classWeight != null) {\n            const classWeights = standardizeClassWeights(classWeight, this.outputNames);\n            standardSampleWeights = [];\n            for (let i = 0; i < classWeights.length; ++i) {\n                standardSampleWeights.push(await standardizeWeights(standardYs[i], null, classWeights[i]));\n            }\n        }\n        // TODO(cais): Deal with the case of model.stateful == true.\n        return [standardXs, standardYs, standardSampleWeights];\n    }\n    /**\n     * Loop over some test data in batches.\n     * @param f A Function returning a list of tensors.\n     * @param ins Array of tensors to be fed to `f`.\n     * @param batchSize Integer batch size or `null` / `undefined`.\n     * @param verbose verbosity mode.\n     * @param steps Total number of steps (batches of samples) before\n     * declaring test finished. Ignored with the default value of `null` /\n     * `undefined`.\n     * @returns Array of Scalars.\n     */\n    testLoop(f, ins, batchSize, verbose = 0, steps) {\n        return tfc.tidy(() => {\n            const numSamples = this.checkNumSamples(ins, batchSize, steps, 'steps');\n            const outs = [];\n            if (verbose > 0) {\n                throw new NotImplementedError('Verbose mode is not implemented yet.');\n            }\n            // TODO(cais): Use `indicesForConversionToDense' to prevent slow down.\n            if (steps != null) {\n                throw new NotImplementedError('steps mode in testLoop() is not implemented yet');\n            }\n            else {\n                const batches = makeBatches(numSamples, batchSize);\n                const indexArray = tensor1d(range(0, numSamples));\n                for (let batchIndex = 0; batchIndex < batches.length; ++batchIndex) {\n                    const batchStart = batches[batchIndex][0];\n                    const batchEnd = batches[batchIndex][1];\n                    const batchIds = K.sliceAlongFirstAxis(indexArray, batchStart, batchEnd - batchStart);\n                    // TODO(cais): In ins, train flag can be a number, instead of an\n                    //   Tensor? Do we need to handle this in tfjs-layers?\n                    const insBatch = sliceArraysByIndices(ins, batchIds);\n                    const batchOuts = f(insBatch);\n                    if (batchIndex === 0) {\n                        for (let i = 0; i < batchOuts.length; ++i) {\n                            outs.push(scalar(0));\n                        }\n                    }\n                    for (let i = 0; i < batchOuts.length; ++i) {\n                        const batchOut = batchOuts[i];\n                        outs[i] =\n                            tfc.add(outs[i], tfc.mul(batchEnd - batchStart, batchOut));\n                    }\n                }\n                for (let i = 0; i < outs.length; ++i) {\n                    outs[i] = tfc.div(outs[i], numSamples);\n                }\n            }\n            return outs;\n        });\n    }\n    getDedupedMetricsNames() {\n        const outLabels = this.metricsNames;\n        // Rename duplicated metrics names (can happen with an output layer\n        // shared among multiple dataflows).\n        const dedupedOutLabels = [];\n        for (let i = 0; i < outLabels.length; ++i) {\n            const label = outLabels[i];\n            let newLabel = label;\n            if (count(outLabels, label) > 1) {\n                const dupIndex = count(outLabels.slice(0, i), label);\n                newLabel += `_${dupIndex}`;\n            }\n            dedupedOutLabels.push(newLabel);\n        }\n        return dedupedOutLabels;\n    }\n    /**\n     * Creates a function that performs the following actions:\n     *\n     * 1. computes the losses\n     * 2. sums them to get the total loss\n     * 3. call the optimizer computes the gradients of the LayersModel's\n     *    trainable weights w.r.t. the total loss and update the variables\n     * 4. calculates the metrics\n     * 5. returns the values of the losses and metrics.\n     */\n    makeTrainFunction() {\n        return (data) => {\n            const lossValues = [];\n            const inputs = data.slice(0, this.inputs.length);\n            const targets = data.slice(this.inputs.length, this.inputs.length + this.outputs.length);\n            const sampleWeights = data.slice(this.inputs.length + this.outputs.length, this.inputs.length + this.outputs.length * 2);\n            const metricsValues = [];\n            // Create a function that computes the total loss based on the\n            // inputs. This function is used for obtaining gradients through\n            // backprop.\n            const totalLossFunction = () => {\n                const feeds = [];\n                for (let i = 0; i < this.inputs.length; ++i) {\n                    feeds.push({ key: this.inputs[i], value: inputs[i] });\n                }\n                const feedDict = new FeedDict(feeds);\n                const outputs = execute(this.outputs, feedDict, { 'training': true });\n                // TODO(cais): Take care of the case of multiple outputs from a\n                //   single layer?\n                let totalLoss;\n                for (let i = 0; i < this.lossFunctions.length; ++i) {\n                    const lossFunction = this.lossFunctions[i];\n                    let loss = lossFunction(targets[i], outputs[i]);\n                    if (sampleWeights[i] != null) {\n                        loss = computeWeightedLoss(loss, sampleWeights[i]);\n                    }\n                    // TODO(cais): push Scalar instead.\n                    const meanLoss = tfc.mean(loss);\n                    // TODO(cais): Use a scope() instead, to avoid ownership.\n                    lossValues.push(meanLoss);\n                    if (i === 0) {\n                        totalLoss = loss;\n                    }\n                    else {\n                        totalLoss = tfc.add(totalLoss, loss);\n                    }\n                }\n                // Compute the metrics.\n                // TODO(cais): These should probably be calculated outside\n                //   totalLossFunction to benefit speed?\n                for (let i = 0; i < this.metricsTensors.length; ++i) {\n                    let weightedMetric;\n                    if (this.outputs.length > 1 && i < this.outputs.length) {\n                        weightedMetric = lossValues[i];\n                    }\n                    else {\n                        const metric = this.metricsTensors[i][0];\n                        const outputIndex = this.metricsTensors[i][1];\n                        weightedMetric =\n                            tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));\n                    }\n                    tfc.keep(weightedMetric);\n                    // TODO(cais): Use a scope() instead, to avoid ownership.\n                    metricsValues.push(weightedMetric);\n                }\n                totalLoss = tfc.mean(totalLoss);\n                // Add regularizer penalties.\n                this.calculateLosses().forEach(regularizerLoss => {\n                    totalLoss = tfc.add(totalLoss, regularizerLoss);\n                });\n                return totalLoss;\n            };\n            const variables = this.collectedTrainableWeights.map(param => param.read());\n            const returnCost = true;\n            const totalLossValue = this.optimizer_.minimize(totalLossFunction, returnCost, variables);\n            return [totalLossValue].concat(metricsValues);\n        };\n    }\n    /**\n     * Create a function which, when invoked with an array of `tf.Tensor`s as a\n     * batch of inputs, returns the prespecified loss and metrics of the model\n     * under the batch of input data.\n     */\n    makeTestFunction() {\n        this.testFunction = (data) => {\n            return tfc.tidy(() => {\n                const valOutputs = [];\n                let totalLoss;\n                const inputs = data.slice(0, this.inputs.length);\n                const targets = data.slice(this.inputs.length, this.inputs.length + this.outputs.length);\n                const feeds = [];\n                for (let i = 0; i < this.inputs.length; ++i) {\n                    feeds.push({ key: this.inputs[i], value: inputs[i] });\n                }\n                const feedDict = new FeedDict(feeds);\n                const outputs = execute(this.outputs, feedDict);\n                // Compute total loss.\n                for (let i = 0; i < this.lossFunctions.length; ++i) {\n                    const lossFunction = this.lossFunctions[i];\n                    // TODO(cais): Add sample weighting and replace the simple\n                    // averaging.\n                    const loss = tfc.mean(lossFunction(targets[i], outputs[i]));\n                    if (i === 0) {\n                        totalLoss = loss;\n                    }\n                    else {\n                        totalLoss = tfc.add(totalLoss, loss);\n                    }\n                    valOutputs.push(totalLoss);\n                }\n                // Compute the metrics.\n                for (let i = 0; i < this.metricsTensors.length; ++i) {\n                    const metric = this.metricsTensors[i][0];\n                    const outputIndex = this.metricsTensors[i][1];\n                    // TODO(cais): Replace K.mean() with a proper weighting function.\n                    const meanMetric = tfc.mean(metric(targets[outputIndex], outputs[outputIndex]));\n                    valOutputs.push(meanMetric);\n                }\n                return valOutputs;\n            });\n        };\n    }\n    /**\n     * Trains the model for a fixed number of epochs (iterations on a\n     * dataset).\n     *\n     * ```js\n     * const model = tf.sequential({\n     *     layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * for (let i = 1; i < 5 ; ++i) {\n     *   const h = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *       batchSize: 4,\n     *       epochs: 3\n     *   });\n     *   console.log(\"Loss after Epoch \" + i + \" : \" + h.history.loss[0]);\n     * }\n     * ```\n     *\n     * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n     * model has multiple inputs. If all inputs in the model are named, you\n     * can also pass a dictionary mapping input names to `tf.Tensor`s.\n     * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n     * the model has multiple outputs. If all outputs in the model are named,\n     * you can also pass a dictionary mapping output names to `tf.Tensor`s.\n     * @param args A `ModelFitArgs`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @exception ValueError In case of mismatch between the provided input\n     * data and what the model expects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async fit(x, y, args = {}) {\n        return fitTensors(this, x, y, args);\n    }\n    // TODO(cais): Add code snippet below when it's possible to instantiate\n    //   actual dataset objects.\n    /**\n     * Trains the model using a dataset object.\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected\n     *   to generate a dataset iterator object, the `next()` method of which\n     *   is expected to produce data batches for training. The return value\n     *   of the `next()` call ought to contain a boolean `done` field and a\n     *   `value` field. The `value` field is expected to be an array of two\n     *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n     *   case is for models with exactly one input and one output (e.g..\n     *   a sequential model). The latter case is for models with multiple\n     *   inputs and/or multiple outputs.\n     *   Of the two items in the array, the first is the input feature(s) and\n     *   the second is the output target(s).\n     * @param args A `ModelFitDatasetArgs`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async fitDataset(dataset, args) {\n        return fitDataset(this, dataset, args);\n    }\n    /**\n     * Runs a single gradient update on a single batch of data.\n     *\n     * This method differs from `fit()` and `fitDataset()` in the following\n     * regards:\n     *   - It operates on exactly one batch of data.\n     *   - It returns only the loss and matric values, instead of\n     *     returning the batch-by-batch loss and metric values.\n     *   - It doesn't support fine-grained options such as verbosity and\n     *     callbacks.\n     *\n     * @param x Input data. It could be one of the following:\n     *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n     *     multiple inputs).\n     *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n     *     model has named inputs).\n     * @param y Target darta. It could be either a `tf.Tensor` a multiple\n     *   `tf.Tensor`s. It should be consistent with `x`.\n     * @returns Training loss or losses (in case the model has\n     *   multiple outputs), along with metrics (if any), as numbers.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async trainOnBatch(x, y) {\n        // TODO(cais): Support sampleWeight and classWeight.\n        // TODO(cais): Support Dataset objects.\n        const standardizeOut = await this.standardizeUserData(x, y);\n        const inputs = standardizeOut[0];\n        const targets = standardizeOut[1];\n        const trainFunction = this.makeTrainFunction();\n        const losses = trainFunction(inputs.concat(targets));\n        const lossValues = [];\n        for (const loss of losses) {\n            const v = await loss.data();\n            lossValues.push(v[0]);\n        }\n        tfc.dispose(losses);\n        disposeNewTensors(standardizeOut[0], x);\n        disposeNewTensors(standardizeOut[1], y);\n        return singletonOrArray(lossValues);\n    }\n    /**\n     * Extract weight values of the model.\n     *\n     * @param config: An instance of `io.SaveConfig`, which specifies\n     * model-saving options such as whether only trainable weights are to be\n     * saved.\n     * @returns A `NamedTensorMap` mapping original weight names (i.e.,\n     *   non-uniqueified weight names) to their values.\n     */\n    getNamedWeights(config) {\n        const namedWeights = [];\n        const trainableOnly = config != null && config.trainableOnly;\n        const weights = trainableOnly ? this.trainableWeights : this.weights;\n        const weightValues = this.getWeights(trainableOnly);\n        for (let i = 0; i < weights.length; ++i) {\n            if (trainableOnly && !weights[i].trainable) {\n                // Optionally skip non-trainable weights.\n                continue;\n            }\n            namedWeights.push({ name: weights[i].originalName, tensor: weightValues[i] });\n        }\n        return namedWeights;\n    }\n    /**\n     * Setter used for force stopping of LayersModel.fit() (i.e., training).\n     *\n     * Example:\n     *\n     * ```js\n     * const input = tf.input({shape: [10]});\n     * const output = tf.layers.dense({units: 1}).apply(input);\n     * const model = tf.model({inputs: [input], outputs: [output]});\n     * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n     * const xs = tf.ones([8, 10]);\n     * const ys = tf.zeros([8, 1]);\n     *\n     * const history = await model.fit(xs, ys, {\n     *   epochs: 10,\n     *   callbacks: {\n     *     onEpochEnd: async (epoch, logs) => {\n     *       if (epoch === 2) {\n     *         model.stopTraining = true;\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * // There should be only 3 values in the loss array, instead of 10\n     * values,\n     * // due to the stopping after 3 epochs.\n     * console.log(history.history.loss);\n     * ```\n     */\n    set stopTraining(stop) {\n        this.stopTraining_ = stop;\n    }\n    get stopTraining() {\n        return this.stopTraining_;\n    }\n    get optimizer() {\n        return this.optimizer_;\n    }\n    set optimizer(optimizer) {\n        if (this.optimizer_ !== optimizer) {\n            this.optimizer_ = optimizer;\n            this.isOptimizerOwned = false;\n        }\n    }\n    dispose() {\n        const result = super.dispose();\n        if (result.refCountAfterDispose === 0 && this.optimizer != null &&\n            this.isOptimizerOwned) {\n            const numTensorsBeforeOptmizerDisposal = tfc.memory().numTensors;\n            this.optimizer_.dispose();\n            result.numDisposedVariables +=\n                numTensorsBeforeOptmizerDisposal - tfc.memory().numTensors;\n        }\n        return result;\n    }\n    getLossIdentifiers() {\n        let lossNames;\n        if (typeof this.loss === 'string') {\n            lossNames = toSnakeCase(this.loss);\n        }\n        else if (Array.isArray(this.loss)) {\n            for (const loss of this.loss) {\n                if (typeof loss !== 'string') {\n                    throw new Error('Serialization of non-string loss is not supported.');\n                }\n            }\n            lossNames = this.loss.map(name => toSnakeCase(name));\n        }\n        else {\n            const outputNames = Object.keys(this.loss);\n            lossNames = {};\n            const losses = this.loss;\n            for (const outputName of outputNames) {\n                if (typeof losses[outputName] === 'string') {\n                    lossNames[outputName] =\n                        toSnakeCase(losses[outputName]);\n                }\n                else {\n                    throw new Error('Serialization of non-string loss is not supported.');\n                }\n            }\n        }\n        return lossNames;\n    }\n    getMetricIdentifiers() {\n        if (typeof this.metrics === 'string' ||\n            typeof this.metrics === 'function') {\n            return [toSnakeCase(Metrics.getLossOrMetricName(this.metrics))];\n        }\n        else if (Array.isArray(this.metrics)) {\n            return this.metrics.map(metric => toSnakeCase(Metrics.getLossOrMetricName(metric)));\n        }\n        else {\n            const metricsIdentifiers = {};\n            for (const key in this.metrics) {\n                metricsIdentifiers[key] =\n                    toSnakeCase(Metrics.getLossOrMetricName(this.metrics[key]));\n            }\n            return metricsIdentifiers;\n        }\n    }\n    getTrainingConfig() {\n        return {\n            loss: this.getLossIdentifiers(),\n            metrics: this.getMetricIdentifiers(),\n            optimizer_config: {\n                class_name: this.optimizer.getClassName(),\n                config: this.optimizer.getConfig()\n            }\n        };\n        // TODO(cais): Add weight_metrics when they are supported.\n        // TODO(cais): Add sample_weight_mode when it's supported.\n        // TODO(cais): Add loss_weights when it's supported.\n    }\n    loadTrainingConfig(trainingConfig) {\n        if (trainingConfig.weighted_metrics != null) {\n            throw new Error('Loading weight_metrics is not supported yet.');\n        }\n        if (trainingConfig.loss_weights != null) {\n            throw new Error('Loading loss_weights is not supported yet.');\n        }\n        if (trainingConfig.sample_weight_mode != null) {\n            throw new Error('Loading sample_weight_mode is not supported yet.');\n        }\n        const tsConfig = convertPythonicToTs(trainingConfig.optimizer_config);\n        const optimizer = deserialize(tsConfig);\n        let loss;\n        if (typeof trainingConfig.loss === 'string') {\n            loss = toCamelCase(trainingConfig.loss);\n        }\n        else if (Array.isArray(trainingConfig.loss)) {\n            loss = trainingConfig.loss.map(lossEntry => toCamelCase(lossEntry));\n        }\n        else if (trainingConfig.loss != null) {\n            loss = {};\n            for (const key in trainingConfig.loss) {\n                loss[key] = toCamelCase(trainingConfig.loss[key]);\n            }\n        }\n        let metrics;\n        if (Array.isArray(trainingConfig.metrics)) {\n            metrics = trainingConfig.metrics.map(metric => toCamelCase(metric));\n        }\n        else if (trainingConfig.metrics != null) {\n            metrics = {};\n            for (const key in trainingConfig.metrics) {\n                metrics[key] = toCamelCase(trainingConfig.metrics[key]);\n            }\n        }\n        this.compile({ loss, metrics, optimizer });\n    }\n    /**\n     * Save the configuration and/or weights of the LayersModel.\n     *\n     * An `IOHandler` is an object that has a `save` method of the proper\n     * signature defined. The `save` method manages the storing or\n     * transmission of serialized data (\"artifacts\") that represent the\n     * model's topology and weights onto or via a specific medium, such as\n     * file downloads, local storage, IndexedDB in the web browser and HTTP\n     * requests to a server. TensorFlow.js provides `IOHandler`\n     * implementations for a number of frequently used saving mediums, such as\n     * `tf.io.browserDownloads` and `tf.io.browserLocalStorage`. See `tf.io`\n     * for more details.\n     *\n     * This method also allows you to refer to certain types of `IOHandler`s\n     * as URL-like string shortcuts, such as 'localstorage://' and\n     * 'indexeddb://'.\n     *\n     * Example 1: Save `model`'s topology and weights to browser [local\n     * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n     * then load it back.\n     *\n     * ```js\n     * const model = tf.sequential(\n     *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n     * console.log('Prediction from original model:');\n     * model.predict(tf.ones([1, 3])).print();\n     *\n     * const saveResults = await model.save('localstorage://my-model-1');\n     *\n     * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n     * console.log('Prediction from loaded model:');\n     * loadedModel.predict(tf.ones([1, 3])).print();\n     * ```\n     *\n     * Example 2. Saving `model`'s topology and weights to browser\n     * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n     * then load it back.\n     *\n     * ```js\n     * const model = tf.sequential(\n     *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n     * console.log('Prediction from original model:');\n     * model.predict(tf.ones([1, 3])).print();\n     *\n     * const saveResults = await model.save('indexeddb://my-model-1');\n     *\n     * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n     * console.log('Prediction from loaded model:');\n     * loadedModel.predict(tf.ones([1, 3])).print();\n     * ```\n     *\n     * Example 3. Saving `model`'s topology and weights as two files\n     * (`my-model-1.json` and `my-model-1.weights.bin`) downloaded from\n     * browser.\n     *\n     * ```js\n     * const model = tf.sequential(\n     *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n     * const saveResults = await model.save('downloads://my-model-1');\n     * ```\n     *\n     * Example 4. Send  `model`'s topology and weights to an HTTP server.\n     * See the documentation of `tf.io.http` for more details\n     * including specifying request parameters and implementation of the\n     * server.\n     *\n     * ```js\n     * const model = tf.sequential(\n     *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n     * const saveResults = await model.save('http://my-server/model/upload');\n     * ```\n     *\n     * @param handlerOrURL An instance of `IOHandler` or a URL-like,\n     * scheme-based string shortcut for `IOHandler`.\n     * @param config Options for saving the model.\n     * @returns A `Promise` of `SaveResult`, which summarizes the result of\n     * the saving, such as byte sizes of the saved artifacts for the model's\n     *   topology and weight values.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n    async save(handlerOrURL, config) {\n        if (typeof handlerOrURL === 'string') {\n            const handlers = io.getSaveHandlers(handlerOrURL);\n            if (handlers.length === 0) {\n                throw new ValueError(`Cannot find any save handlers for URL '${handlerOrURL}'`);\n            }\n            else if (handlers.length > 1) {\n                throw new ValueError(`Found more than one (${handlers.length}) save handlers for ` +\n                    `URL '${handlerOrURL}'`);\n            }\n            handlerOrURL = handlers[0];\n        }\n        if (handlerOrURL.save == null) {\n            throw new ValueError('LayersModel.save() cannot proceed because the IOHandler ' +\n                'provided does not have the `save` attribute defined.');\n        }\n        const weightDataAndSpecs = await io.encodeWeights(this.getNamedWeights(config));\n        const returnString = false;\n        const unusedArg = null;\n        const modelConfig = this.toJSON(unusedArg, returnString);\n        const modelArtifacts = {\n            modelTopology: modelConfig,\n            format: LAYERS_MODEL_FORMAT_NAME,\n            generatedBy: `TensorFlow.js tfjs-layers v${version}`,\n            convertedBy: null,\n        };\n        const includeOptimizer = config == null ? false : config.includeOptimizer;\n        if (includeOptimizer && this.optimizer != null) {\n            modelArtifacts.trainingConfig = this.getTrainingConfig();\n            const weightType = 'optimizer';\n            const { data: optimizerWeightData, specs: optimizerWeightSpecs } = await io.encodeWeights(await this.optimizer.getWeights(), weightType);\n            weightDataAndSpecs.specs.push(...optimizerWeightSpecs);\n            weightDataAndSpecs.data = io.concatenateArrayBuffers([weightDataAndSpecs.data, optimizerWeightData]);\n        }\n        if (this.userDefinedMetadata != null) {\n            // Check serialized size of user-defined metadata.\n            const checkSize = true;\n            checkUserDefinedMetadata(this.userDefinedMetadata, this.name, checkSize);\n            modelArtifacts.userDefinedMetadata = this.userDefinedMetadata;\n        }\n        modelArtifacts.weightData = weightDataAndSpecs.data;\n        modelArtifacts.weightSpecs = weightDataAndSpecs.specs;\n        return handlerOrURL.save(modelArtifacts);\n    }\n    /**\n     * Set user-defined metadata.\n     *\n     * The set metadata will be serialized together with the topology\n     * and weights of the model during `save()` calls.\n     *\n     * @param setUserDefinedMetadata\n     */\n    setUserDefinedMetadata(userDefinedMetadata) {\n        checkUserDefinedMetadata(userDefinedMetadata, this.name);\n        this.userDefinedMetadata = userDefinedMetadata;\n    }\n    /**\n     * Get user-defined metadata.\n     *\n     * The metadata is supplied via one of the two routes:\n     *   1. By calling `setUserDefinedMetadata()`.\n     *   2. Loaded during model loading (if the model is constructed\n     *      via `tf.loadLayersModel()`.)\n     *\n     * If no user-defined metadata is available from either of the\n     * two routes, this function will return `undefined`.\n     */\n    getUserDefinedMetadata() {\n        return this.userDefinedMetadata;\n    }\n}\n// The class name is 'Model' rather than 'LayersModel' for backwards\n// compatibility since this class name shows up in the serialization format.\n/** @nocollapse */\nLayersModel.className = 'Model';\nserialization.registerClass(LayersModel);\n/**\n * A `tf.Functional` is an alias to `tf.LayersModel`.\n *\n * See also:\n *   `tf.LayersModel`, `tf.Sequential`, `tf.loadLayersModel`.\n */\n/** @doc {heading: 'Models', subheading: 'Classes'} */\nexport class Functional extends LayersModel {\n}\nFunctional.className = 'Functional';\nserialization.registerClass(Functional);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJhaW5pbmcuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvZW5naW5lL3RyYWluaW5nLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgseUNBQXlDO0FBRXpDLE9BQU8sS0FBSyxHQUFHLE1BQU0sdUJBQXVCLENBQUM7QUFDN0MsT0FBTyxFQUFDLEVBQUUsRUFBMEQsU0FBUyxFQUFVLE1BQU0sRUFBRSxhQUFhLEVBQUUsTUFBTSxFQUFZLFFBQVEsRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUU3SyxPQUFPLEtBQUssQ0FBQyxNQUFNLHlCQUF5QixDQUFDO0FBRTdDLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDcEMsT0FBTyxFQUFDLG1CQUFtQixFQUFFLFlBQVksRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFLeEUsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBQ3BELE9BQU8sS0FBSyxNQUFNLE1BQU0sV0FBVyxDQUFDO0FBQ3BDLE9BQU8sS0FBSyxPQUFPLE1BQU0sWUFBWSxDQUFDO0FBQ3RDLE9BQU8sS0FBSyxVQUFVLE1BQU0sZUFBZSxDQUFDO0FBRTVDLE9BQU8sRUFBQyx3QkFBd0IsRUFBQyxNQUFNLDBCQUEwQixDQUFDO0FBQ2xFLE9BQU8sRUFBQyxLQUFLLEVBQUUsWUFBWSxFQUFFLGdCQUFnQixFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsTUFBTSxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDL0csT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBQ2xELE9BQU8sRUFBQyxLQUFLLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUMxQyxPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSw4QkFBOEIsQ0FBQztBQUVqRSxPQUFPLEVBQUMsT0FBTyxFQUFD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bUIsR0FBRyxJQUFJLENBQUMsbUJBQW1CLENBQUM7U0FDL0Q7UUFFRCxjQUFjLENBQUMsVUFBVSxHQUFHLGtCQUFrQixDQUFDLElBQUksQ0FBQztRQUNwRCxjQUFjLENBQUMsV0FBVyxHQUFHLGtCQUFrQixDQUFDLEtBQUssQ0FBQztRQUN0RCxPQUFPLFlBQVksQ0FBQyxJQUFJLENBQUMsY0FBYyxDQUFDLENBQUM7SUFDM0MsQ0FBQztJQUVEOzs7Ozs7O09BT0c7SUFDSCxzQkFBc0IsQ0FBQyxtQkFBdUI7UUFDNUMsd0JBQXdCLENBQUMsbUJBQW1CLEVBQUUsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ3pELElBQUksQ0FBQyxtQkFBbUIsR0FBRyxtQkFBbUIsQ0FBQztJQUNqRCxDQUFDO0lBRUQ7Ozs7Ozs7Ozs7T0FVRztJQUNILHNCQUFzQjtRQUNwQixPQUFPLElBQUksQ0FBQyxtQkFBbUIsQ0FBQztJQUNsQyxDQUFDOztBQTc0Q0Qsb0VBQW9FO0FBQ3BFLDRFQUE0RTtBQUM1RSxrQkFBa0I7QUFDWCxxQkFBUyxHQUFHLE9BQU8sQ0FBQztBQTQ0QzdCLGFBQWEsQ0FBQyxhQUFhLENBQUMsV0FBVyxDQUFDLENBQUM7QUFFekM7Ozs7O0dBS0c7QUFDSCxzREFBc0Q7QUFDdEQsTUFBTSxPQUFPLFVBQVcsU0FBUSxXQUFXOztBQUNsQyxvQkFBUyxHQUFHLFlBQVksQ0FBQztBQUVsQyxhQUFhLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyogT3JpZ2luYWwgU291cmNlOiBlbmdpbmUvdHJhaW5pbmcucHkgKi9cblxuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge2lvLCBNb2RlbFByZWRpY3RDb25maWcgYXMgTW9kZWxQcmVkaWN0QXJncywgTmFtZWRUZW5zb3JNYXAsIE9wdGltaXplciwgU2NhbGFyLCBzY2FsYXIsIHNlcmlhbGl6YXRpb24sIFRlbnNvciwgVGVuc29yMUQsIHRlbnNvcjFkLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQgKiBhcyBLIGZyb20gJy4uL2JhY2tlbmQvdGZqc19iYWNrZW5kJztcbmltcG9ydCB7SGlzdG9yeSwgTW9kZWxMb2dnaW5nVmVyYm9zaXR5fSBmcm9tICcuLi9iYXNlX2NhbGxiYWNrcyc7XG5pbXBvcnQge25hbWVTY29wZX0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7Tm90SW1wbGVtZW50ZWRFcnJvciwgUnVudGltZUVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge0xvc3NJZGVudGlmaWVyfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvbG9zc19jb25maWcnO1xuaW1wb3J0IHtPcHRpbWl6ZXJTZXJpYWxpemF0aW9ufSBmcm9tICcuLi9rZXJhc19mb3JtYXQvb3B0aW1pemVyX2NvbmZpZyc7XG5pbXBvcnQge01ldHJpY3NJZGVudGlmaWVyLCBUcmFpbmluZ0NvbmZpZ30gZnJvbSAnLi4va2VyYXNfZm9ybWF0L3RyYWluaW5nX2NvbmZpZyc7XG5pbXBvcnQge2Rlc2VyaWFsaXplfSBmcm9tICcuLi9sYXllcnMvc2VyaWFsaXphdGlvbic7XG5pbXBvcnQgKiBhcyBsb3NzZXMgZnJvbSAnLi4vbG9zc2VzJztcbmltcG9ydCAqIGFzIE1ldHJpY3MgZnJvbSAnLi4vbWV0cmljcyc7XG5pbXBvcnQgKiBhcyBvcHRpbWl6ZXJzIGZyb20gJy4uL29wdGltaXplcnMnO1xuaW1wb3J0IHtMb3NzT3JNZXRyaWNGbiwgTmFtZWRUZW5zb3J9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Y2hlY2tVc2VyRGVmaW5lZE1ldGFkYXRhfSBmcm9tICcuLi91c2VyX2RlZmluZWRfbWV0YWRhdGEnO1xuaW1wb3J0IHtjb3VudCwgcHlMaXN0UmVwZWF0LCBzaW5nbGV0b25PckFycmF5LCB0b0NhbWVsQ2FzZSwgdG9TbmFrZUNhc2UsIHVuaXF1ZX0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQge3ByaW50U3VtbWFyeX0gZnJvbSAnLi4vdXRpbHMvbGF5ZXJfdXRpbHMnO1xuaW1wb3J0IHtyYW5nZX0gZnJvbSAnLi4vdXRpbHMvbWF0aF91dGlscyc7XG5pbXBvcnQge2NvbnZlcnRQeXRob25pY1RvVHN9IGZyb20gJy4uL3V0aWxzL3NlcmlhbGl6YXRpb25fdXRpbHMnO1xuaW1wb3J0IHtMYXllclZhcmlhYmxlfSBmcm9tICcuLi92YXJpYWJsZXMnO1xuaW1wb3J0IHt2ZXJzaW9ufSBmcm9tICcuLi92ZXJzaW9uJztcblxuaW1wb3J0IHtDb250YWluZXIsIENvbnRhaW5lckFyZ3N9IGZyb20gJy4vY29udGFpbmVyJztcbmltcG9ydCB7RGF0YXNldH0gZnJvbSAnLi9kYXRhc2V0X3N0dWInO1xuaW1wb3J0IHtleGVjdXRlLCBGZWVkRGljdH0gZnJvbSAnLi9leGVjdXRvcic7XG5pbXBvcnQge0Rpc3Bvc2VSZXN1bHQsIFN5bWJvbGljVGVuc29yfSBmcm9tICcuL3RvcG9sb2d5JztcbmltcG9ydCB7ZXZhbHVhdGVEYXRhc2V0LCBmaXREYXRhc2V0LCBNb2RlbEV2YWx1YXRlRGF0YXNldEFyZ3MsIE1vZGVsRml0RGF0YXNldEFyZ3N9IGZyb20gJy4vdHJhaW5pbmdfZGF0YXNldCc7XG5pbXBvcnQge2NoZWNrQmF0Y2hTaXplLCBkaXNwb3NlTmV3VGVuc29ycywgZW5zdXJlVGVuc29yc1JhbmsyT3JIaWdoZXIsIGZpdFRlbnNvcnMsIG1ha2VCYXRjaGVzLCBNb2RlbEZpdEFyZ3MsIHNsaWNlQXJyYXlzLCBzbGljZUFycmF5c0J5SW5kaWNlc30gZnJvbSAnLi90cmFpbmluZ190ZW5zb3JzJztcbmltcG9ydCB7Q2xhc3NXZWlnaHQsIENsYXNzV2VpZ2h0TWFwLCBjb21wdXRlV2VpZ2h0ZWRMb3NzLCBzdGFuZGFyZGl6ZUNsYXNzV2VpZ2h0cywgc3RhbmRhcmRpemVXZWlnaHRzfSBmcm9tICcuL3RyYWluaW5nX3V0aWxzJztcblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gZm9yIHBvbHltb3JwaGljIGlucHV0IGRhdGE6IDEuIHNpbmdsZXRvbiBUZW5zb3IuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBpc0RhdGFUZW5zb3IoeDogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7W2lucHV0TmFtZTogc3RyaW5nXTogVGVuc29yW119KTogYm9vbGVhbiB7XG4gIHJldHVybiB4IGluc3RhbmNlb2YgVGVuc29yO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcG9seW1vcnBoaWMgaW5wdXQgZGF0YTogMi4gQXJyYXkgb2YgVGVuc29yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRhQXJyYXkoeDogVGVuc29yfFRlbnNvcltdfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9KTogYm9vbGVhbiB7XG4gIHJldHVybiBBcnJheS5pc0FycmF5KHgpO1xufVxuXG4vKipcbiAqIEhlbHBlciBmdW5jdGlvbiBmb3IgcG9seW1vcnBoaWMgaW5wdXQgZGF0YTogMy4gXCJkaWN0XCIgb2YgVGVuc29yLlxuICovXG5leHBvcnQgZnVuY3Rpb24gaXNEYXRhRGljdCh4OiBUZW5zb3J8VGVuc29yW118XG4gICAgICAgICAgICAgICAgICAgICAgICAgICB7W2lucHV0TmFtZTogc3RyaW5nXTogVGVuc29yfSk6IGJvb2xlYW4ge1xuICByZXR1cm4gIWlzRGF0YVRlbnNvcih4KSAmJiAhaXNEYXRhQXJyYXkoeCk7XG59XG5cbi8qKlxuICogTm9ybWFsaXplcyBpbnB1dHMgYW5kIHRhcmdldHMgcHJvdmlkZWQgYnkgdXNlcnMuXG4gKiBAcGFyYW0gZGF0YSBVc2VyLXByb3ZpZGVkIGlucHV0IGRhdGEgKHBvbHltb3JwaGljKS5cbiAqIEBwYXJhbSBuYW1lcyBBbiBBcnJheSBvZiBleHBlY3RlZCBUZW5zb3IgbmFtZXMuXG4gKiBAcGFyYW0gc2hhcGVzIE9wdGlvbmFsIEFycmF5IG9mIGV4cGVjdGVkIFRlbnNvciBzaGFwZXMuXG4gKiBAcGFyYW0gY2hlY2tCYXRjaEF4aXMgV2hldGhlciB0byBjaGVjayB0aGF0IHRoZSBiYXRjaCBheGlzIG9mIHRoZSBhcnJheXNcbiAqICAgbWF0Y2ggIHRoZSBleHBlY3RlZCB2YWx1ZSBmb3VuZCBpbiBgc2hhcGVzYC5cbiAqIEBwYXJhbSBleGNlcHRpb25QcmVmaXggU3RyaW5nIHByZWZpeCB1c2VkIGZvciBleGNlcHRpb24gZm9ybWF0dGluZy5cbiAqIEByZXR1cm5zIExpc3Qgb2Ygc3RhbmRhcmRpemVkIGlucHV0IFRlbnNvcnMgKG9uZSBUZW5zb3IgcGVyIG1vZGVsIGlucHV0KS5cbiAqIEB0aHJvd3MgVmFsdWVFcnJvcjogaW4gY2FzZSBvZiBpbXByb3Blcmx5IGZvcm1hdHRlZCB1c2VyIGRhdGEuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFuZGFyZGl6ZUlucHV0RGF0YShcbiAgICBkYXRhOiBUZW5zb3J8VGVuc29yW118e1tpbnB1dE5hbWU6IHN0cmluZ106IFRlbnNvcn0sIG5hbWVzOiBzdHJpbmdbXSxcbiAgICBzaGFwZXM/OiBTaGFwZVtdLCBjaGVja0JhdGNoQXhpcyA9IHRydWUsIGV4Y2VwdGlvblByZWZpeCA9ICcnKTogVGVuc29yW10ge1xuICBpZiAobmFtZXMgPT0gbnVsbCB8fCBuYW1lcy5sZW5ndGggPT09IDApIHtcbiAgICAvLyBDaGVjayBmb3IgdGhlIGNhc2Ugd2hlcmUgdGhlIG1vZGVsIGV4cGVjdGVkIG5vIGRhdGEsIGJ1dCBzb21lIGRhdGEgZ290XG4gICAgLy8gc2VudC5cbiAgICBpZiAoZGF0YSAhPSBudWxsKSB7XG4gICAgICBsZXQgZ290VW5leHBlY3RlZERhdGEgPSBmYWxzZTtcbiAgICAgIGlmIChpc0RhdGFBcnJheShkYXRhKSAmJiAoZGF0YSBhcyBUZW5zb3JbXSkubGVuZ3RoID4gMCkge1xuICAgICAgICBnb3RVbmV4cGVjdGVkRGF0YSA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGlzRGF0YURpY3QoZGF0YSkpIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgIGdvdFVuZXhwZWN0ZWREYXRhID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gYGRhdGFgIGlzIGEgc2luZ2xldG9uIFRlbnNvciBpbiB0aGlzIGNhc2UuXG4gICAgICAgIGdvdFVuZXhwZWN0ZWREYXRhID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChnb3RVbmV4cGVjdGVkRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBFcnJvciB3aGVuIGNoZWNraW5nIG1vZGVsICR7ZXhjZXB0aW9uUHJlZml4fSBleHBlY3RlZCBubyBkYXRhLCBgICtcbiAgICAgICAgICAgIGBidXQgZ290ICR7ZGF0YX1gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChkYXRhID09IG51bGwpIHtcbiAgICByZXR1cm4gbmFtZXMubWFwKG5hbWUgPT4gbnVsbCk7XG4gIH1cblxuICBsZXQgYXJyYXlzOiBUZW5zb3JbXTtcbiAgaWYgKGlzRGF0YURpY3QoZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YSBhcyB7W2lucHV0TmFtZTogc3RyaW5nXTogVGVuc29yfTtcbiAgICBhcnJheXMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICAgIGlmIChkYXRhW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgTm8gZGF0YSBwcm92aWRlZCBmb3IgXCIke25hbWV9XCIuIE5lZWQgZGF0YSBmb3IgZWFjaCBrZXkgaW46IGAgK1xuICAgICAgICAgICAgYCR7bmFtZXN9YCk7XG4gICAgICB9XG4gICAgICBhcnJheXMucHVzaChkYXRhW25hbWVdKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNEYXRhQXJyYXkoZGF0YSkpIHtcbiAgICBkYXRhID0gZGF0YSBhcyBUZW5zb3JbXTtcbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IG5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYEVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgJHtleGNlcHRpb25QcmVmaXh9OiB0aGUgQXJyYXkgb2YgYCArXG4gICAgICAgICAgYFRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIGAgK1xuICAgICAgICAgIGBtb2RlbCBleHBlY3RlZC4gRXhwZWN0ZWQgdG8gc2VlICR7bmFtZXMubGVuZ3RofSBUZW5zb3IocyksIGJ1dCBgICtcbiAgICAgICAgICBgaW5zdGVhZCBnb3QgdGhlIGZvbGxvd2luZyBsaXN0IG9mIFRlbnNvcihzKTogJHtkYXRhfWApO1xuICAgIH1cbiAgICBhcnJheXMgPSBkYXRhO1xuICB9IGVsc2Uge1xuICAgIGRhdGEgPSBkYXRhIGFzIFRlbnNvcjtcbiAgICBpZiAobmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYFRoZSBtb2RlbCAke2V4Y2VwdGlvblByZWZpeH0gZXhwZWN0cyAke25hbWVzLmxlbmd0aH0gVGVuc29yKHMpLCBgICtcbiAgICAgICAgICBgYnV0IG9ubHkgcmVjZWl2ZWQgb25lIFRlbnNvci4gRm91bmQ6IFRlbnNvciB3aXRoIHNoYXBlICR7XG4gICAgICAgICAgICAgIGRhdGEuc2hhcGV9YCk7XG4gICAgfVxuICAgIGFycmF5cyA9IFtkYXRhXTtcbiAgfVxuXG4gIGFycmF5cyA9IGVuc3VyZVRlbnNvcnNSYW5rMk9ySGlnaGVyKGFycmF5cyk7XG5cbiAgLy8gQ2hlY2sgc2hhcGUgY29tcGF0aWJpbGl0eS5cbiAgaWYgKHNoYXBlcyAhPSBudWxsKSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHNoYXBlc1tpXSA9PSBudWxsKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgYXJyYXkgPSBhcnJheXNbaV07XG4gICAgICBpZiAoYXJyYXkuc2hhcGUubGVuZ3RoICE9PSBzaGFwZXNbaV0ubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYEVycm9yIHdoZW4gY2hlY2tpbmcgJHtleGNlcHRpb25QcmVmaXh9OiBleHBlY3RlZCAke25hbWVzW2ldfSBgICtcbiAgICAgICAgICAgIGB0byBoYXZlICR7c2hhcGVzW2ldLmxlbmd0aH0gZGltZW5zaW9uKHMpLiBidXQgZ290IGFycmF5IHdpdGggYCArXG4gICAgICAgICAgICBgc2hhcGUgJHthcnJheS5zaGFwZX1gKTtcbiAgICAgIH1cbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2hhcGVzW2ldLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGlmIChqID09PSAwICYmICFjaGVja0JhdGNoQXhpcykge1xuICAgICAgICAgIC8vIFNraXAgdGhlIGZpcnN0IChiYXRjaCkgYXhpcy5cbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkaW0gPSBhcnJheS5zaGFwZVtqXTtcbiAgICAgICAgY29uc3QgcmVmRGltID0gc2hhcGVzW2ldW2pdO1xuICAgICAgICBpZiAocmVmRGltICE9IG51bGwgJiYgcmVmRGltID49IDAgJiYgZGltICE9PSByZWZEaW0pIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgYCR7ZXhjZXB0aW9uUHJlZml4fSBleHBlY3RlZCBhIGJhdGNoIG9mIGVsZW1lbnRzIHdoZXJlIGVhY2ggYCArXG4gICAgICAgICAgICAgIGBleGFtcGxlIGhhcyBzaGFwZSBbJHtzaGFwZXNbaV0uc2xpY2UoMSwgc2hhcGVzW2ldLmxlbmd0aCl9XSBgICtcbiAgICAgICAgICAgICAgYChpLmUuLHRlbnNvciBzaGFwZSBbKiwke1xuICAgICAgICAgICAgICAgICAgc2hhcGVzW2ldLnNsaWNlKDEsIHNoYXBlc1tpXS5sZW5ndGgpfV0pYCArXG4gICAgICAgICAgICAgIGAgYnV0IHRoZSAke2V4Y2VwdGlvblByZWZpeH0gcmVjZWl2ZWQgYW4gaW5wdXQgd2l0aCAke1xuICAgICAgICAgICAgICAgICAgYXJyYXkuc2hhcGVbMF19YCArXG4gICAgICAgICAgICAgIGAgZXhhbXBsZXMsIGVhY2ggd2l0aCBzaGFwZSBbJHtcbiAgICAgICAgICAgICAgICAgIGFycmF5LnNoYXBlLnNsaWNlKDEsIGFycmF5LnNoYXBlLmxlbmd0aCl9XWAgK1xuICAgICAgICAgICAgICBgICh0ZW5zb3Igc2hhcGUgWyR7YXJyYXkuc2hhcGV9XSlgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gYXJyYXlzO1xufVxuXG4vKipcbiAqIFVzZXIgaW5wdXQgdmFsaWRhdGlvbiBmb3IgVGVuc29ycy5cbiAqIEBwYXJhbSBpbnB1dHMgYEFycmF5YCBvZiBgdGYuVGVuc29yYHMgZm9yIGlucHV0cy5cbiAqIEBwYXJhbSB0YXJnZXRzIGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzIGZvciB0YXJnZXRzLlxuICogQHBhcmFtIHdlaWdodHMgT3B0aW9uYWwgYEFycmF5YCBvZiBgdGYuVGVuc29yYHMgZm9yIHNhbXBsZSB3ZWlnaHRzLlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBpbiBjYXNlIG9mIGluY29ycmVjdGx5IGZvcm1hdHRlZCBkYXRhLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY2hlY2tBcnJheUxlbmd0aHMoXG4gICAgaW5wdXRzOiBUZW5zb3JbXSwgdGFyZ2V0czogVGVuc29yW10sIHdlaWdodHM/OiBUZW5zb3JbXSkge1xuICBjb25zdCBzZXRYID0gdW5pcXVlKGlucHV0cy5tYXAoaW5wdXQgPT4gaW5wdXQuc2hhcGVbMF0pKTtcbiAgc2V0WC5zb3J0KCk7XG4gIGNvbnN0IHNldFkgPSB1bmlxdWUodGFyZ2V0cy5tYXAodGFyZ2V0ID0+IHRhcmdldC5zaGFwZVswXSkpO1xuICBzZXRZLnNvcnQoKTtcbiAgLy8gVE9ETyhjYWlzKTogQ2hlY2sgYHdlaWdodHNgIGFzIHdlbGwuXG4gIGlmIChzZXRYLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgYEFsbCBpbnB1dCBUZW5zb3JzICh4KSBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2FtcGxlcy4gYCArXG4gICAgICAgIGBHb3QgYXJyYXkgc2hhcGVzOiBgICtcbiAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoaW5wdXRzLm1hcChpbnB1dCA9PiBpbnB1dC5zaGFwZSkpfWApO1xuICB9XG4gIGlmIChzZXRZLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgYEFsbCB0YXJnZXQgVGVuc29ycyAoeSkgc2hvdWxkIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHNhbXBsZXMuIGAgK1xuICAgICAgICBgR290IGFycmF5IHNoYXBlczogYCArXG4gICAgICAgIGAke0pTT04uc3RyaW5naWZ5KHRhcmdldHMubWFwKHRhcmdldCA9PiB0YXJnZXQuc2hhcGUpKX1gKTtcbiAgfVxuICBpZiAoc2V0WC5sZW5ndGggPiAwICYmIHNldFkubGVuZ3RoID4gMCAmJiAhdXRpbC5hcnJheXNFcXVhbChzZXRYLCBzZXRZKSkge1xuICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICBgSW5wdXQgVGVuc29ycyBzaG91bGQgaGF2ZSB0aGUgc2FtZSBudW1iZXIgb2Ygc2FtcGxlcyBhcyB0YXJnZXQgYCArXG4gICAgICAgIGBUZW5zb3JzLiBGb3VuZCAke3NldFhbMF19IGlucHV0IHNhbXBsZShzKSBhbmQgJHtzZXRZWzBdfSB0YXJnZXQgYCArXG4gICAgICAgIGBzYW1wbGUocykuYCk7XG4gIH1cbn1cblxuLyoqXG4gKiBWYWxpZGF0aW9uIG9uIHRoZSBjb21wYXRpYmlsaXR5IG9mIHRhcmdlcyBhbmQgbG9zcyBmdW5jdGlvbnMuXG4gKlxuICogVGhpcyBoZWxwcyBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgbG9zcyBmdW5jdGlvbnMgaW5jb3JyZWN0bHkuXG4gKlxuICogQHBhcmFtIHRhcmdldHMgYEFycmF5YCBvZiBgdGYuVGVuc29yYHMgb2YgdGFyZ2V0cy5cbiAqIEBwYXJhbSBsb3NzRm5zIGBBcnJheWAgb2YgbG9zcyBmdW5jdGlvbnMuXG4gKiBAcGFyYW0gb3V0cHV0U2hhcGVzIGBBcnJheWAgb2Ygc2hhcGVzIG9mIG1vZGVsIG91dHB1dHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrTG9zc0FuZFRhcmdldENvbXBhdGliaWxpdHkoXG4gICAgdGFyZ2V0czogVGVuc29yW10sIGxvc3NGbnM6IExvc3NPck1ldHJpY0ZuW10sIG91dHB1dFNoYXBlczogU2hhcGVbXSkge1xuICAvLyBUT0RPKGNhaXMpOiBEZWRpY2F0ZWQgdGVzdCBjb3ZlcmFnZT9cbiAgY29uc3Qga2V5TG9zc2VzID0gW1xuICAgIGxvc3Nlcy5tZWFuU3F1YXJlZEVycm9yLCBsb3NzZXMuYmluYXJ5Q3Jvc3NlbnRyb3B5LFxuICAgIGxvc3Nlcy5jYXRlZ29yaWNhbENyb3NzZW50cm9weVxuICBdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IHRhcmdldHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb25zdCB5ID0gdGFyZ2V0c1tpXTtcbiAgICBjb25zdCBsb3NzID0gbG9zc0Zuc1tpXTtcbiAgICBjb25zdCBzaGFwZSA9IG91dHB1dFNoYXBlc1tpXTtcbiAgICBpZiAobG9zcyA9PSBudWxsKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKGxvc3MgPT09IGxvc3Nlcy5jYXRlZ29yaWNhbENyb3NzZW50cm9weSkge1xuICAgICAgaWYgKHkuc2hhcGVbeS5zaGFwZS5sZW5ndGggLSAxXSA9PT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBZb3UgYXJlIHBhc3NpbmcgYSB0YXJnZXQgYXJyYXkgb2Ygc2hhcGUgJHt5LnNoYXBlfSB3aGlsZSB1c2luZyBgICtcbiAgICAgICAgICAgIGBhIGxvc3MgJ2NhdGVnb3JpY2FsX2Nyb3NzZW50cm9weScuICdjYXRlZ29yaWNhbF9jcm9zc2VudHJvcHknYCArXG4gICAgICAgICAgICBgZXhwZWN0cyB0YXJnZXRzIHRvIGJlIGJpbmFyeSBtYXRyaWNlcyAoMXMgYW5kIDBzKSBvZiBzaGFwZSBgICtcbiAgICAgICAgICAgIGBbc2FtcGxlcywgY2xhc3Nlc10uYCk7XG4gICAgICAgIC8vIFRPRE8oY2Fpcyk6IEV4YW1wbGUgY29kZSBpbiBlcnJvciBtZXNzYWdlLlxuICAgICAgfVxuICAgIH1cbiAgICBpZiAoa2V5TG9zc2VzLmluZGV4T2YobG9zcykgIT09IC0xKSB7XG4gICAgICBjb25zdCBzbGljZWRZU2hhcGUgPSB5LnNoYXBlLnNsaWNlKDEpO1xuICAgICAgY29uc3Qgc2xpY2VkU2hhcGUgPSBzaGFwZS5zbGljZSgxKTtcbiAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgc2xpY2VkWVNoYXBlLmxlbmd0aDsgKytqKSB7XG4gICAgICAgIGNvbnN0IHRhcmdldERpbSA9IHNsaWNlZFlTaGFwZVtqXTtcbiAgICAgICAgY29uc3Qgb3V0RGltID0gc2xpY2VkU2hhcGVbal07XG4gICAgICAgIGlmIChvdXREaW0gIT0gbnVsbCAmJiB0YXJnZXREaW0gIT09IG91dERpbSkge1xuICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgQSB0YXJnZXQgVGVuc29yIHdpdGggc2hhcGUgJHt5LnNoYXBlfSB3YXMgcGFzc2VkIGZvciBhbiBgICtcbiAgICAgICAgICAgICAgYG91dHB1dCBvZiBzaGFwZSAke3NoYXBlfSwgd2hpbGUgdXNpbmcgYSBsb3NzIGZ1bmN0aW9uIHRoYXQgYCArXG4gICAgICAgICAgICAgIGBleHBlY3RzIHRhcmdldHMgdG8gaGF2ZSB0aGUgc2FtZSBzaGFwZSBhcyB0aGUgb3V0cHV0LmApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQ2hlY2sgaW5wdXRzIHByb3ZpZGVkIGJ5IHRoZSB1c2VyLlxuICpcbiAqIFBvcnRpbmcgTm90ZTogVGhpcyBjb3JyZXNwb25kcyB0byBfc3RhbmRhcmRpemVfaW5wdXRfZGF0YSgpIGluIFB5dGhvblxuICogICBLZXJhcy4gQmVjYXVzZSBvZiB0aGUgc3Ryb25nIHR5cGluZyBpbiBURi5qcywgd2UgZG8gbm90IG5lZWQgdG8gY29udmVydFxuICogICB0aGUgZGF0YS4gU3BlY2lmaWNhbGx5OlxuICogICAxKSBpbiBQeUtlcmFzLCBgZGF0YWAgY2FuIGJlIGBEYXRhRnJhbWVgIGluc3RhbmNlcyBmcm9tIHBhbmRhcywgZm9yXG4gKiAgICAgIGV4YW1wbGUuIFdlIGRvbid0IG5lZWQgdG8gd29ycnkgYWJvdXQgdGhhdCBoZXJlIGJlY2F1c2UgdGhlcmUgaXMgbm9cbiAqICAgICAgd2lkZWx5IHBvcHVsYXIgamF2YXNjcmlwdC90eXBlc2RjcmlwdCBlcXVpdmFsZW50IG9mIHBhbmRhcyAoc28gZmFyKS5cbiAqICAgICAgSWYgb25lIGJlY29tZXMgYXZhaWxhYmxlIGluIHRoZSBmdXR1cmUsIHdlIGNhbiBhZGQgc3VwcG9ydC5cbiAqICAgMikgaW4gUHlLZXJhcywgaW5wdXRzIGNhbiBiZSBQeXRob24gZGljdC4gQnV0IGhlcmUgd2UgYXJlIHN0aXB1bGF0aW5nXG4gKiB0aGF0IHRoZSBkYXRhIGlzIGVpdGhlciBhIHNpbmdsZSBgdGYuVGVuc29yYCBvciBhbiBBcnJheSBvZiBgdGYuVGVuc29yYHMuIFdlXG4gKiBtYXkgYWRkIHN1cHBvcnQgZm9yIGBPYmplY3RgIGRhdGEgaW5wdXRzIGluIHRoZSBmdXR1cmUgd2hlbiB0aGUgbmVlZFxuICogYXJpc2VzLlxuICpcbiAqIEluc3RlYWQsIHdlIHBlcmZvcm0gYmFzaWMgY2hlY2tzIGZvciBudW1iZXIgb2YgcGFyYW1ldGVycyBhbmQgc2hhcGVzLlxuICpcbiAqIEBwYXJhbSBkYXRhOiBUaGUgaW5wdXQgZGF0YS5cbiAqIEBwYXJhbSBuYW1lczogTmFtZSBmb3IgdGhlIGlucHV0cywgZnJvbSB0aGUgbW9kZWwuXG4gKiBAcGFyYW0gc2hhcGVzOiBFeHBlY3RlZCBzaGFwZXMgZm9yIHRoZSBpbnB1dCBkYXRhLCBmcm9tIHRoZSBtb2RlbC5cbiAqIEBwYXJhbSBjaGVja0JhdGNoQXhpczogV2hldGhlciB0aGUgc2l6ZSBhbG9uZyB0aGUgYmF0Y2ggYXhpcyAoaS5lLiwgdGhlXG4gKiAgIGZpcnN0IGRpbWVuc2lvbikgd2lsbCBiZSBjaGVja2VkIGZvciBtYXRjaGluZy5cbiAqIEBwYXJhbSBleGNlcHRpb25QcmVmaXg6IEV4ZWNwdGlvbiBwcmVmaXggbWVzc2FnZSwgdXNlZCBpbiBnZW5lcmF0aW5nIGVycm9yXG4gKiAgIG1lc3NhZ2VzLlxuICogQHRocm93cyBWYWx1ZUVycm9yOiBvbiBpbmNvcnJlY3QgbnVtYmVyIG9mIGlucHV0cyBvciBtaXNtYXRjaGVzIGluIHNoYXBlcy5cbiAqL1xuZnVuY3Rpb24gY2hlY2tJbnB1dERhdGEoXG4gICAgZGF0YTogVGVuc29yfFRlbnNvcltdLCBuYW1lczogc3RyaW5nW10sIHNoYXBlcz86IFNoYXBlW10sXG4gICAgY2hlY2tCYXRjaEF4aXMgPSB0cnVlLCBleGNlcHRpb25QcmVmaXggPSAnJykge1xuICBsZXQgYXJyYXlzOiBUZW5zb3JbXTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggIT09IG5hbWVzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYEVycm9yIHdoZW4gY2hlY2tpbmcgbW9kZWwgJHtleGNlcHRpb25QcmVmaXh9OiB0aGUgQXJyYXkgb2YgYCArXG4gICAgICAgICAgYFRlbnNvcnMgdGhhdCB5b3UgYXJlIHBhc3NpbmcgdG8geW91ciBtb2RlbCBpcyBub3QgdGhlIHNpemUgdGhlIGAgK1xuICAgICAgICAgIGB0aGUgbW9kZWwgZXhwZWN0ZWQuIEV4cGVjdGVkIHRvIHNlZSAke25hbWVzLmxlbmd0aH0gVGVuc29yKHMpLGAgK1xuICAgICAgICAgIGAgYnV0IGluc3RlYWQgZ290ICR7ZGF0YS5sZW5ndGh9IFRlbnNvcnMocykuYCk7XG4gICAgfVxuICAgIGFycmF5cyA9IGRhdGE7XG4gIH0gZWxzZSB7XG4gICAgaWYgKG5hbWVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBUaGUgbW9kZWwgZXhwZWN0cyAke25hbWVzLmxlbmd0aH0gJHtleGNlcHRpb25QcmVmaXh9IFRlbnNvcnMsIGAgK1xuICAgICAgICAgIGBidXQgb25seSByZWNlaXZlZCBvbmUgVGVuc29yLiBGb3VuZDogYXJyYXkgd2l0aCBzaGFwZSBgICtcbiAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeShkYXRhLnNoYXBlKX0uYCk7XG4gICAgfVxuICAgIGFycmF5cyA9IFtkYXRhXTtcbiAgfVxuXG4gIGlmIChzaGFwZXMgIT0gbnVsbCkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmIChzaGFwZXNbaV0gPT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFycmF5ID0gYXJyYXlzW2ldO1xuICAgICAgaWYgKGFycmF5LnNoYXBlLmxlbmd0aCAhPT0gc2hhcGVzW2ldLmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBFcnJvciB3aGVuIGNoZWNraW5nICR7ZXhjZXB0aW9uUHJlZml4fTogZXhwZWN0ZWQgJHtuYW1lc1tpXX0gYCArXG4gICAgICAgICAgICBgdG8gaGF2ZSAke3NoYXBlc1tpXS5sZW5ndGh9IGRpbWVuc2lvbihzKSwgYnV0IGdvdCBhcnJheSB3aXRoIGAgK1xuICAgICAgICAgICAgYHNoYXBlICR7SlNPTi5zdHJpbmdpZnkoYXJyYXkuc2hhcGUpfWApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBzaGFwZXNbaV0ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYgKGogPT09IDAgJiYgIWNoZWNrQmF0Y2hBeGlzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGltID0gYXJyYXkuc2hhcGVbal07XG4gICAgICAgIGNvbnN0IHJlZkRpbSA9IHNoYXBlc1tpXVtqXTtcbiAgICAgICAgaWYgKHJlZkRpbSAhPSBudWxsKSB7XG4gICAgICAgICAgaWYgKHJlZkRpbSAhPT0gZGltKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgICBgRXJyb3Igd2hlbiBjaGVja2luZyAke2V4Y2VwdGlvblByZWZpeH06IGV4cGVjdGVkIGAgK1xuICAgICAgICAgICAgICAgIGAke25hbWVzW2ldfSB0byBoYXZlIHNoYXBlICR7SlNPTi5zdHJpbmdpZnkoc2hhcGVzW2ldKX0gYnV0IGAgK1xuICAgICAgICAgICAgICAgIGBnb3QgYXJyYXkgd2l0aCBzaGFwZSAke0pTT04uc3RyaW5naWZ5KGFycmF5LnNoYXBlKX0uYCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogTWFwcyBtZXRyaWMgZnVuY3Rpb25zIHRvIG1vZGVsIG91dHB1dHMuXG4gKiBAcGFyYW0gbWV0cmljcyBBbiBzaG9ydGN1dCBzdHJpbmdzIG5hbWUsIG1ldHJpYyBmdW5jdGlvbiwgYEFycmF5YCBvciBkaWN0XG4gKiAgIChgT2JqZWN0YCkgb2YgbWV0cmljIGZ1bmN0aW9ucy5cbiAqIEBwYXJhbSBvdXRwdXROYW1lcyBBbiBgQXJyYXlgIG9mIHRoZSBuYW1lcyBvZiBtb2RlbCBvdXRwdXRzLlxuICogQHJldHVybnMgQW4gYEFycmF5YCAob25lIGVudHJ5IHBlciBtb2RlbCBvdXRwdXQpIG9mIGBBcnJheWAgb2YgbWV0cmljXG4gKiAgIGZ1bmN0aW9ucy4gRm9yIGluc3RhbmNlLCBpZiB0aGUgbW9kZWwgaGFzIDIgb3V0cHV0cywgYW5kIGZvciB0aGUgZmlyc3RcbiAqICAgb3V0cHV0IHdlIHdhbnQgdG8gY29tcHV0ZSBgYmluYXJ5QWNjdXJhY3lgIGFuZCBgYmluYXJ5Q3Jvc3NlbnRyb3B5YCxcbiAqICAgYW5kIGp1c3QgYGJpbmFyeUFjY3VyYWN5YCBmb3IgdGhlIHNlY29uZCBvdXRwdXQsIHRoZSBgQXJyYXlgIHdvdWxkIGxvb2tcbiAqICAgbGlrZTpcbiAqICAgICBgW1tiaW5hcnlBY2N1cmFjeSwgYmluYXJ5Q3Jvc3NlbnRyb3B5XSwgIFtiaW5hcnlBY2N1cmFjeV1dYFxuICogQHRocm93cyBUeXBlRXJyb3I6IGluY29tcGF0aWJsZSBtZXRyaWNzIGZvcm1hdC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbGxlY3RNZXRyaWNzKFxuICAgIG1ldHJpY3M6IHN0cmluZ3xMb3NzT3JNZXRyaWNGbnxBcnJheTxzdHJpbmd8TG9zc09yTWV0cmljRm4+fFxuICAgIHtbb3V0cHV0TmFtZTogc3RyaW5nXTogc3RyaW5nIHwgTG9zc09yTWV0cmljRm59LFxuICAgIG91dHB1dE5hbWVzOiBzdHJpbmdbXSk6IEFycmF5PEFycmF5PHN0cmluZ3xMb3NzT3JNZXRyaWNGbj4+IHtcbiAgaWYgKG1ldHJpY3MgPT0gbnVsbCB8fCBBcnJheS5pc0FycmF5KG1ldHJpY3MpICYmIG1ldHJpY3MubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG91dHB1dE5hbWVzLm1hcChuYW1lID0+IFtdKTtcbiAgfVxuXG4gIGxldCB3cmFwcGVkTWV0cmljczogQXJyYXk8c3RyaW5nfExvc3NPck1ldHJpY0ZuPnxcbiAgICAgIHtbb3V0cHV0TmFtZTogc3RyaW5nXTogc3RyaW5nIHwgTG9zc09yTWV0cmljRm59O1xuICBpZiAodHlwZW9mIG1ldHJpY3MgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBtZXRyaWNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgd3JhcHBlZE1ldHJpY3MgPSBbbWV0cmljc107XG4gIH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShtZXRyaWNzKSB8fCB0eXBlb2YgbWV0cmljcyA9PT0gJ29iamVjdCcpIHtcbiAgICB3cmFwcGVkTWV0cmljcyA9IG1ldHJpY3MgYXMgQXJyYXk8c3RyaW5nfExvc3NPck1ldHJpY0ZuPnxcbiAgICAgICAge1tvdXRwdXROYW1lOiBzdHJpbmddOiBzdHJpbmd9IHwge1tvdXRwdXROYW1lOiBzdHJpbmddOiBMb3NzT3JNZXRyaWNGbn07XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgJ1R5cGUgb2YgbWV0cmljcyBhcmd1bWVudCBub3QgdW5kZXJzdG9vZC4gRXhwZWN0ZWQgYW4gc3RyaW5nLCcgK1xuICAgICAgICBgZnVuY3Rpb24sIEFycmF5LCBvciBPYmplY3QsIGZvdW5kOiAke21ldHJpY3N9YCk7XG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheSh3cmFwcGVkTWV0cmljcykpIHtcbiAgICAvLyBXZSB0aGVuIGFwcGx5IGFsbCBtZXRyaWNzIHRvIGFsbCBvdXRwdXRzLlxuICAgIHJldHVybiBvdXRwdXROYW1lcy5tYXAoXG4gICAgICAgIG5hbWUgPT4gd3JhcHBlZE1ldHJpY3MgYXMgQXJyYXk8c3RyaW5nfExvc3NPck1ldHJpY0ZuPik7XG4gIH0gZWxzZSB7XG4gICAgLy8gSW4gdGhpcyBjYXNlLCBtZXRyaWNzIGlzIGEgZGljdC5cbiAgICBjb25zdCBuZXN0ZWRNZXRyaWNzOiBBcnJheTxBcnJheTxzdHJpbmd8TG9zc09yTWV0cmljRm4+PiA9IFtdO1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBvdXRwdXROYW1lcykge1xuICAgICAgbGV0IG91dHB1dE1ldHJpY3M6IHN0cmluZ3xMb3NzT3JNZXRyaWNGbnxBcnJheTxzdHJpbmd8TG9zc09yTWV0cmljRm4+ID1cbiAgICAgICAgICB3cmFwcGVkTWV0cmljcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSA/IHdyYXBwZWRNZXRyaWNzW25hbWVdIDogW107XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkob3V0cHV0TWV0cmljcykpIHtcbiAgICAgICAgb3V0cHV0TWV0cmljcyA9IFtvdXRwdXRNZXRyaWNzXTtcbiAgICAgIH1cbiAgICAgIG5lc3RlZE1ldHJpY3MucHVzaChvdXRwdXRNZXRyaWNzKTtcbiAgICB9XG4gICAgcmV0dXJuIG5lc3RlZE1ldHJpY3M7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2RlbEV2YWx1YXRlQXJncyB7XG4gIC8qKlxuICAgKiBCYXRjaCBzaXplIChJbnRlZ2VyKS4gSWYgdW5zcGVjaWZpZWQsIGl0IHdpbGwgZGVmYXVsdCB0byAzMi5cbiAgICovXG4gIGJhdGNoU2l6ZT86IG51bWJlcjtcblxuICAvKipcbiAgICogVmVyYm9zaXR5IG1vZGUuXG4gICAqL1xuICB2ZXJib3NlPzogTW9kZWxMb2dnaW5nVmVyYm9zaXR5O1xuXG4gIC8qKlxuICAgKiBUZW5zb3Igb2Ygd2VpZ2h0cyB0byB3ZWlnaHQgdGhlIGNvbnRyaWJ1dGlvbiBvZiBkaWZmZXJlbnQgc2FtcGxlcyB0byB0aGVcbiAgICogbG9zcyBhbmQgbWV0cmljcy5cbiAgICovXG4gIHNhbXBsZVdlaWdodD86IFRlbnNvcjtcblxuICAvKipcbiAgICogaW50ZWdlcjogdG90YWwgbnVtYmVyIG9mIHN0ZXBzIChiYXRjaGVzIG9mIHNhbXBsZXMpXG4gICAqIGJlZm9yZSBkZWNsYXJpbmcgdGhlIGV2YWx1YXRpb24gcm91bmQgZmluaXNoZWQuIElnbm9yZWQgd2l0aCB0aGUgZGVmYXVsdFxuICAgKiB2YWx1ZSBvZiBgdW5kZWZpbmVkYC5cbiAgICovXG4gIHN0ZXBzPzogbnVtYmVyO1xufVxuXG4vKipcbiAqIENvbmZpZ3VyYXRpb24gZm9yIGNhbGxzIHRvIGBMYXllcnNNb2RlbC5jb21waWxlKClgLlxuICovXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsQ29tcGlsZUFyZ3Mge1xuICAvKipcbiAgICogQW4gaW5zdGFuY2Ugb2YgYHRmLnRyYWluLk9wdGltaXplcmAgb3IgYSBzdHJpbmcgbmFtZSBmb3IgYW4gT3B0aW1pemVyLlxuICAgKi9cbiAgb3B0aW1pemVyOiBzdHJpbmd8T3B0aW1pemVyO1xuXG4gIC8qKlxuICAgKiBPYmplY3QgZnVuY3Rpb24ocykgb3IgbmFtZShzKSBvZiBvYmplY3QgZnVuY3Rpb24ocykuXG4gICAqIElmIHRoZSBtb2RlbCBoYXMgbXVsdGlwbGUgb3V0cHV0cywgeW91IGNhbiB1c2UgYSBkaWZmZXJlbnQgbG9zc1xuICAgKiBvbiBlYWNoIG91dHB1dCBieSBwYXNzaW5nIGEgZGljdGlvbmFyeSBvciBhbiBBcnJheSBvZiBsb3NzZXMuXG4gICAqIFRoZSBsb3NzIHZhbHVlIHRoYXQgd2lsbCBiZSBtaW5pbWl6ZWQgYnkgdGhlIG1vZGVsIHdpbGwgdGhlbiBiZSB0aGUgc3VtXG4gICAqIG9mIGFsbCBpbmRpdmlkdWFsIGxvc3Nlcy5cbiAgICovXG4gIGxvc3M6IHN0cmluZ3xzdHJpbmdbXXx7W291dHB1dE5hbWU6IHN0cmluZ106IHN0cmluZ318TG9zc09yTWV0cmljRm58XG4gICAgICBMb3NzT3JNZXRyaWNGbltdfHtbb3V0cHV0TmFtZTogc3RyaW5nXTogTG9zc09yTWV0cmljRm59O1xuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1ldHJpY3MgdG8gYmUgZXZhbHVhdGVkIGJ5IHRoZSBtb2RlbCBkdXJpbmcgdHJhaW5pbmcgYW5kIHRlc3RpbmcuXG4gICAqIFR5cGljYWxseSB5b3Ugd2lsbCB1c2UgYG1ldHJpY3M9WydhY2N1cmFjeSddYC5cbiAgICogVG8gc3BlY2lmeSBkaWZmZXJlbnQgbWV0cmljcyBmb3IgZGlmZmVyZW50IG91dHB1dHMgb2YgYSBtdWx0aS1vdXRwdXRcbiAgICogbW9kZWwsIHlvdSBjb3VsZCBhbHNvIHBhc3MgYSBkaWN0aW9uYXJ5LlxuICAgKi9cbiAgbWV0cmljcz86IHN0cmluZ3xMb3NzT3JNZXRyaWNGbnxBcnJheTxzdHJpbmd8TG9zc09yTWV0cmljRm4+fFxuICAgICAge1tvdXRwdXROYW1lOiBzdHJpbmddOiBzdHJpbmcgfCBMb3NzT3JNZXRyaWNGbn07XG5cbiAgLy8gVE9ETyhjYWlzKTogQWRkIGxvc3NXZWlnaHRzLCBzYW1wbGVXZWlnaHRNb2RlLCB3ZWlnaHRlZE1ldHJpY3MsIGFuZFxuICAvLyAgIHRhcmdldFRlbnNvcnMuXG59XG5cbmNvbnN0IExBWUVSU19NT0RFTF9GT1JNQVRfTkFNRSA9ICdsYXllcnMtbW9kZWwnO1xuXG4vKipcbiAqIEEgYHRmLkxheWVyc01vZGVsYCBpcyBhIGRpcmVjdGVkLCBhY3ljbGljIGdyYXBoIG9mIGB0Zi5MYXllcmBzIHBsdXMgbWV0aG9kc1xuICogZm9yIHRyYWluaW5nLCBldmFsdWF0aW9uLCBwcmVkaWN0aW9uIGFuZCBzYXZpbmcuXG4gKlxuICogYHRmLkxheWVyc01vZGVsYCBpcyB0aGUgYmFzaWMgdW5pdCBvZiB0cmFpbmluZywgaW5mZXJlbmNlIGFuZCBldmFsdWF0aW9uIGluXG4gKiBUZW5zb3JGbG93LmpzLiBUbyBjcmVhdGUgYSBgdGYuTGF5ZXJzTW9kZWxgLCB1c2UgYHRmLkxheWVyc01vZGVsYC5cbiAqXG4gKiBTZWUgYWxzbzpcbiAqICAgYHRmLlNlcXVlbnRpYWxgLCBgdGYubG9hZExheWVyc01vZGVsYC5cbiAqXG4gKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICovXG5leHBvcnQgY2xhc3MgTGF5ZXJzTW9kZWwgZXh0ZW5kcyBDb250YWluZXIgaW1wbGVtZW50cyB0ZmMuSW5mZXJlbmNlTW9kZWwge1xuICAvLyBUaGUgY2xhc3MgbmFtZSBpcyAnTW9kZWwnIHJhdGhlciB0aGFuICdMYXllcnNNb2RlbCcgZm9yIGJhY2t3YXJkc1xuICAvLyBjb21wYXRpYmlsaXR5IHNpbmNlIHRoaXMgY2xhc3MgbmFtZSBzaG93cyB1cCBpbiB0aGUgc2VyaWFsaXphdGlvbiBmb3JtYXQuXG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ01vZGVsJztcbiAgcHJvdGVjdGVkIG9wdGltaXplcl86IE9wdGltaXplcjtcbiAgLy8gV2hldGhlciB0aGUgbW9kZWwgaW5zdGFuY2Ugb3ducyB0aGUgb3B0aW1pemVyOiBgdHJ1ZWAgaWYgYW5kIG9ubHkgaWZcbiAgLy8gYG9wdGltaXplcmAgaXMgY3JlYXRlZCBmcm9tIGEgc3RyaW5nIHBhcmFtZXRlciBkdXJpbmcgYGNvbXBpbGUoKWAgY2FsbC5cbiAgcHJvdGVjdGVkIGlzT3B0aW1pemVyT3duZWQ6IGJvb2xlYW47XG5cbiAgbG9zczogc3RyaW5nfHN0cmluZ1tdfHtbb3V0cHV0TmFtZTogc3RyaW5nXTogc3RyaW5nfXxMb3NzT3JNZXRyaWNGbnxcbiAgICAgIExvc3NPck1ldHJpY0ZuW118e1tvdXRwdXROYW1lOiBzdHJpbmddOiBMb3NzT3JNZXRyaWNGbn07XG4gIGxvc3NGdW5jdGlvbnM6IExvc3NPck1ldHJpY0ZuW107XG5cbiAgLy8gVE9ETyhjYWlzKTogVGhlc2UgcHJpdmF0ZSB2YXJpYWJsZXMgc2hvdWxkIHByb2JhYmx5IG5vdCBoYXZlIHRoZSBzdHJpbmdcbiAgLy8gICAnZmVlZCcgaW4gdGhlaXIgbmFtZXMsIGJlY2F1c2Ugd2UgYXJlIG5vdCBkZWFsaW5nIHdpdGggYSBzeW1ib2xpY1xuICAvLyAgIGJhY2tlbmQuXG4gIHByaXZhdGUgZmVlZE91dHB1dFNoYXBlczogU2hhcGVbXTtcbiAgcHJpdmF0ZSBmZWVkTG9zc0ZuczogTG9zc09yTWV0cmljRm5bXTtcbiAgcHJpdmF0ZSBjb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzOiBMYXllclZhcmlhYmxlW107XG4gIHByaXZhdGUgdGVzdEZ1bmN0aW9uOiAoZGF0YTogVGVuc29yW10pID0+IFNjYWxhcltdO1xuICBoaXN0b3J5OiBIaXN0b3J5O1xuXG4gIC8vIEEgcHVibGljIHByb3BlcnR5IHRoYXQgY2FuIGJlIHNldCBieSBDYWxsYmFja3MgdG8gb3JkZXIgZWFybHkgc3RvcHBpbmdcbiAgLy8gZHVyaW5nIGBmaXQoKWAgY2FsbHMuXG4gIHByb3RlY3RlZCBzdG9wVHJhaW5pbmdfOiBib29sZWFuO1xuICBwcm90ZWN0ZWQgaXNUcmFpbmluZzogYm9vbGVhbjtcblxuICBtZXRyaWNzOiBzdHJpbmd8TG9zc09yTWV0cmljRm58QXJyYXk8c3RyaW5nfExvc3NPck1ldHJpY0ZuPnxcbiAgICAgIHtbb3V0cHV0TmFtZTogc3RyaW5nXTogc3RyaW5nIHwgTG9zc09yTWV0cmljRm59O1xuICBtZXRyaWNzTmFtZXM6IHN0cmluZ1tdO1xuICAvLyBQb3J0aW5nIE5vdGU6IGBtZXRyaWNzX3RlbnNvcnNgIGluIFB5S2VyYXMgaXMgYSBzeW1ib2xpYyB0ZW5zb3IuIEJ1dCBnaXZlblxuICAvLyAgIHRoZSBpbXBlcmF0aXZlIG5hdHVyZSBvZiB0ZmpzLWNvcmUsIGBtZXRyaWNzVGVuc29yc2AgaXMgYVxuICAvLyAgIFR5cGVTY3JpcHQgZnVuY3Rpb24gaGVyZS5cbiAgLy8gICBBbHNvIG5vdGUgdGhhdCBkdWUgdG8gdGhlIGltcGVyYXRpdmUgbmF0dXJlIG9mIHRmanMtY29yZSwgYG1ldHJpY3NUZW5zb3JgXG4gIC8vICAgaGVyZSBuZWVkcyBhbiBvdXRwdXQgaW5kZXggdG8ga2VlcCB0cmFjayBvZiB3aGljaCBvdXRwdXQgb2YgdGhlXG4gIC8vICAgTGF5ZXJzTW9kZWwgYSBtZXRyaWMgYmVsb25ncyB0by4gVGhpcyBpcyB1bmxpa2UgYG1ldHJpY3NfdGVuc29yc2AgaW5cbiAgLy8gICBQeUtlcmFzLCB3aGljaCBpcyBhIGBsaXN0YCBvZiBzeW1ib2xpYyB0ZW5zb3JzLCBlYWNoIG9mIHdoaWNoIGhhc1xuICAvLyAgIGltcGxpY2l0IFwia25vd2xlZGdlXCIgb2YgdGhlIG91dHB1dHMgaXQgZGVwZW5kcyBvbi5cbiAgbWV0cmljc1RlbnNvcnM6IEFycmF5PFtMb3NzT3JNZXRyaWNGbiwgbnVtYmVyXT47XG5cbiAgLy8gVXNlciBkZWZpbmQgbWV0YWRhdGEgKGlmIGFueSkuXG4gIHByaXZhdGUgdXNlckRlZmluZWRNZXRhZGF0YToge307XG5cbiAgY29uc3RydWN0b3IoYXJnczogQ29udGFpbmVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMuaXNUcmFpbmluZyA9IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIFByaW50IGEgdGV4dCBzdW1tYXJ5IG9mIHRoZSBtb2RlbCdzIGxheWVycy5cbiAgICpcbiAgICogVGhlIHN1bW1hcnkgaW5jbHVkZXNcbiAgICogLSBOYW1lIGFuZCB0eXBlIG9mIGFsbCBsYXllcnMgdGhhdCBjb21wcmlzZSB0aGUgbW9kZWwuXG4gICAqIC0gT3V0cHV0IHNoYXBlKHMpIG9mIHRoZSBsYXllcnNcbiAgICogLSBOdW1iZXIgb2Ygd2VpZ2h0IHBhcmFtZXRlcnMgb2YgZWFjaCBsYXllclxuICAgKiAtIElmIHRoZSBtb2RlbCBoYXMgbm9uLXNlcXVlbnRpYWwtbGlrZSB0b3BvbG9neSwgdGhlIGlucHV0cyBlYWNoIGxheWVyXG4gICAqICAgcmVjZWl2ZXNcbiAgICogLSBUaGUgdG90YWwgbnVtYmVyIG9mIHRyYWluYWJsZSBhbmQgbm9uLXRyYWluYWJsZSBwYXJhbWV0ZXJzIG9mIHRoZSBtb2RlbC5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgaW5wdXQxID0gdGYuaW5wdXQoe3NoYXBlOiBbMTBdfSk7XG4gICAqIGNvbnN0IGlucHV0MiA9IHRmLmlucHV0KHtzaGFwZTogWzIwXX0pO1xuICAgKiBjb25zdCBkZW5zZTEgPSB0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiA0fSkuYXBwbHkoaW5wdXQxKTtcbiAgICogY29uc3QgZGVuc2UyID0gdGYubGF5ZXJzLmRlbnNlKHt1bml0czogOH0pLmFwcGx5KGlucHV0Mik7XG4gICAqIGNvbnN0IGNvbmNhdCA9IHRmLmxheWVycy5jb25jYXRlbmF0ZSgpLmFwcGx5KFtkZW5zZTEsIGRlbnNlMl0pO1xuICAgKiBjb25zdCBvdXRwdXQgPVxuICAgKiAgICAgdGYubGF5ZXJzLmRlbnNlKHt1bml0czogMywgYWN0aXZhdGlvbjogJ3NvZnRtYXgnfSkuYXBwbHkoY29uY2F0KTtcbiAgICpcbiAgICogY29uc3QgbW9kZWwgPSB0Zi5tb2RlbCh7aW5wdXRzOiBbaW5wdXQxLCBpbnB1dDJdLCBvdXRwdXRzOiBvdXRwdXR9KTtcbiAgICogbW9kZWwuc3VtbWFyeSgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIGxpbmVMZW5ndGggQ3VzdG9tIGxpbmUgbGVuZ3RoLCBpbiBudW1iZXIgb2YgY2hhcmFjdGVycy5cbiAgICogQHBhcmFtIHBvc2l0aW9ucyBDdXN0b20gd2lkdGhzIG9mIGVhY2ggb2YgdGhlIGNvbHVtbnMsIGFzIGVpdGhlclxuICAgKiAgIGZyYWN0aW9ucyBvZiBgbGluZUxlbmd0aGAgKGUuZy4sIGBbMC41LCAwLjc1LCAxXWApIG9yIGFic29sdXRlIG51bWJlclxuICAgKiAgIG9mIGNoYXJhY3RlcnMgKGUuZy4sIGBbMzAsIDUwLCA2NV1gKS4gRWFjaCBudW1iZXIgY29ycmVzcG9uZHMgdG9cbiAgICogICByaWdodC1tb3N0IChpLmUuLCBlbmRpbmcpIHBvc2l0aW9uIG9mIGEgY29sdW1uLlxuICAgKiBAcGFyYW0gcHJpbnRGbiBDdXN0b20gcHJpbnQgZnVuY3Rpb24uIENhbiBiZSB1c2VkIHRvIHJlcGxhY2UgdGhlIGRlZmF1bHRcbiAgICogICBgY29uc29sZS5sb2dgLiBGb3IgZXhhbXBsZSwgeW91IGNhbiB1c2UgYHggPT4ge31gIHRvIG11dGUgdGhlIHByaW50ZWRcbiAgICogICBtZXNzYWdlcyBpbiB0aGUgY29uc29sZS5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIHN1bW1hcnkoXG4gICAgICBsaW5lTGVuZ3RoPzogbnVtYmVyLCBwb3NpdGlvbnM/OiBudW1iZXJbXSxcbiAgICAgIHByaW50Rm46XG4gICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICAgICAgKG1lc3NhZ2U/OiBhbnksIC4uLm9wdGlvbmFsUGFyYW1zOiBhbnlbXSkgPT4gdm9pZCA9IGNvbnNvbGUubG9nKSB7XG4gICAgaWYgKCF0aGlzLmJ1aWx0KSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgVGhpcyBtb2RlbCBoYXMgbmV2ZXIgYmVlbiBjYWxsZWQsIHRodXMgaXRzIHdlaWdodHMgaGF2ZSBub3QgYmVlbiBgICtcbiAgICAgICAgICBgY3JlYXRlZCB5ZXQuIFNvIG5vIHN1bW1hcnkgY2FuIGJlIGRpc3BsYXllZC4gQnVpbGQgdGhlIG1vZGVsIGAgK1xuICAgICAgICAgIGBmaXJzdCAoZS5nLiwgYnkgY2FsbGluZyBpdCBvbiBzb21lIHRlc3QgZGF0YSkuYCk7XG4gICAgfVxuICAgIHByaW50U3VtbWFyeSh0aGlzLCBsaW5lTGVuZ3RoLCBwb3NpdGlvbnMsIHByaW50Rm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmZpZ3VyZXMgYW5kIHByZXBhcmVzIHRoZSBtb2RlbCBmb3IgdHJhaW5pbmcgYW5kIGV2YWx1YXRpb24uICBDb21waWxpbmdcbiAgICogb3V0Zml0cyB0aGUgbW9kZWwgd2l0aCBhbiBvcHRpbWl6ZXIsIGxvc3MsIGFuZC9vciBtZXRyaWNzLiAgQ2FsbGluZyBgZml0YFxuICAgKiBvciBgZXZhbHVhdGVgIG9uIGFuIHVuLWNvbXBpbGVkIG1vZGVsIHdpbGwgdGhyb3cgYW4gZXJyb3IuXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzIGEgYE1vZGVsQ29tcGlsZUFyZ3NgIHNwZWNpZnlpbmcgdGhlIGxvc3MsIG9wdGltaXplciwgYW5kXG4gICAqIG1ldHJpY3MgdG8gYmUgdXNlZCBmb3IgZml0dGluZyBhbmQgZXZhbHVhdGluZyB0aGlzIG1vZGVsLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgY29tcGlsZShhcmdzOiBNb2RlbENvbXBpbGVBcmdzKTogdm9pZCB7XG4gICAgaWYgKGFyZ3MubG9zcyA9PSBudWxsKSB7XG4gICAgICBhcmdzLmxvc3MgPSBbXTtcbiAgICB9XG4gICAgdGhpcy5sb3NzID0gYXJncy5sb3NzO1xuXG4gICAgaWYgKHR5cGVvZiBhcmdzLm9wdGltaXplciA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRoaXMub3B0aW1pemVyXyA9IG9wdGltaXplcnMuZ2V0T3B0aW1pemVyKGFyZ3Mub3B0aW1pemVyKTtcbiAgICAgIHRoaXMuaXNPcHRpbWl6ZXJPd25lZCA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghKGFyZ3Mub3B0aW1pemVyIGluc3RhbmNlb2YgT3B0aW1pemVyKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBVc2VyLWRlZmluZWQgb3B0aW1pemVyIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgdGYuT3B0aW1pemVyLmApO1xuICAgICAgfVxuICAgICAgdGhpcy5vcHRpbWl6ZXJfID0gYXJncy5vcHRpbWl6ZXI7XG4gICAgICB0aGlzLmlzT3B0aW1pemVyT3duZWQgPSBmYWxzZTtcbiAgICB9XG5cbiAgICAvLyBUT0RPKGNhaXMpOiBBZGQgbG9zc1dlaWdodHMuXG4gICAgLy8gVE9ETyhjYWlzKTogQWRkIHNhbXBsZVdlaWdodE1vZGUuXG5cbiAgICAvLyBQcmVwYXJlIGxvc3MgZnVuY3Rpb25zLlxuICAgIGxldCBsb3NzRnVuY3Rpb25zOiBMb3NzT3JNZXRyaWNGbltdID0gW107XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MubG9zcykgJiYgdHlwZW9mIGFyZ3MubG9zcyAhPT0gJ3N0cmluZycgJiZcbiAgICAgICAgdHlwZW9mIGFyZ3MubG9zcyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYXJncy5sb3NzID0gYXJncy5sb3NzIGFzIHtbb3V0cHV0TmFtZTogc3RyaW5nXTogc3RyaW5nfTtcbiAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBhcmdzLmxvc3MpIHtcbiAgICAgICAgaWYgKHRoaXMub3V0cHV0TmFtZXMuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgYFVua25vd24gZW50cnkgaW4gbG9zcyBkaWN0aW9uYXJ5OiBcIiR7bmFtZX1cIi4gYCArXG4gICAgICAgICAgICAgIGBPbmx5IGV4cGVjdGVkIHRoZSBmb2xsb3dpbmcga2V5czogJHt0aGlzLm91dHB1dE5hbWVzfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgdGhpcy5vdXRwdXROYW1lcykge1xuICAgICAgICBpZiAoYXJncy5sb3NzW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIGBPdXRwdXQgXCIke25hbWV9XCIgaXMgbWlzc2luZyBmcm9tIGxvc3MgZGljdGlvbmFyeS4gV2UgYXNzdW1lIGAgK1xuICAgICAgICAgICAgICBgdGhpcyB3YXMgZG9uZSBvbiBwdXJwb3NlLCBhbmQgd2Ugd2lsbCBub3QgYmUgZXhwZWN0aW5nIGRhdGEgYCArXG4gICAgICAgICAgICAgIGB0byBiZSBwYXNzZWQgdG8gJHtuYW1lfSBkdXJpbmcgdHJhaW5pbmdgKTtcbiAgICAgICAgfVxuICAgICAgICBsb3NzRnVuY3Rpb25zLnB1c2gobG9zc2VzLmdldChhcmdzLmxvc3NbbmFtZV0pKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJncy5sb3NzKSkge1xuICAgICAgaWYgKGFyZ3MubG9zcy5sZW5ndGggIT09IHRoaXMub3V0cHV0cy5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgV2hlbiBwYXNzaW5nIGFuIEFycmF5IGFzIGxvc3MsIGl0IHNob3VsZCBoYXZlIG9uZSBlbnRyeSBwZXIgYCArXG4gICAgICAgICAgICBgbW9kZWwgb3V0cHV0LiBUaGUgbW9kZWwgaGFzICR7dGhpcy5vdXRwdXRzLmxlbmd0aH0gb3V0cHV0KHMpLCBgICtcbiAgICAgICAgICAgIGBidXQgeW91IHBhc3NlZCBsb3NzPSR7YXJncy5sb3NzfS5gKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHRoZUxvc3NlcyA9IGFyZ3MubG9zcyBhcyBBcnJheTxzdHJpbmd8TG9zc09yTWV0cmljRm4+O1xuICAgICAgbG9zc0Z1bmN0aW9ucyA9IHRoZUxvc3Nlcy5tYXAobCA9PiBsb3NzZXMuZ2V0KGwpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbG9zc0Z1bmN0aW9uID0gbG9zc2VzLmdldChhcmdzLmxvc3MpO1xuICAgICAgdGhpcy5vdXRwdXRzLmZvckVhY2goXyA9PiB7XG4gICAgICAgIGxvc3NGdW5jdGlvbnMucHVzaChsb3NzRnVuY3Rpb24pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgdGhpcy5sb3NzRnVuY3Rpb25zID0gbG9zc0Z1bmN0aW9ucztcblxuICAgIHRoaXMuZmVlZE91dHB1dE5hbWVzID0gW107XG4gICAgdGhpcy5mZWVkT3V0cHV0U2hhcGVzID0gW107XG4gICAgdGhpcy5mZWVkTG9zc0ZucyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBMb2dpYyBmb3Igc2tpcHBpbmcgdGFyZ2V0KHMpLlxuICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmludGVybmFsT3V0cHV0U2hhcGVzW2ldO1xuICAgICAgY29uc3QgbmFtZSA9IHRoaXMub3V0cHV0TmFtZXNbaV07XG4gICAgICB0aGlzLmZlZWRPdXRwdXROYW1lcy5wdXNoKG5hbWUpO1xuICAgICAgdGhpcy5mZWVkT3V0cHV0U2hhcGVzLnB1c2goc2hhcGUpO1xuICAgICAgdGhpcy5mZWVkTG9zc0Zucy5wdXNoKHRoaXMubG9zc0Z1bmN0aW9uc1tpXSk7XG4gICAgfVxuXG4gICAgLy8gVE9ETyhjYWlzKTogQWRkIGxvZ2ljIGZvciBvdXRwdXQgbWFza3MuXG4gICAgLy8gVE9ETyhjYWlzKTogQWRkIGxvZ2ljIGZvciBzYW1wbGUgd2VpZ2h0cy5cbiAgICBjb25zdCBza2lwVGFyZ2V0SW5kaWNlczogbnVtYmVyW10gPSBbXTtcblxuICAgIC8vIFByZXBhcmUgbWV0cmljcy5cbiAgICB0aGlzLm1ldHJpY3MgPSBhcmdzLm1ldHJpY3M7XG4gICAgLy8gVE9ETyhjYWlzKTogQWRkIHdlaWdodGVkTWV0cmljcy5cbiAgICB0aGlzLm1ldHJpY3NOYW1lcyA9IFsnbG9zcyddO1xuICAgIHRoaXMubWV0cmljc1RlbnNvcnMgPSBbXTtcblxuICAgIC8vIENvbXB1dGUgdG90YWwgbG9zcy5cbiAgICAvLyBQb3J0aW5nIE5vdGU6IEluIFB5S2VyYXMsIG1ldHJpY3NfdGVuc29ycyBhcmUgc3ltYm9saWMgdGVuc29yIG9iamVjdHMuXG4gICAgLy8gICBIZXJlLCBtZXRyaWNzVGVuc29ycyBhcmUgVHlwZVNjcmlwdCBmdW5jdGlvbnMuIFRoaXMgZGlmZmVyZW5jZSBpcyBkdWVcbiAgICAvLyAgIHRvIHRoZSBkaWZmZXJlbmNlIGluIHN5bWJvbGljL2ltcGVyYXRpdmUgcHJvcGVydHkgb2YgdGhlIGJhY2tlbmRzLlxuICAgIG5hbWVTY29wZSgnbG9zcycsICgpID0+IHtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5vdXRwdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGlmIChza2lwVGFyZ2V0SW5kaWNlcy5pbmRleE9mKGkpICE9PSAtMSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCB3ZWlnaHRlZExvc3MsIHNhbXBsZVdlaWdodCBhbmQgbWFzay5cbiAgICAgICAgLy8gICBUaGUgZm9sbG93aW5nIGxpbmUgc2hvdWxkIGJlIHdlaWdodGVkTG9zc1xuICAgICAgICBjb25zdCB3ZWlnaHRlZExvc3MgPSB0aGlzLmxvc3NGdW5jdGlvbnNbaV07XG4gICAgICAgIGlmICh0aGlzLm91dHB1dHMubGVuZ3RoID4gMSkge1xuICAgICAgICAgIHRoaXMubWV0cmljc1RlbnNvcnMucHVzaChbd2VpZ2h0ZWRMb3NzLCBpXSk7XG4gICAgICAgICAgdGhpcy5tZXRyaWNzTmFtZXMucHVzaCh0aGlzLm91dHB1dE5hbWVzW2ldICsgJ19sb3NzJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gUG9ydGluZyBOb3RlOiBEdWUgdG8gdGhlIGltcGVyYXRpdmUgbmF0dXJlIG9mIHRoZSBiYWNrZW5kLCB3ZSBjYWxjdWxhdGVcbiAgICAgIC8vICAgdGhlIHJlZ3VsYXJpemVyIHBlbmFsdGllcyBpbiB0aGUgdG90YWxMb3NzRnVuY3Rpb24sIGluc3RlYWQgb2YgaGVyZS5cbiAgICB9KTtcblxuICAgIGNvbnN0IG5lc3RlZE1ldHJpY3MgPSBjb2xsZWN0TWV0cmljcyhhcmdzLm1ldHJpY3MsIHRoaXMub3V0cHV0TmFtZXMpO1xuICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBuZXN0ZWRXZWlnaHRlZE1ldHJpY3MuXG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdXNlZCBpbiBsb29wIGJlbG93LlxuICAgICAqL1xuICAgIGNvbnN0IGFwcGVuZE1ldHJpYyA9XG4gICAgICAgIChvdXRwdXRJbmRleDogbnVtYmVyLCBtZXRyaWNOYW1lOiBzdHJpbmcsXG4gICAgICAgICBtZXRyaWNUZW5zb3I6IExvc3NPck1ldHJpY0ZuKSA9PiB7XG4gICAgICAgICAgaWYgKHRoaXMub3V0cHV0TmFtZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbWV0cmljTmFtZSA9IHRoaXMub3V0cHV0TmFtZXNbb3V0cHV0SW5kZXhdICsgJ18nICsgbWV0cmljTmFtZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5tZXRyaWNzTmFtZXMucHVzaChtZXRyaWNOYW1lKTtcbiAgICAgICAgICB0aGlzLm1ldHJpY3NUZW5zb3JzLnB1c2goW21ldHJpY1RlbnNvciwgb3V0cHV0SW5kZXhdKTtcbiAgICAgICAgfTtcblxuICAgIG5hbWVTY29wZSgnbWV0cmljJywgKCkgPT4ge1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKHNraXBUYXJnZXRJbmRpY2VzLmluZGV4T2YoaSkgIT09IC0xKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3V0cHV0TWV0cmljcyA9IG5lc3RlZE1ldHJpY3NbaV07XG4gICAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCB3ZWlnaHRzIGFuZCBvdXRwdXRXZWlnaHRlZE1ldHJpY3MuXG5cbiAgICAgICAgLy8gVE9ETyhjYWlzKTogQWRkIG9wdGlvbmFsIGFyZyBgd2VpZ2h0c2AgdG8gdGhlIGZvbGxvd2luZyBmdW5jdGlvbi5cbiAgICAgICAgY29uc3QgaGFuZGxlTWV0cmljcyA9IChtZXRyaWNzOiBBcnJheTxzdHJpbmd8TG9zc09yTWV0cmljRm4+KSA9PiB7XG4gICAgICAgICAgY29uc3QgbWV0cmljTmFtZVByZWZpeCA9ICcnO1xuICAgICAgICAgIGxldCBtZXRyaWNOYW1lOiBzdHJpbmc7XG4gICAgICAgICAgbGV0IGFjY0ZuOiBMb3NzT3JNZXRyaWNGbjtcbiAgICAgICAgICBsZXQgd2VpZ2h0ZWRNZXRyaWNGbjogTG9zc09yTWV0cmljRm47XG4gICAgICAgICAgLy8gIFRPRE8oY2Fpcyk6IFVzZSAnd2VpZ2h0c18nIGZvciB3ZWlnaHRlZCBtZXRyaWNzLlxuXG4gICAgICAgICAgZm9yIChjb25zdCBtZXRyaWMgb2YgbWV0cmljcykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXRyaWMgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICAgICAgWydhY2N1cmFjeScsICdhY2MnLCAnY3Jvc3NlbnRyb3B5JywgJ2NlJ10uaW5kZXhPZihtZXRyaWMpICE9PVxuICAgICAgICAgICAgICAgICAgICAtMSkge1xuICAgICAgICAgICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHRoaXMuaW50ZXJuYWxPdXRwdXRTaGFwZXNbaV07XG5cbiAgICAgICAgICAgICAgaWYgKG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDFdID09PSAxIHx8XG4gICAgICAgICAgICAgICAgICB0aGlzLmxvc3NGdW5jdGlvbnNbaV0gPT09IGxvc3Nlcy5iaW5hcnlDcm9zc2VudHJvcHkpIHtcbiAgICAgICAgICAgICAgICAvLyBjYXNlOiBiaW5hcnkgYWNjdXJhY3kvY3Jvc3NlbnRyb3B5LlxuICAgICAgICAgICAgICAgIGlmIChbJ2FjY3VyYWN5JywgJ2FjYyddLmluZGV4T2YobWV0cmljKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGFjY0ZuID0gTWV0cmljcy5iaW5hcnlBY2N1cmFjeTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFsnY3Jvc3NlbnRyb3B5JywgJ2NlJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgYWNjRm4gPSBNZXRyaWNzLmJpbmFyeUNyb3NzZW50cm9weTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgICAgICAgICAgICB0aGlzLmxvc3NGdW5jdGlvbnNbaV0gPT09XG4gICAgICAgICAgICAgICAgICBsb3NzZXMuc3BhcnNlQ2F0ZWdvcmljYWxDcm9zc2VudHJvcHkpIHtcbiAgICAgICAgICAgICAgICAvLyBjYXNlOiBjYXRlZ29yaWNhbCBhY2N1cmFjeSAvIGNyb3NzZW50cm9weSB3aXRoIHNwYXJzZVxuICAgICAgICAgICAgICAgIC8vIHRhcmdldHMuXG4gICAgICAgICAgICAgICAgaWYgKFsnYWNjdXJhY3knLCAnYWNjJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgYWNjRm4gPSBNZXRyaWNzLnNwYXJzZUNhdGVnb3JpY2FsQWNjdXJhY3k7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChbJ2Nyb3NzZW50cm9weScsICdjZSddLmluZGV4T2YobWV0cmljKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGFjY0ZuID0gTWV0cmljcy5zcGFyc2VDYXRlZ29yaWNhbENyb3NzZW50cm9weTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gY2FzZTogY2F0ZWdvcmljYWwgYWNjdXJhY3kgLyBjcm9zc2VudHJvcHkuXG4gICAgICAgICAgICAgICAgaWYgKFsnYWNjdXJhY3knLCAnYWNjJ10uaW5kZXhPZihtZXRyaWMpICE9PSAtMSkge1xuICAgICAgICAgICAgICAgICAgYWNjRm4gPSBNZXRyaWNzLmNhdGVnb3JpY2FsQWNjdXJhY3k7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChbJ2Nyb3NzZW50cm9weScsICdjZSddLmluZGV4T2YobWV0cmljKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgIGFjY0ZuID0gTWV0cmljcy5jYXRlZ29yaWNhbENyb3NzZW50cm9weTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbGV0IHN1ZmZpeDogc3RyaW5nO1xuICAgICAgICAgICAgICBpZiAoWydhY2N1cmFjeScsICdhY2MnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gJ2FjYyc7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoWydjcm9zc2VudHJvcHknLCAnY2UnXS5pbmRleE9mKG1ldHJpYykgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgc3VmZml4ID0gJ2NlJztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgd2VpZ2h0aW5nIGFjdHVhbGx5LlxuICAgICAgICAgICAgICB3ZWlnaHRlZE1ldHJpY0ZuID0gYWNjRm47XG4gICAgICAgICAgICAgIG1ldHJpY05hbWUgPSBtZXRyaWNOYW1lUHJlZml4ICsgc3VmZml4O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgY29uc3QgbWV0cmljRm4gPSBNZXRyaWNzLmdldChtZXRyaWMpO1xuICAgICAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgd2VpZ2h0aW5nIGFjdHVhbGx5LlxuICAgICAgICAgICAgICB3ZWlnaHRlZE1ldHJpY0ZuID0gbWV0cmljRm47XG4gICAgICAgICAgICAgIG1ldHJpY05hbWUgPVxuICAgICAgICAgICAgICAgICAgbWV0cmljTmFtZVByZWZpeCArIE1ldHJpY3MuZ2V0TG9zc09yTWV0cmljTmFtZShtZXRyaWMpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgd2VpZ2h0aW5nIGFuZCBtYXNraW5nIHRvIG1ldHJpY1Jlc3VsdC5cbiAgICAgICAgICAgIGxldCBtZXRyaWNSZXN1bHQ6IExvc3NPck1ldHJpY0ZuO1xuICAgICAgICAgICAgbmFtZVNjb3BlKG1ldHJpY05hbWUsICgpID0+IHtcbiAgICAgICAgICAgICAgbWV0cmljUmVzdWx0ID0gd2VpZ2h0ZWRNZXRyaWNGbjtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYXBwZW5kTWV0cmljKGksIG1ldHJpY05hbWUsIG1ldHJpY1Jlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIGhhbmRsZU1ldHJpY3Mob3V0cHV0TWV0cmljcyk7XG4gICAgICAgIC8vIFRPRE8oY2Fpcyk6IENhbGwgaGFuZGxlTWV0cmljcyB3aXRoIHdlaWdodHMuXG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBQb3J0aW5nIE5vdGVzOiBHaXZlbiB0aGUgaW1wZXJhdGl2ZSBiYWNrZW5kIG9mIHRmanMtY29yZSxcbiAgICAvLyAgIHRoZXJlIGlzIG5vIG5lZWQgZm9yIGNvbnN0cnVjdGluZyB0aGUgc3ltYm9saWMgZ3JhcGggYW5kIHBsYWNlaG9sZGVycy5cbiAgICB0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMgPSB0aGlzLnRyYWluYWJsZVdlaWdodHM7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2sgdHJhaW5hYmxlIHdlaWdodHMgY291bnQgY29uc2lzdGVuY3kuXG4gICAqXG4gICAqIFRoaXMgd2lsbCByYWlzZSBhIHdhcm5pbmcgaWYgYHRoaXMudHJhaW5hYmxlV2VpZ2h0c2AgYW5kXG4gICAqIGB0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHNgIGFyZSBpbmNvbnNpc3RlbnQgKGkuZS4sIGhhdmUgZGlmZmVyZW50XG4gICAqIG51bWJlcnMgb2YgcGFyYW1ldGVycykuXG4gICAqIEluY29uc2lzdGVuY3kgd2lsbCB0eXBpY2FsbHkgYXJpc2Ugd2hlbiBvbmUgbW9kaWZpZXMgYG1vZGVsLnRyYWluYWJsZWBcbiAgICogd2l0aG91dCBjYWxsaW5nIGBtb2RlbC5jb21waWxlKClgIGFnYWluLlxuICAgKi9cbiAgcHJvdGVjdGVkIGNoZWNrVHJhaW5hYmxlV2VpZ2h0c0NvbnNpc3RlbmN5KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy50cmFpbmFibGVXZWlnaHRzLmxlbmd0aCAhPT1cbiAgICAgICAgdGhpcy5jb2xsZWN0ZWRUcmFpbmFibGVXZWlnaHRzLmxlbmd0aCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdEaXNjcmVwYW5jeSBiZXR3ZWVuIHRyYWluYWJsZXdlaWdodHMgYW5kIGNvbGxlY3RlZCB0cmFpbmFibGUgJyArXG4gICAgICAgICAgJ3dlaWdodHMuIERpZCB5b3Ugc2V0IGBtb2RlbC50cmFpbmFibGVgIHdpdGhvdXQgY2FsbGluZyAnICtcbiAgICAgICAgICAnYG1vZGVsLmNvbXBpbGUoKWAgYWZ0ZXJ3YXJkcz8nKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgbG9zcyB2YWx1ZSAmIG1ldHJpY3MgdmFsdWVzIGZvciB0aGUgbW9kZWwgaW4gdGVzdCBtb2RlLlxuICAgKlxuICAgKiBMb3NzIGFuZCBtZXRyaWNzIGFyZSBzcGVjaWZpZWQgZHVyaW5nIGBjb21waWxlKClgLCB3aGljaCBuZWVkcyB0byBoYXBwZW5cbiAgICogYmVmb3JlIGNhbGxzIHRvIGBldmFsdWF0ZSgpYC5cbiAgICpcbiAgICogQ29tcHV0YXRpb24gaXMgZG9uZSBpbiBiYXRjaGVzLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtb2RlbCA9IHRmLnNlcXVlbnRpYWwoe1xuICAgKiAgIGxheWVyczogW3RmLmxheWVycy5kZW5zZSh7dW5pdHM6IDEsIGlucHV0U2hhcGU6IFsxMF19KV1cbiAgICogfSk7XG4gICAqIG1vZGVsLmNvbXBpbGUoe29wdGltaXplcjogJ3NnZCcsIGxvc3M6ICdtZWFuU3F1YXJlZEVycm9yJ30pO1xuICAgKiBjb25zdCByZXN1bHQgPSBtb2RlbC5ldmFsdWF0ZShcbiAgICogICAgIHRmLm9uZXMoWzgsIDEwXSksIHRmLm9uZXMoWzgsIDFdKSwge2JhdGNoU2l6ZTogNH0pO1xuICAgKiByZXN1bHQucHJpbnQoKTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB4IGB0Zi5UZW5zb3JgIG9mIHRlc3QgZGF0YSwgb3IgYW4gYEFycmF5YCBvZiBgdGYuVGVuc29yYHMgaWYgdGhlXG4gICAqIG1vZGVsIGhhcyBtdWx0aXBsZSBpbnB1dHMuXG4gICAqIEBwYXJhbSB5IGB0Zi5UZW5zb3JgIG9mIHRhcmdldCBkYXRhLCBvciBhbiBgQXJyYXlgIG9mIGB0Zi5UZW5zb3JgcyBpZiB0aGVcbiAgICogbW9kZWwgaGFzIG11bHRpcGxlIG91dHB1dHMuXG4gICAqIEBwYXJhbSBhcmdzIEEgYE1vZGVsRXZhbHVhdGVBcmdzYCwgY29udGFpbmluZyBvcHRpb25hbCBmaWVsZHMuXG4gICAqXG4gICAqIEByZXR1cm4gYFNjYWxhcmAgdGVzdCBsb3NzIChpZiB0aGUgbW9kZWwgaGFzIGEgc2luZ2xlIG91dHB1dCBhbmQgbm9cbiAgICogICBtZXRyaWNzKSBvciBgQXJyYXlgIG9mIGBTY2FsYXJgcyAoaWYgdGhlIG1vZGVsIGhhcyBtdWx0aXBsZSBvdXRwdXRzXG4gICAqICAgYW5kL29yIG1ldHJpY3MpLiBUaGUgYXR0cmlidXRlIGBtb2RlbC5tZXRyaWNzTmFtZXNgXG4gICAqICAgd2lsbCBnaXZlIHlvdSB0aGUgZGlzcGxheSBsYWJlbHMgZm9yIHRoZSBzY2FsYXIgb3V0cHV0cy5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGV2YWx1YXRlKFxuICAgICAgeDogVGVuc29yfFRlbnNvcltdLCB5OiBUZW5zb3J8VGVuc29yW10sXG4gICAgICBhcmdzOiBNb2RlbEV2YWx1YXRlQXJncyA9IHt9KTogU2NhbGFyfFNjYWxhcltdIHtcbiAgICBjb25zdCBiYXRjaFNpemUgPSBhcmdzLmJhdGNoU2l6ZSA9PSBudWxsID8gMzIgOiBhcmdzLmJhdGNoU2l6ZTtcbiAgICBjaGVja0JhdGNoU2l6ZShiYXRjaFNpemUpO1xuXG4gICAgLy8gVE9ETyhjYWlzKTogU3RhbmRhcmRpemUgYGNvbmZpZy5zYW1wbGVXZWlnaHRzYCBhcyB3ZWxsLlxuICAgIC8vIFZhbGlkYXRlIHVzZXIgZGF0YS5cbiAgICBjb25zdCBjaGVja0JhdGNoQXhpcyA9IHRydWU7XG4gICAgY29uc3Qgc3RhbmRhcmRpemVkT3V0cyA9XG4gICAgICAgIHRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YVhZKHgsIHksIGNoZWNrQmF0Y2hBeGlzLCBiYXRjaFNpemUpO1xuICAgIHRyeSB7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBJZiB1c2VzIGB1c2VMZWFybmluZ1BoYXNlYCwgc2V0IHRoZSBjb3JyZXNwb25kaW5nIGVsZW1lbnRcbiAgICAgIC8vIG9mIHRoZSBpbnB1dCB0byAwLlxuICAgICAgY29uc3QgaW5zID0gc3RhbmRhcmRpemVkT3V0c1swXS5jb25jYXQoc3RhbmRhcmRpemVkT3V0c1sxXSk7XG4gICAgICB0aGlzLm1ha2VUZXN0RnVuY3Rpb24oKTtcbiAgICAgIGNvbnN0IGYgPSB0aGlzLnRlc3RGdW5jdGlvbjtcbiAgICAgIGNvbnN0IHRlc3RPdXRzID1cbiAgICAgICAgICB0aGlzLnRlc3RMb29wKGYsIGlucywgYmF0Y2hTaXplLCBhcmdzLnZlcmJvc2UsIGFyZ3Muc3RlcHMpO1xuICAgICAgcmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkodGVzdE91dHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBkaXNwb3NlTmV3VGVuc29ycyhzdGFuZGFyZGl6ZWRPdXRzWzBdLCB4KTtcbiAgICAgIGRpc3Bvc2VOZXdUZW5zb3JzKHN0YW5kYXJkaXplZE91dHNbMV0sIHkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIFRPRE8oY2Fpcyk6IEFkZCBjb2RlIHNuaXBwZXQgYmVsb3cgb25jZSByZWFsIGRhdGFzZXQgb2JqZWN0cyBhcmVcbiAgLy8gICBhdmFpbGFibGUuXG4gIC8qKlxuICAgKiBFdmFsdWF0ZSBtb2RlbCB1c2luZyBhIGRhdGFzZXQgb2JqZWN0LlxuICAgKlxuICAgKiBOb3RlOiBVbmxpa2UgYGV2YWx1YXRlKClgLCB0aGlzIG1ldGhvZCBpcyBhc3luY2hyb25vdXMgKGBhc3luY2ApO1xuICAgKlxuICAgKiBAcGFyYW0gZGF0YXNldCBBIGRhdGFzZXQgb2JqZWN0LiBJdHMgYGl0ZXJhdG9yKClgIG1ldGhvZCBpcyBleHBlY3RlZFxuICAgKiAgIHRvIGdlbmVyYXRlIGEgZGF0YXNldCBpdGVyYXRvciBvYmplY3QsIHRoZSBgbmV4dCgpYCBtZXRob2Qgb2Ygd2hpY2hcbiAgICogICBpcyBleHBlY3RlZCB0byBwcm9kdWNlIGRhdGEgYmF0Y2hlcyBmb3IgZXZhbHVhdGlvbi4gVGhlIHJldHVybiB2YWx1ZVxuICAgKiAgIG9mIHRoZSBgbmV4dCgpYCBjYWxsIG91Z2h0IHRvIGNvbnRhaW4gYSBib29sZWFuIGBkb25lYCBmaWVsZCBhbmQgYVxuICAgKiAgIGB2YWx1ZWAgZmllbGQuIFRoZSBgdmFsdWVgIGZpZWxkIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5IG9mIHR3b1xuICAgKiAgIGB0Zi5UZW5zb3JgcyBvciBhbiBhcnJheSBvZiB0d28gbmVzdGVkIGB0Zi5UZW5zb3JgIHN0cnVjdHVyZXMuIFRoZSBmb3JtZXJcbiAgICogICBjYXNlIGlzIGZvciBtb2RlbHMgd2l0aCBleGFjdGx5IG9uZSBpbnB1dCBhbmQgb25lIG91dHB1dCAoZS5nLi5cbiAgICogICBhIHNlcXVlbnRpYWwgbW9kZWwpLiBUaGUgbGF0dGVyIGNhc2UgaXMgZm9yIG1vZGVscyB3aXRoIG11bHRpcGxlXG4gICAqICAgaW5wdXRzIGFuZC9vciBtdWx0aXBsZSBvdXRwdXRzLiBPZiB0aGUgdHdvIGl0ZW1zIGluIHRoZSBhcnJheSwgdGhlXG4gICAqICAgZmlyc3QgaXMgdGhlIGlucHV0IGZlYXR1cmUocykgYW5kIHRoZSBzZWNvbmQgaXMgdGhlIG91dHB1dCB0YXJnZXQocykuXG4gICAqIEBwYXJhbSBhcmdzIEEgY29uZmlndXJhdGlvbiBvYmplY3QgZm9yIHRoZSBkYXRhc2V0LWJhc2VkIGV2YWx1YXRpb24uXG4gICAqIEByZXR1cm5zIExvc3MgYW5kIG1ldHJpYyB2YWx1ZXMgYXMgYW4gQXJyYXkgb2YgYFNjYWxhcmAgb2JqZWN0cy5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGFzeW5jIGV2YWx1YXRlRGF0YXNldChkYXRhc2V0OiBEYXRhc2V0PHt9PiwgYXJncz86IE1vZGVsRXZhbHVhdGVEYXRhc2V0QXJncyk6XG4gICAgICBQcm9taXNlPFNjYWxhcnxTY2FsYXJbXT4ge1xuICAgIHRoaXMubWFrZVRlc3RGdW5jdGlvbigpO1xuICAgIHJldHVybiBldmFsdWF0ZURhdGFzZXQodGhpcywgZGF0YXNldCwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogR2V0IG51bWJlciBvZiBzYW1wbGVzIHByb3ZpZGVkIGZvciB0cmFpbmluZywgZXZhbHVhdGlvbiBvciBwcmVkaWN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gaW5zIElucHV0IGB0Zi5UZW5zb3JgLlxuICAgKiBAcGFyYW0gYmF0Y2hTaXplIEludGVnZXIgYmF0Y2ggc2l6ZSwgb3B0aW9uYWwuXG4gICAqIEBwYXJhbSBzdGVwcyBUb3RhbCBudW1iZXIgb2Ygc3RlcHMgKGJhdGNoZXMgb2Ygc2FtcGxlcykgYmVmb3JlXG4gICAqIGRlY2xhcmluZyBsb29wIGZpbmlzaGVkLiBPcHRpb25hbC5cbiAgICogQHBhcmFtIHN0ZXBzTmFtZSBUaGUgcHVibGljIEFQSSdzIHBhcmFtZXRlciBuYW1lIGZvciBgc3RlcHNgLlxuICAgKiBAcmV0dXJucyBOdW1iZXIgb2Ygc2FtcGxlcyBwcm92aWRlZC5cbiAgICovXG4gIHByaXZhdGUgY2hlY2tOdW1TYW1wbGVzKFxuICAgICAgaW5zOiBUZW5zb3J8VGVuc29yW10sIGJhdGNoU2l6ZT86IG51bWJlciwgc3RlcHM/OiBudW1iZXIsXG4gICAgICBzdGVwc05hbWUgPSAnc3RlcHMnKTogbnVtYmVyIHtcbiAgICBsZXQgbnVtU2FtcGxlczogbnVtYmVyO1xuICAgIGlmIChzdGVwcyAhPSBudWxsKSB7XG4gICAgICBudW1TYW1wbGVzID0gbnVsbDtcbiAgICAgIGlmIChiYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBJZiAke3N0ZXBzTmFtZX0gaXMgc2V0LCBiYXRjaFNpemUgbXVzdCBiZSBudWxsIG9yIHVuZGVmaW5lZC5gICtcbiAgICAgICAgICAgIGBHb3QgYmF0Y2hTaXplID0gJHtiYXRjaFNpemV9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpbnMgIT0gbnVsbCkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoaW5zKSkge1xuICAgICAgICBudW1TYW1wbGVzID0gaW5zWzBdLnNoYXBlWzBdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbnVtU2FtcGxlcyA9IGlucy5zaGFwZVswXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYEVpdGhlciB0aGUgaW5wdXQgZGF0YSBzaG91bGQgaGF2ZSBhIGRlZmluZWQgc2hhcGUsIG9yIGAgK1xuICAgICAgICAgIGAke3N0ZXBzTmFtZX0gc2hvdWQgYmUgc3BlY2lmaWVkLmApO1xuICAgIH1cbiAgICByZXR1cm4gbnVtU2FtcGxlcztcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlIGludGVybmFsIHRlbnNvcnMgb2YgdGhlIG1vZGVsIHdpdGggaW5wdXQgZGF0YSBmZWVkLlxuICAgKiBAcGFyYW0gaW5wdXRzIElucHV0IGRhdGEgZmVlZC4gTXVzdCBtYXRjaCB0aGUgaW5wdXRzIG9mIHRoZSBtb2RlbC5cbiAgICogQHBhcmFtIG91dHB1dHMgTmFtZXMgb2YgdGhlIG91dHB1dCB0ZW5zb3JzIHRvIGJlIGZldGNoZWQuIE11c3QgbWF0Y2hcbiAgICogICBuYW1lcyBvZiB0aGUgU3ltYm9saWNUZW5zb3JzIHRoYXQgYmVsb25nIHRvIHRoZSBncmFwaC5cbiAgICogQHJldHVybnMgRmV0Y2hlZCB2YWx1ZXMgZm9yIGBvdXRwdXRzYC5cbiAgICovXG4gIGV4ZWN1dGUoaW5wdXRzOiBUZW5zb3J8VGVuc29yW118TmFtZWRUZW5zb3JNYXAsIG91dHB1dHM6IHN0cmluZ3xzdHJpbmdbXSk6XG4gICAgICBUZW5zb3J8VGVuc29yW10ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dHMpICYmIG91dHB1dHMubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnYG91dHB1dHNgIGlzIGFuIGVtcHR5IEFycmF5LCB3aGljaCBpcyBub3QgYWxsb3dlZC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBvdXRwdXRzSXNBcnJheSA9IEFycmF5LmlzQXJyYXkob3V0cHV0cyk7XG4gICAgY29uc3Qgb3V0cHV0TmFtZXMgPVxuICAgICAgICAob3V0cHV0c0lzQXJyYXkgPyBvdXRwdXRzIGFzIHN0cmluZ1tdIDogW291dHB1dHMgYXMgc3RyaW5nXSk7XG4gICAgY29uc3Qgb3V0cHV0U3ltYm9saWNUZW5zb3JzID0gdGhpcy5yZXRyaWV2ZVN5bWJvbGljVGVuc29ycyhvdXRwdXROYW1lcyk7XG5cbiAgICAvLyBGb3JtYXQgdGhlIGlucHV0IGludG8gYSBGZWVkRGljdC5cbiAgICBjb25zdCBmZWVkRGljdCA9IG5ldyBGZWVkRGljdCgpO1xuICAgIGlmIChpbnB1dHMgaW5zdGFuY2VvZiBUZW5zb3IpIHtcbiAgICAgIGlucHV0cyA9IFtpbnB1dHNdO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gdGhpcy5pbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYFRoZSBudW1iZXIgb2YgaW5wdXRzIHByb3ZpZGVkICgke2lucHV0cy5sZW5ndGh9KSBgICtcbiAgICAgICAgICAgIGBkb2VzIG5vdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGlucHV0cyBvZiB0aGlzIG1vZGVsIGAgK1xuICAgICAgICAgICAgYCgke3RoaXMuaW5wdXRzLmxlbmd0aH0pLmApO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBmZWVkRGljdC5hZGQodGhpcy5pbnB1dHNbaV0sIGlucHV0c1tpXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAoY29uc3QgaW5wdXQgb2YgdGhpcy5pbnB1dHMpIHtcbiAgICAgICAgY29uc3QgdGVuc29yVmFsdWUgPSBpbnB1dHNbaW5wdXQubmFtZV07XG4gICAgICAgIGlmICh0ZW5zb3JWYWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgIGBObyB2YWx1ZSBpcyBwcm92aWRlZCBmb3IgdGhlIG1vZGVsJ3MgaW5wdXQgJHtpbnB1dC5uYW1lfWApO1xuICAgICAgICB9XG4gICAgICAgIGZlZWREaWN0LmFkZChpbnB1dCwgdGVuc29yVmFsdWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJ1biBleGVjdXRpb24uXG4gICAgY29uc3QgZXhlY3V0ZU91dHB1dHMgPSBleGVjdXRlKG91dHB1dFN5bWJvbGljVGVuc29ycywgZmVlZERpY3QpIGFzIFRlbnNvcltdO1xuICAgIHJldHVybiBvdXRwdXRzSXNBcnJheSA/IGV4ZWN1dGVPdXRwdXRzIDogZXhlY3V0ZU91dHB1dHNbMF07XG4gIH1cblxuICAvKipcbiAgICogUmV0cmlldmUgdGhlIG1vZGVsJ3MgaW50ZXJuYWwgc3ltYm9saWMgdGVuc29ycyBmcm9tIHN5bWJvbGljLXRlbnNvciBuYW1lcy5cbiAgICovXG4gIHByaXZhdGUgcmV0cmlldmVTeW1ib2xpY1RlbnNvcnMoc3ltYm9saWNUZW5zb3JOYW1lczogc3RyaW5nW10pOlxuICAgICAgU3ltYm9saWNUZW5zb3JbXSB7XG4gICAgY29uc3Qgb3V0cHV0U3ltYm9saWNUZW5zb3JzOiBTeW1ib2xpY1RlbnNvcltdID1cbiAgICAgICAgcHlMaXN0UmVwZWF0KG51bGwsIHN5bWJvbGljVGVuc29yTmFtZXMubGVuZ3RoKTtcbiAgICBsZXQgb3V0cHV0c1JlbWFpbmluZyA9IHN5bWJvbGljVGVuc29yTmFtZXMubGVuZ3RoO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy5sYXllcnMpIHtcbiAgICAgIGNvbnN0IGxheWVyT3V0cHV0czogU3ltYm9saWNUZW5zb3JbXSA9XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShsYXllci5vdXRwdXQpID8gbGF5ZXIub3V0cHV0IDogW2xheWVyLm91dHB1dF07XG4gICAgICBjb25zdCBsYXllck91dHB1dE5hbWVzID0gbGF5ZXJPdXRwdXRzLm1hcChvdXRwdXQgPT4gb3V0cHV0Lm5hbWUpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzeW1ib2xpY1RlbnNvck5hbWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbGF5ZXJPdXRwdXROYW1lcy5pbmRleE9mKHN5bWJvbGljVGVuc29yTmFtZXNbaV0pO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgb3V0cHV0U3ltYm9saWNUZW5zb3JzW2ldID0gbGF5ZXJPdXRwdXRzW2luZGV4XTtcbiAgICAgICAgICBvdXRwdXRzUmVtYWluaW5nLS07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG91dHB1dHNSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG91dHB1dHNSZW1haW5pbmcgPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG91dHB1dHNSZW1haW5pbmcgPiAwKSB7XG4gICAgICBjb25zdCByZW1haW5pbmdOYW1lczogc3RyaW5nW10gPSBbXTtcbiAgICAgIG91dHB1dFN5bWJvbGljVGVuc29ycy5mb3JFYWNoKCh0ZW5zb3IsIGkpID0+IHtcbiAgICAgICAgaWYgKHRlbnNvciA9PSBudWxsKSB7XG4gICAgICAgICAgcmVtYWluaW5nTmFtZXMucHVzaChzeW1ib2xpY1RlbnNvck5hbWVzW2ldKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgQ2Fubm90IGZpbmQgU3ltYm9saWNUZW5zb3JzIGZvciBvdXRwdXQgbmFtZShzKTogYCArXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkocmVtYWluaW5nTmFtZXMpfWApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0U3ltYm9saWNUZW5zb3JzO1xuICB9XG5cbiAgLyoqXG4gICAqIEhlbHBlciBtZXRob2QgdG8gbG9vcCBvdmVyIHNvbWUgZGF0YSBpbiBiYXRjaGVzLlxuICAgKlxuICAgKiBQb3J0aW5nIE5vdGU6IE5vdCB1c2luZyB0aGUgZnVuY3Rpb25hbCBhcHByb2FjaCBpbiB0aGUgUHl0aG9uIGVxdWl2YWxlbnRcbiAgICogICBkdWUgdG8gdGhlIGltcGVyYXRpdmUgYmFja2VuZC5cbiAgICogUG9ydGluZyBOb3RlOiBEb2VzIG5vdCBzdXBwb3J0IHN0ZXAgbW9kZSBjdXJyZW50bHkuXG4gICAqXG4gICAqIEBwYXJhbSBpbnM6IGlucHV0IGRhdGFcbiAgICogQHBhcmFtIGJhdGNoU2l6ZTogaW50ZWdlciBiYXRjaCBzaXplLlxuICAgKiBAcGFyYW0gdmVyYm9zZTogdmVyYm9zaXR5IG1vZGVsXG4gICAqIEByZXR1cm5zOiBQcmVkaWN0aW9ucyBhcyBgdGYuVGVuc29yYCAoaWYgYSBzaW5nbGUgb3V0cHV0KSBvciBhbiBgQXJyYXlgIG9mXG4gICAqICAgYHRmLlRlbnNvcmAgKGlmIG11bHRpcGUgb3V0cHV0cykuXG4gICAqL1xuICBwcml2YXRlIHByZWRpY3RMb29wKGluczogVGVuc29yfFRlbnNvcltdLCBiYXRjaFNpemUgPSAzMiwgdmVyYm9zZSA9IGZhbHNlKTpcbiAgICAgIFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRmYy50aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IG51bVNhbXBsZXMgPSB0aGlzLmNoZWNrTnVtU2FtcGxlcyhpbnMpO1xuICAgICAgaWYgKHZlcmJvc2UpIHtcbiAgICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgICAnVmVyYm9zZSBwcmVkaWN0TG9vcCgpIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNhbXBsZS1iYXNlZCBwcmVkaWN0aW9ucy5cbiAgICAgIC8vIFBvcnRpbmcgTm90ZTogVGVuc29yIGN1cnJlbnRseSBkb2VzIG5vdCBzdXBwb3J0IHNsaWNlZCBhc3NpZ25tZW50cyBhc1xuICAgICAgLy8gICBpbiBudW1weSwgZS5nLiwgeFsxOjNdID0geS4gVGhlcmVmb3JlIHdlIHVzZSBjb25jYXRlbmF0aW9uIHdoaWxlXG4gICAgICAvLyAgIGl0ZXJhdGluZyBvdmVyIHRoZSBiYXRjaGVzLlxuXG4gICAgICBjb25zdCBiYXRjaGVzID0gbWFrZUJhdGNoZXMobnVtU2FtcGxlcywgYmF0Y2hTaXplKTtcbiAgICAgIGNvbnN0IG91dHNCYXRjaGVzOiBUZW5zb3JbXVtdID0gdGhpcy5vdXRwdXRzLm1hcChvdXRwdXQgPT4gW10pO1xuXG4gICAgICAvLyBUT0RPKGNhaXMpOiBDYW4gdGhlIHNjb3BlKCkgYmUgcHVzaGVkIGRvd24gaW5zaWRlIHRoZSBmb3IgbG9vcD9cbiAgICAgIGZvciAobGV0IGJhdGNoSW5kZXggPSAwOyBiYXRjaEluZGV4IDwgYmF0Y2hlcy5sZW5ndGg7ICsrYmF0Y2hJbmRleCkge1xuICAgICAgICBjb25zdCBiYXRjaE91dHMgPSB0ZmMudGlkeSgoKSA9PiB7XG4gICAgICAgICAgY29uc3QgYmF0Y2hTdGFydCA9IGJhdGNoZXNbYmF0Y2hJbmRleF1bMF07XG4gICAgICAgICAgY29uc3QgYmF0Y2hFbmQgPSBiYXRjaGVzW2JhdGNoSW5kZXhdWzFdO1xuICAgICAgICAgIC8vIFRPRE8oY2Fpcyk6IFRha2UgY2FyZSBvZiB0aGUgY2FzZSBvZiB0aGUgbGFzdCBlbGVtZW50IGlzIGEgZmxhZyBmb3JcbiAgICAgICAgICAvLyAgIHRyYWluaW5nL3Rlc3QuXG4gICAgICAgICAgY29uc3QgaW5zQmF0Y2ggPSBzbGljZUFycmF5cyhpbnMsIGJhdGNoU3RhcnQsIGJhdGNoRW5kKTtcblxuICAgICAgICAgIC8vIENvbnN0cnVjdCB0aGUgZmVlZHMgZm9yIGV4ZWN1dGUoKTtcbiAgICAgICAgICBjb25zdCBmZWVkcyA9IFtdO1xuICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGluc0JhdGNoKSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnNCYXRjaC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICBmZWVkcy5wdXNoKHtrZXk6IHRoaXMuaW5wdXRzW2ldLCB2YWx1ZTogaW5zQmF0Y2hbaV19KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmVlZHMucHVzaCh7a2V5OiB0aGlzLmlucHV0c1swXSwgdmFsdWU6IGluc0JhdGNofSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZlZWREaWN0ID0gbmV3IEZlZWREaWN0KGZlZWRzKTtcbiAgICAgICAgICByZXR1cm4gZXhlY3V0ZSh0aGlzLm91dHB1dHMsIGZlZWREaWN0KSBhcyBUZW5zb3JbXTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJhdGNoT3V0cy5mb3JFYWNoKChiYXRjaE91dCwgaSkgPT4gb3V0c0JhdGNoZXNbaV0ucHVzaChiYXRjaE91dCkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkoXG4gICAgICAgICAgb3V0c0JhdGNoZXMubWFwKGJhdGNoZXMgPT4gdGZjLmNvbmNhdChiYXRjaGVzLCAwKSkpO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBvdXRwdXQgcHJlZGljdGlvbnMgZm9yIHRoZSBpbnB1dCBzYW1wbGVzLlxuICAgKlxuICAgKiBDb21wdXRhdGlvbiBpcyBkb25lIGluIGJhdGNoZXMuXG4gICAqXG4gICAqIE5vdGU6IHRoZSBcInN0ZXBcIiBtb2RlIG9mIHByZWRpY3QoKSBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cbiAgICogICBUaGlzIGlzIGJlY2F1c2UgdGhlIFRlbnNvckZsb3cuanMgY29yZSBiYWNrZW5kIGlzIGltcGVyYXRpdmUgb25seS5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKHtcbiAgICogICBsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbMTBdfSldXG4gICAqIH0pO1xuICAgKiBtb2RlbC5wcmVkaWN0KHRmLm9uZXMoWzgsIDEwXSksIHtiYXRjaFNpemU6IDR9KS5wcmludCgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHggVGhlIGlucHV0IGRhdGEsIGFzIGEgVGVuc29yLCBvciBhbiBgQXJyYXlgIG9mIGB0Zi5UZW5zb3JgcyBpZlxuICAgKiAgIHRoZSBtb2RlbCBoYXMgbXVsdGlwbGUgaW5wdXRzLlxuICAgKiBAcGFyYW0gYXJncyBBIGBNb2RlbFByZWRpY3RBcmdzYCBvYmplY3QgY29udGFpbmluZyBvcHRpb25hbCBmaWVsZHMuXG4gICAqXG4gICAqIEByZXR1cm4gUHJlZGljdGlvbiByZXN1bHRzIGFzIGEgYHRmLlRlbnNvcmAocykuXG4gICAqXG4gICAqIEBleGNlcHRpb24gVmFsdWVFcnJvciBJbiBjYXNlIG9mIG1pc21hdGNoIGJldHdlZW4gdGhlIHByb3ZpZGVkIGlucHV0IGRhdGFcbiAgICogICBhbmQgdGhlIG1vZGVsJ3MgZXhwZWN0YXRpb25zLCBvciBpbiBjYXNlIGEgc3RhdGVmdWwgbW9kZWwgcmVjZWl2ZXMgYVxuICAgKiAgIG51bWJlciBvZiBzYW1wbGVzIHRoYXQgaXMgbm90IGEgbXVsdGlwbGUgb2YgdGhlIGJhdGNoIHNpemUuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBwcmVkaWN0KHg6IFRlbnNvcnxUZW5zb3JbXSwgYXJnczogTW9kZWxQcmVkaWN0QXJncyA9IHt9KTogVGVuc29yfFRlbnNvcltdIHtcbiAgICBjb25zdCB4c1JhbmsyT3JIaWdoZXIgPSBlbnN1cmVUZW5zb3JzUmFuazJPckhpZ2hlcih4KTtcbiAgICBjaGVja0lucHV0RGF0YShcbiAgICAgICAgeHNSYW5rMk9ySGlnaGVyLCB0aGlzLmlucHV0TmFtZXMsIHRoaXMuZmVlZElucHV0U2hhcGVzLCBmYWxzZSk7XG4gICAgdHJ5IHtcbiAgICAgIC8vIFRPRE8oY2Fpcyk6IFRha2UgY2FyZSBvZiBzdGF0ZWZ1bCBtb2RlbHMuXG4gICAgICAvLyAgIGlmICh0aGlzLnN0YXRlZnVsKSAuLi5cbiAgICAgIC8vIFRPRE8oY2Fpcyk6IFRha2UgY2FyZSBvZiB0aGUgbGVhcm5pbmdfcGhhc2UgYm9vbGVhbiBmbGFnLlxuICAgICAgLy8gICBpZiAodGhpcy51c2VMZWFybmluZ1BoYXNlKSAuLi5cbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGFyZ3MuYmF0Y2hTaXplID09IG51bGwgPyAzMiA6IGFyZ3MuYmF0Y2hTaXplO1xuICAgICAgY2hlY2tCYXRjaFNpemUoYmF0Y2hTaXplKTtcbiAgICAgIHJldHVybiB0aGlzLnByZWRpY3RMb29wKHhzUmFuazJPckhpZ2hlciwgYmF0Y2hTaXplKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgZGlzcG9zZU5ld1RlbnNvcnMoeHNSYW5rMk9ySGlnaGVyLCB4KTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwcmVkaWN0aW9ucyBmb3IgYSBzaW5nbGUgYmF0Y2ggb2Ygc2FtcGxlcy5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKHtcbiAgICogICBsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbMTBdfSldXG4gICAqIH0pO1xuICAgKiBtb2RlbC5wcmVkaWN0T25CYXRjaCh0Zi5vbmVzKFs4LCAxMF0pKS5wcmludCgpO1xuICAgKiBgYGBcbiAgICogQHBhcmFtIHg6IElucHV0IHNhbXBsZXMsIGFzIGEgVGVuc29yIChmb3IgbW9kZWxzIHdpdGggZXhhY3RseSBvbmVcbiAgICogICBpbnB1dCkgb3IgYW4gYXJyYXkgb2YgVGVuc29ycyAoZm9yIG1vZGVscyB3aXRoIG1vcmUgdGhhbiBvbmUgaW5wdXQpLlxuICAgKiBAcmV0dXJuIFRlbnNvcihzKSBvZiBwcmVkaWN0aW9uc1xuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgcHJlZGljdE9uQmF0Y2goeDogVGVuc29yfFRlbnNvcltdKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICBjaGVja0lucHV0RGF0YSh4LCB0aGlzLmlucHV0TmFtZXMsIHRoaXMuZmVlZElucHV0U2hhcGVzLCB0cnVlKTtcbiAgICAvLyBUT0RPKGNhaXMpOiBUYWtlIGNhcmUgb2YgdGhlIGxlYXJuaW5nX3BoYXNlIGJvb2xlYW4gZmxhZy5cbiAgICAvLyAgIGlmICh0aGlzLnVzZUxlYXJuaW5nUGhhc2UpIC4uLlxuICAgIGNvbnN0IGJhdGNoU2l6ZSA9IChBcnJheS5pc0FycmF5KHgpID8geFswXSA6IHgpLnNoYXBlWzBdO1xuICAgIHJldHVybiB0aGlzLnByZWRpY3RMb29wKHgsIGJhdGNoU2l6ZSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhbmRhcmRpemVVc2VyRGF0YVhZKFxuICAgICAgeDogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LFxuICAgICAgeTogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LCBjaGVja0JhdGNoQXhpcyA9IHRydWUsXG4gICAgICBiYXRjaFNpemU/OiBudW1iZXIpOiBbVGVuc29yW10sIFRlbnNvcltdXSB7XG4gICAgLy8gVE9ETyhjYWlzKTogQWRkIHNhbXBsZVdlaWdodCwgY2xhc3NXZWlnaHRcbiAgICBpZiAodGhpcy5vcHRpbWl6ZXJfID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgJ1lvdSBtdXN0IGNvbXBpbGUgYSBtb2RlbCBiZWZvcmUgdHJhaW5pbmcvdGVzdGluZy4gVXNlICcgK1xuICAgICAgICAgICdMYXllcnNNb2RlbC5jb21waWxlKG1vZGVsQ29tcGlsZUFyZ3MpLicpO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXRTaGFwZXM6IFNoYXBlW10gPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuZmVlZE91dHB1dFNoYXBlcy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgb3V0cHV0U2hhcGUgPSB0aGlzLmZlZWRPdXRwdXRTaGFwZXNbaV07XG4gICAgICBjb25zdCBsb3NzRm4gPSB0aGlzLmZlZWRMb3NzRm5zW2ldO1xuICAgICAgaWYgKGxvc3NGbiA9PT0gbG9zc2VzLnNwYXJzZUNhdGVnb3JpY2FsQ3Jvc3NlbnRyb3B5KSB7XG4gICAgICAgIG91dHB1dFNoYXBlcy5wdXNoKFxuICAgICAgICAgICAgb3V0cHV0U2hhcGUuc2xpY2UoMCwgb3V0cHV0U2hhcGUubGVuZ3RoIC0gMSkuY29uY2F0KFsxXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUG9ydGluZyBOb3RlOiBCZWNhdXNlIG9mIHN0cm9uZyB0eXBpbmcgYGxvc3NGbmAgbXVzdCBiZSBhIGZ1bmN0aW9uLlxuICAgICAgICBvdXRwdXRTaGFwZXMucHVzaChvdXRwdXRTaGFwZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHggPSBzdGFuZGFyZGl6ZUlucHV0RGF0YShcbiAgICAgICAgeCwgdGhpcy5mZWVkSW5wdXROYW1lcywgdGhpcy5mZWVkSW5wdXRTaGFwZXMsIGZhbHNlLCAnaW5wdXQnKTtcbiAgICB5ID0gc3RhbmRhcmRpemVJbnB1dERhdGEoXG4gICAgICAgIHksIHRoaXMuZmVlZE91dHB1dE5hbWVzLCBvdXRwdXRTaGFwZXMsIGZhbHNlLCAndGFyZ2V0Jyk7XG4gICAgLy8gVE9ETyhjYWlzKTogU3RhbmRhcmRpemUgc2FtcGxlV2VpZ2h0cyAmIGNsYXNzV2VpZ2h0cy5cbiAgICBjaGVja0FycmF5TGVuZ3Rocyh4LCB5LCBudWxsKTtcbiAgICAvLyBUT0RPKGNhaXMpOiBDaGVjayBzYW1wbGVXZWlnaHRzIGFzIHdlbGwuXG4gICAgY2hlY2tMb3NzQW5kVGFyZ2V0Q29tcGF0aWJpbGl0eSh5LCB0aGlzLmZlZWRMb3NzRm5zLCB0aGlzLmZlZWRPdXRwdXRTaGFwZXMpO1xuICAgIGlmICh0aGlzLnN0YXRlZnVsICYmIGJhdGNoU2l6ZSAhPSBudWxsICYmIGJhdGNoU2l6ZSA+IDApIHtcbiAgICAgIGlmICh4WzBdLnNoYXBlWzBdICUgYmF0Y2hTaXplICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYEluIGEgc3RhdGVmdWwgbmV0d29yaywgeW91IHNob3VsZCBvbmx5IHBhc3MgaW5wdXRzIHdpdGggYSBgICtcbiAgICAgICAgICAgIGBudW1iZXIgb2Ygc2FtcGxlcyB0aGF0IGlzIGRpdmlzaWJsZSBieSB0aGUgYmF0Y2ggc2l6ZSBgICtcbiAgICAgICAgICAgIGAke2JhdGNoU2l6ZX0uIEZvdW5kOiAke3hbMF0uc2hhcGVbMF19IHNhbXBsZShzKS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFt4LCB5XTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhc3luYyBzdGFuZGFyZGl6ZVVzZXJEYXRhKFxuICAgICAgeDogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LFxuICAgICAgeTogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LFxuICAgICAgc2FtcGxlV2VpZ2h0PzogVGVuc29yfFRlbnNvcltdfHtbb3V0cHV0TmFtZTogc3RyaW5nXTogVGVuc29yfSxcbiAgICAgIGNsYXNzV2VpZ2h0PzogQ2xhc3NXZWlnaHR8Q2xhc3NXZWlnaHRbXXxDbGFzc1dlaWdodE1hcCxcbiAgICAgIGNoZWNrQmF0Y2hBeGlzID0gdHJ1ZSxcbiAgICAgIGJhdGNoU2l6ZT86IG51bWJlcik6IFByb21pc2U8W1RlbnNvcltdLCBUZW5zb3JbXSwgVGVuc29yW11dPiB7XG4gICAgY29uc3QgW3N0YW5kYXJkWHMsIHN0YW5kYXJkWXNdID1cbiAgICAgICAgdGhpcy5zdGFuZGFyZGl6ZVVzZXJEYXRhWFkoeCwgeSwgY2hlY2tCYXRjaEF4aXMsIGJhdGNoU2l6ZSk7XG4gICAgLy8gVE9ETyhjYWlzKTogSGFuZGxlIHNhbXBsZVdlaWdodHMuXG4gICAgaWYgKHNhbXBsZVdlaWdodCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ3NhbXBsZSB3ZWlnaHQgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgfVxuXG4gICAgbGV0IHN0YW5kYXJkU2FtcGxlV2VpZ2h0czogVGVuc29yW10gPSBudWxsO1xuICAgIGlmIChjbGFzc1dlaWdodCAhPSBudWxsKSB7XG4gICAgICBjb25zdCBjbGFzc1dlaWdodHMgPVxuICAgICAgICAgIHN0YW5kYXJkaXplQ2xhc3NXZWlnaHRzKGNsYXNzV2VpZ2h0LCB0aGlzLm91dHB1dE5hbWVzKTtcbiAgICAgIHN0YW5kYXJkU2FtcGxlV2VpZ2h0cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjbGFzc1dlaWdodHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgc3RhbmRhcmRTYW1wbGVXZWlnaHRzLnB1c2goXG4gICAgICAgICAgICBhd2FpdCBzdGFuZGFyZGl6ZVdlaWdodHMoc3RhbmRhcmRZc1tpXSwgbnVsbCwgY2xhc3NXZWlnaHRzW2ldKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVE9ETyhjYWlzKTogRGVhbCB3aXRoIHRoZSBjYXNlIG9mIG1vZGVsLnN0YXRlZnVsID09IHRydWUuXG4gICAgcmV0dXJuIFtzdGFuZGFyZFhzLCBzdGFuZGFyZFlzLCBzdGFuZGFyZFNhbXBsZVdlaWdodHNdO1xuICB9XG5cbiAgLyoqXG4gICAqIExvb3Agb3ZlciBzb21lIHRlc3QgZGF0YSBpbiBiYXRjaGVzLlxuICAgKiBAcGFyYW0gZiBBIEZ1bmN0aW9uIHJldHVybmluZyBhIGxpc3Qgb2YgdGVuc29ycy5cbiAgICogQHBhcmFtIGlucyBBcnJheSBvZiB0ZW5zb3JzIHRvIGJlIGZlZCB0byBgZmAuXG4gICAqIEBwYXJhbSBiYXRjaFNpemUgSW50ZWdlciBiYXRjaCBzaXplIG9yIGBudWxsYCAvIGB1bmRlZmluZWRgLlxuICAgKiBAcGFyYW0gdmVyYm9zZSB2ZXJib3NpdHkgbW9kZS5cbiAgICogQHBhcmFtIHN0ZXBzIFRvdGFsIG51bWJlciBvZiBzdGVwcyAoYmF0Y2hlcyBvZiBzYW1wbGVzKSBiZWZvcmVcbiAgICogZGVjbGFyaW5nIHRlc3QgZmluaXNoZWQuIElnbm9yZWQgd2l0aCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBgbnVsbGAgL1xuICAgKiBgdW5kZWZpbmVkYC5cbiAgICogQHJldHVybnMgQXJyYXkgb2YgU2NhbGFycy5cbiAgICovXG4gIHByaXZhdGUgdGVzdExvb3AoXG4gICAgICBmOiAoZGF0YTogVGVuc29yW10pID0+IFNjYWxhcltdLCBpbnM6IFRlbnNvcltdLCBiYXRjaFNpemU/OiBudW1iZXIsXG4gICAgICB2ZXJib3NlID0gMCwgc3RlcHM/OiBudW1iZXIpOiBTY2FsYXJbXSB7XG4gICAgcmV0dXJuIHRmYy50aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IG51bVNhbXBsZXMgPSB0aGlzLmNoZWNrTnVtU2FtcGxlcyhpbnMsIGJhdGNoU2l6ZSwgc3RlcHMsICdzdGVwcycpO1xuICAgICAgY29uc3Qgb3V0czogU2NhbGFyW10gPSBbXTtcbiAgICAgIGlmICh2ZXJib3NlID4gMCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcignVmVyYm9zZSBtb2RlIGlzIG5vdCBpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPKGNhaXMpOiBVc2UgYGluZGljZXNGb3JDb252ZXJzaW9uVG9EZW5zZScgdG8gcHJldmVudCBzbG93IGRvd24uXG4gICAgICBpZiAoc3RlcHMgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAgICdzdGVwcyBtb2RlIGluIHRlc3RMb29wKCkgaXMgbm90IGltcGxlbWVudGVkIHlldCcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYmF0Y2hlcyA9IG1ha2VCYXRjaGVzKG51bVNhbXBsZXMsIGJhdGNoU2l6ZSk7XG4gICAgICAgIGNvbnN0IGluZGV4QXJyYXkgPSB0ZW5zb3IxZChyYW5nZSgwLCBudW1TYW1wbGVzKSk7XG4gICAgICAgIGZvciAobGV0IGJhdGNoSW5kZXggPSAwOyBiYXRjaEluZGV4IDwgYmF0Y2hlcy5sZW5ndGg7ICsrYmF0Y2hJbmRleCkge1xuICAgICAgICAgIGNvbnN0IGJhdGNoU3RhcnQgPSBiYXRjaGVzW2JhdGNoSW5kZXhdWzBdO1xuICAgICAgICAgIGNvbnN0IGJhdGNoRW5kID0gYmF0Y2hlc1tiYXRjaEluZGV4XVsxXTtcbiAgICAgICAgICBjb25zdCBiYXRjaElkcyA9XG4gICAgICAgICAgICAgIEsuc2xpY2VBbG9uZ0ZpcnN0QXhpcyhcbiAgICAgICAgICAgICAgICAgIGluZGV4QXJyYXksIGJhdGNoU3RhcnQsIGJhdGNoRW5kIC0gYmF0Y2hTdGFydCkgYXMgVGVuc29yMUQ7XG4gICAgICAgICAgLy8gVE9ETyhjYWlzKTogSW4gaW5zLCB0cmFpbiBmbGFnIGNhbiBiZSBhIG51bWJlciwgaW5zdGVhZCBvZiBhblxuICAgICAgICAgIC8vICAgVGVuc29yPyBEbyB3ZSBuZWVkIHRvIGhhbmRsZSB0aGlzIGluIHRmanMtbGF5ZXJzP1xuICAgICAgICAgIGNvbnN0IGluc0JhdGNoID0gc2xpY2VBcnJheXNCeUluZGljZXMoaW5zLCBiYXRjaElkcykgYXMgU2NhbGFyW107XG4gICAgICAgICAgY29uc3QgYmF0Y2hPdXRzID0gZihpbnNCYXRjaCk7XG4gICAgICAgICAgaWYgKGJhdGNoSW5kZXggPT09IDApIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmF0Y2hPdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgIG91dHMucHVzaChzY2FsYXIoMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGJhdGNoT3V0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYmF0Y2hPdXQgPSBiYXRjaE91dHNbaV07XG4gICAgICAgICAgICBvdXRzW2ldID1cbiAgICAgICAgICAgICAgICB0ZmMuYWRkKG91dHNbaV0sIHRmYy5tdWwoYmF0Y2hFbmQgLSBiYXRjaFN0YXJ0LCBiYXRjaE91dCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBvdXRzW2ldID0gdGZjLmRpdihvdXRzW2ldLCBudW1TYW1wbGVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHM7XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0RGVkdXBlZE1ldHJpY3NOYW1lcygpOiBzdHJpbmdbXSB7XG4gICAgY29uc3Qgb3V0TGFiZWxzID0gdGhpcy5tZXRyaWNzTmFtZXM7XG4gICAgLy8gUmVuYW1lIGR1cGxpY2F0ZWQgbWV0cmljcyBuYW1lcyAoY2FuIGhhcHBlbiB3aXRoIGFuIG91dHB1dCBsYXllclxuICAgIC8vIHNoYXJlZCBhbW9uZyBtdWx0aXBsZSBkYXRhZmxvd3MpLlxuICAgIGNvbnN0IGRlZHVwZWRPdXRMYWJlbHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG91dExhYmVscy5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgbGFiZWwgPSBvdXRMYWJlbHNbaV07XG4gICAgICBsZXQgbmV3TGFiZWwgPSBsYWJlbDtcbiAgICAgIGlmIChjb3VudChvdXRMYWJlbHMsIGxhYmVsKSA+IDEpIHtcbiAgICAgICAgY29uc3QgZHVwSW5kZXggPSBjb3VudChvdXRMYWJlbHMuc2xpY2UoMCwgaSksIGxhYmVsKTtcbiAgICAgICAgbmV3TGFiZWwgKz0gYF8ke2R1cEluZGV4fWA7XG4gICAgICB9XG4gICAgICBkZWR1cGVkT3V0TGFiZWxzLnB1c2gobmV3TGFiZWwpO1xuICAgIH1cbiAgICByZXR1cm4gZGVkdXBlZE91dExhYmVscztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyB0aGUgZm9sbG93aW5nIGFjdGlvbnM6XG4gICAqXG4gICAqIDEuIGNvbXB1dGVzIHRoZSBsb3NzZXNcbiAgICogMi4gc3VtcyB0aGVtIHRvIGdldCB0aGUgdG90YWwgbG9zc1xuICAgKiAzLiBjYWxsIHRoZSBvcHRpbWl6ZXIgY29tcHV0ZXMgdGhlIGdyYWRpZW50cyBvZiB0aGUgTGF5ZXJzTW9kZWwnc1xuICAgKiAgICB0cmFpbmFibGUgd2VpZ2h0cyB3LnIudC4gdGhlIHRvdGFsIGxvc3MgYW5kIHVwZGF0ZSB0aGUgdmFyaWFibGVzXG4gICAqIDQuIGNhbGN1bGF0ZXMgdGhlIG1ldHJpY3NcbiAgICogNS4gcmV0dXJucyB0aGUgdmFsdWVzIG9mIHRoZSBsb3NzZXMgYW5kIG1ldHJpY3MuXG4gICAqL1xuICBwcm90ZWN0ZWQgbWFrZVRyYWluRnVuY3Rpb24oKTogKGRhdGE6IFRlbnNvcltdKSA9PiBTY2FsYXJbXSB7XG4gICAgcmV0dXJuIChkYXRhOiBUZW5zb3JbXSkgPT4ge1xuICAgICAgY29uc3QgbG9zc1ZhbHVlczogU2NhbGFyW10gPSBbXTtcblxuICAgICAgY29uc3QgaW5wdXRzID0gZGF0YS5zbGljZSgwLCB0aGlzLmlucHV0cy5sZW5ndGgpO1xuICAgICAgY29uc3QgdGFyZ2V0cyA9IGRhdGEuc2xpY2UoXG4gICAgICAgICAgdGhpcy5pbnB1dHMubGVuZ3RoLCB0aGlzLmlucHV0cy5sZW5ndGggKyB0aGlzLm91dHB1dHMubGVuZ3RoKTtcbiAgICAgIGNvbnN0IHNhbXBsZVdlaWdodHMgPSBkYXRhLnNsaWNlKFxuICAgICAgICAgIHRoaXMuaW5wdXRzLmxlbmd0aCArIHRoaXMub3V0cHV0cy5sZW5ndGgsXG4gICAgICAgICAgdGhpcy5pbnB1dHMubGVuZ3RoICsgdGhpcy5vdXRwdXRzLmxlbmd0aCAqIDIpO1xuXG4gICAgICBjb25zdCBtZXRyaWNzVmFsdWVzOiBTY2FsYXJbXSA9IFtdO1xuXG4gICAgICAvLyBDcmVhdGUgYSBmdW5jdGlvbiB0aGF0IGNvbXB1dGVzIHRoZSB0b3RhbCBsb3NzIGJhc2VkIG9uIHRoZVxuICAgICAgLy8gaW5wdXRzLiBUaGlzIGZ1bmN0aW9uIGlzIHVzZWQgZm9yIG9idGFpbmluZyBncmFkaWVudHMgdGhyb3VnaFxuICAgICAgLy8gYmFja3Byb3AuXG4gICAgICBjb25zdCB0b3RhbExvc3NGdW5jdGlvbiA9ICgpID0+IHtcbiAgICAgICAgY29uc3QgZmVlZHMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGZlZWRzLnB1c2goe2tleTogdGhpcy5pbnB1dHNbaV0sIHZhbHVlOiBpbnB1dHNbaV19KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmZWVkRGljdCA9IG5ldyBGZWVkRGljdChmZWVkcyk7XG4gICAgICAgIGNvbnN0IG91dHB1dHMgPVxuICAgICAgICAgICAgZXhlY3V0ZSh0aGlzLm91dHB1dHMsIGZlZWREaWN0LCB7J3RyYWluaW5nJzogdHJ1ZX0pIGFzIFRlbnNvcltdO1xuICAgICAgICAvLyBUT0RPKGNhaXMpOiBUYWtlIGNhcmUgb2YgdGhlIGNhc2Ugb2YgbXVsdGlwbGUgb3V0cHV0cyBmcm9tIGFcbiAgICAgICAgLy8gICBzaW5nbGUgbGF5ZXI/XG5cbiAgICAgICAgbGV0IHRvdGFsTG9zczogVGVuc29yO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9zc0Z1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGxvc3NGdW5jdGlvbiA9IHRoaXMubG9zc0Z1bmN0aW9uc1tpXTtcbiAgICAgICAgICBsZXQgbG9zcyA9IGxvc3NGdW5jdGlvbih0YXJnZXRzW2ldLCBvdXRwdXRzW2ldKTtcbiAgICAgICAgICBpZiAoc2FtcGxlV2VpZ2h0c1tpXSAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb3NzID0gY29tcHV0ZVdlaWdodGVkTG9zcyhsb3NzLCBzYW1wbGVXZWlnaHRzW2ldKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBwdXNoIFNjYWxhciBpbnN0ZWFkLlxuICAgICAgICAgIGNvbnN0IG1lYW5Mb3NzOiBTY2FsYXIgPSB0ZmMubWVhbihsb3NzKTtcbiAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBVc2UgYSBzY29wZSgpIGluc3RlYWQsIHRvIGF2b2lkIG93bmVyc2hpcC5cbiAgICAgICAgICBsb3NzVmFsdWVzLnB1c2gobWVhbkxvc3MpO1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICB0b3RhbExvc3MgPSBsb3NzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3RhbExvc3MgPSB0ZmMuYWRkKHRvdGFsTG9zcywgbG9zcyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbWV0cmljcy5cbiAgICAgICAgLy8gVE9ETyhjYWlzKTogVGhlc2Ugc2hvdWxkIHByb2JhYmx5IGJlIGNhbGN1bGF0ZWQgb3V0c2lkZVxuICAgICAgICAvLyAgIHRvdGFsTG9zc0Z1bmN0aW9uIHRvIGJlbmVmaXQgc3BlZWQ/XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5tZXRyaWNzVGVuc29ycy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGxldCB3ZWlnaHRlZE1ldHJpYzogU2NhbGFyO1xuXG4gICAgICAgICAgaWYgKHRoaXMub3V0cHV0cy5sZW5ndGggPiAxICYmIGkgPCB0aGlzLm91dHB1dHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB3ZWlnaHRlZE1ldHJpYyA9IGxvc3NWYWx1ZXNbaV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG1ldHJpYyA9IHRoaXMubWV0cmljc1RlbnNvcnNbaV1bMF07XG4gICAgICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IHRoaXMubWV0cmljc1RlbnNvcnNbaV1bMV07XG4gICAgICAgICAgICB3ZWlnaHRlZE1ldHJpYyA9XG4gICAgICAgICAgICAgICAgdGZjLm1lYW4obWV0cmljKHRhcmdldHNbb3V0cHV0SW5kZXhdLCBvdXRwdXRzW291dHB1dEluZGV4XSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRmYy5rZWVwKHdlaWdodGVkTWV0cmljKTtcbiAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBVc2UgYSBzY29wZSgpIGluc3RlYWQsIHRvIGF2b2lkIG93bmVyc2hpcC5cbiAgICAgICAgICBtZXRyaWNzVmFsdWVzLnB1c2god2VpZ2h0ZWRNZXRyaWMpO1xuICAgICAgICB9XG5cbiAgICAgICAgdG90YWxMb3NzID0gdGZjLm1lYW4odG90YWxMb3NzKTtcblxuICAgICAgICAvLyBBZGQgcmVndWxhcml6ZXIgcGVuYWx0aWVzLlxuICAgICAgICB0aGlzLmNhbGN1bGF0ZUxvc3NlcygpLmZvckVhY2gocmVndWxhcml6ZXJMb3NzID0+IHtcbiAgICAgICAgICB0b3RhbExvc3MgPSB0ZmMuYWRkKHRvdGFsTG9zcywgcmVndWxhcml6ZXJMb3NzKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgcmV0dXJuIHRvdGFsTG9zcyBhcyBTY2FsYXI7XG4gICAgICB9O1xuXG4gICAgICBjb25zdCB2YXJpYWJsZXMgPSB0aGlzLmNvbGxlY3RlZFRyYWluYWJsZVdlaWdodHMubWFwKFxuICAgICAgICAgIHBhcmFtID0+IHBhcmFtLnJlYWQoKSBhcyB0ZmMuVmFyaWFibGUpO1xuICAgICAgY29uc3QgcmV0dXJuQ29zdCA9IHRydWU7XG4gICAgICBjb25zdCB0b3RhbExvc3NWYWx1ZSA9XG4gICAgICAgICAgdGhpcy5vcHRpbWl6ZXJfLm1pbmltaXplKHRvdGFsTG9zc0Z1bmN0aW9uLCByZXR1cm5Db3N0LCB2YXJpYWJsZXMpO1xuXG4gICAgICByZXR1cm4gW3RvdGFsTG9zc1ZhbHVlXS5jb25jYXQobWV0cmljc1ZhbHVlcyk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBmdW5jdGlvbiB3aGljaCwgd2hlbiBpbnZva2VkIHdpdGggYW4gYXJyYXkgb2YgYHRmLlRlbnNvcmBzIGFzIGFcbiAgICogYmF0Y2ggb2YgaW5wdXRzLCByZXR1cm5zIHRoZSBwcmVzcGVjaWZpZWQgbG9zcyBhbmQgbWV0cmljcyBvZiB0aGUgbW9kZWxcbiAgICogdW5kZXIgdGhlIGJhdGNoIG9mIGlucHV0IGRhdGEuXG4gICAqL1xuICBwcml2YXRlIG1ha2VUZXN0RnVuY3Rpb24oKSB7XG4gICAgdGhpcy50ZXN0RnVuY3Rpb24gPSAoZGF0YTogVGVuc29yW10pID0+IHtcbiAgICAgIHJldHVybiB0ZmMudGlkeSgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbE91dHB1dHM6IFNjYWxhcltdID0gW107XG4gICAgICAgIGxldCB0b3RhbExvc3M6IFNjYWxhcjtcbiAgICAgICAgY29uc3QgaW5wdXRzID0gZGF0YS5zbGljZSgwLCB0aGlzLmlucHV0cy5sZW5ndGgpO1xuICAgICAgICBjb25zdCB0YXJnZXRzID0gZGF0YS5zbGljZShcbiAgICAgICAgICAgIHRoaXMuaW5wdXRzLmxlbmd0aCwgdGhpcy5pbnB1dHMubGVuZ3RoICsgdGhpcy5vdXRwdXRzLmxlbmd0aCk7XG4gICAgICAgIGNvbnN0IGZlZWRzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5pbnB1dHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBmZWVkcy5wdXNoKHtrZXk6IHRoaXMuaW5wdXRzW2ldLCB2YWx1ZTogaW5wdXRzW2ldfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmVlZERpY3QgPSBuZXcgRmVlZERpY3QoZmVlZHMpO1xuICAgICAgICBjb25zdCBvdXRwdXRzID0gZXhlY3V0ZSh0aGlzLm91dHB1dHMsIGZlZWREaWN0KSBhcyBUZW5zb3JbXTtcbiAgICAgICAgLy8gQ29tcHV0ZSB0b3RhbCBsb3NzLlxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubG9zc0Z1bmN0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGNvbnN0IGxvc3NGdW5jdGlvbiA9IHRoaXMubG9zc0Z1bmN0aW9uc1tpXTtcbiAgICAgICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgc2FtcGxlIHdlaWdodGluZyBhbmQgcmVwbGFjZSB0aGUgc2ltcGxlXG4gICAgICAgICAgLy8gYXZlcmFnaW5nLlxuICAgICAgICAgIGNvbnN0IGxvc3M6IFNjYWxhciA9IHRmYy5tZWFuKGxvc3NGdW5jdGlvbih0YXJnZXRzW2ldLCBvdXRwdXRzW2ldKSk7XG4gICAgICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgICAgIHRvdGFsTG9zcyA9IGxvc3M7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvdGFsTG9zcyA9IHRmYy5hZGQodG90YWxMb3NzLCBsb3NzKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdmFsT3V0cHV0cy5wdXNoKHRvdGFsTG9zcyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSB0aGUgbWV0cmljcy5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm1ldHJpY3NUZW5zb3JzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgY29uc3QgbWV0cmljID0gdGhpcy5tZXRyaWNzVGVuc29yc1tpXVswXTtcbiAgICAgICAgICBjb25zdCBvdXRwdXRJbmRleCA9IHRoaXMubWV0cmljc1RlbnNvcnNbaV1bMV07XG4gICAgICAgICAgLy8gVE9ETyhjYWlzKTogUmVwbGFjZSBLLm1lYW4oKSB3aXRoIGEgcHJvcGVyIHdlaWdodGluZyBmdW5jdGlvbi5cbiAgICAgICAgICBjb25zdCBtZWFuTWV0cmljID1cbiAgICAgICAgICAgICAgdGZjLm1lYW4obWV0cmljKHRhcmdldHNbb3V0cHV0SW5kZXhdLCBvdXRwdXRzW291dHB1dEluZGV4XSkpO1xuICAgICAgICAgIHZhbE91dHB1dHMucHVzaChtZWFuTWV0cmljIGFzIFNjYWxhcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbE91dHB1dHM7XG4gICAgICB9KTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRyYWlucyB0aGUgbW9kZWwgZm9yIGEgZml4ZWQgbnVtYmVyIG9mIGVwb2NocyAoaXRlcmF0aW9ucyBvbiBhXG4gICAqIGRhdGFzZXQpLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtb2RlbCA9IHRmLnNlcXVlbnRpYWwoe1xuICAgKiAgICAgbGF5ZXJzOiBbdGYubGF5ZXJzLmRlbnNlKHt1bml0czogMSwgaW5wdXRTaGFwZTogWzEwXX0pXVxuICAgKiB9KTtcbiAgICogbW9kZWwuY29tcGlsZSh7b3B0aW1pemVyOiAnc2dkJywgbG9zczogJ21lYW5TcXVhcmVkRXJyb3InfSk7XG4gICAqIGZvciAobGV0IGkgPSAxOyBpIDwgNSA7ICsraSkge1xuICAgKiAgIGNvbnN0IGggPSBhd2FpdCBtb2RlbC5maXQodGYub25lcyhbOCwgMTBdKSwgdGYub25lcyhbOCwgMV0pLCB7XG4gICAqICAgICAgIGJhdGNoU2l6ZTogNCxcbiAgICogICAgICAgZXBvY2hzOiAzXG4gICAqICAgfSk7XG4gICAqICAgY29uc29sZS5sb2coXCJMb3NzIGFmdGVyIEVwb2NoIFwiICsgaSArIFwiIDogXCIgKyBoLmhpc3RvcnkubG9zc1swXSk7XG4gICAqIH1cbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSB4IGB0Zi5UZW5zb3JgIG9mIHRyYWluaW5nIGRhdGEsIG9yIGFuIGFycmF5IG9mIGB0Zi5UZW5zb3JgcyBpZiB0aGVcbiAgICogbW9kZWwgaGFzIG11bHRpcGxlIGlucHV0cy4gSWYgYWxsIGlucHV0cyBpbiB0aGUgbW9kZWwgYXJlIG5hbWVkLCB5b3VcbiAgICogY2FuIGFsc28gcGFzcyBhIGRpY3Rpb25hcnkgbWFwcGluZyBpbnB1dCBuYW1lcyB0byBgdGYuVGVuc29yYHMuXG4gICAqIEBwYXJhbSB5IGB0Zi5UZW5zb3JgIG9mIHRhcmdldCAobGFiZWwpIGRhdGEsIG9yIGFuIGFycmF5IG9mIGB0Zi5UZW5zb3JgcyBpZlxuICAgKiB0aGUgbW9kZWwgaGFzIG11bHRpcGxlIG91dHB1dHMuIElmIGFsbCBvdXRwdXRzIGluIHRoZSBtb2RlbCBhcmUgbmFtZWQsXG4gICAqIHlvdSBjYW4gYWxzbyBwYXNzIGEgZGljdGlvbmFyeSBtYXBwaW5nIG91dHB1dCBuYW1lcyB0byBgdGYuVGVuc29yYHMuXG4gICAqIEBwYXJhbSBhcmdzIEEgYE1vZGVsRml0QXJnc2AsIGNvbnRhaW5pbmcgb3B0aW9uYWwgZmllbGRzLlxuICAgKlxuICAgKiBAcmV0dXJuIEEgYEhpc3RvcnlgIGluc3RhbmNlLiBJdHMgYGhpc3RvcnlgIGF0dHJpYnV0ZSBjb250YWlucyBhbGxcbiAgICogICBpbmZvcm1hdGlvbiBjb2xsZWN0ZWQgZHVyaW5nIHRyYWluaW5nLlxuICAgKlxuICAgKiBAZXhjZXB0aW9uIFZhbHVlRXJyb3IgSW4gY2FzZSBvZiBtaXNtYXRjaCBiZXR3ZWVuIHRoZSBwcm92aWRlZCBpbnB1dFxuICAgKiBkYXRhIGFuZCB3aGF0IHRoZSBtb2RlbCBleHBlY3RzLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgYXN5bmMgZml0KFxuICAgICAgeDogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LFxuICAgICAgeTogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LFxuICAgICAgYXJnczogTW9kZWxGaXRBcmdzID0ge30pOiBQcm9taXNlPEhpc3Rvcnk+IHtcbiAgICByZXR1cm4gZml0VGVuc29ycyh0aGlzLCB4LCB5LCBhcmdzKTtcbiAgfVxuXG4gIC8vIFRPRE8oY2Fpcyk6IEFkZCBjb2RlIHNuaXBwZXQgYmVsb3cgd2hlbiBpdCdzIHBvc3NpYmxlIHRvIGluc3RhbnRpYXRlXG4gIC8vICAgYWN0dWFsIGRhdGFzZXQgb2JqZWN0cy5cbiAgLyoqXG4gICAqIFRyYWlucyB0aGUgbW9kZWwgdXNpbmcgYSBkYXRhc2V0IG9iamVjdC5cbiAgICpcbiAgICogQHBhcmFtIGRhdGFzZXQgQSBkYXRhc2V0IG9iamVjdC4gSXRzIGBpdGVyYXRvcigpYCBtZXRob2QgaXMgZXhwZWN0ZWRcbiAgICogICB0byBnZW5lcmF0ZSBhIGRhdGFzZXQgaXRlcmF0b3Igb2JqZWN0LCB0aGUgYG5leHQoKWAgbWV0aG9kIG9mIHdoaWNoXG4gICAqICAgaXMgZXhwZWN0ZWQgdG8gcHJvZHVjZSBkYXRhIGJhdGNoZXMgZm9yIHRyYWluaW5nLiBUaGUgcmV0dXJuIHZhbHVlXG4gICAqICAgb2YgdGhlIGBuZXh0KClgIGNhbGwgb3VnaHQgdG8gY29udGFpbiBhIGJvb2xlYW4gYGRvbmVgIGZpZWxkIGFuZCBhXG4gICAqICAgYHZhbHVlYCBmaWVsZC4gVGhlIGB2YWx1ZWAgZmllbGQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXkgb2YgdHdvXG4gICAqICAgYHRmLlRlbnNvcmBzIG9yIGFuIGFycmF5IG9mIHR3byBuZXN0ZWQgYHRmLlRlbnNvcmAgc3RydWN0dXJlcy4gVGhlIGZvcm1lclxuICAgKiAgIGNhc2UgaXMgZm9yIG1vZGVscyB3aXRoIGV4YWN0bHkgb25lIGlucHV0IGFuZCBvbmUgb3V0cHV0IChlLmcuLlxuICAgKiAgIGEgc2VxdWVudGlhbCBtb2RlbCkuIFRoZSBsYXR0ZXIgY2FzZSBpcyBmb3IgbW9kZWxzIHdpdGggbXVsdGlwbGVcbiAgICogICBpbnB1dHMgYW5kL29yIG11bHRpcGxlIG91dHB1dHMuXG4gICAqICAgT2YgdGhlIHR3byBpdGVtcyBpbiB0aGUgYXJyYXksIHRoZSBmaXJzdCBpcyB0aGUgaW5wdXQgZmVhdHVyZShzKSBhbmRcbiAgICogICB0aGUgc2Vjb25kIGlzIHRoZSBvdXRwdXQgdGFyZ2V0KHMpLlxuICAgKiBAcGFyYW0gYXJncyBBIGBNb2RlbEZpdERhdGFzZXRBcmdzYCwgY29udGFpbmluZyBvcHRpb25hbCBmaWVsZHMuXG4gICAqXG4gICAqIEByZXR1cm4gQSBgSGlzdG9yeWAgaW5zdGFuY2UuIEl0cyBgaGlzdG9yeWAgYXR0cmlidXRlIGNvbnRhaW5zIGFsbFxuICAgKiAgIGluZm9ybWF0aW9uIGNvbGxlY3RlZCBkdXJpbmcgdHJhaW5pbmcuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBhc3luYyBmaXREYXRhc2V0PFQ+KGRhdGFzZXQ6IERhdGFzZXQ8VD4sIGFyZ3M6IE1vZGVsRml0RGF0YXNldEFyZ3M8VD4pOlxuICAgICAgUHJvbWlzZTxIaXN0b3J5PiB7XG4gICAgcmV0dXJuIGZpdERhdGFzZXQodGhpcywgZGF0YXNldCwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogUnVucyBhIHNpbmdsZSBncmFkaWVudCB1cGRhdGUgb24gYSBzaW5nbGUgYmF0Y2ggb2YgZGF0YS5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBmaXQoKWAgYW5kIGBmaXREYXRhc2V0KClgIGluIHRoZSBmb2xsb3dpbmdcbiAgICogcmVnYXJkczpcbiAgICogICAtIEl0IG9wZXJhdGVzIG9uIGV4YWN0bHkgb25lIGJhdGNoIG9mIGRhdGEuXG4gICAqICAgLSBJdCByZXR1cm5zIG9ubHkgdGhlIGxvc3MgYW5kIG1hdHJpYyB2YWx1ZXMsIGluc3RlYWQgb2ZcbiAgICogICAgIHJldHVybmluZyB0aGUgYmF0Y2gtYnktYmF0Y2ggbG9zcyBhbmQgbWV0cmljIHZhbHVlcy5cbiAgICogICAtIEl0IGRvZXNuJ3Qgc3VwcG9ydCBmaW5lLWdyYWluZWQgb3B0aW9ucyBzdWNoIGFzIHZlcmJvc2l0eSBhbmRcbiAgICogICAgIGNhbGxiYWNrcy5cbiAgICpcbiAgICogQHBhcmFtIHggSW5wdXQgZGF0YS4gSXQgY291bGQgYmUgb25lIG9mIHRoZSBmb2xsb3dpbmc6XG4gICAqICAgLSBBIGB0Zi5UZW5zb3JgLCBvciBhbiBBcnJheSBvZiBgdGYuVGVuc29yYHMgKGluIGNhc2UgdGhlIG1vZGVsIGhhc1xuICAgKiAgICAgbXVsdGlwbGUgaW5wdXRzKS5cbiAgICogICAtIEFuIE9iamVjdCBtYXBwaW5nIGlucHV0IG5hbWVzIHRvIGNvcnJlc3BvbmRpbmcgYHRmLlRlbnNvcmAgKGlmIHRoZVxuICAgKiAgICAgbW9kZWwgaGFzIG5hbWVkIGlucHV0cykuXG4gICAqIEBwYXJhbSB5IFRhcmdldCBkYXJ0YS4gSXQgY291bGQgYmUgZWl0aGVyIGEgYHRmLlRlbnNvcmAgYSBtdWx0aXBsZVxuICAgKiAgIGB0Zi5UZW5zb3Jgcy4gSXQgc2hvdWxkIGJlIGNvbnNpc3RlbnQgd2l0aCBgeGAuXG4gICAqIEByZXR1cm5zIFRyYWluaW5nIGxvc3Mgb3IgbG9zc2VzIChpbiBjYXNlIHRoZSBtb2RlbCBoYXNcbiAgICogICBtdWx0aXBsZSBvdXRwdXRzKSwgYWxvbmcgd2l0aCBtZXRyaWNzIChpZiBhbnkpLCBhcyBudW1iZXJzLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgYXN5bmMgdHJhaW5PbkJhdGNoKFxuICAgICAgeDogVGVuc29yfFRlbnNvcltdfHtbaW5wdXROYW1lOiBzdHJpbmddOiBUZW5zb3J9LFxuICAgICAgeTogVGVuc29yfFRlbnNvcltdfFxuICAgICAge1tpbnB1dE5hbWU6IHN0cmluZ106IFRlbnNvcn0pOiBQcm9taXNlPG51bWJlcnxudW1iZXJbXT4ge1xuICAgIC8vIFRPRE8oY2Fpcyk6IFN1cHBvcnQgc2FtcGxlV2VpZ2h0IGFuZCBjbGFzc1dlaWdodC5cbiAgICAvLyBUT0RPKGNhaXMpOiBTdXBwb3J0IERhdGFzZXQgb2JqZWN0cy5cbiAgICBjb25zdCBzdGFuZGFyZGl6ZU91dCA9IGF3YWl0IHRoaXMuc3RhbmRhcmRpemVVc2VyRGF0YSh4LCB5KTtcbiAgICBjb25zdCBpbnB1dHMgPSBzdGFuZGFyZGl6ZU91dFswXTtcbiAgICBjb25zdCB0YXJnZXRzID0gc3RhbmRhcmRpemVPdXRbMV07XG4gICAgY29uc3QgdHJhaW5GdW5jdGlvbiA9IHRoaXMubWFrZVRyYWluRnVuY3Rpb24oKTtcbiAgICBjb25zdCBsb3NzZXMgPSB0cmFpbkZ1bmN0aW9uKGlucHV0cy5jb25jYXQodGFyZ2V0cykpO1xuICAgIGNvbnN0IGxvc3NWYWx1ZXM6IG51bWJlcltdID0gW107XG4gICAgZm9yIChjb25zdCBsb3NzIG9mIGxvc3Nlcykge1xuICAgICAgY29uc3QgdiA9IGF3YWl0IGxvc3MuZGF0YSgpO1xuICAgICAgbG9zc1ZhbHVlcy5wdXNoKHZbMF0pO1xuICAgIH1cbiAgICB0ZmMuZGlzcG9zZShsb3NzZXMpO1xuICAgIGRpc3Bvc2VOZXdUZW5zb3JzKHN0YW5kYXJkaXplT3V0WzBdLCB4KTtcbiAgICBkaXNwb3NlTmV3VGVuc29ycyhzdGFuZGFyZGl6ZU91dFsxXSwgeSk7XG4gICAgcmV0dXJuIHNpbmdsZXRvbk9yQXJyYXkobG9zc1ZhbHVlcyk7XG4gIH1cblxuICAvKipcbiAgICogRXh0cmFjdCB3ZWlnaHQgdmFsdWVzIG9mIHRoZSBtb2RlbC5cbiAgICpcbiAgICogQHBhcmFtIGNvbmZpZzogQW4gaW5zdGFuY2Ugb2YgYGlvLlNhdmVDb25maWdgLCB3aGljaCBzcGVjaWZpZXNcbiAgICogbW9kZWwtc2F2aW5nIG9wdGlvbnMgc3VjaCBhcyB3aGV0aGVyIG9ubHkgdHJhaW5hYmxlIHdlaWdodHMgYXJlIHRvIGJlXG4gICAqIHNhdmVkLlxuICAgKiBAcmV0dXJucyBBIGBOYW1lZFRlbnNvck1hcGAgbWFwcGluZyBvcmlnaW5hbCB3ZWlnaHQgbmFtZXMgKGkuZS4sXG4gICAqICAgbm9uLXVuaXF1ZWlmaWVkIHdlaWdodCBuYW1lcykgdG8gdGhlaXIgdmFsdWVzLlxuICAgKi9cbiAgcHJvdGVjdGVkIGdldE5hbWVkV2VpZ2h0cyhjb25maWc/OiBpby5TYXZlQ29uZmlnKTogTmFtZWRUZW5zb3JbXSB7XG4gICAgY29uc3QgbmFtZWRXZWlnaHRzOiBOYW1lZFRlbnNvcltdID0gW107XG5cbiAgICBjb25zdCB0cmFpbmFibGVPbmx5ID0gY29uZmlnICE9IG51bGwgJiYgY29uZmlnLnRyYWluYWJsZU9ubHk7XG4gICAgY29uc3Qgd2VpZ2h0cyA9IHRyYWluYWJsZU9ubHkgPyB0aGlzLnRyYWluYWJsZVdlaWdodHMgOiB0aGlzLndlaWdodHM7XG4gICAgY29uc3Qgd2VpZ2h0VmFsdWVzID0gdGhpcy5nZXRXZWlnaHRzKHRyYWluYWJsZU9ubHkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgd2VpZ2h0cy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKHRyYWluYWJsZU9ubHkgJiYgIXdlaWdodHNbaV0udHJhaW5hYmxlKSB7XG4gICAgICAgIC8vIE9wdGlvbmFsbHkgc2tpcCBub24tdHJhaW5hYmxlIHdlaWdodHMuXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbmFtZWRXZWlnaHRzLnB1c2goXG4gICAgICAgICAge25hbWU6IHdlaWdodHNbaV0ub3JpZ2luYWxOYW1lLCB0ZW5zb3I6IHdlaWdodFZhbHVlc1tpXX0pO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZWRXZWlnaHRzO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciB1c2VkIGZvciBmb3JjZSBzdG9wcGluZyBvZiBMYXllcnNNb2RlbC5maXQoKSAoaS5lLiwgdHJhaW5pbmcpLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBpbnB1dCA9IHRmLmlucHV0KHtzaGFwZTogWzEwXX0pO1xuICAgKiBjb25zdCBvdXRwdXQgPSB0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxfSkuYXBwbHkoaW5wdXQpO1xuICAgKiBjb25zdCBtb2RlbCA9IHRmLm1vZGVsKHtpbnB1dHM6IFtpbnB1dF0sIG91dHB1dHM6IFtvdXRwdXRdfSk7XG4gICAqIG1vZGVsLmNvbXBpbGUoe2xvc3M6ICdtZWFuU3F1YXJlZEVycm9yJywgb3B0aW1pemVyOiAnc2dkJ30pO1xuICAgKiBjb25zdCB4cyA9IHRmLm9uZXMoWzgsIDEwXSk7XG4gICAqIGNvbnN0IHlzID0gdGYuemVyb3MoWzgsIDFdKTtcbiAgICpcbiAgICogY29uc3QgaGlzdG9yeSA9IGF3YWl0IG1vZGVsLmZpdCh4cywgeXMsIHtcbiAgICogICBlcG9jaHM6IDEwLFxuICAgKiAgIGNhbGxiYWNrczoge1xuICAgKiAgICAgb25FcG9jaEVuZDogYXN5bmMgKGVwb2NoLCBsb2dzKSA9PiB7XG4gICAqICAgICAgIGlmIChlcG9jaCA9PT0gMikge1xuICAgKiAgICAgICAgIG1vZGVsLnN0b3BUcmFpbmluZyA9IHRydWU7XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBUaGVyZSBzaG91bGQgYmUgb25seSAzIHZhbHVlcyBpbiB0aGUgbG9zcyBhcnJheSwgaW5zdGVhZCBvZiAxMFxuICAgKiB2YWx1ZXMsXG4gICAqIC8vIGR1ZSB0byB0aGUgc3RvcHBpbmcgYWZ0ZXIgMyBlcG9jaHMuXG4gICAqIGNvbnNvbGUubG9nKGhpc3RvcnkuaGlzdG9yeS5sb3NzKTtcbiAgICogYGBgXG4gICAqL1xuICBzZXQgc3RvcFRyYWluaW5nKHN0b3A6IGJvb2xlYW4pIHtcbiAgICB0aGlzLnN0b3BUcmFpbmluZ18gPSBzdG9wO1xuICB9XG5cbiAgZ2V0IHN0b3BUcmFpbmluZygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5zdG9wVHJhaW5pbmdfO1xuICB9XG5cbiAgZ2V0IG9wdGltaXplcigpOiBPcHRpbWl6ZXIge1xuICAgIHJldHVybiB0aGlzLm9wdGltaXplcl87XG4gIH1cblxuICBzZXQgb3B0aW1pemVyKG9wdGltaXplcjogT3B0aW1pemVyKSB7XG4gICAgaWYgKHRoaXMub3B0aW1pemVyXyAhPT0gb3B0aW1pemVyKSB7XG4gICAgICB0aGlzLm9wdGltaXplcl8gPSBvcHRpbWl6ZXI7XG4gICAgICB0aGlzLmlzT3B0aW1pemVyT3duZWQgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBkaXNwb3NlKCk6IERpc3Bvc2VSZXN1bHQge1xuICAgIGNvbnN0IHJlc3VsdCA9IHN1cGVyLmRpc3Bvc2UoKTtcbiAgICBpZiAocmVzdWx0LnJlZkNvdW50QWZ0ZXJEaXNwb3NlID09PSAwICYmIHRoaXMub3B0aW1pemVyICE9IG51bGwgJiZcbiAgICAgICAgdGhpcy5pc09wdGltaXplck93bmVkKSB7XG4gICAgICBjb25zdCBudW1UZW5zb3JzQmVmb3JlT3B0bWl6ZXJEaXNwb3NhbCA9IHRmYy5tZW1vcnkoKS5udW1UZW5zb3JzO1xuICAgICAgdGhpcy5vcHRpbWl6ZXJfLmRpc3Bvc2UoKTtcbiAgICAgIHJlc3VsdC5udW1EaXNwb3NlZFZhcmlhYmxlcyArPVxuICAgICAgICAgIG51bVRlbnNvcnNCZWZvcmVPcHRtaXplckRpc3Bvc2FsIC0gdGZjLm1lbW9yeSgpLm51bVRlbnNvcnM7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBwcml2YXRlIGdldExvc3NJZGVudGlmaWVycygpOiBMb3NzSWRlbnRpZmllcnxMb3NzSWRlbnRpZmllcltdfFxuICAgICAge1tvdXRwdXROYW1lOiBzdHJpbmddOiBMb3NzSWRlbnRpZmllcn0ge1xuICAgIGxldCBsb3NzTmFtZXM6IExvc3NJZGVudGlmaWVyfExvc3NJZGVudGlmaWVyW118XG4gICAgICAgIHtbb3V0cHV0TmFtZTogc3RyaW5nXTogTG9zc0lkZW50aWZpZXJ9O1xuICAgIGlmICh0eXBlb2YgdGhpcy5sb3NzID09PSAnc3RyaW5nJykge1xuICAgICAgbG9zc05hbWVzID0gdG9TbmFrZUNhc2UodGhpcy5sb3NzKSBhcyBMb3NzSWRlbnRpZmllcjtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5sb3NzKSkge1xuICAgICAgZm9yIChjb25zdCBsb3NzIG9mIHRoaXMubG9zcykge1xuICAgICAgICBpZiAodHlwZW9mIGxvc3MgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdTZXJpYWxpemF0aW9uIG9mIG5vbi1zdHJpbmcgbG9zcyBpcyBub3Qgc3VwcG9ydGVkLicpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsb3NzTmFtZXMgPSAodGhpcy5sb3NzIGFzIHN0cmluZ1tdKS5tYXAobmFtZSA9PiB0b1NuYWtlQ2FzZShuYW1lKSkgYXNcbiAgICAgICAgICBMb3NzSWRlbnRpZmllcltdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBvdXRwdXROYW1lcyA9IE9iamVjdC5rZXlzKHRoaXMubG9zcyk7XG4gICAgICBsb3NzTmFtZXMgPSB7fSBhcyB7W291dHB1dE5hbWU6IHN0cmluZ106IExvc3NJZGVudGlmaWVyfTtcbiAgICAgIGNvbnN0IGxvc3NlcyA9XG4gICAgICAgICAgdGhpcy5sb3NzIGFzIHtbb3V0cHV0TmFtZTogc3RyaW5nXTogTG9zc09yTWV0cmljRm4gfCBzdHJpbmd9O1xuICAgICAgZm9yIChjb25zdCBvdXRwdXROYW1lIG9mIG91dHB1dE5hbWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbG9zc2VzW291dHB1dE5hbWVdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIGxvc3NOYW1lc1tvdXRwdXROYW1lXSA9XG4gICAgICAgICAgICAgIHRvU25ha2VDYXNlKGxvc3Nlc1tvdXRwdXROYW1lXSBhcyBzdHJpbmcpIGFzIExvc3NJZGVudGlmaWVyO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU2VyaWFsaXphdGlvbiBvZiBub24tc3RyaW5nIGxvc3MgaXMgbm90IHN1cHBvcnRlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9zc05hbWVzO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRNZXRyaWNJZGVudGlmaWVycygpOiBNZXRyaWNzSWRlbnRpZmllcltdfFxuICAgICAge1trZXk6IHN0cmluZ106IE1ldHJpY3NJZGVudGlmaWVyfSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLm1ldHJpY3MgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgIHR5cGVvZiB0aGlzLm1ldHJpY3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiBbdG9TbmFrZUNhc2UoTWV0cmljcy5nZXRMb3NzT3JNZXRyaWNOYW1lKHRoaXMubWV0cmljcykpXTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5tZXRyaWNzKSkge1xuICAgICAgcmV0dXJuIHRoaXMubWV0cmljcy5tYXAoXG4gICAgICAgICAgbWV0cmljID0+IHRvU25ha2VDYXNlKE1ldHJpY3MuZ2V0TG9zc09yTWV0cmljTmFtZShtZXRyaWMpKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IG1ldHJpY3NJZGVudGlmaWVyczoge1trZXk6IHN0cmluZ106IE1ldHJpY3NJZGVudGlmaWVyfSA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdGhpcy5tZXRyaWNzKSB7XG4gICAgICAgIG1ldHJpY3NJZGVudGlmaWVyc1trZXldID1cbiAgICAgICAgICAgIHRvU25ha2VDYXNlKE1ldHJpY3MuZ2V0TG9zc09yTWV0cmljTmFtZSh0aGlzLm1ldHJpY3Nba2V5XSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1ldHJpY3NJZGVudGlmaWVycztcbiAgICB9XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0VHJhaW5pbmdDb25maWcoKTogVHJhaW5pbmdDb25maWcge1xuICAgIHJldHVybiB7XG4gICAgICBsb3NzOiB0aGlzLmdldExvc3NJZGVudGlmaWVycygpLFxuICAgICAgbWV0cmljczogdGhpcy5nZXRNZXRyaWNJZGVudGlmaWVycygpLFxuICAgICAgb3B0aW1pemVyX2NvbmZpZzoge1xuICAgICAgICBjbGFzc19uYW1lOiB0aGlzLm9wdGltaXplci5nZXRDbGFzc05hbWUoKSxcbiAgICAgICAgY29uZmlnOiB0aGlzLm9wdGltaXplci5nZXRDb25maWcoKVxuICAgICAgfSBhcyBPcHRpbWl6ZXJTZXJpYWxpemF0aW9uXG4gICAgfTtcbiAgICAvLyBUT0RPKGNhaXMpOiBBZGQgd2VpZ2h0X21ldHJpY3Mgd2hlbiB0aGV5IGFyZSBzdXBwb3J0ZWQuXG4gICAgLy8gVE9ETyhjYWlzKTogQWRkIHNhbXBsZV93ZWlnaHRfbW9kZSB3aGVuIGl0J3Mgc3VwcG9ydGVkLlxuICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBsb3NzX3dlaWdodHMgd2hlbiBpdCdzIHN1cHBvcnRlZC5cbiAgfVxuXG4gIGxvYWRUcmFpbmluZ0NvbmZpZyh0cmFpbmluZ0NvbmZpZzogVHJhaW5pbmdDb25maWcpIHtcbiAgICBpZiAodHJhaW5pbmdDb25maWcud2VpZ2h0ZWRfbWV0cmljcyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRpbmcgd2VpZ2h0X21ldHJpY3MgaXMgbm90IHN1cHBvcnRlZCB5ZXQuJyk7XG4gICAgfVxuICAgIGlmICh0cmFpbmluZ0NvbmZpZy5sb3NzX3dlaWdodHMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdMb2FkaW5nIGxvc3Nfd2VpZ2h0cyBpcyBub3Qgc3VwcG9ydGVkIHlldC4nKTtcbiAgICB9XG4gICAgaWYgKHRyYWluaW5nQ29uZmlnLnNhbXBsZV93ZWlnaHRfbW9kZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0xvYWRpbmcgc2FtcGxlX3dlaWdodF9tb2RlIGlzIG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICAgIH1cblxuICAgIGNvbnN0IHRzQ29uZmlnID0gY29udmVydFB5dGhvbmljVG9Ucyh0cmFpbmluZ0NvbmZpZy5vcHRpbWl6ZXJfY29uZmlnKSBhc1xuICAgICAgICBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Q7XG4gICAgY29uc3Qgb3B0aW1pemVyID0gZGVzZXJpYWxpemUodHNDb25maWcpIGFzIE9wdGltaXplcjtcblxuICAgIGxldCBsb3NzO1xuICAgIGlmICh0eXBlb2YgdHJhaW5pbmdDb25maWcubG9zcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGxvc3MgPSB0b0NhbWVsQ2FzZSh0cmFpbmluZ0NvbmZpZy5sb3NzKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodHJhaW5pbmdDb25maWcubG9zcykpIHtcbiAgICAgIGxvc3MgPSB0cmFpbmluZ0NvbmZpZy5sb3NzLm1hcChsb3NzRW50cnkgPT4gdG9DYW1lbENhc2UobG9zc0VudHJ5KSk7XG4gICAgfSBlbHNlIGlmICh0cmFpbmluZ0NvbmZpZy5sb3NzICE9IG51bGwpIHtcbiAgICAgIGxvc3MgPSB7fSBhcyB7W291dHB1dE5hbWU6IHN0cmluZ106IExvc3NJZGVudGlmaWVyfTtcbiAgICAgIGZvciAoY29uc3Qga2V5IGluIHRyYWluaW5nQ29uZmlnLmxvc3MpIHtcbiAgICAgICAgbG9zc1trZXldID0gdG9DYW1lbENhc2UodHJhaW5pbmdDb25maWcubG9zc1trZXldKSBhcyBMb3NzSWRlbnRpZmllcjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsZXQgbWV0cmljcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0cmFpbmluZ0NvbmZpZy5tZXRyaWNzKSkge1xuICAgICAgbWV0cmljcyA9IHRyYWluaW5nQ29uZmlnLm1ldHJpY3MubWFwKG1ldHJpYyA9PiB0b0NhbWVsQ2FzZShtZXRyaWMpKTtcbiAgICB9IGVsc2UgaWYgKHRyYWluaW5nQ29uZmlnLm1ldHJpY3MgIT0gbnVsbCkge1xuICAgICAgbWV0cmljcyA9IHt9IGFzIHtbb3V0cHV0TmFtZTogc3RyaW5nXTogTWV0cmljc0lkZW50aWZpZXJ9O1xuICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHJhaW5pbmdDb25maWcubWV0cmljcykge1xuICAgICAgICBtZXRyaWNzW2tleV0gPSB0b0NhbWVsQ2FzZSh0cmFpbmluZ0NvbmZpZy5tZXRyaWNzW2tleV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuY29tcGlsZSh7bG9zcywgbWV0cmljcywgb3B0aW1pemVyfSk7XG4gIH1cblxuICAvKipcbiAgICogU2F2ZSB0aGUgY29uZmlndXJhdGlvbiBhbmQvb3Igd2VpZ2h0cyBvZiB0aGUgTGF5ZXJzTW9kZWwuXG4gICAqXG4gICAqIEFuIGBJT0hhbmRsZXJgIGlzIGFuIG9iamVjdCB0aGF0IGhhcyBhIGBzYXZlYCBtZXRob2Qgb2YgdGhlIHByb3BlclxuICAgKiBzaWduYXR1cmUgZGVmaW5lZC4gVGhlIGBzYXZlYCBtZXRob2QgbWFuYWdlcyB0aGUgc3RvcmluZyBvclxuICAgKiB0cmFuc21pc3Npb24gb2Ygc2VyaWFsaXplZCBkYXRhIChcImFydGlmYWN0c1wiKSB0aGF0IHJlcHJlc2VudCB0aGVcbiAgICogbW9kZWwncyB0b3BvbG9neSBhbmQgd2VpZ2h0cyBvbnRvIG9yIHZpYSBhIHNwZWNpZmljIG1lZGl1bSwgc3VjaCBhc1xuICAgKiBmaWxlIGRvd25sb2FkcywgbG9jYWwgc3RvcmFnZSwgSW5kZXhlZERCIGluIHRoZSB3ZWIgYnJvd3NlciBhbmQgSFRUUFxuICAgKiByZXF1ZXN0cyB0byBhIHNlcnZlci4gVGVuc29yRmxvdy5qcyBwcm92aWRlcyBgSU9IYW5kbGVyYFxuICAgKiBpbXBsZW1lbnRhdGlvbnMgZm9yIGEgbnVtYmVyIG9mIGZyZXF1ZW50bHkgdXNlZCBzYXZpbmcgbWVkaXVtcywgc3VjaCBhc1xuICAgKiBgdGYuaW8uYnJvd3NlckRvd25sb2Fkc2AgYW5kIGB0Zi5pby5icm93c2VyTG9jYWxTdG9yYWdlYC4gU2VlIGB0Zi5pb2BcbiAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICpcbiAgICogVGhpcyBtZXRob2QgYWxzbyBhbGxvd3MgeW91IHRvIHJlZmVyIHRvIGNlcnRhaW4gdHlwZXMgb2YgYElPSGFuZGxlcmBzXG4gICAqIGFzIFVSTC1saWtlIHN0cmluZyBzaG9ydGN1dHMsIHN1Y2ggYXMgJ2xvY2Fsc3RvcmFnZTovLycgYW5kXG4gICAqICdpbmRleGVkZGI6Ly8nLlxuICAgKlxuICAgKiBFeGFtcGxlIDE6IFNhdmUgYG1vZGVsYCdzIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIHRvIGJyb3dzZXIgW2xvY2FsXG4gICAqIHN0b3JhZ2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9XaW5kb3cvbG9jYWxTdG9yYWdlKTtcbiAgICogdGhlbiBsb2FkIGl0IGJhY2suXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1vZGVsID0gdGYuc2VxdWVudGlhbChcbiAgICogICAgIHtsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbM119KV19KTtcbiAgICogY29uc29sZS5sb2coJ1ByZWRpY3Rpb24gZnJvbSBvcmlnaW5hbCBtb2RlbDonKTtcbiAgICogbW9kZWwucHJlZGljdCh0Zi5vbmVzKFsxLCAzXSkpLnByaW50KCk7XG4gICAqXG4gICAqIGNvbnN0IHNhdmVSZXN1bHRzID0gYXdhaXQgbW9kZWwuc2F2ZSgnbG9jYWxzdG9yYWdlOi8vbXktbW9kZWwtMScpO1xuICAgKlxuICAgKiBjb25zdCBsb2FkZWRNb2RlbCA9IGF3YWl0IHRmLmxvYWRMYXllcnNNb2RlbCgnbG9jYWxzdG9yYWdlOi8vbXktbW9kZWwtMScpO1xuICAgKiBjb25zb2xlLmxvZygnUHJlZGljdGlvbiBmcm9tIGxvYWRlZCBtb2RlbDonKTtcbiAgICogbG9hZGVkTW9kZWwucHJlZGljdCh0Zi5vbmVzKFsxLCAzXSkpLnByaW50KCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBFeGFtcGxlIDIuIFNhdmluZyBgbW9kZWxgJ3MgdG9wb2xvZ3kgYW5kIHdlaWdodHMgdG8gYnJvd3NlclxuICAgKiBbSW5kZXhlZERCXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW5kZXhlZERCX0FQSSk7XG4gICAqIHRoZW4gbG9hZCBpdCBiYWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtb2RlbCA9IHRmLnNlcXVlbnRpYWwoXG4gICAqICAgICB7bGF5ZXJzOiBbdGYubGF5ZXJzLmRlbnNlKHt1bml0czogMSwgaW5wdXRTaGFwZTogWzNdfSldfSk7XG4gICAqIGNvbnNvbGUubG9nKCdQcmVkaWN0aW9uIGZyb20gb3JpZ2luYWwgbW9kZWw6Jyk7XG4gICAqIG1vZGVsLnByZWRpY3QodGYub25lcyhbMSwgM10pKS5wcmludCgpO1xuICAgKlxuICAgKiBjb25zdCBzYXZlUmVzdWx0cyA9IGF3YWl0IG1vZGVsLnNhdmUoJ2luZGV4ZWRkYjovL215LW1vZGVsLTEnKTtcbiAgICpcbiAgICogY29uc3QgbG9hZGVkTW9kZWwgPSBhd2FpdCB0Zi5sb2FkTGF5ZXJzTW9kZWwoJ2luZGV4ZWRkYjovL215LW1vZGVsLTEnKTtcbiAgICogY29uc29sZS5sb2coJ1ByZWRpY3Rpb24gZnJvbSBsb2FkZWQgbW9kZWw6Jyk7XG4gICAqIGxvYWRlZE1vZGVsLnByZWRpY3QodGYub25lcyhbMSwgM10pKS5wcmludCgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogRXhhbXBsZSAzLiBTYXZpbmcgYG1vZGVsYCdzIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIGFzIHR3byBmaWxlc1xuICAgKiAoYG15LW1vZGVsLTEuanNvbmAgYW5kIGBteS1tb2RlbC0xLndlaWdodHMuYmluYCkgZG93bmxvYWRlZCBmcm9tXG4gICAqIGJyb3dzZXIuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1vZGVsID0gdGYuc2VxdWVudGlhbChcbiAgICogICAgIHtsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbM119KV19KTtcbiAgICogY29uc3Qgc2F2ZVJlc3VsdHMgPSBhd2FpdCBtb2RlbC5zYXZlKCdkb3dubG9hZHM6Ly9teS1tb2RlbC0xJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBFeGFtcGxlIDQuIFNlbmQgIGBtb2RlbGAncyB0b3BvbG9neSBhbmQgd2VpZ2h0cyB0byBhbiBIVFRQIHNlcnZlci5cbiAgICogU2VlIHRoZSBkb2N1bWVudGF0aW9uIG9mIGB0Zi5pby5odHRwYCBmb3IgbW9yZSBkZXRhaWxzXG4gICAqIGluY2x1ZGluZyBzcGVjaWZ5aW5nIHJlcXVlc3QgcGFyYW1ldGVycyBhbmQgaW1wbGVtZW50YXRpb24gb2YgdGhlXG4gICAqIHNlcnZlci5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKFxuICAgKiAgICAge2xheWVyczogW3RmLmxheWVycy5kZW5zZSh7dW5pdHM6IDEsIGlucHV0U2hhcGU6IFszXX0pXX0pO1xuICAgKiBjb25zdCBzYXZlUmVzdWx0cyA9IGF3YWl0IG1vZGVsLnNhdmUoJ2h0dHA6Ly9teS1zZXJ2ZXIvbW9kZWwvdXBsb2FkJyk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gaGFuZGxlck9yVVJMIEFuIGluc3RhbmNlIG9mIGBJT0hhbmRsZXJgIG9yIGEgVVJMLWxpa2UsXG4gICAqIHNjaGVtZS1iYXNlZCBzdHJpbmcgc2hvcnRjdXQgZm9yIGBJT0hhbmRsZXJgLlxuICAgKiBAcGFyYW0gY29uZmlnIE9wdGlvbnMgZm9yIHNhdmluZyB0aGUgbW9kZWwuXG4gICAqIEByZXR1cm5zIEEgYFByb21pc2VgIG9mIGBTYXZlUmVzdWx0YCwgd2hpY2ggc3VtbWFyaXplcyB0aGUgcmVzdWx0IG9mXG4gICAqIHRoZSBzYXZpbmcsIHN1Y2ggYXMgYnl0ZSBzaXplcyBvZiB0aGUgc2F2ZWQgYXJ0aWZhY3RzIGZvciB0aGUgbW9kZWwnc1xuICAgKiAgIHRvcG9sb2d5IGFuZCB3ZWlnaHQgdmFsdWVzLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnLCBpZ25vcmVDSTogdHJ1ZX1cbiAgICovXG4gIGFzeW5jIHNhdmUoaGFuZGxlck9yVVJMOiBpby5JT0hhbmRsZXJ8c3RyaW5nLCBjb25maWc/OiBpby5TYXZlQ29uZmlnKTpcbiAgICAgIFByb21pc2U8aW8uU2F2ZVJlc3VsdD4ge1xuICAgIGlmICh0eXBlb2YgaGFuZGxlck9yVVJMID09PSAnc3RyaW5nJykge1xuICAgICAgY29uc3QgaGFuZGxlcnMgPSBpby5nZXRTYXZlSGFuZGxlcnMoaGFuZGxlck9yVVJMKTtcbiAgICAgIGlmIChoYW5kbGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgQ2Fubm90IGZpbmQgYW55IHNhdmUgaGFuZGxlcnMgZm9yIFVSTCAnJHtoYW5kbGVyT3JVUkx9J2ApO1xuICAgICAgfSBlbHNlIGlmIChoYW5kbGVycy5sZW5ndGggPiAxKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYEZvdW5kIG1vcmUgdGhhbiBvbmUgKCR7aGFuZGxlcnMubGVuZ3RofSkgc2F2ZSBoYW5kbGVycyBmb3IgYCArXG4gICAgICAgICAgICBgVVJMICcke2hhbmRsZXJPclVSTH0nYCk7XG4gICAgICB9XG4gICAgICBoYW5kbGVyT3JVUkwgPSBoYW5kbGVyc1swXTtcbiAgICB9XG4gICAgaWYgKGhhbmRsZXJPclVSTC5zYXZlID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdMYXllcnNNb2RlbC5zYXZlKCkgY2Fubm90IHByb2NlZWQgYmVjYXVzZSB0aGUgSU9IYW5kbGVyICcgK1xuICAgICAgICAgICdwcm92aWRlZCBkb2VzIG5vdCBoYXZlIHRoZSBgc2F2ZWAgYXR0cmlidXRlIGRlZmluZWQuJyk7XG4gICAgfVxuXG4gICAgY29uc3Qgd2VpZ2h0RGF0YUFuZFNwZWNzID1cbiAgICAgICAgYXdhaXQgaW8uZW5jb2RlV2VpZ2h0cyh0aGlzLmdldE5hbWVkV2VpZ2h0cyhjb25maWcpKTtcblxuICAgIGNvbnN0IHJldHVyblN0cmluZyA9IGZhbHNlO1xuICAgIGNvbnN0IHVudXNlZEFyZzoge30gPSBudWxsO1xuICAgIGNvbnN0IG1vZGVsQ29uZmlnID0gdGhpcy50b0pTT04odW51c2VkQXJnLCByZXR1cm5TdHJpbmcpO1xuICAgIGNvbnN0IG1vZGVsQXJ0aWZhY3RzOiBpby5Nb2RlbEFydGlmYWN0cyA9IHtcbiAgICAgIG1vZGVsVG9wb2xvZ3k6IG1vZGVsQ29uZmlnLFxuICAgICAgZm9ybWF0OiBMQVlFUlNfTU9ERUxfRk9STUFUX05BTUUsXG4gICAgICBnZW5lcmF0ZWRCeTogYFRlbnNvckZsb3cuanMgdGZqcy1sYXllcnMgdiR7dmVyc2lvbn1gLFxuICAgICAgY29udmVydGVkQnk6IG51bGwsXG4gICAgfTtcblxuICAgIGNvbnN0IGluY2x1ZGVPcHRpbWl6ZXIgPSBjb25maWcgPT0gbnVsbCA/IGZhbHNlIDogY29uZmlnLmluY2x1ZGVPcHRpbWl6ZXI7XG4gICAgaWYgKGluY2x1ZGVPcHRpbWl6ZXIgJiYgdGhpcy5vcHRpbWl6ZXIgIT0gbnVsbCkge1xuICAgICAgbW9kZWxBcnRpZmFjdHMudHJhaW5pbmdDb25maWcgPSB0aGlzLmdldFRyYWluaW5nQ29uZmlnKCk7XG4gICAgICBjb25zdCB3ZWlnaHRUeXBlID0gJ29wdGltaXplcic7XG4gICAgICBjb25zdCB7ZGF0YTogb3B0aW1pemVyV2VpZ2h0RGF0YSwgc3BlY3M6IG9wdGltaXplcldlaWdodFNwZWNzfSA9XG4gICAgICAgICAgYXdhaXQgaW8uZW5jb2RlV2VpZ2h0cyhhd2FpdCB0aGlzLm9wdGltaXplci5nZXRXZWlnaHRzKCksIHdlaWdodFR5cGUpO1xuICAgICAgd2VpZ2h0RGF0YUFuZFNwZWNzLnNwZWNzLnB1c2goLi4ub3B0aW1pemVyV2VpZ2h0U3BlY3MpO1xuICAgICAgd2VpZ2h0RGF0YUFuZFNwZWNzLmRhdGEgPSBpby5jb25jYXRlbmF0ZUFycmF5QnVmZmVycyhcbiAgICAgICAgICBbd2VpZ2h0RGF0YUFuZFNwZWNzLmRhdGEsIG9wdGltaXplcldlaWdodERhdGFdKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy51c2VyRGVmaW5lZE1ldGFkYXRhICE9IG51bGwpIHtcbiAgICAgIC8vIENoZWNrIHNlcmlhbGl6ZWQgc2l6ZSBvZiB1c2VyLWRlZmluZWQgbWV0YWRhdGEuXG4gICAgICBjb25zdCBjaGVja1NpemUgPSB0cnVlO1xuICAgICAgY2hlY2tVc2VyRGVmaW5lZE1ldGFkYXRhKHRoaXMudXNlckRlZmluZWRNZXRhZGF0YSwgdGhpcy5uYW1lLCBjaGVja1NpemUpO1xuICAgICAgbW9kZWxBcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSA9IHRoaXMudXNlckRlZmluZWRNZXRhZGF0YTtcbiAgICB9XG5cbiAgICBtb2RlbEFydGlmYWN0cy53ZWlnaHREYXRhID0gd2VpZ2h0RGF0YUFuZFNwZWNzLmRhdGE7XG4gICAgbW9kZWxBcnRpZmFjdHMud2VpZ2h0U3BlY3MgPSB3ZWlnaHREYXRhQW5kU3BlY3Muc3BlY3M7XG4gICAgcmV0dXJuIGhhbmRsZXJPclVSTC5zYXZlKG1vZGVsQXJ0aWZhY3RzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdXNlci1kZWZpbmVkIG1ldGFkYXRhLlxuICAgKlxuICAgKiBUaGUgc2V0IG1ldGFkYXRhIHdpbGwgYmUgc2VyaWFsaXplZCB0b2dldGhlciB3aXRoIHRoZSB0b3BvbG9neVxuICAgKiBhbmQgd2VpZ2h0cyBvZiB0aGUgbW9kZWwgZHVyaW5nIGBzYXZlKClgIGNhbGxzLlxuICAgKlxuICAgKiBAcGFyYW0gc2V0VXNlckRlZmluZWRNZXRhZGF0YVxuICAgKi9cbiAgc2V0VXNlckRlZmluZWRNZXRhZGF0YSh1c2VyRGVmaW5lZE1ldGFkYXRhOiB7fSk6IHZvaWQge1xuICAgIGNoZWNrVXNlckRlZmluZWRNZXRhZGF0YSh1c2VyRGVmaW5lZE1ldGFkYXRhLCB0aGlzLm5hbWUpO1xuICAgIHRoaXMudXNlckRlZmluZWRNZXRhZGF0YSA9IHVzZXJEZWZpbmVkTWV0YWRhdGE7XG4gIH1cblxuICAvKipcbiAgICogR2V0IHVzZXItZGVmaW5lZCBtZXRhZGF0YS5cbiAgICpcbiAgICogVGhlIG1ldGFkYXRhIGlzIHN1cHBsaWVkIHZpYSBvbmUgb2YgdGhlIHR3byByb3V0ZXM6XG4gICAqICAgMS4gQnkgY2FsbGluZyBgc2V0VXNlckRlZmluZWRNZXRhZGF0YSgpYC5cbiAgICogICAyLiBMb2FkZWQgZHVyaW5nIG1vZGVsIGxvYWRpbmcgKGlmIHRoZSBtb2RlbCBpcyBjb25zdHJ1Y3RlZFxuICAgKiAgICAgIHZpYSBgdGYubG9hZExheWVyc01vZGVsKClgLilcbiAgICpcbiAgICogSWYgbm8gdXNlci1kZWZpbmVkIG1ldGFkYXRhIGlzIGF2YWlsYWJsZSBmcm9tIGVpdGhlciBvZiB0aGVcbiAgICogdHdvIHJvdXRlcywgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiBgdW5kZWZpbmVkYC5cbiAgICovXG4gIGdldFVzZXJEZWZpbmVkTWV0YWRhdGEoKToge30ge1xuICAgIHJldHVybiB0aGlzLnVzZXJEZWZpbmVkTWV0YWRhdGE7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMYXllcnNNb2RlbCk7XG5cbi8qKlxuICogQSBgdGYuRnVuY3Rpb25hbGAgaXMgYW4gYWxpYXMgdG8gYHRmLkxheWVyc01vZGVsYC5cbiAqXG4gKiBTZWUgYWxzbzpcbiAqICAgYHRmLkxheWVyc01vZGVsYCwgYHRmLlNlcXVlbnRpYWxgLCBgdGYubG9hZExheWVyc01vZGVsYC5cbiAqL1xuLyoqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9ICovXG5leHBvcnQgY2xhc3MgRnVuY3Rpb25hbCBleHRlbmRzIExheWVyc01vZGVsIHtcbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdGdW5jdGlvbmFsJztcbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhGdW5jdGlvbmFsKTtcbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* Original source keras/models.py */\nimport { dispose, io, serialization, util } from '@tensorflow/tfjs-core';\nimport { getUid } from './backend/state';\nimport { Input } from './engine/input_layer';\nimport { getSourceInputs, Node } from './engine/topology';\nimport { LayersModel } from './engine/training';\nimport { NotImplementedError, RuntimeError, ValueError } from './errors';\nimport { deserialize } from './layers/serialization';\nimport * as generic_utils from './utils/generic_utils';\nimport { convertPythonicToTs } from './utils/serialization_utils';\nimport { getExactlyOneShape } from './utils/types_utils';\n/**\n * Parses a JSON model configuration file and returns a model instance.\n *\n * ```js\n * // This example shows how to serialize a model using `toJSON()` and\n * // deserialize it as another model using `tf.models.modelFromJSON()`.\n * // Note: this example serializes and deserializes only the topology\n * // of the model; the weights of the loaded model will be different\n * // from those of the the original model, due to random weight\n * // initialization.\n * // To load the topology and weights of a model, use `tf.loadLayersModel()`.\n * const model1 = tf.sequential();\n * model1.add(tf.layers.repeatVector({inputShape: [2], n: 4}));\n * // Serialize `model1` as a JSON object.\n * const model1JSON = model1.toJSON(null, false);\n * model1.summary();\n *\n * const model2 = await tf.models.modelFromJSON(model1JSON);\n * model2.summary();\n * ```\n *\n *  @param modelAndWeightsConfig JSON object or string encoding a model and\n *       weights configuration. It can also be only the topology JSON of the\n *       model, in which case the weights will not be loaded.\n *  @param custom_objects Optional dictionary mapping names\n *       (strings) to custom classes or functions to be\n *       considered during deserialization.\n * @returns A TensorFlow.js Layers `tf.LayersModel` instance (uncompiled).\n */\nexport async function modelFromJSON(modelAndWeightsConfig, customObjects) {\n    if (!('modelTopology' in modelAndWeightsConfig)) {\n        modelAndWeightsConfig = { modelTopology: modelAndWeightsConfig };\n    }\n    modelAndWeightsConfig = modelAndWeightsConfig;\n    let modelTopology = modelAndWeightsConfig.modelTopology;\n    if (modelTopology['model_config'] != null) {\n        // If the model-topology JSON contains a 'model_config' field, then it is\n        // a full model JSON (e.g., from `keras.Model.save()`), which contains\n        // not only the model's architecture in its 'model_config' field, but\n        // additional information such as the model's optimizer. We use only the\n        // 'model_config' field currently.\n        modelTopology = modelTopology['model_config'];\n    }\n    const tsConfig = convertPythonicToTs(modelTopology);\n    const model = deserialize(tsConfig, customObjects);\n    if (modelAndWeightsConfig.weightsManifest != null) {\n        // Load the weight values keyed by the original tensor names in the model\n        // file that was loaded.  These should match the keys of the weight\n        // manifest.\n        const weightValues = await io.loadWeights(modelAndWeightsConfig.weightsManifest, modelAndWeightsConfig.pathPrefix, model.weights.map(weight => weight.originalName));\n        // Map the weights to the unique tensor names generated during model loading\n        const uniqueWeightValues = {};\n        for (const weight of model.weights) {\n            uniqueWeightValues[weight.originalName] =\n                weightValues[weight.originalName];\n        }\n        model.loadWeights(uniqueWeightValues);\n        // Dispose temporary weight values.\n        dispose(weightValues);\n    }\n    return model;\n}\n/**\n * Load a model, including its topology and optionally weights.  See the\n * Tutorial named \"How to import a Keras Model\" for usage examples.\n *\n * Example 1: Save `model`'s topology and weights to browser [local\n * storage](https://developer.mozilla.org/en-US/docs/Web/API/Window/localStorage);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('localstorage://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('localstorage://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 2. Saving `model`'s topology and weights to browser\n * [IndexedDB](https://developer.mozilla.org/en-US/docs/Web/API/IndexedDB_API);\n * then load it back.\n *\n * ```js\n * const model = tf.sequential(\n *     {layers: [tf.layers.dense({units: 1, inputShape: [3]})]});\n * console.log('Prediction from original model:');\n * model.predict(tf.ones([1, 3])).print();\n *\n * const saveResults = await model.save('indexeddb://my-model-1');\n *\n * const loadedModel = await tf.loadLayersModel('indexeddb://my-model-1');\n * console.log('Prediction from loaded model:');\n * loadedModel.predict(tf.ones([1, 3])).print();\n * ```\n *\n * Example 3. Load a model from user-selected files from HTML\n * [file input\n * elements](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input/file).\n *\n * ```js\n * // Note: this code snippet will not work without the HTML elements in the\n * //   page\n * const jsonUpload = document.getElementById('json-upload');\n * const weightsUpload = document.getElementById('weights-upload');\n *\n * const model = await tf.loadLayersModel(\n *     tf.io.browserFiles([jsonUpload.files[0], weightsUpload.files[0]]));\n * ```\n *\n * Example 4. Load a model from an HTTP server.\n *\n * ```js\n * const model = await\n *     tf.loadLayersModel('https://storage.googleapis.com/tfjs-models/tfjs/iris_v1/model.json');\n * model.summary();\n * ```\n *\n * @param pathOrIOHandler Can be either of the two formats\n *   1. A string path to the `ModelAndWeightsConfig` JSON describing\n *      the model in the canonical TensorFlow.js format. This path will be\n *      interpreted as a relative HTTP path, to which `fetch` will be used to\n *      request the model topology and weight manifest JSON.\n *      The content of the JSON file is assumed to be a JSON object with the\n *      following fields and values:\n *      - 'modelTopology': A JSON object that can be either of:\n *        1. a model architecture JSON consistent with the format of the return\n *            value of `keras.Model.to_json()`\n *        2. a full model JSON in the format of `keras.models.save_model()`.\n *      - 'weightsManifest': A TensorFlow.js weights manifest.\n *      See the Python converter function `save_model()` for more details.\n *      It is also assumed that model weights can be accessed from relative\n *      paths described by the `paths` fields in weights manifest.\n *   2. An `tf.io.IOHandler` object that loads model artifacts with its `load`\n *      method.\n * @param options Optional configuration arguments for the model loading,\n *   including:\n *   - `strict`: Require that the provided weights exactly match those required\n *     by the layers.  Default true.  Passing false means that both extra\n *     weights and missing weights will be silently ignored.\n *   - `onProgress`: A progress callback of the form:\n *     `(fraction: number) => void`. This callback can be used to monitor the\n *     model-loading process.\n * @returns A `Promise` of `tf.LayersModel`, with the topology and weights\n *     loaded.\n */\nexport async function loadLayersModelInternal(pathOrIOHandler, options) {\n    if (options == null) {\n        options = {};\n    }\n    if (typeof pathOrIOHandler === 'string') {\n        const handlers = io.getLoadHandlers(pathOrIOHandler, options);\n        if (handlers.length === 0) {\n            // For backward compatibility: if no load handler can be found,\n            // assume it is a relative http path.\n            // TODO(cais): Reformat the args into a single `LoadOptions` once the core\n            // is refactored.\n            handlers.push(io.browserHTTPRequest(pathOrIOHandler, options));\n        }\n        else if (handlers.length > 1) {\n            throw new ValueError(`Found more than one (${handlers.length}) load handlers for ` +\n                `URL '${pathOrIOHandler}'`);\n        }\n        pathOrIOHandler = handlers[0];\n    }\n    return loadLayersModelFromIOHandler(pathOrIOHandler, undefined, options);\n}\n/**\n * Load a model and optionally its weights, using an IOHandler object.\n *\n * @param handler The instance of `IOHandler` to be used during the model\n *   loading.\n * @param customObjects Any optional custom objects to be used during model\n *   loading.\n * @param strict Whether the weight loading will be done in strict mode.\n *   Default: `true`.\n */\nexport async function loadLayersModelFromIOHandler(handler, customObjects, options) {\n    if (options == null) {\n        options = {};\n    }\n    if (handler.load == null) {\n        throw new ValueError('Cannot proceed with model loading because the IOHandler provided ' +\n            'does not have the `load` method implemented.');\n    }\n    const artifacts = await handler.load();\n    let modelTopology = artifacts.modelTopology;\n    if (modelTopology['model_config'] != null) {\n        modelTopology = modelTopology['model_config'];\n    }\n    const strict = options.strict == null ? true : options.strict;\n    // If weights are provided and the weight-loading mode is strict, use\n    // fast weight initialization. This skips costly initializers such as\n    // 'orthogonal' and saves unnecessary computation in cases where\n    // the initialized weight values will immediately be overwritten by\n    // loaded weight values.\n    const fastWeightInit = artifacts.weightData != null && artifacts.weightSpecs != null && strict;\n    const model = deserialize(convertPythonicToTs(modelTopology), customObjects, fastWeightInit);\n    const trainingConfig = artifacts.trainingConfig;\n    if (trainingConfig != null) {\n        model.loadTrainingConfig(trainingConfig);\n    }\n    if (artifacts.userDefinedMetadata != null) {\n        model.setUserDefinedMetadata(artifacts.userDefinedMetadata);\n    }\n    // If weightData is present, load the weights into the model.\n    if (artifacts.weightData != null) {\n        // Loading weights requires weightSpecs.\n        if (artifacts.weightSpecs == null) {\n            throw new ValueError('LayersModel artifacts contains weight data, but not weight specs. ' +\n                'Therefore loading of weights cannot proceed.');\n        }\n        const { modelWeights, optimizerWeights } = decodeModelAndOptimizerWeights(artifacts.weightData, artifacts.weightSpecs);\n        model.loadWeights(modelWeights, strict);\n        if (model.optimizer != null && optimizerWeights.length > 0) {\n            await model.optimizer.setWeights(optimizerWeights);\n        }\n        // Dispose temporary weight values.\n        dispose(modelWeights);\n        dispose(optimizerWeights.map(w => w.tensor));\n    }\n    return model;\n}\nfunction decodeModelAndOptimizerWeights(buffer, specs) {\n    const name2Tensor = io.decodeWeights(buffer, specs);\n    const modelWeights = {};\n    const optimizerWeights = [];\n    specs.forEach(spec => {\n        if (spec.group === 'optimizer') {\n            optimizerWeights.push({ name: spec.name, tensor: name2Tensor[spec.name] });\n        }\n        else {\n            modelWeights[spec.name] = name2Tensor[spec.name];\n        }\n    });\n    return { modelWeights, optimizerWeights };\n}\n/**\n * A model with a stack of layers, feeding linearly from one to the next.\n *\n * `tf.sequential` is a factory function that creates an instance of\n * `tf.Sequential`.\n *\n * ```js\n *  // Define a model for linear regression.\n *  const model = tf.sequential();\n *  model.add(tf.layers.dense({units: 1, inputShape: [1]}));\n *\n *  // Prepare the model for training: Specify the loss and the optimizer.\n *  model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n *\n *  // Generate some synthetic data for training.\n *  const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);\n *  const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);\n *\n *  // Train the model using the data then do inference on a data point the\n *  // model hasn't seen:\n *  await model.fit(xs, ys);\n *  model.predict(tf.tensor2d([5], [1, 1])).print();\n * ```\n *\n * @doc {heading: 'Models', subheading: 'Classes'}\n */\nexport class Sequential extends LayersModel {\n    constructor(args) {\n        super({ inputs: [], outputs: [] });\n        args = args || {};\n        this.trainable = true;\n        this.built = false;\n        // Set model name.\n        this.name = (args.name != null) ? args.name : getUid('sequential_');\n        // Add to the model any layers passed to the constructor.\n        if (args.layers != null) {\n            for (const layer of args.layers) {\n                this.add(layer);\n            }\n        }\n    }\n    // Helper function to Sequential.add  Throws if the new output shape will be\n    // invalid.\n    checkShape(layer) {\n        const shape = layer.inboundNodes[0].outputTensors[0].shape;\n        if (shape.some(x => x < 0)) {\n            throw new ValueError('Negative dimension size caused by adding layer ' +\n                `${layer.name} with input shape [` +\n                `${layer.inboundNodes[0].inputTensors[0].shape}]`);\n        }\n    }\n    /**\n     * Adds a layer instance on top of the layer stack.\n     *\n     * ```js\n     *  const model = tf.sequential();\n     *  model.add(tf.layers.dense({units: 8, inputShape: [1]}));\n     *  model.add(tf.layers.dense({units: 4, activation: 'relu6'}));\n     *  model.add(tf.layers.dense({units: 1, activation: 'relu6'}));\n     *  // Note that the untrained model is random at this point.\n     *  model.predict(tf.randomNormal([10, 1])).print();\n     * ```\n     * @param layer Layer instance.\n     *\n     * @exception ValueError In case the `layer` argument does not know its\n     * input shape.\n     * @exception ValueError In case the `layer` argument has multiple output\n     *   tensors, or is already connected somewhere else (forbidden in\n     *   `Sequential` models).\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    add(layer) {\n        const isLayerModelInstance = layer instanceof Sequential || layer instanceof LayersModel;\n        let modelLayer;\n        if (isLayerModelInstance) {\n            modelLayer = layer;\n            if (modelLayer.outputs.length !== 1) {\n                throw new ValueError('All layers in a Sequential model ' +\n                    'should have a single output tensor. ' +\n                    'For multi-output layers, ' +\n                    'use the functional API.');\n            }\n            if (modelLayer.inputs.length !== 1) {\n                throw new ValueError('All layers in a Sequential model ' +\n                    'should have a single input tensor. ' +\n                    'For multi-input layers, ' +\n                    'use the functional API.');\n            }\n        }\n        if (this.outputs.length === 0) {\n            // first layer in model: check that it is an input layer\n            if (layer.inboundNodes.length === 0) {\n                // create an input layer\n                if (layer.batchInputShape == null) {\n                    throw new ValueError('The first layer in a Sequential model must ' +\n                        'get an `inputShape` or `batchInputShape` argument.');\n                }\n                // Instantiate the input layer.\n                const x = Input({\n                    batchShape: layer.batchInputShape,\n                    dtype: layer.dtype,\n                    name: layer.name + '_input'\n                });\n                // This will build the current layer and create the node connecting\n                // the current layer to the input layer we just created.\n                layer.apply(x);\n            }\n            if (isLayerModelInstance) {\n                this.outputs = modelLayer.outputs;\n                this.inputs = modelLayer.inputs;\n            }\n            else {\n                if (layer.inboundNodes.length !== 1) {\n                    throw new ValueError('A layer added to a Sequential model must not already be ' +\n                        `connected somewhere else. LayersModel received layer ${layer.name} ` +\n                        `which has ${layer.inboundNodes.length} pre-existing inbound ` +\n                        'connections.');\n                }\n                if (layer.inboundNodes[0].outputTensors.length !== 1) {\n                    throw new ValueError('All layers in a Sequential model ' +\n                        'should have a single output tensor. ' +\n                        'For multi-output layers, ' +\n                        'use the functional API.');\n                }\n                this.checkShape(layer);\n                this.outputs = [layer.inboundNodes[0].outputTensors[0]];\n                this.inputs = getSourceInputs(this.outputs[0]);\n            }\n            this.inboundNodes = [];\n            // We create an input node, which we will keep updated\n            // as we add more layers.\n            // (This call has side effects.)\n            // tslint:disable-next-line:no-unused-expression\n            new Node({\n                outboundLayer: this,\n                inboundLayers: [],\n                nodeIndices: [],\n                tensorIndices: [],\n                inputTensors: this.inputs,\n                outputTensors: this.outputs,\n                // no model-level masking for now\n                inputMasks: generic_utils.pyListRepeat(null, this.inputs.length),\n                outputMasks: [null],\n                inputShapes: this.inputs.map(x => x.shape),\n                outputShapes: this.outputs[0].shape\n            });\n        }\n        else {\n            const outputTensor = layer.apply(this.outputs[0]);\n            if (Array.isArray(outputTensor)) {\n                throw new TypeError('All layers in a Sequential model ' +\n                    'should have a single output tensor. ' +\n                    'For multi-output layers, ' +\n                    'use the functional API.');\n            }\n            this.checkShape(layer);\n            this.outputs = [outputTensor];\n            // update self.inbound_nodes\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n        this.layers.push(layer);\n        this.built = false;\n    }\n    /**\n     * Removes the last layer in the model.\n     *\n     * @exception TypeError if there are no layers in the model.\n     */\n    pop() {\n        if (this.layers.length === 0) {\n            throw new TypeError('There are no layers in the model.');\n        }\n        this.layers.pop();\n        if (this.layers.length === 0) {\n            this.outputs = [];\n            this.inboundNodes = [];\n            this.outboundNodes = [];\n        }\n        else {\n            const lastLayerIndex = this.layers.length - 1;\n            this.layers[lastLayerIndex].outboundNodes = [];\n            this.outputs = [this.layers[lastLayerIndex].output];\n            // update self.inbound_nodes\n            this.inboundNodes[0].outputTensors = this.outputs;\n            this.inboundNodes[0].outputShapes = [this.outputs[0].shape];\n        }\n    }\n    call(inputs, kwargs) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.call(inputs, kwargs);\n    }\n    build(inputShape) {\n        // Call `getExactlyOneShape` without using its return value,\n        // to verify that exactly one input shape is provided.\n        getExactlyOneShape(inputShape);\n        if (this.inputs.length === 0 || this.outputs.length === 0) {\n            throw new TypeError('Sequential model cannot be built: model is empty.' +\n                ' Add some layers first.');\n        }\n        // actually create the model\n        this.model = new LayersModel({\n            inputs: this.inputs,\n            outputs: this.outputs[0],\n            name: this.name + '_model'\n        });\n        this.model.trainable = this.trainable;\n        // mirror model attributes\n        this.supportsMasking = this.model.supportsMasking;\n        // TODO(michaelterry): Add caches\n        this.inputLayers = this.model.inputLayers;\n        this.inputLayersNodeIndices = this.model.inputLayersNodeIndices;\n        this.inputLayersTensorIndices = this.model.inputLayersTensorIndices;\n        this.outputLayers = this.model.outputLayers;\n        this.outputLayersNodeIndices = this.model.outputLayersNodeIndices;\n        this.outputLayersTensorIndices = this.model.outputLayersTensorIndices;\n        this.nodesByDepth = this.model.nodesByDepth;\n        this.containerNodes = this.model.containerNodes;\n        this.outputNames = this.model.outputNames;\n        this.inputNames = this.model.inputNames;\n        // TODO(michaelterry): Add feedInputNames, feedInputs, if needed.\n        // TODO(michaelterry): Add callbackModel if needed.\n        this.built = true;\n    }\n    countParams() {\n        if (!this.built) {\n            this.build();\n        }\n        return super.countParams();\n    }\n    /**\n     * Print a text summary of the Sequential model's layers.\n     *\n     * The summary includes\n     * - Name and type of all layers that comprise the model.\n     * - Output shape(s) of the layers\n     * - Number of weight parameters of each layer\n     * - The total number of trainable and non-trainable parameters of the\n     * model.\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(\n     *     tf.layers.dense({units: 100, inputShape: [10], activation: 'relu'}));\n     * model.add(tf.layers.dense({units: 1, activation: 'sigmoid'}));\n     *\n     * model.summary();\n     * ```\n     *\n     * @param lineLength Custom line length, in number of characters.\n     * @param positions Custom widths of each of the columns, as either\n     *   fractions of `lineLength` (e.g., `[0.5, 0.75, 1]`) or absolute number\n     *   of characters (e.g., `[30, 50, 65]`). Each number corresponds to\n     *   right-most (i.e., ending) position of a column.\n     * @param printFn Custom print function. Can be used to replace the default\n     *   `console.log`. For example, you can use `x => {}` to mute the printed\n     *   messages in the console.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    summary(lineLength, positions, printFn = console.log) {\n        if (!this.built) {\n            this.build();\n        }\n        super.summary(lineLength, positions, printFn);\n    }\n    /**\n     * Sets the weights of the model.\n     *\n     * @param weights Should be a list of Tensors with shapes and types matching\n     *   the output of `model.getWeights()`.\n     */\n    setWeights(weights) {\n        if (this.model == null) {\n            this.build();\n        }\n        this.model.setWeights(weights);\n    }\n    /**\n     * Returns the loss value & metrics values for the model in test mode.\n     *\n     * Loss and metrics are specified during `compile()`, which needs to happen\n     * before calls to `evaluate()`.\n     *\n     * Computation is done in batches.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const result = model.evaluate(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     * });\n     * result.print();\n     * ```\n     *\n     * @param x `tf.Tensor` of test data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple inputs.\n     * @param y `tf.Tensor` of target data, or an `Array` of `tf.Tensor`s if the\n     * model has multiple outputs.\n     * @param args A `ModelEvaluateConfig`, containing optional fields.\n     *\n     * @return `Scalar` test loss (if the model has a single output and no\n     *   metrics) or `Array` of `Scalar`s (if the model has multiple outputs\n     *   and/or metrics). The attribute `model.metricsNames`\n     *   will give you the display labels for the scalar outputs.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    evaluate(x, y, args = {}) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluate(x, y, args);\n    }\n    // TODO(cais): Add code snippet below once real dataset objects are\n    //   available.\n    /**\n     * Evaluate model using a dataset object.\n     *\n     * Note: Unlike `evaluate()`, this method is asynchronous (`async`);\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected\n     *   to generate a dataset iterator object, the `next()` method of which\n     *   is expected to produce data batches for evaluation. The return value\n     *   of the `next()` call ought to contain a boolean `done` field and a\n     *   `value` field. The `value` field is expected to be an array of two\n     *   `tf.Tensor`s or an array of two nested `tf.Tensor` structures. The former\n     *   case is for models with exactly one input and one output (e.g..\n     *   a sequential model). The latter case is for models with multiple\n     *   inputs and/or multiple outputs. Of the two items in the array, the\n     *   first is the input feature(s) and the second is the output target(s).\n     * @param args A configuration object for the dataset-based evaluation.\n     * @returns Loss and metric values as an Array of `Scalar` objects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async evaluateDataset(dataset, args) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before being used.');\n        }\n        return this.model.evaluateDataset(dataset, args);\n    }\n    /**\n     * Generates output predictions for the input samples.\n     *\n     * Computation is done in batches.\n     *\n     * Note: the \"step\" mode of predict() is currently not supported.\n     *   This is because the TensorFlow.js core backend is imperative only.\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.predict(tf.ones([2, 10])).print();\n     * ```\n     *\n     * @param x The input data, as a Tensor, or an `Array` of `tf.Tensor`s if\n     *   the model has multiple inputs.\n     * @param conifg A `ModelPredictConfig` object containing optional fields.\n     *\n     * @return `tf.Tensor`(s) of predictions.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and the model's expectations, or in case a stateful model receives a\n     *   number of samples that is not a multiple of the batch size.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    predict(x, args = {}) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predict(x, args);\n    }\n    /**\n     * Returns predictions for a single batch of samples.\n     *\n     * @param x: Input samples, as a Tensor, or list of Tensors (if the model\n     *   has multiple inputs).\n     * @return Tensor(s) of predictions\n     */\n    predictOnBatch(x) {\n        if (this.model == null) {\n            this.build();\n        }\n        return this.model.predictOnBatch(x);\n    }\n    /**\n     * See `LayersModel.compile`.\n     *\n     * @param args\n     */\n    compile(args) {\n        this.build();\n        this.model.compile(args);\n        this.optimizer_ = this.model.optimizer;\n        // tslint:disable-next-line:no-any\n        this.isOptimizerOwned = this.model.isOptimizerOwned;\n        this.loss = this.model.loss;\n        this.metrics = this.model.metrics;\n        // TODO(cais): Add this.lossWeights, this.sampleWeightMode,\n        //   this.weightedMetrics, this.targets.\n        this.metricsTensors = this.model.metricsTensors;\n        this.metricsNames = this.model.metricsNames;\n        // TODO(cais): Add sampleWeights.\n    }\n    get optimizer() {\n        return this.model == null ? undefined : this.model.optimizer;\n    }\n    set optimizer(optimizer) {\n        this.model.optimizer = optimizer;\n    }\n    /**\n     * Trains the model for a fixed number of epochs (iterations on a dataset).\n     *\n     * ```js\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [10]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fit(tf.ones([8, 10]), tf.ones([8, 1]), {\n     *   batchSize: 4,\n     *   epochs: 3\n     * });\n     * console.log(history.history.loss[0]);\n     * ```\n     *\n     * @param x `tf.Tensor` of training data, or an array of `tf.Tensor`s if the\n     * model has multiple inputs. If all inputs in the model are named, you can\n     * also pass a dictionary mapping input names to `tf.Tensor`s.\n     * @param y `tf.Tensor` of target (label) data, or an array of `tf.Tensor`s if\n     * the model has multiple outputs. If all outputs in the model are named, you\n     *  can also pass a dictionary mapping output names to `tf.Tensor`s.\n     * @param args  A `ModelFitConfig`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @exception ValueError In case of mismatch between the provided input data\n     *   and what the model expects.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async fit(x, y, args = {}) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before ' +\n                'being used.');\n        }\n        return this.model.fit(x, y, args);\n    }\n    /**\n     * Trains the model using a dataset object.\n     *\n     * ```js\n     * const xArray = [\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     *   [1, 1, 1, 1, 1, 1, 1, 1, 1],\n     * ];\n     * const yArray = [1, 1, 1, 1];\n     * // Create a dataset from the JavaScript array.\n     * const xDataset = tf.data.array(xArray);\n     * const yDataset = tf.data.array(yArray);\n     * // Zip combines the `x` and `y` Datasets into a single Dataset, the\n     * // iterator of which will return an object containing of two tensors,\n     * // corresponding to `x` and `y`.  The call to `batch(4)` will bundle\n     * // four such samples into a single object, with the same keys now pointing\n     * // to tensors that hold 4 examples, organized along the batch dimension.\n     * // The call to `shuffle(4)` causes each iteration through the dataset to\n     * // happen in a different order.  The size of the shuffle window is 4.\n     * const xyDataset = tf.data.zip({xs: xDataset, ys: yDataset})\n     *     .batch(4)\n     *     .shuffle(4);\n     * const model = tf.sequential({\n     *   layers: [tf.layers.dense({units: 1, inputShape: [9]})]\n     * });\n     * model.compile({optimizer: 'sgd', loss: 'meanSquaredError'});\n     * const history = await model.fitDataset(xyDataset, {\n     *   epochs: 4,\n     *   callbacks: {onEpochEnd: (epoch, logs) => console.log(logs.loss)}\n     * });\n     * ```\n     *\n     * @param dataset A dataset object. Its `iterator()` method is expected to\n     *   generate a dataset iterator object, the `next()` method of which is\n     *   expected to produce data batches for evaluation. The return value of the\n     *   `next()` call ought to contain a boolean `done` field and a `value`\n     *   field.\n     *\n     *   The `value` field is expected to be an object of with fields\n     *   `xs` and `ys`, which point to the feature tensor and the target tensor,\n     *   respectively. This case is for models with exactly one input and one\n     *   output (e.g.. a sequential model). For example:\n     *   ```js\n     *   {value: {xs: xsTensor, ys: ysTensor}, done: false}\n     *   ```\n     *\n     *   If the model has multiple inputs, the `xs` field of `value` should\n     *   be an object mapping input names to their respective feature tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: {\n     *         input_1: xsTensor1,\n     *         input_2: xsTensor2\n     *       },\n     *       ys: ysTensor\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     *   If the model has multiple outputs, the `ys` field of `value` should\n     *   be an object mapping output names to their respective target tensors.\n     *   For example:\n     *   ```js\n     *   {\n     *     value: {\n     *       xs: xsTensor,\n     *       ys: {\n     *         output_1: ysTensor1,\n     *         output_2: ysTensor2\n     *       },\n     *     },\n     *     done: false\n     *   }\n     *   ```\n     * @param args A `ModelFitDatasetArgs`, containing optional fields.\n     *\n     * @return A `History` instance. Its `history` attribute contains all\n     *   information collected during training.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes', ignoreCI: true}\n     */\n    async fitDataset(dataset, args) {\n        if (!this.built) {\n            throw new RuntimeError('The model needs to be compiled before ' +\n                'being used.');\n        }\n        return this.model.fitDataset(dataset, args);\n    }\n    /**\n     * Runs a single gradient update on a single batch of data.\n     *\n     * This method differs from `fit()` and `fitDataset()` in the following\n     * regards:\n     *   - It operates on exactly one batch of data.\n     *   - It returns only the loss and matric values, instead of\n     *     returning the batch-by-batch loss and metric values.\n     *   - It doesn't support fine-grained options such as verbosity and\n     *     callbacks.\n     *\n     * @param x Input data. It could be one of the following:\n     *   - A `tf.Tensor`, or an Array of `tf.Tensor`s (in case the model has\n     *     multiple inputs).\n     *   - An Object mapping input names to corresponding `tf.Tensor` (if the\n     *     model has named inputs).\n     * @param y Target darta. It could be either a `tf.Tensor` a multiple\n     *   `tf.Tensor`s. It should be consistent with `x`.\n     * @returns Training loss or losses (in case the model has\n     *   multiple outputs), along with metrics (if any), as numbers.\n     *\n     * @doc {heading: 'Models', subheading: 'Classes'}\n     */\n    async trainOnBatch(x, y) {\n        return this.model.trainOnBatch(x, y);\n    }\n    /* See parent class for JsDoc */\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}, fastWeightInit = false) {\n        let configArray;\n        let extraModelConfig = {};\n        if (config instanceof Array) {\n            if (!(config[0].className != null) ||\n                config[0]['className'] === 'Merge') {\n                throw new ValueError('Legacy serialization format not supported yet.');\n            }\n            configArray = config;\n        }\n        else {\n            util.assert(config['layers'] != null, () => `When the config data for a Sequential model is not an Array, ` +\n                `it must be an Object that contains the 'layers' field.`);\n            configArray = config['layers'];\n            delete config['layers'];\n            extraModelConfig = config;\n        }\n        const model = new cls(extraModelConfig);\n        if (!(model instanceof Sequential)) {\n            throw new NotImplementedError(`Sequential.fromConfig called on non-Sequential input: ${model}`);\n        }\n        for (const conf of configArray) {\n            const customObjects = undefined;\n            const layer = deserialize(conf, customObjects, fastWeightInit);\n            if (fastWeightInit) {\n                layer.setFastWeightInitDuringBuild(true);\n            }\n            model.add(layer);\n        }\n        return model;\n    }\n    /**\n     * Setter used for force stopping of LayersModel.fit() (i.e., training).\n     *\n     * Example:\n     *\n     * ```js\n     * const model = tf.sequential();\n     * model.add(tf.layers.dense({units: 1, inputShape: [10]}));\n     * model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});\n     * const xs = tf.ones([8, 10]);\n     * const ys = tf.zeros([8, 1]);\n     *\n     * const history = await model.fit(xs, ys, {\n     *   epochs: 10,\n     *   callbacks: {\n     *     onEpochEnd: async (epoch, logs) => {\n     *       if (epoch === 2) {\n     *         model.stopTraining = true;\n     *       }\n     *     }\n     *   }\n     * });\n     *\n     * // There should be only 3 values in the loss array, instead of 10 values,\n     * // due to the stopping after 3 epochs.\n     * console.log(history.history.loss);\n     * ```\n     */\n    set stopTraining(stop) {\n        // TODO(cais): When refactoring to remove the composition pattern happens,\n        // remove this method overriding.\n        if (this.model == null) {\n            throw new ValueError('Cannot set the stopTraining property of a sequential model before ' +\n                'it is compiled.');\n        }\n        this.model.stopTraining = stop;\n    }\n    get stopTraining() {\n        if (this.model == null) {\n            throw new ValueError('Cannot get the stopTraining property of a sequential model before ' +\n                'it is compiled.');\n        }\n        return this.model.stopTraining;\n    }\n    // TODO(cais): Override get trainableWeights() here\n    // tslint:disable-next-line:no-any\n    getConfig() {\n        // NOTE(cais): We override the return type of getConfig() to `any` here,\n        //   because the `Sequential` class is a special case among `Container`\n        //   subtypes in that its getConfig() method returns an Array (not a\n        //   dict).\n        const layers = [];\n        for (const layer of this.layers) {\n            const dict = {};\n            dict['className'] = layer.getClassName();\n            dict['config'] = layer.getConfig();\n            layers.push(dict);\n        }\n        return { name: this.name, layers };\n    }\n}\n/** @nocollapse */\nSequential.className = 'Sequential';\nserialization.registerClass(Sequential);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibW9kZWxzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL21vZGVscy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILHFDQUFxQztBQUVyQyxPQUFPLEVBQUMsT0FBTyxFQUFFLEVBQUUsRUFBcUMsYUFBYSxFQUFVLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRWxILE9BQU8sRUFBQyxNQUFNLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUd2QyxPQUFPLEVBQUMsS0FBSyxFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFDM0MsT0FBTyxFQUFDLGVBQWUsRUFBUyxJQUFJLEVBQWlCLE1BQU0sbUJBQW1CLENBQUM7QUFDL0UsT0FBTyxFQUFDLFdBQVcsRUFBc0MsTUFBTSxtQkFBbUIsQ0FBQztBQUduRixPQUFPLEVBQUMsbUJBQW1CLEVBQUUsWUFBWSxFQUFFLFVBQVUsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUl2RSxPQUFPLEVBQUMsV0FBVyxFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFFbkQsT0FBTyxLQUFLLGFBQWEsTUFBTSx1QkFBdUIsQ0FBQztBQUN2RCxPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSw2QkFBNkIsQ0FBQztBQUNoRSxPQUFPLEVBQUMsa0JBQWtCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUV2RDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQTRCRztBQUNILE1BQU0sQ0FBQyxLQUFLLFVBQVUsYUFBYSxDQUMvQixxQkFBdUQsRUFDdkQsYUFBd0M7SUFDMUMsSUFBSSxDQUFDLENBQUMsZUFBZSxJQUFJLHFCQUFxQixDQUFDLEVBQUU7UUFDL0MscUJBQXFCLEdBQUcsRUFBQyxhQUFhLEVBQUUscUJBQXFCLEVBQUMsQ0FBQztLQUNoRTtJQUNELHFCQUFxQixHQUFHLHFCQUE4QyxDQUFDO0lBRXZFLElBQUksYUFBYSxHQUFHLHFCQUFx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QUM7U0FDbkI7UUFDRCxPQUFPLEVBQUMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJLEVBQUUsTUFBTSxFQUFDLENBQUM7SUFDbkMsQ0FBQzs7QUF6c0JELGtCQUFrQjtBQUNYLG9CQUFTLEdBQUcsWUFBWSxDQUFDO0FBMHNCbEMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxVQUFVLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qIE9yaWdpbmFsIHNvdXJjZSBrZXJhcy9tb2RlbHMucHkgKi9cblxuaW1wb3J0IHtkaXNwb3NlLCBpbywgTmFtZWRUZW5zb3JNYXAsIE9wdGltaXplciwgU2NhbGFyLCBzZXJpYWxpemF0aW9uLCBUZW5zb3IsIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7Z2V0VWlkfSBmcm9tICcuL2JhY2tlbmQvc3RhdGUnO1xuaW1wb3J0IHtIaXN0b3J5fSBmcm9tICcuL2Jhc2VfY2FsbGJhY2tzJztcbmltcG9ydCB7RGF0YXNldH0gZnJvbSAnLi9lbmdpbmUvZGF0YXNldF9zdHViJztcbmltcG9ydCB7SW5wdXR9IGZyb20gJy4vZW5naW5lL2lucHV0X2xheWVyJztcbmltcG9ydCB7Z2V0U291cmNlSW5wdXRzLCBMYXllciwgTm9kZSwgU3ltYm9saWNUZW5zb3J9IGZyb20gJy4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7TGF5ZXJzTW9kZWwsIE1vZGVsQ29tcGlsZUFyZ3MsIE1vZGVsRXZhbHVhdGVBcmdzfSBmcm9tICcuL2VuZ2luZS90cmFpbmluZyc7XG5pbXBvcnQge01vZGVsRXZhbHVhdGVEYXRhc2V0QXJncywgTW9kZWxGaXREYXRhc2V0QXJnc30gZnJvbSAnLi9lbmdpbmUvdHJhaW5pbmdfZGF0YXNldCc7XG5pbXBvcnQge01vZGVsRml0QXJnc30gZnJvbSAnLi9lbmdpbmUvdHJhaW5pbmdfdGVuc29ycyc7XG5pbXBvcnQge05vdEltcGxlbWVudGVkRXJyb3IsIFJ1bnRpbWVFcnJvciwgVmFsdWVFcnJvcn0gZnJvbSAnLi9lcnJvcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi9rZXJhc19mb3JtYXQvY29tbW9uJztcbmltcG9ydCB7VHJhaW5pbmdDb25maWd9IGZyb20gJy4va2VyYXNfZm9ybWF0L3RyYWluaW5nX2NvbmZpZyc7XG5pbXBvcnQge1B5SnNvbkRpY3R9IGZyb20gJy4va2VyYXNfZm9ybWF0L3R5cGVzJztcbmltcG9ydCB7ZGVzZXJpYWxpemV9IGZyb20gJy4vbGF5ZXJzL3NlcmlhbGl6YXRpb24nO1xuaW1wb3J0IHtLd2FyZ3MsIE5hbWVkVGVuc29yfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi91dGlscy9nZW5lcmljX3V0aWxzJztcbmltcG9ydCB7Y29udmVydFB5dGhvbmljVG9Uc30gZnJvbSAnLi91dGlscy9zZXJpYWxpemF0aW9uX3V0aWxzJztcbmltcG9ydCB7Z2V0RXhhY3RseU9uZVNoYXBlfSBmcm9tICcuL3V0aWxzL3R5cGVzX3V0aWxzJztcblxuLyoqXG4gKiBQYXJzZXMgYSBKU09OIG1vZGVsIGNvbmZpZ3VyYXRpb24gZmlsZSBhbmQgcmV0dXJucyBhIG1vZGVsIGluc3RhbmNlLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBUaGlzIGV4YW1wbGUgc2hvd3MgaG93IHRvIHNlcmlhbGl6ZSBhIG1vZGVsIHVzaW5nIGB0b0pTT04oKWAgYW5kXG4gKiAvLyBkZXNlcmlhbGl6ZSBpdCBhcyBhbm90aGVyIG1vZGVsIHVzaW5nIGB0Zi5tb2RlbHMubW9kZWxGcm9tSlNPTigpYC5cbiAqIC8vIE5vdGU6IHRoaXMgZXhhbXBsZSBzZXJpYWxpemVzIGFuZCBkZXNlcmlhbGl6ZXMgb25seSB0aGUgdG9wb2xvZ3lcbiAqIC8vIG9mIHRoZSBtb2RlbDsgdGhlIHdlaWdodHMgb2YgdGhlIGxvYWRlZCBtb2RlbCB3aWxsIGJlIGRpZmZlcmVudFxuICogLy8gZnJvbSB0aG9zZSBvZiB0aGUgdGhlIG9yaWdpbmFsIG1vZGVsLCBkdWUgdG8gcmFuZG9tIHdlaWdodFxuICogLy8gaW5pdGlhbGl6YXRpb24uXG4gKiAvLyBUbyBsb2FkIHRoZSB0b3BvbG9neSBhbmQgd2VpZ2h0cyBvZiBhIG1vZGVsLCB1c2UgYHRmLmxvYWRMYXllcnNNb2RlbCgpYC5cbiAqIGNvbnN0IG1vZGVsMSA9IHRmLnNlcXVlbnRpYWwoKTtcbiAqIG1vZGVsMS5hZGQodGYubGF5ZXJzLnJlcGVhdFZlY3Rvcih7aW5wdXRTaGFwZTogWzJdLCBuOiA0fSkpO1xuICogLy8gU2VyaWFsaXplIGBtb2RlbDFgIGFzIGEgSlNPTiBvYmplY3QuXG4gKiBjb25zdCBtb2RlbDFKU09OID0gbW9kZWwxLnRvSlNPTihudWxsLCBmYWxzZSk7XG4gKiBtb2RlbDEuc3VtbWFyeSgpO1xuICpcbiAqIGNvbnN0IG1vZGVsMiA9IGF3YWl0IHRmLm1vZGVscy5tb2RlbEZyb21KU09OKG1vZGVsMUpTT04pO1xuICogbW9kZWwyLnN1bW1hcnkoKTtcbiAqIGBgYFxuICpcbiAqICBAcGFyYW0gbW9kZWxBbmRXZWlnaHRzQ29uZmlnIEpTT04gb2JqZWN0IG9yIHN0cmluZyBlbmNvZGluZyBhIG1vZGVsIGFuZFxuICogICAgICAgd2VpZ2h0cyBjb25maWd1cmF0aW9uLiBJdCBjYW4gYWxzbyBiZSBvbmx5IHRoZSB0b3BvbG9neSBKU09OIG9mIHRoZVxuICogICAgICAgbW9kZWwsIGluIHdoaWNoIGNhc2UgdGhlIHdlaWdodHMgd2lsbCBub3QgYmUgbG9hZGVkLlxuICogIEBwYXJhbSBjdXN0b21fb2JqZWN0cyBPcHRpb25hbCBkaWN0aW9uYXJ5IG1hcHBpbmcgbmFtZXNcbiAqICAgICAgIChzdHJpbmdzKSB0byBjdXN0b20gY2xhc3NlcyBvciBmdW5jdGlvbnMgdG8gYmVcbiAqICAgICAgIGNvbnNpZGVyZWQgZHVyaW5nIGRlc2VyaWFsaXphdGlvbi5cbiAqIEByZXR1cm5zIEEgVGVuc29yRmxvdy5qcyBMYXllcnMgYHRmLkxheWVyc01vZGVsYCBpbnN0YW5jZSAodW5jb21waWxlZCkuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBtb2RlbEZyb21KU09OKFxuICAgIG1vZGVsQW5kV2VpZ2h0c0NvbmZpZzogTW9kZWxBbmRXZWlnaHRzQ29uZmlnfFB5SnNvbkRpY3QsXG4gICAgY3VzdG9tT2JqZWN0cz86IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCk6IFByb21pc2U8TGF5ZXJzTW9kZWw+IHtcbiAgaWYgKCEoJ21vZGVsVG9wb2xvZ3knIGluIG1vZGVsQW5kV2VpZ2h0c0NvbmZpZykpIHtcbiAgICBtb2RlbEFuZFdlaWdodHNDb25maWcgPSB7bW9kZWxUb3BvbG9neTogbW9kZWxBbmRXZWlnaHRzQ29uZmlnfTtcbiAgfVxuICBtb2RlbEFuZFdlaWdodHNDb25maWcgPSBtb2RlbEFuZFdlaWdodHNDb25maWcgYXMgTW9kZWxBbmRXZWlnaHRzQ29uZmlnO1xuXG4gIGxldCBtb2RlbFRvcG9sb2d5ID0gbW9kZWxBbmRXZWlnaHRzQ29uZmlnLm1vZGVsVG9wb2xvZ3k7XG4gIGlmIChtb2RlbFRvcG9sb2d5Wydtb2RlbF9jb25maWcnXSAhPSBudWxsKSB7XG4gICAgLy8gSWYgdGhlIG1vZGVsLXRvcG9sb2d5IEpTT04gY29udGFpbnMgYSAnbW9kZWxfY29uZmlnJyBmaWVsZCwgdGhlbiBpdCBpc1xuICAgIC8vIGEgZnVsbCBtb2RlbCBKU09OIChlLmcuLCBmcm9tIGBrZXJhcy5Nb2RlbC5zYXZlKClgKSwgd2hpY2ggY29udGFpbnNcbiAgICAvLyBub3Qgb25seSB0aGUgbW9kZWwncyBhcmNoaXRlY3R1cmUgaW4gaXRzICdtb2RlbF9jb25maWcnIGZpZWxkLCBidXRcbiAgICAvLyBhZGRpdGlvbmFsIGluZm9ybWF0aW9uIHN1Y2ggYXMgdGhlIG1vZGVsJ3Mgb3B0aW1pemVyLiBXZSB1c2Ugb25seSB0aGVcbiAgICAvLyAnbW9kZWxfY29uZmlnJyBmaWVsZCBjdXJyZW50bHkuXG4gICAgbW9kZWxUb3BvbG9neSA9IG1vZGVsVG9wb2xvZ3lbJ21vZGVsX2NvbmZpZyddIGFzIFB5SnNvbkRpY3Q7XG4gIH1cbiAgY29uc3QgdHNDb25maWcgPVxuICAgICAgY29udmVydFB5dGhvbmljVG9Ucyhtb2RlbFRvcG9sb2d5KSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Q7XG4gIGNvbnN0IG1vZGVsID0gZGVzZXJpYWxpemUodHNDb25maWcsIGN1c3RvbU9iamVjdHMpIGFzIExheWVyc01vZGVsO1xuXG4gIGlmIChtb2RlbEFuZFdlaWdodHNDb25maWcud2VpZ2h0c01hbmlmZXN0ICE9IG51bGwpIHtcbiAgICAvLyBMb2FkIHRoZSB3ZWlnaHQgdmFsdWVzIGtleWVkIGJ5IHRoZSBvcmlnaW5hbCB0ZW5zb3IgbmFtZXMgaW4gdGhlIG1vZGVsXG4gICAgLy8gZmlsZSB0aGF0IHdhcyBsb2FkZWQuICBUaGVzZSBzaG91bGQgbWF0Y2ggdGhlIGtleXMgb2YgdGhlIHdlaWdodFxuICAgIC8vIG1hbmlmZXN0LlxuICAgIGNvbnN0IHdlaWdodFZhbHVlcyA9IGF3YWl0IGlvLmxvYWRXZWlnaHRzKFxuICAgICAgICBtb2RlbEFuZFdlaWdodHNDb25maWcud2VpZ2h0c01hbmlmZXN0LCBtb2RlbEFuZFdlaWdodHNDb25maWcucGF0aFByZWZpeCxcbiAgICAgICAgbW9kZWwud2VpZ2h0cy5tYXAod2VpZ2h0ID0+IHdlaWdodC5vcmlnaW5hbE5hbWUpKTtcblxuICAgIC8vIE1hcCB0aGUgd2VpZ2h0cyB0byB0aGUgdW5pcXVlIHRlbnNvciBuYW1lcyBnZW5lcmF0ZWQgZHVyaW5nIG1vZGVsIGxvYWRpbmdcbiAgICBjb25zdCB1bmlxdWVXZWlnaHRWYWx1ZXM6IE5hbWVkVGVuc29yTWFwID0ge307XG4gICAgZm9yIChjb25zdCB3ZWlnaHQgb2YgbW9kZWwud2VpZ2h0cykge1xuICAgICAgdW5pcXVlV2VpZ2h0VmFsdWVzW3dlaWdodC5vcmlnaW5hbE5hbWVdID1cbiAgICAgICAgICB3ZWlnaHRWYWx1ZXNbd2VpZ2h0Lm9yaWdpbmFsTmFtZV07XG4gICAgfVxuXG4gICAgbW9kZWwubG9hZFdlaWdodHModW5pcXVlV2VpZ2h0VmFsdWVzKTtcbiAgICAvLyBEaXNwb3NlIHRlbXBvcmFyeSB3ZWlnaHQgdmFsdWVzLlxuICAgIGRpc3Bvc2Uod2VpZ2h0VmFsdWVzKTtcbiAgfVxuICByZXR1cm4gbW9kZWw7XG59XG5cbi8qKlxuICogT3B0aW9ucyBmb3IgbG9hZGluZyBhIHNhdmVkIG1vZGUgaW4gVGVuc29yRmxvdy5qcyBmb3JtYXQuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWxBbmRXZWlnaHRzQ29uZmlnIHtcbiAgLyoqXG4gICAqIEEgSlNPTiBvYmplY3Qgb3IgSlNPTiBzdHJpbmcgY29udGFpbmluZyB0aGUgbW9kZWwgY29uZmlnLlxuICAgKlxuICAgKiBUaGlzIGNhbiBiZSBlaXRoZXIgb2YgdGhlIGZvbGxvd2luZyB0d28gZm9ybWF0czpcbiAgICogICAtIEEgbW9kZWwgYXJjaGllY3R1cmUtb25seSBjb25maWcsICBpLmUuLCBhIGZvcm1hdCBjb25zaXN0ZW50IHdpdGggdGhlXG4gICAqICAgICByZXR1cm4gdmFsdWUgb2Zga2VyYXMuTW9kZWwudG9fanNvbigpYC5cbiAgICogICAtIEEgZnVsbCBtb2RlbCBjb25maWcsIGNvbnRhaW5pbmcgbm90IG9ubHkgbW9kZWwgYXJjaGl0ZWN0dXJlLCBidXQgYWxzb1xuICAgKiAgICAgdHJhaW5pbmcgb3B0aW9ucyBhbmQgc3RhdGUsIGkuZS4sIGEgZm9ybWF0IGNvbnNpc3RlbnQgd2l0aCB0aGUgcmV0dXJuXG4gICAqICAgICB2YWx1ZSBvZiBga2VyYXMubW9kZWxzLnNhdmVfbW9kZWwoKWAuXG4gICAqL1xuICBtb2RlbFRvcG9sb2d5OiBQeUpzb25EaWN0O1xuXG4gIC8qKlxuICAgKiBBIHdlaWdodHMgbWFuaWZlc3QgaW4gVGVuc29yRmxvdy5qcyBmb3JtYXQuXG4gICAqL1xuICB3ZWlnaHRzTWFuaWZlc3Q/OiBpby5XZWlnaHRzTWFuaWZlc3RDb25maWc7XG5cbiAgLyoqXG4gICAqIFBhdGggdG8gcHJlcGVuZCB0byB0aGUgcGF0aHMgaW4gYHdlaWdodE1hbmlmZXN0YCBiZWZvcmUgZmV0Y2hpbmcuXG4gICAqXG4gICAqIFRoZSBwYXRoIG1heSBvcHRpb25hbGx5IGVuZCBpbiBhIHNsYXNoICgnLycpLlxuICAgKi9cbiAgcGF0aFByZWZpeD86IHN0cmluZztcbn1cblxuLy8gVE9ETyhuaWVsc2VuZSk6IFJlbW92ZSBhZnRlcjogaHR0cHM6Ly9naXRodWIuY29tL3RlbnNvcmZsb3cvdGZqcy9pc3N1ZXMvNDAwXG5leHBvcnQgaW50ZXJmYWNlIE1vZGVsUHJlZGljdEFyZ3Mge1xuICAvKipcbiAgICogT3B0aW9uYWwuIEJhdGNoIHNpemUgKEludGVnZXIpLiBJZiB1bnNwZWNpZmllZCwgaXQgd2lsbCBkZWZhdWx0IHRvIDMyLlxuICAgKi9cbiAgYmF0Y2hTaXplPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBPcHRpb25hbC4gVmVyYm9zaXR5IG1vZGUuIERlZmF1bHRzIHRvIGZhbHNlLlxuICAgKi9cbiAgdmVyYm9zZT86IGJvb2xlYW47XG59XG5cbi8qKlxuICogTG9hZCBhIG1vZGVsLCBpbmNsdWRpbmcgaXRzIHRvcG9sb2d5IGFuZCBvcHRpb25hbGx5IHdlaWdodHMuICBTZWUgdGhlXG4gKiBUdXRvcmlhbCBuYW1lZCBcIkhvdyB0byBpbXBvcnQgYSBLZXJhcyBNb2RlbFwiIGZvciB1c2FnZSBleGFtcGxlcy5cbiAqXG4gKiBFeGFtcGxlIDE6IFNhdmUgYG1vZGVsYCdzIHRvcG9sb2d5IGFuZCB3ZWlnaHRzIHRvIGJyb3dzZXIgW2xvY2FsXG4gKiBzdG9yYWdlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2xvY2FsU3RvcmFnZSk7XG4gKiB0aGVuIGxvYWQgaXQgYmFjay5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKFxuICogICAgIHtsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbM119KV19KTtcbiAqIGNvbnNvbGUubG9nKCdQcmVkaWN0aW9uIGZyb20gb3JpZ2luYWwgbW9kZWw6Jyk7XG4gKiBtb2RlbC5wcmVkaWN0KHRmLm9uZXMoWzEsIDNdKSkucHJpbnQoKTtcbiAqXG4gKiBjb25zdCBzYXZlUmVzdWx0cyA9IGF3YWl0IG1vZGVsLnNhdmUoJ2xvY2Fsc3RvcmFnZTovL215LW1vZGVsLTEnKTtcbiAqXG4gKiBjb25zdCBsb2FkZWRNb2RlbCA9IGF3YWl0IHRmLmxvYWRMYXllcnNNb2RlbCgnbG9jYWxzdG9yYWdlOi8vbXktbW9kZWwtMScpO1xuICogY29uc29sZS5sb2coJ1ByZWRpY3Rpb24gZnJvbSBsb2FkZWQgbW9kZWw6Jyk7XG4gKiBsb2FkZWRNb2RlbC5wcmVkaWN0KHRmLm9uZXMoWzEsIDNdKSkucHJpbnQoKTtcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGUgMi4gU2F2aW5nIGBtb2RlbGAncyB0b3BvbG9neSBhbmQgd2VpZ2h0cyB0byBicm93c2VyXG4gKiBbSW5kZXhlZERCXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSW5kZXhlZERCX0FQSSk7XG4gKiB0aGVuIGxvYWQgaXQgYmFjay5cbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKFxuICogICAgIHtsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbM119KV19KTtcbiAqIGNvbnNvbGUubG9nKCdQcmVkaWN0aW9uIGZyb20gb3JpZ2luYWwgbW9kZWw6Jyk7XG4gKiBtb2RlbC5wcmVkaWN0KHRmLm9uZXMoWzEsIDNdKSkucHJpbnQoKTtcbiAqXG4gKiBjb25zdCBzYXZlUmVzdWx0cyA9IGF3YWl0IG1vZGVsLnNhdmUoJ2luZGV4ZWRkYjovL215LW1vZGVsLTEnKTtcbiAqXG4gKiBjb25zdCBsb2FkZWRNb2RlbCA9IGF3YWl0IHRmLmxvYWRMYXllcnNNb2RlbCgnaW5kZXhlZGRiOi8vbXktbW9kZWwtMScpO1xuICogY29uc29sZS5sb2coJ1ByZWRpY3Rpb24gZnJvbSBsb2FkZWQgbW9kZWw6Jyk7XG4gKiBsb2FkZWRNb2RlbC5wcmVkaWN0KHRmLm9uZXMoWzEsIDNdKSkucHJpbnQoKTtcbiAqIGBgYFxuICpcbiAqIEV4YW1wbGUgMy4gTG9hZCBhIG1vZGVsIGZyb20gdXNlci1zZWxlY3RlZCBmaWxlcyBmcm9tIEhUTUxcbiAqIFtmaWxlIGlucHV0XG4gKiBlbGVtZW50c10oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSFRNTC9FbGVtZW50L2lucHV0L2ZpbGUpLlxuICpcbiAqIGBgYGpzXG4gKiAvLyBOb3RlOiB0aGlzIGNvZGUgc25pcHBldCB3aWxsIG5vdCB3b3JrIHdpdGhvdXQgdGhlIEhUTUwgZWxlbWVudHMgaW4gdGhlXG4gKiAvLyAgIHBhZ2VcbiAqIGNvbnN0IGpzb25VcGxvYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnanNvbi11cGxvYWQnKTtcbiAqIGNvbnN0IHdlaWdodHNVcGxvYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnd2VpZ2h0cy11cGxvYWQnKTtcbiAqXG4gKiBjb25zdCBtb2RlbCA9IGF3YWl0IHRmLmxvYWRMYXllcnNNb2RlbChcbiAqICAgICB0Zi5pby5icm93c2VyRmlsZXMoW2pzb25VcGxvYWQuZmlsZXNbMF0sIHdlaWdodHNVcGxvYWQuZmlsZXNbMF1dKSk7XG4gKiBgYGBcbiAqXG4gKiBFeGFtcGxlIDQuIExvYWQgYSBtb2RlbCBmcm9tIGFuIEhUVFAgc2VydmVyLlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBtb2RlbCA9IGF3YWl0XG4gKiAgICAgdGYubG9hZExheWVyc01vZGVsKCdodHRwczovL3N0b3JhZ2UuZ29vZ2xlYXBpcy5jb20vdGZqcy1tb2RlbHMvdGZqcy9pcmlzX3YxL21vZGVsLmpzb24nKTtcbiAqIG1vZGVsLnN1bW1hcnkoKTtcbiAqIGBgYFxuICpcbiAqIEBwYXJhbSBwYXRoT3JJT0hhbmRsZXIgQ2FuIGJlIGVpdGhlciBvZiB0aGUgdHdvIGZvcm1hdHNcbiAqICAgMS4gQSBzdHJpbmcgcGF0aCB0byB0aGUgYE1vZGVsQW5kV2VpZ2h0c0NvbmZpZ2AgSlNPTiBkZXNjcmliaW5nXG4gKiAgICAgIHRoZSBtb2RlbCBpbiB0aGUgY2Fub25pY2FsIFRlbnNvckZsb3cuanMgZm9ybWF0LiBUaGlzIHBhdGggd2lsbCBiZVxuICogICAgICBpbnRlcnByZXRlZCBhcyBhIHJlbGF0aXZlIEhUVFAgcGF0aCwgdG8gd2hpY2ggYGZldGNoYCB3aWxsIGJlIHVzZWQgdG9cbiAqICAgICAgcmVxdWVzdCB0aGUgbW9kZWwgdG9wb2xvZ3kgYW5kIHdlaWdodCBtYW5pZmVzdCBKU09OLlxuICogICAgICBUaGUgY29udGVudCBvZiB0aGUgSlNPTiBmaWxlIGlzIGFzc3VtZWQgdG8gYmUgYSBKU09OIG9iamVjdCB3aXRoIHRoZVxuICogICAgICBmb2xsb3dpbmcgZmllbGRzIGFuZCB2YWx1ZXM6XG4gKiAgICAgIC0gJ21vZGVsVG9wb2xvZ3knOiBBIEpTT04gb2JqZWN0IHRoYXQgY2FuIGJlIGVpdGhlciBvZjpcbiAqICAgICAgICAxLiBhIG1vZGVsIGFyY2hpdGVjdHVyZSBKU09OIGNvbnNpc3RlbnQgd2l0aCB0aGUgZm9ybWF0IG9mIHRoZSByZXR1cm5cbiAqICAgICAgICAgICAgdmFsdWUgb2YgYGtlcmFzLk1vZGVsLnRvX2pzb24oKWBcbiAqICAgICAgICAyLiBhIGZ1bGwgbW9kZWwgSlNPTiBpbiB0aGUgZm9ybWF0IG9mIGBrZXJhcy5tb2RlbHMuc2F2ZV9tb2RlbCgpYC5cbiAqICAgICAgLSAnd2VpZ2h0c01hbmlmZXN0JzogQSBUZW5zb3JGbG93LmpzIHdlaWdodHMgbWFuaWZlc3QuXG4gKiAgICAgIFNlZSB0aGUgUHl0aG9uIGNvbnZlcnRlciBmdW5jdGlvbiBgc2F2ZV9tb2RlbCgpYCBmb3IgbW9yZSBkZXRhaWxzLlxuICogICAgICBJdCBpcyBhbHNvIGFzc3VtZWQgdGhhdCBtb2RlbCB3ZWlnaHRzIGNhbiBiZSBhY2Nlc3NlZCBmcm9tIHJlbGF0aXZlXG4gKiAgICAgIHBhdGhzIGRlc2NyaWJlZCBieSB0aGUgYHBhdGhzYCBmaWVsZHMgaW4gd2VpZ2h0cyBtYW5pZmVzdC5cbiAqICAgMi4gQW4gYHRmLmlvLklPSGFuZGxlcmAgb2JqZWN0IHRoYXQgbG9hZHMgbW9kZWwgYXJ0aWZhY3RzIHdpdGggaXRzIGBsb2FkYFxuICogICAgICBtZXRob2QuXG4gKiBAcGFyYW0gb3B0aW9ucyBPcHRpb25hbCBjb25maWd1cmF0aW9uIGFyZ3VtZW50cyBmb3IgdGhlIG1vZGVsIGxvYWRpbmcsXG4gKiAgIGluY2x1ZGluZzpcbiAqICAgLSBgc3RyaWN0YDogUmVxdWlyZSB0aGF0IHRoZSBwcm92aWRlZCB3ZWlnaHRzIGV4YWN0bHkgbWF0Y2ggdGhvc2UgcmVxdWlyZWRcbiAqICAgICBieSB0aGUgbGF5ZXJzLiAgRGVmYXVsdCB0cnVlLiAgUGFzc2luZyBmYWxzZSBtZWFucyB0aGF0IGJvdGggZXh0cmFcbiAqICAgICB3ZWlnaHRzIGFuZCBtaXNzaW5nIHdlaWdodHMgd2lsbCBiZSBzaWxlbnRseSBpZ25vcmVkLlxuICogICAtIGBvblByb2dyZXNzYDogQSBwcm9ncmVzcyBjYWxsYmFjayBvZiB0aGUgZm9ybTpcbiAqICAgICBgKGZyYWN0aW9uOiBudW1iZXIpID0+IHZvaWRgLiBUaGlzIGNhbGxiYWNrIGNhbiBiZSB1c2VkIHRvIG1vbml0b3IgdGhlXG4gKiAgICAgbW9kZWwtbG9hZGluZyBwcm9jZXNzLlxuICogQHJldHVybnMgQSBgUHJvbWlzZWAgb2YgYHRmLkxheWVyc01vZGVsYCwgd2l0aCB0aGUgdG9wb2xvZ3kgYW5kIHdlaWdodHNcbiAqICAgICBsb2FkZWQuXG4gKi9cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2FkTGF5ZXJzTW9kZWxJbnRlcm5hbChcbiAgICBwYXRoT3JJT0hhbmRsZXI6IHN0cmluZ3xpby5JT0hhbmRsZXIsXG4gICAgb3B0aW9ucz86IGlvLkxvYWRPcHRpb25zKTogUHJvbWlzZTxMYXllcnNNb2RlbD4ge1xuICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgb3B0aW9ucyA9IHt9O1xuICB9XG4gIGlmICh0eXBlb2YgcGF0aE9ySU9IYW5kbGVyID09PSAnc3RyaW5nJykge1xuICAgIGNvbnN0IGhhbmRsZXJzID0gaW8uZ2V0TG9hZEhhbmRsZXJzKHBhdGhPcklPSGFuZGxlciwgb3B0aW9ucyk7XG4gICAgaWYgKGhhbmRsZXJzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gRm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHk6IGlmIG5vIGxvYWQgaGFuZGxlciBjYW4gYmUgZm91bmQsXG4gICAgICAvLyBhc3N1bWUgaXQgaXMgYSByZWxhdGl2ZSBodHRwIHBhdGguXG4gICAgICAvLyBUT0RPKGNhaXMpOiBSZWZvcm1hdCB0aGUgYXJncyBpbnRvIGEgc2luZ2xlIGBMb2FkT3B0aW9uc2Agb25jZSB0aGUgY29yZVxuICAgICAgLy8gaXMgcmVmYWN0b3JlZC5cbiAgICAgIGhhbmRsZXJzLnB1c2goaW8uYnJvd3NlckhUVFBSZXF1ZXN0KHBhdGhPcklPSGFuZGxlciwgb3B0aW9ucykpO1xuICAgIH0gZWxzZSBpZiAoaGFuZGxlcnMubGVuZ3RoID4gMSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYEZvdW5kIG1vcmUgdGhhbiBvbmUgKCR7aGFuZGxlcnMubGVuZ3RofSkgbG9hZCBoYW5kbGVycyBmb3IgYCArXG4gICAgICAgICAgYFVSTCAnJHtwYXRoT3JJT0hhbmRsZXJ9J2ApO1xuICAgIH1cbiAgICBwYXRoT3JJT0hhbmRsZXIgPSBoYW5kbGVyc1swXTtcbiAgfVxuICByZXR1cm4gbG9hZExheWVyc01vZGVsRnJvbUlPSGFuZGxlcihwYXRoT3JJT0hhbmRsZXIsIHVuZGVmaW5lZCwgb3B0aW9ucyk7XG59XG5cbi8qKlxuICogTG9hZCBhIG1vZGVsIGFuZCBvcHRpb25hbGx5IGl0cyB3ZWlnaHRzLCB1c2luZyBhbiBJT0hhbmRsZXIgb2JqZWN0LlxuICpcbiAqIEBwYXJhbSBoYW5kbGVyIFRoZSBpbnN0YW5jZSBvZiBgSU9IYW5kbGVyYCB0byBiZSB1c2VkIGR1cmluZyB0aGUgbW9kZWxcbiAqICAgbG9hZGluZy5cbiAqIEBwYXJhbSBjdXN0b21PYmplY3RzIEFueSBvcHRpb25hbCBjdXN0b20gb2JqZWN0cyB0byBiZSB1c2VkIGR1cmluZyBtb2RlbFxuICogICBsb2FkaW5nLlxuICogQHBhcmFtIHN0cmljdCBXaGV0aGVyIHRoZSB3ZWlnaHQgbG9hZGluZyB3aWxsIGJlIGRvbmUgaW4gc3RyaWN0IG1vZGUuXG4gKiAgIERlZmF1bHQ6IGB0cnVlYC5cbiAqL1xuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGxvYWRMYXllcnNNb2RlbEZyb21JT0hhbmRsZXIoXG4gICAgaGFuZGxlcjogaW8uSU9IYW5kbGVyLCBjdXN0b21PYmplY3RzPzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0LFxuICAgIG9wdGlvbnM/OiBpby5Mb2FkT3B0aW9ucyk6IFByb21pc2U8TGF5ZXJzTW9kZWw+IHtcbiAgaWYgKG9wdGlvbnMgPT0gbnVsbCkge1xuICAgIG9wdGlvbnMgPSB7fTtcbiAgfVxuICBpZiAoaGFuZGxlci5sb2FkID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgJ0Nhbm5vdCBwcm9jZWVkIHdpdGggbW9kZWwgbG9hZGluZyBiZWNhdXNlIHRoZSBJT0hhbmRsZXIgcHJvdmlkZWQgJyArXG4gICAgICAgICdkb2VzIG5vdCBoYXZlIHRoZSBgbG9hZGAgbWV0aG9kIGltcGxlbWVudGVkLicpO1xuICB9XG4gIGNvbnN0IGFydGlmYWN0cyA9IGF3YWl0IGhhbmRsZXIubG9hZCgpO1xuICBsZXQgbW9kZWxUb3BvbG9neSA9IGFydGlmYWN0cy5tb2RlbFRvcG9sb2d5IGFzIFB5SnNvbkRpY3Q7XG4gIGlmIChtb2RlbFRvcG9sb2d5Wydtb2RlbF9jb25maWcnXSAhPSBudWxsKSB7XG4gICAgbW9kZWxUb3BvbG9neSA9IG1vZGVsVG9wb2xvZ3lbJ21vZGVsX2NvbmZpZyddIGFzIFB5SnNvbkRpY3Q7XG4gIH1cblxuICBjb25zdCBzdHJpY3QgPSBvcHRpb25zLnN0cmljdCA9PSBudWxsID8gdHJ1ZSA6IG9wdGlvbnMuc3RyaWN0O1xuICAvLyBJZiB3ZWlnaHRzIGFyZSBwcm92aWRlZCBhbmQgdGhlIHdlaWdodC1sb2FkaW5nIG1vZGUgaXMgc3RyaWN0LCB1c2VcbiAgLy8gZmFzdCB3ZWlnaHQgaW5pdGlhbGl6YXRpb24uIFRoaXMgc2tpcHMgY29zdGx5IGluaXRpYWxpemVycyBzdWNoIGFzXG4gIC8vICdvcnRob2dvbmFsJyBhbmQgc2F2ZXMgdW5uZWNlc3NhcnkgY29tcHV0YXRpb24gaW4gY2FzZXMgd2hlcmVcbiAgLy8gdGhlIGluaXRpYWxpemVkIHdlaWdodCB2YWx1ZXMgd2lsbCBpbW1lZGlhdGVseSBiZSBvdmVyd3JpdHRlbiBieVxuICAvLyBsb2FkZWQgd2VpZ2h0IHZhbHVlcy5cbiAgY29uc3QgZmFzdFdlaWdodEluaXQgPVxuICAgICAgYXJ0aWZhY3RzLndlaWdodERhdGEgIT0gbnVsbCAmJiBhcnRpZmFjdHMud2VpZ2h0U3BlY3MgIT0gbnVsbCAmJiBzdHJpY3Q7XG4gIGNvbnN0IG1vZGVsID1cbiAgICAgIGRlc2VyaWFsaXplKFxuICAgICAgICAgIGNvbnZlcnRQeXRob25pY1RvVHMobW9kZWxUb3BvbG9neSkgYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0LFxuICAgICAgICAgIGN1c3RvbU9iamVjdHMsIGZhc3RXZWlnaHRJbml0KSBhcyBMYXllcnNNb2RlbDtcblxuICBjb25zdCB0cmFpbmluZ0NvbmZpZyA9IGFydGlmYWN0cy50cmFpbmluZ0NvbmZpZyBhcyBUcmFpbmluZ0NvbmZpZztcbiAgaWYgKHRyYWluaW5nQ29uZmlnICE9IG51bGwpIHtcbiAgICBtb2RlbC5sb2FkVHJhaW5pbmdDb25maWcodHJhaW5pbmdDb25maWcpO1xuICB9XG4gIGlmIChhcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSAhPSBudWxsKSB7XG4gICAgbW9kZWwuc2V0VXNlckRlZmluZWRNZXRhZGF0YShhcnRpZmFjdHMudXNlckRlZmluZWRNZXRhZGF0YSk7XG4gIH1cblxuICAvLyBJZiB3ZWlnaHREYXRhIGlzIHByZXNlbnQsIGxvYWQgdGhlIHdlaWdodHMgaW50byB0aGUgbW9kZWwuXG4gIGlmIChhcnRpZmFjdHMud2VpZ2h0RGF0YSAhPSBudWxsKSB7XG4gICAgLy8gTG9hZGluZyB3ZWlnaHRzIHJlcXVpcmVzIHdlaWdodFNwZWNzLlxuICAgIGlmIChhcnRpZmFjdHMud2VpZ2h0U3BlY3MgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ0xheWVyc01vZGVsIGFydGlmYWN0cyBjb250YWlucyB3ZWlnaHQgZGF0YSwgYnV0IG5vdCB3ZWlnaHQgc3BlY3MuICcgK1xuICAgICAgICAgICdUaGVyZWZvcmUgbG9hZGluZyBvZiB3ZWlnaHRzIGNhbm5vdCBwcm9jZWVkLicpO1xuICAgIH1cblxuICAgIGNvbnN0IHttb2RlbFdlaWdodHMsIG9wdGltaXplcldlaWdodHN9ID0gZGVjb2RlTW9kZWxBbmRPcHRpbWl6ZXJXZWlnaHRzKFxuICAgICAgICBhcnRpZmFjdHMud2VpZ2h0RGF0YSwgYXJ0aWZhY3RzLndlaWdodFNwZWNzKTtcbiAgICBtb2RlbC5sb2FkV2VpZ2h0cyhtb2RlbFdlaWdodHMsIHN0cmljdCk7XG5cbiAgICBpZiAobW9kZWwub3B0aW1pemVyICE9IG51bGwgJiYgb3B0aW1pemVyV2VpZ2h0cy5sZW5ndGggPiAwKSB7XG4gICAgICBhd2FpdCBtb2RlbC5vcHRpbWl6ZXIuc2V0V2VpZ2h0cyhvcHRpbWl6ZXJXZWlnaHRzKTtcbiAgICB9XG5cbiAgICAvLyBEaXNwb3NlIHRlbXBvcmFyeSB3ZWlnaHQgdmFsdWVzLlxuICAgIGRpc3Bvc2UobW9kZWxXZWlnaHRzKTtcbiAgICBkaXNwb3NlKG9wdGltaXplcldlaWdodHMubWFwKHcgPT4gdy50ZW5zb3IpKTtcbiAgfVxuICByZXR1cm4gbW9kZWw7XG59XG5cbmZ1bmN0aW9uIGRlY29kZU1vZGVsQW5kT3B0aW1pemVyV2VpZ2h0cyhcbiAgICBidWZmZXI6IEFycmF5QnVmZmVyLCBzcGVjczogaW8uV2VpZ2h0c01hbmlmZXN0RW50cnlbXSk6XG4gICAge21vZGVsV2VpZ2h0czogTmFtZWRUZW5zb3JNYXAsIG9wdGltaXplcldlaWdodHM6IE5hbWVkVGVuc29yW119IHtcbiAgY29uc3QgbmFtZTJUZW5zb3IgPSBpby5kZWNvZGVXZWlnaHRzKGJ1ZmZlciwgc3BlY3MpO1xuICBjb25zdCBtb2RlbFdlaWdodHM6IE5hbWVkVGVuc29yTWFwID0ge307XG4gIGNvbnN0IG9wdGltaXplcldlaWdodHM6IE5hbWVkVGVuc29yW10gPSBbXTtcbiAgc3BlY3MuZm9yRWFjaChzcGVjID0+IHtcbiAgICBpZiAoc3BlYy5ncm91cCA9PT0gJ29wdGltaXplcicpIHtcbiAgICAgIG9wdGltaXplcldlaWdodHMucHVzaCh7bmFtZTogc3BlYy5uYW1lLCB0ZW5zb3I6IG5hbWUyVGVuc29yW3NwZWMubmFtZV19KTtcbiAgICB9IGVsc2Uge1xuICAgICAgbW9kZWxXZWlnaHRzW3NwZWMubmFtZV0gPSBuYW1lMlRlbnNvcltzcGVjLm5hbWVdO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiB7bW9kZWxXZWlnaHRzLCBvcHRpbWl6ZXJXZWlnaHRzfTtcbn1cblxuLyoqXG4gKiBDb25maWd1cmF0aW9uIGZvciBhIFNlcXVlbnRpYWwgbW9kZWwuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgU2VxdWVudGlhbEFyZ3Mge1xuICAvKiogU3RhY2sgb2YgbGF5ZXJzIGZvciB0aGUgbW9kZWwuICovXG4gIGxheWVycz86IExheWVyW107XG5cbiAgLyoqIFRoZSBuYW1lIG9mIHRoaXMgbW9kZWwuICovXG4gIG5hbWU/OiBzdHJpbmc7XG59XG5cbi8qKlxuICogQSBtb2RlbCB3aXRoIGEgc3RhY2sgb2YgbGF5ZXJzLCBmZWVkaW5nIGxpbmVhcmx5IGZyb20gb25lIHRvIHRoZSBuZXh0LlxuICpcbiAqIGB0Zi5zZXF1ZW50aWFsYCBpcyBhIGZhY3RvcnkgZnVuY3Rpb24gdGhhdCBjcmVhdGVzIGFuIGluc3RhbmNlIG9mXG4gKiBgdGYuU2VxdWVudGlhbGAuXG4gKlxuICogYGBganNcbiAqICAvLyBEZWZpbmUgYSBtb2RlbCBmb3IgbGluZWFyIHJlZ3Jlc3Npb24uXG4gKiAgY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKCk7XG4gKiAgbW9kZWwuYWRkKHRmLmxheWVycy5kZW5zZSh7dW5pdHM6IDEsIGlucHV0U2hhcGU6IFsxXX0pKTtcbiAqXG4gKiAgLy8gUHJlcGFyZSB0aGUgbW9kZWwgZm9yIHRyYWluaW5nOiBTcGVjaWZ5IHRoZSBsb3NzIGFuZCB0aGUgb3B0aW1pemVyLlxuICogIG1vZGVsLmNvbXBpbGUoe2xvc3M6ICdtZWFuU3F1YXJlZEVycm9yJywgb3B0aW1pemVyOiAnc2dkJ30pO1xuICpcbiAqICAvLyBHZW5lcmF0ZSBzb21lIHN5bnRoZXRpYyBkYXRhIGZvciB0cmFpbmluZy5cbiAqICBjb25zdCB4cyA9IHRmLnRlbnNvcjJkKFsxLCAyLCAzLCA0XSwgWzQsIDFdKTtcbiAqICBjb25zdCB5cyA9IHRmLnRlbnNvcjJkKFsxLCAzLCA1LCA3XSwgWzQsIDFdKTtcbiAqXG4gKiAgLy8gVHJhaW4gdGhlIG1vZGVsIHVzaW5nIHRoZSBkYXRhIHRoZW4gZG8gaW5mZXJlbmNlIG9uIGEgZGF0YSBwb2ludCB0aGVcbiAqICAvLyBtb2RlbCBoYXNuJ3Qgc2VlbjpcbiAqICBhd2FpdCBtb2RlbC5maXQoeHMsIHlzKTtcbiAqICBtb2RlbC5wcmVkaWN0KHRmLnRlbnNvcjJkKFs1XSwgWzEsIDFdKSkucHJpbnQoKTtcbiAqIGBgYFxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gKi9cbmV4cG9ydCBjbGFzcyBTZXF1ZW50aWFsIGV4dGVuZHMgTGF5ZXJzTW9kZWwge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdTZXF1ZW50aWFsJztcbiAgcHJpdmF0ZSBtb2RlbDogTGF5ZXJzTW9kZWw7XG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBTZXF1ZW50aWFsQXJncykge1xuICAgIHN1cGVyKHtpbnB1dHM6IFtdLCBvdXRwdXRzOiBbXX0pO1xuICAgIGFyZ3MgPSBhcmdzIHx8IHt9O1xuXG4gICAgdGhpcy50cmFpbmFibGUgPSB0cnVlO1xuICAgIHRoaXMuYnVpbHQgPSBmYWxzZTtcblxuICAgIC8vIFNldCBtb2RlbCBuYW1lLlxuICAgIHRoaXMubmFtZSA9IChhcmdzLm5hbWUgIT0gbnVsbCkgPyBhcmdzLm5hbWUgOiBnZXRVaWQoJ3NlcXVlbnRpYWxfJyk7XG5cbiAgICAvLyBBZGQgdG8gdGhlIG1vZGVsIGFueSBsYXllcnMgcGFzc2VkIHRvIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICBpZiAoYXJncy5sYXllcnMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiBhcmdzLmxheWVycykge1xuICAgICAgICB0aGlzLmFkZChsYXllcik7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIFNlcXVlbnRpYWwuYWRkICBUaHJvd3MgaWYgdGhlIG5ldyBvdXRwdXQgc2hhcGUgd2lsbCBiZVxuICAvLyBpbnZhbGlkLlxuICBwcml2YXRlIGNoZWNrU2hhcGUobGF5ZXI6IExheWVyKSB7XG4gICAgY29uc3Qgc2hhcGUgPSBsYXllci5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29yc1swXS5zaGFwZTtcbiAgICBpZiAoc2hhcGUuc29tZSh4ID0+IHggPCAwKSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ05lZ2F0aXZlIGRpbWVuc2lvbiBzaXplIGNhdXNlZCBieSBhZGRpbmcgbGF5ZXIgJyArXG4gICAgICAgICAgYCR7bGF5ZXIubmFtZX0gd2l0aCBpbnB1dCBzaGFwZSBbYCArXG4gICAgICAgICAgYCR7bGF5ZXIuaW5ib3VuZE5vZGVzWzBdLmlucHV0VGVuc29yc1swXS5zaGFwZX1dYCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEFkZHMgYSBsYXllciBpbnN0YW5jZSBvbiB0b3Agb2YgdGhlIGxheWVyIHN0YWNrLlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiAgY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKCk7XG4gICAqICBtb2RlbC5hZGQodGYubGF5ZXJzLmRlbnNlKHt1bml0czogOCwgaW5wdXRTaGFwZTogWzFdfSkpO1xuICAgKiAgbW9kZWwuYWRkKHRmLmxheWVycy5kZW5zZSh7dW5pdHM6IDQsIGFjdGl2YXRpb246ICdyZWx1Nid9KSk7XG4gICAqICBtb2RlbC5hZGQodGYubGF5ZXJzLmRlbnNlKHt1bml0czogMSwgYWN0aXZhdGlvbjogJ3JlbHU2J30pKTtcbiAgICogIC8vIE5vdGUgdGhhdCB0aGUgdW50cmFpbmVkIG1vZGVsIGlzIHJhbmRvbSBhdCB0aGlzIHBvaW50LlxuICAgKiAgbW9kZWwucHJlZGljdCh0Zi5yYW5kb21Ob3JtYWwoWzEwLCAxXSkpLnByaW50KCk7XG4gICAqIGBgYFxuICAgKiBAcGFyYW0gbGF5ZXIgTGF5ZXIgaW5zdGFuY2UuXG4gICAqXG4gICAqIEBleGNlcHRpb24gVmFsdWVFcnJvciBJbiBjYXNlIHRoZSBgbGF5ZXJgIGFyZ3VtZW50IGRvZXMgbm90IGtub3cgaXRzXG4gICAqIGlucHV0IHNoYXBlLlxuICAgKiBAZXhjZXB0aW9uIFZhbHVlRXJyb3IgSW4gY2FzZSB0aGUgYGxheWVyYCBhcmd1bWVudCBoYXMgbXVsdGlwbGUgb3V0cHV0XG4gICAqICAgdGVuc29ycywgb3IgaXMgYWxyZWFkeSBjb25uZWN0ZWQgc29tZXdoZXJlIGVsc2UgKGZvcmJpZGRlbiBpblxuICAgKiAgIGBTZXF1ZW50aWFsYCBtb2RlbHMpLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgYWRkKGxheWVyOiBMYXllcik6IHZvaWQge1xuICAgIGNvbnN0IGlzTGF5ZXJNb2RlbEluc3RhbmNlID1cbiAgICAgICAgbGF5ZXIgaW5zdGFuY2VvZiBTZXF1ZW50aWFsIHx8IGxheWVyIGluc3RhbmNlb2YgTGF5ZXJzTW9kZWw7XG4gICAgbGV0IG1vZGVsTGF5ZXI6IExheWVyc01vZGVsO1xuICAgIGlmIChpc0xheWVyTW9kZWxJbnN0YW5jZSkge1xuICAgICAgbW9kZWxMYXllciA9IGxheWVyIGFzIExheWVyc01vZGVsO1xuICAgICAgaWYgKG1vZGVsTGF5ZXIub3V0cHV0cy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAnQWxsIGxheWVycyBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgJyArXG4gICAgICAgICAgICAnc2hvdWxkIGhhdmUgYSBzaW5nbGUgb3V0cHV0IHRlbnNvci4gJyArXG4gICAgICAgICAgICAnRm9yIG11bHRpLW91dHB1dCBsYXllcnMsICcgK1xuICAgICAgICAgICAgJ3VzZSB0aGUgZnVuY3Rpb25hbCBBUEkuJyk7XG4gICAgICB9XG4gICAgICBpZiAobW9kZWxMYXllci5pbnB1dHMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgJ0FsbCBsYXllcnMgaW4gYSBTZXF1ZW50aWFsIG1vZGVsICcgK1xuICAgICAgICAgICAgJ3Nob3VsZCBoYXZlIGEgc2luZ2xlIGlucHV0IHRlbnNvci4gJyArXG4gICAgICAgICAgICAnRm9yIG11bHRpLWlucHV0IGxheWVycywgJyArXG4gICAgICAgICAgICAndXNlIHRoZSBmdW5jdGlvbmFsIEFQSS4nKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAodGhpcy5vdXRwdXRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgLy8gZmlyc3QgbGF5ZXIgaW4gbW9kZWw6IGNoZWNrIHRoYXQgaXQgaXMgYW4gaW5wdXQgbGF5ZXJcbiAgICAgIGlmIChsYXllci5pbmJvdW5kTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIC8vIGNyZWF0ZSBhbiBpbnB1dCBsYXllclxuICAgICAgICBpZiAobGF5ZXIuYmF0Y2hJbnB1dFNoYXBlID09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgJ1RoZSBmaXJzdCBsYXllciBpbiBhIFNlcXVlbnRpYWwgbW9kZWwgbXVzdCAnICtcbiAgICAgICAgICAgICAgJ2dldCBhbiBgaW5wdXRTaGFwZWAgb3IgYGJhdGNoSW5wdXRTaGFwZWAgYXJndW1lbnQuJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gSW5zdGFudGlhdGUgdGhlIGlucHV0IGxheWVyLlxuICAgICAgICBjb25zdCB4ID0gSW5wdXQoe1xuICAgICAgICAgIGJhdGNoU2hhcGU6IGxheWVyLmJhdGNoSW5wdXRTaGFwZSxcbiAgICAgICAgICBkdHlwZTogbGF5ZXIuZHR5cGUsXG4gICAgICAgICAgbmFtZTogbGF5ZXIubmFtZSArICdfaW5wdXQnXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBUaGlzIHdpbGwgYnVpbGQgdGhlIGN1cnJlbnQgbGF5ZXIgYW5kIGNyZWF0ZSB0aGUgbm9kZSBjb25uZWN0aW5nXG4gICAgICAgIC8vIHRoZSBjdXJyZW50IGxheWVyIHRvIHRoZSBpbnB1dCBsYXllciB3ZSBqdXN0IGNyZWF0ZWQuXG4gICAgICAgIGxheWVyLmFwcGx5KHgpO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNMYXllck1vZGVsSW5zdGFuY2UpIHtcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gbW9kZWxMYXllci5vdXRwdXRzO1xuICAgICAgICB0aGlzLmlucHV0cyA9IG1vZGVsTGF5ZXIuaW5wdXRzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGxheWVyLmluYm91bmROb2Rlcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgJ0EgbGF5ZXIgYWRkZWQgdG8gYSBTZXF1ZW50aWFsIG1vZGVsIG11c3Qgbm90IGFscmVhZHkgYmUgJyArXG4gICAgICAgICAgICAgIGBjb25uZWN0ZWQgc29tZXdoZXJlIGVsc2UuIExheWVyc01vZGVsIHJlY2VpdmVkIGxheWVyICR7XG4gICAgICAgICAgICAgICAgICBsYXllci5uYW1lfSBgICtcbiAgICAgICAgICAgICAgYHdoaWNoIGhhcyAke2xheWVyLmluYm91bmROb2Rlcy5sZW5ndGh9IHByZS1leGlzdGluZyBpbmJvdW5kIGAgK1xuICAgICAgICAgICAgICAnY29ubmVjdGlvbnMuJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobGF5ZXIuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnMubGVuZ3RoICE9PSAxKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgICdBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCAnICtcbiAgICAgICAgICAgICAgJ3Nob3VsZCBoYXZlIGEgc2luZ2xlIG91dHB1dCB0ZW5zb3IuICcgK1xuICAgICAgICAgICAgICAnRm9yIG11bHRpLW91dHB1dCBsYXllcnMsICcgK1xuICAgICAgICAgICAgICAndXNlIHRoZSBmdW5jdGlvbmFsIEFQSS4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNoZWNrU2hhcGUobGF5ZXIpO1xuICAgICAgICB0aGlzLm91dHB1dHMgPSBbbGF5ZXIuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnNbMF1dO1xuICAgICAgICB0aGlzLmlucHV0cyA9IGdldFNvdXJjZUlucHV0cyh0aGlzLm91dHB1dHNbMF0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmluYm91bmROb2RlcyA9IFtdO1xuICAgICAgLy8gV2UgY3JlYXRlIGFuIGlucHV0IG5vZGUsIHdoaWNoIHdlIHdpbGwga2VlcCB1cGRhdGVkXG4gICAgICAvLyBhcyB3ZSBhZGQgbW9yZSBsYXllcnMuXG4gICAgICAvLyAoVGhpcyBjYWxsIGhhcyBzaWRlIGVmZmVjdHMuKVxuICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXVudXNlZC1leHByZXNzaW9uXG4gICAgICBuZXcgTm9kZSh7XG4gICAgICAgIG91dGJvdW5kTGF5ZXI6IHRoaXMsXG4gICAgICAgIGluYm91bmRMYXllcnM6IFtdLFxuICAgICAgICBub2RlSW5kaWNlczogW10sXG4gICAgICAgIHRlbnNvckluZGljZXM6IFtdLFxuICAgICAgICBpbnB1dFRlbnNvcnM6IHRoaXMuaW5wdXRzLFxuICAgICAgICBvdXRwdXRUZW5zb3JzOiB0aGlzLm91dHB1dHMsXG4gICAgICAgIC8vIG5vIG1vZGVsLWxldmVsIG1hc2tpbmcgZm9yIG5vd1xuICAgICAgICBpbnB1dE1hc2tzOiBnZW5lcmljX3V0aWxzLnB5TGlzdFJlcGVhdChudWxsLCB0aGlzLmlucHV0cy5sZW5ndGgpLFxuICAgICAgICBvdXRwdXRNYXNrczogW251bGxdLFxuICAgICAgICBpbnB1dFNoYXBlczogdGhpcy5pbnB1dHMubWFwKHggPT4geC5zaGFwZSksXG4gICAgICAgIG91dHB1dFNoYXBlczogdGhpcy5vdXRwdXRzWzBdLnNoYXBlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3Qgb3V0cHV0VGVuc29yID0gbGF5ZXIuYXBwbHkodGhpcy5vdXRwdXRzWzBdKTtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KG91dHB1dFRlbnNvcikpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgICAgICAgICdBbGwgbGF5ZXJzIGluIGEgU2VxdWVudGlhbCBtb2RlbCAnICtcbiAgICAgICAgICAgICdzaG91bGQgaGF2ZSBhIHNpbmdsZSBvdXRwdXQgdGVuc29yLiAnICtcbiAgICAgICAgICAgICdGb3IgbXVsdGktb3V0cHV0IGxheWVycywgJyArXG4gICAgICAgICAgICAndXNlIHRoZSBmdW5jdGlvbmFsIEFQSS4nKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY2hlY2tTaGFwZShsYXllcik7XG4gICAgICB0aGlzLm91dHB1dHMgPSBbb3V0cHV0VGVuc29yIGFzIFN5bWJvbGljVGVuc29yXTtcbiAgICAgIC8vIHVwZGF0ZSBzZWxmLmluYm91bmRfbm9kZXNcbiAgICAgIHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFRlbnNvcnMgPSB0aGlzLm91dHB1dHM7XG4gICAgICB0aGlzLmluYm91bmROb2Rlc1swXS5vdXRwdXRTaGFwZXMgPSBbdGhpcy5vdXRwdXRzWzBdLnNoYXBlXTtcbiAgICB9XG5cbiAgICB0aGlzLmxheWVycy5wdXNoKGxheWVyKTtcbiAgICB0aGlzLmJ1aWx0ID0gZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlcyB0aGUgbGFzdCBsYXllciBpbiB0aGUgbW9kZWwuXG4gICAqXG4gICAqIEBleGNlcHRpb24gVHlwZUVycm9yIGlmIHRoZXJlIGFyZSBubyBsYXllcnMgaW4gdGhlIG1vZGVsLlxuICAgKi9cbiAgcG9wKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZXJlIGFyZSBubyBsYXllcnMgaW4gdGhlIG1vZGVsLicpO1xuICAgIH1cblxuICAgIHRoaXMubGF5ZXJzLnBvcCgpO1xuICAgIGlmICh0aGlzLmxheWVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMub3V0cHV0cyA9IFtdO1xuICAgICAgdGhpcy5pbmJvdW5kTm9kZXMgPSBbXTtcbiAgICAgIHRoaXMub3V0Ym91bmROb2RlcyA9IFtdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBsYXN0TGF5ZXJJbmRleCA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7XG4gICAgICB0aGlzLmxheWVyc1tsYXN0TGF5ZXJJbmRleF0ub3V0Ym91bmROb2RlcyA9IFtdO1xuICAgICAgdGhpcy5vdXRwdXRzID0gW3RoaXMubGF5ZXJzW2xhc3RMYXllckluZGV4XS5vdXRwdXQgYXMgU3ltYm9saWNUZW5zb3JdO1xuICAgICAgLy8gdXBkYXRlIHNlbGYuaW5ib3VuZF9ub2Rlc1xuICAgICAgdGhpcy5pbmJvdW5kTm9kZXNbMF0ub3V0cHV0VGVuc29ycyA9IHRoaXMub3V0cHV0cztcbiAgICAgIHRoaXMuaW5ib3VuZE5vZGVzWzBdLm91dHB1dFNoYXBlcyA9IFt0aGlzLm91dHB1dHNbMF0uc2hhcGVdO1xuICAgIH1cbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICBpZiAodGhpcy5tb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vZGVsLmNhbGwoaW5wdXRzLCBrd2FyZ3MpO1xuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZT86IFNoYXBlfFNoYXBlW10pIHtcbiAgICAvLyBDYWxsIGBnZXRFeGFjdGx5T25lU2hhcGVgIHdpdGhvdXQgdXNpbmcgaXRzIHJldHVybiB2YWx1ZSxcbiAgICAvLyB0byB2ZXJpZnkgdGhhdCBleGFjdGx5IG9uZSBpbnB1dCBzaGFwZSBpcyBwcm92aWRlZC5cbiAgICBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG5cbiAgICBpZiAodGhpcy5pbnB1dHMubGVuZ3RoID09PSAwIHx8IHRoaXMub3V0cHV0cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgJ1NlcXVlbnRpYWwgbW9kZWwgY2Fubm90IGJlIGJ1aWx0OiBtb2RlbCBpcyBlbXB0eS4nICtcbiAgICAgICAgICAnIEFkZCBzb21lIGxheWVycyBmaXJzdC4nKTtcbiAgICB9XG4gICAgLy8gYWN0dWFsbHkgY3JlYXRlIHRoZSBtb2RlbFxuICAgIHRoaXMubW9kZWwgPSBuZXcgTGF5ZXJzTW9kZWwoe1xuICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cyxcbiAgICAgIG91dHB1dHM6IHRoaXMub3V0cHV0c1swXSxcbiAgICAgIG5hbWU6IHRoaXMubmFtZSArICdfbW9kZWwnXG4gICAgfSk7XG4gICAgdGhpcy5tb2RlbC50cmFpbmFibGUgPSB0aGlzLnRyYWluYWJsZTtcblxuICAgIC8vIG1pcnJvciBtb2RlbCBhdHRyaWJ1dGVzXG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0aGlzLm1vZGVsLnN1cHBvcnRzTWFza2luZztcbiAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IEFkZCBjYWNoZXNcbiAgICB0aGlzLmlucHV0TGF5ZXJzID0gdGhpcy5tb2RlbC5pbnB1dExheWVycztcbiAgICB0aGlzLmlucHV0TGF5ZXJzTm9kZUluZGljZXMgPSB0aGlzLm1vZGVsLmlucHV0TGF5ZXJzTm9kZUluZGljZXM7XG4gICAgdGhpcy5pbnB1dExheWVyc1RlbnNvckluZGljZXMgPSB0aGlzLm1vZGVsLmlucHV0TGF5ZXJzVGVuc29ySW5kaWNlcztcbiAgICB0aGlzLm91dHB1dExheWVycyA9IHRoaXMubW9kZWwub3V0cHV0TGF5ZXJzO1xuICAgIHRoaXMub3V0cHV0TGF5ZXJzTm9kZUluZGljZXMgPSB0aGlzLm1vZGVsLm91dHB1dExheWVyc05vZGVJbmRpY2VzO1xuICAgIHRoaXMub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcyA9IHRoaXMubW9kZWwub3V0cHV0TGF5ZXJzVGVuc29ySW5kaWNlcztcbiAgICB0aGlzLm5vZGVzQnlEZXB0aCA9IHRoaXMubW9kZWwubm9kZXNCeURlcHRoO1xuICAgIHRoaXMuY29udGFpbmVyTm9kZXMgPSB0aGlzLm1vZGVsLmNvbnRhaW5lck5vZGVzO1xuICAgIHRoaXMub3V0cHV0TmFtZXMgPSB0aGlzLm1vZGVsLm91dHB1dE5hbWVzO1xuICAgIHRoaXMuaW5wdXROYW1lcyA9IHRoaXMubW9kZWwuaW5wdXROYW1lcztcbiAgICAvLyBUT0RPKG1pY2hhZWx0ZXJyeSk6IEFkZCBmZWVkSW5wdXROYW1lcywgZmVlZElucHV0cywgaWYgbmVlZGVkLlxuICAgIC8vIFRPRE8obWljaGFlbHRlcnJ5KTogQWRkIGNhbGxiYWNrTW9kZWwgaWYgbmVlZGVkLlxuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY291bnRQYXJhbXMoKTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMuYnVpbHQpIHtcbiAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN1cGVyLmNvdW50UGFyYW1zKCk7XG4gIH1cblxuICAvKipcbiAgICogUHJpbnQgYSB0ZXh0IHN1bW1hcnkgb2YgdGhlIFNlcXVlbnRpYWwgbW9kZWwncyBsYXllcnMuXG4gICAqXG4gICAqIFRoZSBzdW1tYXJ5IGluY2x1ZGVzXG4gICAqIC0gTmFtZSBhbmQgdHlwZSBvZiBhbGwgbGF5ZXJzIHRoYXQgY29tcHJpc2UgdGhlIG1vZGVsLlxuICAgKiAtIE91dHB1dCBzaGFwZShzKSBvZiB0aGUgbGF5ZXJzXG4gICAqIC0gTnVtYmVyIG9mIHdlaWdodCBwYXJhbWV0ZXJzIG9mIGVhY2ggbGF5ZXJcbiAgICogLSBUaGUgdG90YWwgbnVtYmVyIG9mIHRyYWluYWJsZSBhbmQgbm9uLXRyYWluYWJsZSBwYXJhbWV0ZXJzIG9mIHRoZVxuICAgKiBtb2RlbC5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKCk7XG4gICAqIG1vZGVsLmFkZChcbiAgICogICAgIHRmLmxheWVycy5kZW5zZSh7dW5pdHM6IDEwMCwgaW5wdXRTaGFwZTogWzEwXSwgYWN0aXZhdGlvbjogJ3JlbHUnfSkpO1xuICAgKiBtb2RlbC5hZGQodGYubGF5ZXJzLmRlbnNlKHt1bml0czogMSwgYWN0aXZhdGlvbjogJ3NpZ21vaWQnfSkpO1xuICAgKlxuICAgKiBtb2RlbC5zdW1tYXJ5KCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0gbGluZUxlbmd0aCBDdXN0b20gbGluZSBsZW5ndGgsIGluIG51bWJlciBvZiBjaGFyYWN0ZXJzLlxuICAgKiBAcGFyYW0gcG9zaXRpb25zIEN1c3RvbSB3aWR0aHMgb2YgZWFjaCBvZiB0aGUgY29sdW1ucywgYXMgZWl0aGVyXG4gICAqICAgZnJhY3Rpb25zIG9mIGBsaW5lTGVuZ3RoYCAoZS5nLiwgYFswLjUsIDAuNzUsIDFdYCkgb3IgYWJzb2x1dGUgbnVtYmVyXG4gICAqICAgb2YgY2hhcmFjdGVycyAoZS5nLiwgYFszMCwgNTAsIDY1XWApLiBFYWNoIG51bWJlciBjb3JyZXNwb25kcyB0b1xuICAgKiAgIHJpZ2h0LW1vc3QgKGkuZS4sIGVuZGluZykgcG9zaXRpb24gb2YgYSBjb2x1bW4uXG4gICAqIEBwYXJhbSBwcmludEZuIEN1c3RvbSBwcmludCBmdW5jdGlvbi4gQ2FuIGJlIHVzZWQgdG8gcmVwbGFjZSB0aGUgZGVmYXVsdFxuICAgKiAgIGBjb25zb2xlLmxvZ2AuIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSBgeCA9PiB7fWAgdG8gbXV0ZSB0aGUgcHJpbnRlZFxuICAgKiAgIG1lc3NhZ2VzIGluIHRoZSBjb25zb2xlLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgc3VtbWFyeShcbiAgICAgIGxpbmVMZW5ndGg/OiBudW1iZXIsIHBvc2l0aW9ucz86IG51bWJlcltdLFxuICAgICAgcHJpbnRGbjpcbiAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgICAobWVzc2FnZT86IGFueSwgLi4ub3B0aW9uYWxQYXJhbXM6IGFueVtdKSA9PiB2b2lkID0gY29uc29sZS5sb2cpIHtcbiAgICBpZiAoIXRoaXMuYnVpbHQpIHtcbiAgICAgIHRoaXMuYnVpbGQoKTtcbiAgICB9XG4gICAgc3VwZXIuc3VtbWFyeShsaW5lTGVuZ3RoLCBwb3NpdGlvbnMsIHByaW50Rm4pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHMgdGhlIHdlaWdodHMgb2YgdGhlIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gd2VpZ2h0cyBTaG91bGQgYmUgYSBsaXN0IG9mIFRlbnNvcnMgd2l0aCBzaGFwZXMgYW5kIHR5cGVzIG1hdGNoaW5nXG4gICAqICAgdGhlIG91dHB1dCBvZiBgbW9kZWwuZ2V0V2VpZ2h0cygpYC5cbiAgICovXG4gIHNldFdlaWdodHMod2VpZ2h0czogVGVuc29yW10pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5tb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICAgIHRoaXMubW9kZWwuc2V0V2VpZ2h0cyh3ZWlnaHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBsb3NzIHZhbHVlICYgbWV0cmljcyB2YWx1ZXMgZm9yIHRoZSBtb2RlbCBpbiB0ZXN0IG1vZGUuXG4gICAqXG4gICAqIExvc3MgYW5kIG1ldHJpY3MgYXJlIHNwZWNpZmllZCBkdXJpbmcgYGNvbXBpbGUoKWAsIHdoaWNoIG5lZWRzIHRvIGhhcHBlblxuICAgKiBiZWZvcmUgY2FsbHMgdG8gYGV2YWx1YXRlKClgLlxuICAgKlxuICAgKiBDb21wdXRhdGlvbiBpcyBkb25lIGluIGJhdGNoZXMuXG4gICAqXG4gICAqIGBgYGpzXG4gICAqIGNvbnN0IG1vZGVsID0gdGYuc2VxdWVudGlhbCh7XG4gICAqICAgbGF5ZXJzOiBbdGYubGF5ZXJzLmRlbnNlKHt1bml0czogMSwgaW5wdXRTaGFwZTogWzEwXX0pXVxuICAgKiB9KTtcbiAgICogbW9kZWwuY29tcGlsZSh7b3B0aW1pemVyOiAnc2dkJywgbG9zczogJ21lYW5TcXVhcmVkRXJyb3InfSk7XG4gICAqIGNvbnN0IHJlc3VsdCA9IG1vZGVsLmV2YWx1YXRlKHRmLm9uZXMoWzgsIDEwXSksIHRmLm9uZXMoWzgsIDFdKSwge1xuICAgKiAgIGJhdGNoU2l6ZTogNCxcbiAgICogfSk7XG4gICAqIHJlc3VsdC5wcmludCgpO1xuICAgKiBgYGBcbiAgICpcbiAgICogQHBhcmFtIHggYHRmLlRlbnNvcmAgb2YgdGVzdCBkYXRhLCBvciBhbiBgQXJyYXlgIG9mIGB0Zi5UZW5zb3JgcyBpZiB0aGVcbiAgICogbW9kZWwgaGFzIG11bHRpcGxlIGlucHV0cy5cbiAgICogQHBhcmFtIHkgYHRmLlRlbnNvcmAgb2YgdGFyZ2V0IGRhdGEsIG9yIGFuIGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzIGlmIHRoZVxuICAgKiBtb2RlbCBoYXMgbXVsdGlwbGUgb3V0cHV0cy5cbiAgICogQHBhcmFtIGFyZ3MgQSBgTW9kZWxFdmFsdWF0ZUNvbmZpZ2AsIGNvbnRhaW5pbmcgb3B0aW9uYWwgZmllbGRzLlxuICAgKlxuICAgKiBAcmV0dXJuIGBTY2FsYXJgIHRlc3QgbG9zcyAoaWYgdGhlIG1vZGVsIGhhcyBhIHNpbmdsZSBvdXRwdXQgYW5kIG5vXG4gICAqICAgbWV0cmljcykgb3IgYEFycmF5YCBvZiBgU2NhbGFyYHMgKGlmIHRoZSBtb2RlbCBoYXMgbXVsdGlwbGUgb3V0cHV0c1xuICAgKiAgIGFuZC9vciBtZXRyaWNzKS4gVGhlIGF0dHJpYnV0ZSBgbW9kZWwubWV0cmljc05hbWVzYFxuICAgKiAgIHdpbGwgZ2l2ZSB5b3UgdGhlIGRpc3BsYXkgbGFiZWxzIGZvciB0aGUgc2NhbGFyIG91dHB1dHMuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBldmFsdWF0ZShcbiAgICAgIHg6IFRlbnNvcnxUZW5zb3JbXSwgeTogVGVuc29yfFRlbnNvcltdLFxuICAgICAgYXJnczogTW9kZWxFdmFsdWF0ZUFyZ3MgPSB7fSk6IFNjYWxhcnxTY2FsYXJbXSB7XG4gICAgaWYgKCF0aGlzLmJ1aWx0KSB7XG4gICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFxuICAgICAgICAgICdUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlIGJlaW5nIHVzZWQuJyk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vZGVsLmV2YWx1YXRlKHgsIHksIGFyZ3MpO1xuICB9XG5cbiAgLy8gVE9ETyhjYWlzKTogQWRkIGNvZGUgc25pcHBldCBiZWxvdyBvbmNlIHJlYWwgZGF0YXNldCBvYmplY3RzIGFyZVxuICAvLyAgIGF2YWlsYWJsZS5cbiAgLyoqXG4gICAqIEV2YWx1YXRlIG1vZGVsIHVzaW5nIGEgZGF0YXNldCBvYmplY3QuXG4gICAqXG4gICAqIE5vdGU6IFVubGlrZSBgZXZhbHVhdGUoKWAsIHRoaXMgbWV0aG9kIGlzIGFzeW5jaHJvbm91cyAoYGFzeW5jYCk7XG4gICAqXG4gICAqIEBwYXJhbSBkYXRhc2V0IEEgZGF0YXNldCBvYmplY3QuIEl0cyBgaXRlcmF0b3IoKWAgbWV0aG9kIGlzIGV4cGVjdGVkXG4gICAqICAgdG8gZ2VuZXJhdGUgYSBkYXRhc2V0IGl0ZXJhdG9yIG9iamVjdCwgdGhlIGBuZXh0KClgIG1ldGhvZCBvZiB3aGljaFxuICAgKiAgIGlzIGV4cGVjdGVkIHRvIHByb2R1Y2UgZGF0YSBiYXRjaGVzIGZvciBldmFsdWF0aW9uLiBUaGUgcmV0dXJuIHZhbHVlXG4gICAqICAgb2YgdGhlIGBuZXh0KClgIGNhbGwgb3VnaHQgdG8gY29udGFpbiBhIGJvb2xlYW4gYGRvbmVgIGZpZWxkIGFuZCBhXG4gICAqICAgYHZhbHVlYCBmaWVsZC4gVGhlIGB2YWx1ZWAgZmllbGQgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXkgb2YgdHdvXG4gICAqICAgYHRmLlRlbnNvcmBzIG9yIGFuIGFycmF5IG9mIHR3byBuZXN0ZWQgYHRmLlRlbnNvcmAgc3RydWN0dXJlcy4gVGhlIGZvcm1lclxuICAgKiAgIGNhc2UgaXMgZm9yIG1vZGVscyB3aXRoIGV4YWN0bHkgb25lIGlucHV0IGFuZCBvbmUgb3V0cHV0IChlLmcuLlxuICAgKiAgIGEgc2VxdWVudGlhbCBtb2RlbCkuIFRoZSBsYXR0ZXIgY2FzZSBpcyBmb3IgbW9kZWxzIHdpdGggbXVsdGlwbGVcbiAgICogICBpbnB1dHMgYW5kL29yIG11bHRpcGxlIG91dHB1dHMuIE9mIHRoZSB0d28gaXRlbXMgaW4gdGhlIGFycmF5LCB0aGVcbiAgICogICBmaXJzdCBpcyB0aGUgaW5wdXQgZmVhdHVyZShzKSBhbmQgdGhlIHNlY29uZCBpcyB0aGUgb3V0cHV0IHRhcmdldChzKS5cbiAgICogQHBhcmFtIGFyZ3MgQSBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIGRhdGFzZXQtYmFzZWQgZXZhbHVhdGlvbi5cbiAgICogQHJldHVybnMgTG9zcyBhbmQgbWV0cmljIHZhbHVlcyBhcyBhbiBBcnJheSBvZiBgU2NhbGFyYCBvYmplY3RzLlxuICAgKlxuICAgKiBAZG9jIHtoZWFkaW5nOiAnTW9kZWxzJywgc3ViaGVhZGluZzogJ0NsYXNzZXMnfVxuICAgKi9cbiAgYXN5bmMgZXZhbHVhdGVEYXRhc2V0KGRhdGFzZXQ6IERhdGFzZXQ8e30+LCBhcmdzOiBNb2RlbEV2YWx1YXRlRGF0YXNldEFyZ3MpOlxuICAgICAgUHJvbWlzZTxTY2FsYXJ8U2NhbGFyW10+IHtcbiAgICBpZiAoIXRoaXMuYnVpbHQpIHtcbiAgICAgIHRocm93IG5ldyBSdW50aW1lRXJyb3IoXG4gICAgICAgICAgJ1RoZSBtb2RlbCBuZWVkcyB0byBiZSBjb21waWxlZCBiZWZvcmUgYmVpbmcgdXNlZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZXZhbHVhdGVEYXRhc2V0KGRhdGFzZXQsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBvdXRwdXQgcHJlZGljdGlvbnMgZm9yIHRoZSBpbnB1dCBzYW1wbGVzLlxuICAgKlxuICAgKiBDb21wdXRhdGlvbiBpcyBkb25lIGluIGJhdGNoZXMuXG4gICAqXG4gICAqIE5vdGU6IHRoZSBcInN0ZXBcIiBtb2RlIG9mIHByZWRpY3QoKSBpcyBjdXJyZW50bHkgbm90IHN1cHBvcnRlZC5cbiAgICogICBUaGlzIGlzIGJlY2F1c2UgdGhlIFRlbnNvckZsb3cuanMgY29yZSBiYWNrZW5kIGlzIGltcGVyYXRpdmUgb25seS5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKHtcbiAgICogICBsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbMTBdfSldXG4gICAqIH0pO1xuICAgKiBtb2RlbC5wcmVkaWN0KHRmLm9uZXMoWzIsIDEwXSkpLnByaW50KCk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0geCBUaGUgaW5wdXQgZGF0YSwgYXMgYSBUZW5zb3IsIG9yIGFuIGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzIGlmXG4gICAqICAgdGhlIG1vZGVsIGhhcyBtdWx0aXBsZSBpbnB1dHMuXG4gICAqIEBwYXJhbSBjb25pZmcgQSBgTW9kZWxQcmVkaWN0Q29uZmlnYCBvYmplY3QgY29udGFpbmluZyBvcHRpb25hbCBmaWVsZHMuXG4gICAqXG4gICAqIEByZXR1cm4gYHRmLlRlbnNvcmAocykgb2YgcHJlZGljdGlvbnMuXG4gICAqXG4gICAqIEBleGNlcHRpb24gVmFsdWVFcnJvciBJbiBjYXNlIG9mIG1pc21hdGNoIGJldHdlZW4gdGhlIHByb3ZpZGVkIGlucHV0IGRhdGFcbiAgICogICBhbmQgdGhlIG1vZGVsJ3MgZXhwZWN0YXRpb25zLCBvciBpbiBjYXNlIGEgc3RhdGVmdWwgbW9kZWwgcmVjZWl2ZXMgYVxuICAgKiAgIG51bWJlciBvZiBzYW1wbGVzIHRoYXQgaXMgbm90IGEgbXVsdGlwbGUgb2YgdGhlIGJhdGNoIHNpemUuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBwcmVkaWN0KHg6IFRlbnNvcnxUZW5zb3JbXSwgYXJnczogTW9kZWxQcmVkaWN0QXJncyA9IHt9KTogVGVuc29yfFRlbnNvcltdIHtcbiAgICBpZiAodGhpcy5tb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vZGVsLnByZWRpY3QoeCwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyBwcmVkaWN0aW9ucyBmb3IgYSBzaW5nbGUgYmF0Y2ggb2Ygc2FtcGxlcy5cbiAgICpcbiAgICogQHBhcmFtIHg6IElucHV0IHNhbXBsZXMsIGFzIGEgVGVuc29yLCBvciBsaXN0IG9mIFRlbnNvcnMgKGlmIHRoZSBtb2RlbFxuICAgKiAgIGhhcyBtdWx0aXBsZSBpbnB1dHMpLlxuICAgKiBAcmV0dXJuIFRlbnNvcihzKSBvZiBwcmVkaWN0aW9uc1xuICAgKi9cbiAgcHJlZGljdE9uQmF0Y2goeDogVGVuc29yKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICBpZiAodGhpcy5tb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aGlzLmJ1aWxkKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1vZGVsLnByZWRpY3RPbkJhdGNoKHgpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNlZSBgTGF5ZXJzTW9kZWwuY29tcGlsZWAuXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzXG4gICAqL1xuICBjb21waWxlKGFyZ3M6IE1vZGVsQ29tcGlsZUFyZ3MpOiB2b2lkIHtcbiAgICB0aGlzLmJ1aWxkKCk7XG4gICAgdGhpcy5tb2RlbC5jb21waWxlKGFyZ3MpO1xuICAgIHRoaXMub3B0aW1pemVyXyA9IHRoaXMubW9kZWwub3B0aW1pemVyO1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICB0aGlzLmlzT3B0aW1pemVyT3duZWQgPSAodGhpcy5tb2RlbCBhcyBhbnkpLmlzT3B0aW1pemVyT3duZWQ7XG4gICAgdGhpcy5sb3NzID0gdGhpcy5tb2RlbC5sb3NzO1xuICAgIHRoaXMubWV0cmljcyA9IHRoaXMubW9kZWwubWV0cmljcztcbiAgICAvLyBUT0RPKGNhaXMpOiBBZGQgdGhpcy5sb3NzV2VpZ2h0cywgdGhpcy5zYW1wbGVXZWlnaHRNb2RlLFxuICAgIC8vICAgdGhpcy53ZWlnaHRlZE1ldHJpY3MsIHRoaXMudGFyZ2V0cy5cbiAgICB0aGlzLm1ldHJpY3NUZW5zb3JzID0gdGhpcy5tb2RlbC5tZXRyaWNzVGVuc29ycztcbiAgICB0aGlzLm1ldHJpY3NOYW1lcyA9IHRoaXMubW9kZWwubWV0cmljc05hbWVzO1xuICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBzYW1wbGVXZWlnaHRzLlxuICB9XG5cbiAgZ2V0IG9wdGltaXplcigpOiBPcHRpbWl6ZXIge1xuICAgIHJldHVybiB0aGlzLm1vZGVsID09IG51bGwgPyB1bmRlZmluZWQgOiB0aGlzLm1vZGVsLm9wdGltaXplcjtcbiAgfVxuXG4gIHNldCBvcHRpbWl6ZXIob3B0aW1pemVyOiBPcHRpbWl6ZXIpIHtcbiAgICB0aGlzLm1vZGVsLm9wdGltaXplciA9IG9wdGltaXplcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUcmFpbnMgdGhlIG1vZGVsIGZvciBhIGZpeGVkIG51bWJlciBvZiBlcG9jaHMgKGl0ZXJhdGlvbnMgb24gYSBkYXRhc2V0KS5cbiAgICpcbiAgICogYGBganNcbiAgICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKHtcbiAgICogICBsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbMTBdfSldXG4gICAqIH0pO1xuICAgKiBtb2RlbC5jb21waWxlKHtvcHRpbWl6ZXI6ICdzZ2QnLCBsb3NzOiAnbWVhblNxdWFyZWRFcnJvcid9KTtcbiAgICogY29uc3QgaGlzdG9yeSA9IGF3YWl0IG1vZGVsLmZpdCh0Zi5vbmVzKFs4LCAxMF0pLCB0Zi5vbmVzKFs4LCAxXSksIHtcbiAgICogICBiYXRjaFNpemU6IDQsXG4gICAqICAgZXBvY2hzOiAzXG4gICAqIH0pO1xuICAgKiBjb25zb2xlLmxvZyhoaXN0b3J5Lmhpc3RvcnkubG9zc1swXSk7XG4gICAqIGBgYFxuICAgKlxuICAgKiBAcGFyYW0geCBgdGYuVGVuc29yYCBvZiB0cmFpbmluZyBkYXRhLCBvciBhbiBhcnJheSBvZiBgdGYuVGVuc29yYHMgaWYgdGhlXG4gICAqIG1vZGVsIGhhcyBtdWx0aXBsZSBpbnB1dHMuIElmIGFsbCBpbnB1dHMgaW4gdGhlIG1vZGVsIGFyZSBuYW1lZCwgeW91IGNhblxuICAgKiBhbHNvIHBhc3MgYSBkaWN0aW9uYXJ5IG1hcHBpbmcgaW5wdXQgbmFtZXMgdG8gYHRmLlRlbnNvcmBzLlxuICAgKiBAcGFyYW0geSBgdGYuVGVuc29yYCBvZiB0YXJnZXQgKGxhYmVsKSBkYXRhLCBvciBhbiBhcnJheSBvZiBgdGYuVGVuc29yYHMgaWZcbiAgICogdGhlIG1vZGVsIGhhcyBtdWx0aXBsZSBvdXRwdXRzLiBJZiBhbGwgb3V0cHV0cyBpbiB0aGUgbW9kZWwgYXJlIG5hbWVkLCB5b3VcbiAgICogIGNhbiBhbHNvIHBhc3MgYSBkaWN0aW9uYXJ5IG1hcHBpbmcgb3V0cHV0IG5hbWVzIHRvIGB0Zi5UZW5zb3Jgcy5cbiAgICogQHBhcmFtIGFyZ3MgIEEgYE1vZGVsRml0Q29uZmlnYCwgY29udGFpbmluZyBvcHRpb25hbCBmaWVsZHMuXG4gICAqXG4gICAqIEByZXR1cm4gQSBgSGlzdG9yeWAgaW5zdGFuY2UuIEl0cyBgaGlzdG9yeWAgYXR0cmlidXRlIGNvbnRhaW5zIGFsbFxuICAgKiAgIGluZm9ybWF0aW9uIGNvbGxlY3RlZCBkdXJpbmcgdHJhaW5pbmcuXG4gICAqXG4gICAqIEBleGNlcHRpb24gVmFsdWVFcnJvciBJbiBjYXNlIG9mIG1pc21hdGNoIGJldHdlZW4gdGhlIHByb3ZpZGVkIGlucHV0IGRhdGFcbiAgICogICBhbmQgd2hhdCB0aGUgbW9kZWwgZXhwZWN0cy5cbiAgICpcbiAgICogQGRvYyB7aGVhZGluZzogJ01vZGVscycsIHN1YmhlYWRpbmc6ICdDbGFzc2VzJ31cbiAgICovXG4gIGFzeW5jIGZpdChcbiAgICAgIHg6IFRlbnNvcnxUZW5zb3JbXXx7W2lucHV0TmFtZTogc3RyaW5nXTogVGVuc29yfSxcbiAgICAgIHk6IFRlbnNvcnxUZW5zb3JbXXx7W2lucHV0TmFtZTogc3RyaW5nXTogVGVuc29yfSxcbiAgICAgIGFyZ3M6IE1vZGVsRml0QXJncyA9IHt9KTogUHJvbWlzZTxIaXN0b3J5PiB7XG4gICAgaWYgKCF0aGlzLmJ1aWx0KSB7XG4gICAgICB0aHJvdyBuZXcgUnVudGltZUVycm9yKFxuICAgICAgICAgICdUaGUgbW9kZWwgbmVlZHMgdG8gYmUgY29tcGlsZWQgYmVmb3JlICcgK1xuICAgICAgICAgICdiZWluZyB1c2VkLicpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tb2RlbC5maXQoeCwgeSwgYXJncyk7XG4gIH1cblxuICAvKipcbiAgICogVHJhaW5zIHRoZSBtb2RlbCB1c2luZyBhIGRhdGFzZXQgb2JqZWN0LlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCB4QXJyYXkgPSBbXG4gICAqICAgWzEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDFdLFxuICAgKiAgIFsxLCAxLCAxLCAxLCAxLCAxLCAxLCAxLCAxXSxcbiAgICogICBbMSwgMSwgMSwgMSwgMSwgMSwgMSwgMSwgMV0sXG4gICAqICAgWzEsIDEsIDEsIDEsIDEsIDEsIDEsIDEsIDFdLFxuICAgKiBdO1xuICAgKiBjb25zdCB5QXJyYXkgPSBbMSwgMSwgMSwgMV07XG4gICAqIC8vIENyZWF0ZSBhIGRhdGFzZXQgZnJvbSB0aGUgSmF2YVNjcmlwdCBhcnJheS5cbiAgICogY29uc3QgeERhdGFzZXQgPSB0Zi5kYXRhLmFycmF5KHhBcnJheSk7XG4gICAqIGNvbnN0IHlEYXRhc2V0ID0gdGYuZGF0YS5hcnJheSh5QXJyYXkpO1xuICAgKiAvLyBaaXAgY29tYmluZXMgdGhlIGB4YCBhbmQgYHlgIERhdGFzZXRzIGludG8gYSBzaW5nbGUgRGF0YXNldCwgdGhlXG4gICAqIC8vIGl0ZXJhdG9yIG9mIHdoaWNoIHdpbGwgcmV0dXJuIGFuIG9iamVjdCBjb250YWluaW5nIG9mIHR3byB0ZW5zb3JzLFxuICAgKiAvLyBjb3JyZXNwb25kaW5nIHRvIGB4YCBhbmQgYHlgLiAgVGhlIGNhbGwgdG8gYGJhdGNoKDQpYCB3aWxsIGJ1bmRsZVxuICAgKiAvLyBmb3VyIHN1Y2ggc2FtcGxlcyBpbnRvIGEgc2luZ2xlIG9iamVjdCwgd2l0aCB0aGUgc2FtZSBrZXlzIG5vdyBwb2ludGluZ1xuICAgKiAvLyB0byB0ZW5zb3JzIHRoYXQgaG9sZCA0IGV4YW1wbGVzLCBvcmdhbml6ZWQgYWxvbmcgdGhlIGJhdGNoIGRpbWVuc2lvbi5cbiAgICogLy8gVGhlIGNhbGwgdG8gYHNodWZmbGUoNClgIGNhdXNlcyBlYWNoIGl0ZXJhdGlvbiB0aHJvdWdoIHRoZSBkYXRhc2V0IHRvXG4gICAqIC8vIGhhcHBlbiBpbiBhIGRpZmZlcmVudCBvcmRlci4gIFRoZSBzaXplIG9mIHRoZSBzaHVmZmxlIHdpbmRvdyBpcyA0LlxuICAgKiBjb25zdCB4eURhdGFzZXQgPSB0Zi5kYXRhLnppcCh7eHM6IHhEYXRhc2V0LCB5czogeURhdGFzZXR9KVxuICAgKiAgICAgLmJhdGNoKDQpXG4gICAqICAgICAuc2h1ZmZsZSg0KTtcbiAgICogY29uc3QgbW9kZWwgPSB0Zi5zZXF1ZW50aWFsKHtcbiAgICogICBsYXllcnM6IFt0Zi5sYXllcnMuZGVuc2Uoe3VuaXRzOiAxLCBpbnB1dFNoYXBlOiBbOV19KV1cbiAgICogfSk7XG4gICAqIG1vZGVsLmNvbXBpbGUoe29wdGltaXplcjogJ3NnZCcsIGxvc3M6ICdtZWFuU3F1YXJlZEVycm9yJ30pO1xuICAgKiBjb25zdCBoaXN0b3J5ID0gYXdhaXQgbW9kZWwuZml0RGF0YXNldCh4eURhdGFzZXQsIHtcbiAgICogICBlcG9jaHM6IDQsXG4gICAqICAgY2FsbGJhY2tzOiB7b25FcG9jaEVuZDogKGVwb2NoLCBsb2dzKSA9PiBjb25zb2xlLmxvZyhsb2dzLmxvc3MpfVxuICAgKiB9KTtcbiAgICogYGBgXG4gICAqXG4gICAqIEBwYXJhbSBkYXRhc2V0IEEgZGF0YXNldCBvYmplY3QuIEl0cyBgaXRlcmF0b3IoKWAgbWV0aG9kIGlzIGV4cGVjdGVkIHRvXG4gICAqICAgZ2VuZXJhdGUgYSBkYXRhc2V0IGl0ZXJhdG9yIG9iamVjdCwgdGhlIGBuZXh0KClgIG1ldGhvZCBvZiB3aGljaCBpc1xuICAgKiAgIGV4cGVjdGVkIHRvIHByb2R1Y2UgZGF0YSBiYXRjaGVzIGZvciBldmFsdWF0aW9uLiBUaGUgcmV0dXJuIHZhbHVlIG9mIHRoZVxuICAgKiAgIGBuZXh0KClgIGNhbGwgb3VnaHQgdG8gY29udGFpbiBhIGJvb2xlYW4gYGRvbmVgIGZpZWxkIGFuZCBhIGB2YWx1ZWBcbiAgICogICBmaWVsZC5cbiAgICpcbiAgICogICBUaGUgYHZhbHVlYCBmaWVsZCBpcyBleHBlY3RlZCB0byBiZSBhbiBvYmplY3Qgb2Ygd2l0aCBmaWVsZHNcbiAgICogICBgeHNgIGFuZCBgeXNgLCB3aGljaCBwb2ludCB0byB0aGUgZmVhdHVyZSB0ZW5zb3IgYW5kIHRoZSB0YXJnZXQgdGVuc29yLFxuICAgKiAgIHJlc3BlY3RpdmVseS4gVGhpcyBjYXNlIGlzIGZvciBtb2RlbHMgd2l0aCBleGFjdGx5IG9uZSBpbnB1dCBhbmQgb25lXG4gICAqICAgb3V0cHV0IChlLmcuLiBhIHNlcXVlbnRpYWwgbW9kZWwpLiBGb3IgZXhhbXBsZTpcbiAgICogICBgYGBqc1xuICAgKiAgIHt2YWx1ZToge3hzOiB4c1RlbnNvciwgeXM6IHlzVGVuc29yfSwgZG9uZTogZmFsc2V9XG4gICAqICAgYGBgXG4gICAqXG4gICAqICAgSWYgdGhlIG1vZGVsIGhhcyBtdWx0aXBsZSBpbnB1dHMsIHRoZSBgeHNgIGZpZWxkIG9mIGB2YWx1ZWAgc2hvdWxkXG4gICAqICAgYmUgYW4gb2JqZWN0IG1hcHBpbmcgaW5wdXQgbmFtZXMgdG8gdGhlaXIgcmVzcGVjdGl2ZSBmZWF0dXJlIHRlbnNvcnMuXG4gICAqICAgRm9yIGV4YW1wbGU6XG4gICAqICAgYGBganNcbiAgICogICB7XG4gICAqICAgICB2YWx1ZToge1xuICAgKiAgICAgICB4czoge1xuICAgKiAgICAgICAgIGlucHV0XzE6IHhzVGVuc29yMSxcbiAgICogICAgICAgICBpbnB1dF8yOiB4c1RlbnNvcjJcbiAgICogICAgICAgfSxcbiAgICogICAgICAgeXM6IHlzVGVuc29yXG4gICAqICAgICB9LFxuICAgKiAgICAgZG9uZTogZmFsc2VcbiAgICogICB9XG4gICAqICAgYGBgXG4gICAqICAgSWYgdGhlIG1vZGVsIGhhcyBtdWx0aXBsZSBvdXRwdXRzLCB0aGUgYHlzYCBmaWVsZCBvZiBgdmFsdWVgIHNob3VsZFxuICAgKiAgIGJlIGFuIG9iamVjdCBtYXBwaW5nIG91dHB1dCBuYW1lcyB0byB0aGVpciByZXNwZWN0aXZlIHRhcmdldCB0ZW5zb3JzLlxuICAgKiAgIEZvciBleGFtcGxlOlxuICAgKiAgIGBgYGpzXG4gICAqICAge1xuICAgKiAgICAgdmFsdWU6IHtcbiAgICogICAgICAgeHM6IHhzVGVuc29yLFxuICAgKiAgICAgICB5czoge1xuICAgKiAgICAgICAgIG91dHB1dF8xOiB5c1RlbnNvcjEsXG4gICAqICAgICAgICAgb3V0cHV0XzI6IHlzVGVuc29yMlxuICAgKiAgICAgICB9LFxuICAgKiAgICAgfSxcbiAgICogICAgIGRvbmU6IGZhbHNlXG4gICAqICAgfVxuICAgKiAgIGBgYFxuICAgKiBAcGFyYW0gYXJncyBBIGBNb2RlbEZpdERhdGFzZXRBcmdzYCwgY29udGFpbmluZyBvcHRpb25hbCBmaWVsZHMuXG4gICAqXG4gICAqIEByZXR1cm4gQSBgSGlzdG9yeWAgaW5zdGFuY2UuIEl0cyBgaGlzdG9yeWAgYXR0cmlidXRlIGNvbnRhaW5zIGFsbFxuICAgKiAgIGluZm9ybWF0aW9uIGNvbGxlY3RlZCBkdXJpbmcgdHJhaW5pbmcuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3NlcycsIGlnbm9yZUNJOiB0cnVlfVxuICAgKi9cbiAgYXN5bmMgZml0RGF0YXNldDxUPihkYXRhc2V0OiBEYXRhc2V0PFQ+LCBhcmdzOiBNb2RlbEZpdERhdGFzZXRBcmdzPFQ+KTpcbiAgICAgIFByb21pc2U8SGlzdG9yeT4ge1xuICAgIGlmICghdGhpcy5idWlsdCkge1xuICAgICAgdGhyb3cgbmV3IFJ1bnRpbWVFcnJvcihcbiAgICAgICAgICAnVGhlIG1vZGVsIG5lZWRzIHRvIGJlIGNvbXBpbGVkIGJlZm9yZSAnICtcbiAgICAgICAgICAnYmVpbmcgdXNlZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuZml0RGF0YXNldChkYXRhc2V0LCBhcmdzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSdW5zIGEgc2luZ2xlIGdyYWRpZW50IHVwZGF0ZSBvbiBhIHNpbmdsZSBiYXRjaCBvZiBkYXRhLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYGZpdCgpYCBhbmQgYGZpdERhdGFzZXQoKWAgaW4gdGhlIGZvbGxvd2luZ1xuICAgKiByZWdhcmRzOlxuICAgKiAgIC0gSXQgb3BlcmF0ZXMgb24gZXhhY3RseSBvbmUgYmF0Y2ggb2YgZGF0YS5cbiAgICogICAtIEl0IHJldHVybnMgb25seSB0aGUgbG9zcyBhbmQgbWF0cmljIHZhbHVlcywgaW5zdGVhZCBvZlxuICAgKiAgICAgcmV0dXJuaW5nIHRoZSBiYXRjaC1ieS1iYXRjaCBsb3NzIGFuZCBtZXRyaWMgdmFsdWVzLlxuICAgKiAgIC0gSXQgZG9lc24ndCBzdXBwb3J0IGZpbmUtZ3JhaW5lZCBvcHRpb25zIHN1Y2ggYXMgdmVyYm9zaXR5IGFuZFxuICAgKiAgICAgY2FsbGJhY2tzLlxuICAgKlxuICAgKiBAcGFyYW0geCBJbnB1dCBkYXRhLiBJdCBjb3VsZCBiZSBvbmUgb2YgdGhlIGZvbGxvd2luZzpcbiAgICogICAtIEEgYHRmLlRlbnNvcmAsIG9yIGFuIEFycmF5IG9mIGB0Zi5UZW5zb3JgcyAoaW4gY2FzZSB0aGUgbW9kZWwgaGFzXG4gICAqICAgICBtdWx0aXBsZSBpbnB1dHMpLlxuICAgKiAgIC0gQW4gT2JqZWN0IG1hcHBpbmcgaW5wdXQgbmFtZXMgdG8gY29ycmVzcG9uZGluZyBgdGYuVGVuc29yYCAoaWYgdGhlXG4gICAqICAgICBtb2RlbCBoYXMgbmFtZWQgaW5wdXRzKS5cbiAgICogQHBhcmFtIHkgVGFyZ2V0IGRhcnRhLiBJdCBjb3VsZCBiZSBlaXRoZXIgYSBgdGYuVGVuc29yYCBhIG11bHRpcGxlXG4gICAqICAgYHRmLlRlbnNvcmBzLiBJdCBzaG91bGQgYmUgY29uc2lzdGVudCB3aXRoIGB4YC5cbiAgICogQHJldHVybnMgVHJhaW5pbmcgbG9zcyBvciBsb3NzZXMgKGluIGNhc2UgdGhlIG1vZGVsIGhhc1xuICAgKiAgIG11bHRpcGxlIG91dHB1dHMpLCBhbG9uZyB3aXRoIG1ldHJpY3MgKGlmIGFueSksIGFzIG51bWJlcnMuXG4gICAqXG4gICAqIEBkb2Mge2hlYWRpbmc6ICdNb2RlbHMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gICAqL1xuICBhc3luYyB0cmFpbk9uQmF0Y2goXG4gICAgICB4OiBUZW5zb3J8VGVuc29yW118e1tpbnB1dE5hbWU6IHN0cmluZ106IFRlbnNvcn0sXG4gICAgICB5OiBUZW5zb3J8VGVuc29yW118XG4gICAgICB7W2lucHV0TmFtZTogc3RyaW5nXTogVGVuc29yfSk6IFByb21pc2U8bnVtYmVyfG51bWJlcltdPiB7XG4gICAgcmV0dXJuIHRoaXMubW9kZWwudHJhaW5PbkJhdGNoKHgsIHkpO1xuICB9XG5cbiAgLyogU2VlIHBhcmVudCBjbGFzcyBmb3IgSnNEb2MgKi9cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlQ29uc3RydWN0b3I8VD4sXG4gICAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCxcbiAgICAgIGN1c3RvbU9iamVjdHMgPSB7fSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QsXG4gICAgICBmYXN0V2VpZ2h0SW5pdCA9IGZhbHNlKTogVCB7XG4gICAgbGV0IGNvbmZpZ0FycmF5OiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3RBcnJheTtcbiAgICBsZXQgZXh0cmFNb2RlbENvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge307XG4gICAgaWYgKGNvbmZpZyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgICBpZiAoIShjb25maWdbMF0uY2xhc3NOYW1lICE9IG51bGwpIHx8XG4gICAgICAgICAgY29uZmlnWzBdWydjbGFzc05hbWUnXSA9PT0gJ01lcmdlJykge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignTGVnYWN5IHNlcmlhbGl6YXRpb24gZm9ybWF0IG5vdCBzdXBwb3J0ZWQgeWV0LicpO1xuICAgICAgfVxuICAgICAgY29uZmlnQXJyYXkgPSBjb25maWc7XG4gICAgfSBlbHNlIHtcbiAgICAgIHV0aWwuYXNzZXJ0KFxuICAgICAgICAgIGNvbmZpZ1snbGF5ZXJzJ10gIT0gbnVsbCxcbiAgICAgICAgICAoKSA9PlxuICAgICAgICAgICAgICBgV2hlbiB0aGUgY29uZmlnIGRhdGEgZm9yIGEgU2VxdWVudGlhbCBtb2RlbCBpcyBub3QgYW4gQXJyYXksIGAgK1xuICAgICAgICAgICAgICBgaXQgbXVzdCBiZSBhbiBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgJ2xheWVycycgZmllbGQuYCk7XG4gICAgICBjb25maWdBcnJheSA9IGNvbmZpZ1snbGF5ZXJzJ10gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0QXJyYXk7XG4gICAgICBkZWxldGUgY29uZmlnWydsYXllcnMnXTtcbiAgICAgIGV4dHJhTW9kZWxDb25maWcgPSBjb25maWc7XG4gICAgfVxuXG4gICAgY29uc3QgbW9kZWwgPSBuZXcgY2xzKGV4dHJhTW9kZWxDb25maWcpO1xuICAgIGlmICghKG1vZGVsIGluc3RhbmNlb2YgU2VxdWVudGlhbCkpIHtcbiAgICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAgIGBTZXF1ZW50aWFsLmZyb21Db25maWcgY2FsbGVkIG9uIG5vbi1TZXF1ZW50aWFsIGlucHV0OiAke21vZGVsfWApO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvbmYgb2YgY29uZmlnQXJyYXkpIHtcbiAgICAgIGNvbnN0IGN1c3RvbU9iamVjdHM6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGxheWVyID0gZGVzZXJpYWxpemUoXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25mIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCwgY3VzdG9tT2JqZWN0cyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhc3RXZWlnaHRJbml0KSBhcyBMYXllcjtcbiAgICAgIGlmIChmYXN0V2VpZ2h0SW5pdCkge1xuICAgICAgICBsYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHRydWUpO1xuICAgICAgfVxuICAgICAgbW9kZWwuYWRkKGxheWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG5cbiAgLyoqXG4gICAqIFNldHRlciB1c2VkIGZvciBmb3JjZSBzdG9wcGluZyBvZiBMYXllcnNNb2RlbC5maXQoKSAoaS5lLiwgdHJhaW5pbmcpLlxuICAgKlxuICAgKiBFeGFtcGxlOlxuICAgKlxuICAgKiBgYGBqc1xuICAgKiBjb25zdCBtb2RlbCA9IHRmLnNlcXVlbnRpYWwoKTtcbiAgICogbW9kZWwuYWRkKHRmLmxheWVycy5kZW5zZSh7dW5pdHM6IDEsIGlucHV0U2hhcGU6IFsxMF19KSk7XG4gICAqIG1vZGVsLmNvbXBpbGUoe2xvc3M6ICdtZWFuU3F1YXJlZEVycm9yJywgb3B0aW1pemVyOiAnc2dkJ30pO1xuICAgKiBjb25zdCB4cyA9IHRmLm9uZXMoWzgsIDEwXSk7XG4gICAqIGNvbnN0IHlzID0gdGYuemVyb3MoWzgsIDFdKTtcbiAgICpcbiAgICogY29uc3QgaGlzdG9yeSA9IGF3YWl0IG1vZGVsLmZpdCh4cywgeXMsIHtcbiAgICogICBlcG9jaHM6IDEwLFxuICAgKiAgIGNhbGxiYWNrczoge1xuICAgKiAgICAgb25FcG9jaEVuZDogYXN5bmMgKGVwb2NoLCBsb2dzKSA9PiB7XG4gICAqICAgICAgIGlmIChlcG9jaCA9PT0gMikge1xuICAgKiAgICAgICAgIG1vZGVsLnN0b3BUcmFpbmluZyA9IHRydWU7XG4gICAqICAgICAgIH1cbiAgICogICAgIH1cbiAgICogICB9XG4gICAqIH0pO1xuICAgKlxuICAgKiAvLyBUaGVyZSBzaG91bGQgYmUgb25seSAzIHZhbHVlcyBpbiB0aGUgbG9zcyBhcnJheSwgaW5zdGVhZCBvZiAxMCB2YWx1ZXMsXG4gICAqIC8vIGR1ZSB0byB0aGUgc3RvcHBpbmcgYWZ0ZXIgMyBlcG9jaHMuXG4gICAqIGNvbnNvbGUubG9nKGhpc3RvcnkuaGlzdG9yeS5sb3NzKTtcbiAgICogYGBgXG4gICAqL1xuICBzZXQgc3RvcFRyYWluaW5nKHN0b3A6IGJvb2xlYW4pIHtcbiAgICAvLyBUT0RPKGNhaXMpOiBXaGVuIHJlZmFjdG9yaW5nIHRvIHJlbW92ZSB0aGUgY29tcG9zaXRpb24gcGF0dGVybiBoYXBwZW5zLFxuICAgIC8vIHJlbW92ZSB0aGlzIG1ldGhvZCBvdmVycmlkaW5nLlxuICAgIGlmICh0aGlzLm1vZGVsID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdDYW5ub3Qgc2V0IHRoZSBzdG9wVHJhaW5pbmcgcHJvcGVydHkgb2YgYSBzZXF1ZW50aWFsIG1vZGVsIGJlZm9yZSAnICtcbiAgICAgICAgICAnaXQgaXMgY29tcGlsZWQuJyk7XG4gICAgfVxuICAgIHRoaXMubW9kZWwuc3RvcFRyYWluaW5nID0gc3RvcDtcbiAgfVxuXG4gIGdldCBzdG9wVHJhaW5pbmcoKTogYm9vbGVhbiB7XG4gICAgaWYgKHRoaXMubW9kZWwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ0Nhbm5vdCBnZXQgdGhlIHN0b3BUcmFpbmluZyBwcm9wZXJ0eSBvZiBhIHNlcXVlbnRpYWwgbW9kZWwgYmVmb3JlICcgK1xuICAgICAgICAgICdpdCBpcyBjb21waWxlZC4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubW9kZWwuc3RvcFRyYWluaW5nO1xuICB9XG5cbiAgLy8gVE9ETyhjYWlzKTogT3ZlcnJpZGUgZ2V0IHRyYWluYWJsZVdlaWdodHMoKSBoZXJlXG5cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxuICBnZXRDb25maWcoKTogYW55IHtcbiAgICAvLyBOT1RFKGNhaXMpOiBXZSBvdmVycmlkZSB0aGUgcmV0dXJuIHR5cGUgb2YgZ2V0Q29uZmlnKCkgdG8gYGFueWAgaGVyZSxcbiAgICAvLyAgIGJlY2F1c2UgdGhlIGBTZXF1ZW50aWFsYCBjbGFzcyBpcyBhIHNwZWNpYWwgY2FzZSBhbW9uZyBgQ29udGFpbmVyYFxuICAgIC8vICAgc3VidHlwZXMgaW4gdGhhdCBpdHMgZ2V0Q29uZmlnKCkgbWV0aG9kIHJldHVybnMgYW4gQXJyYXkgKG5vdCBhXG4gICAgLy8gICBkaWN0KS5cbiAgICBjb25zdCBsYXllcnM6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFtdID0gW107XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLmxheWVycykge1xuICAgICAgY29uc3QgZGljdDogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge307XG4gICAgICBkaWN0WydjbGFzc05hbWUnXSA9IGxheWVyLmdldENsYXNzTmFtZSgpO1xuICAgICAgZGljdFsnY29uZmlnJ10gPSBsYXllci5nZXRDb25maWcoKTtcbiAgICAgIGxheWVycy5wdXNoKGRpY3QpO1xuICAgIH1cbiAgICByZXR1cm4ge25hbWU6IHRoaXMubmFtZSwgbGF5ZXJzfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNlcXVlbnRpYWwpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n// Layer activation functions\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { deserializeKerasObject } from './utils/generic_utils';\n/**\n * Base class for Activations.\n *\n * Special note: due to cross-language compatibility reasons, the\n * static readonly className field in this family of classes must be set to\n * the initialLowerCamelCase name of the activation.\n */\nexport class Activation extends serialization.Serializable {\n    getConfig() {\n        return {};\n    }\n}\n/**\n * Exponential linear unit (ELU).\n * Reference: https://arxiv.org/abs/1511.07289\n */\nexport class Elu extends Activation {\n    /**\n     * Calculate the activation function.\n     *\n     * @param x: Input.\n     * @param alpha: Scaling factor the negative section.\n     * @return Output of the ELU activation.\n     */\n    apply(x, alpha = 1) {\n        return K.elu(x, alpha);\n    }\n}\n/** @nocollapse */\nElu.className = 'elu';\nserialization.registerClass(Elu);\n/**\n * Scaled Exponential Linear Unit. (Klambauer et al., 2017).\n * Reference: Self-Normalizing Neural Networks, https://arxiv.org/abs/1706.02515\n * Notes:\n *   - To be used together with the initialization \"lecunNormal\".\n *   - To be used together with the dropout variant \"AlphaDropout\".\n */\nexport class Selu extends Activation {\n    apply(x) {\n        return tfc.selu(x);\n    }\n}\n/** @nocollapse */\nSelu.className = 'selu';\nserialization.registerClass(Selu);\n/**\n *  Rectified linear unit\n */\nexport class Relu extends Activation {\n    apply(x) {\n        return tfc.relu(x);\n    }\n}\n/** @nocollapse */\nRelu.className = 'relu';\nserialization.registerClass(Relu);\n/**\n * Rectified linear unit activation maxing out at 6.0.\n */\nexport class Relu6 extends Activation {\n    apply(x) {\n        return tidy(() => tfc.minimum(6.0, tfc.relu(x)));\n    }\n}\n/** @nocollapse */\nRelu6.className = 'relu6';\nserialization.registerClass(Relu6);\n//* Linear activation (no-op) */\nexport class Linear extends Activation {\n    apply(x) {\n        return x;\n    }\n}\n/** @nocollapse */\nLinear.className = 'linear';\nserialization.registerClass(Linear);\n/**\n * Sigmoid activation function.\n */\nexport class Sigmoid extends Activation {\n    apply(x) {\n        return tfc.sigmoid(x);\n    }\n}\n/** @nocollapse */\nSigmoid.className = 'sigmoid';\nserialization.registerClass(Sigmoid);\n/**\n * Segment-wise linear approximation of sigmoid.\n */\nexport class HardSigmoid extends Activation {\n    apply(x) {\n        return K.hardSigmoid(x);\n    }\n}\n/** @nocollapse */\nHardSigmoid.className = 'hardSigmoid';\nserialization.registerClass(HardSigmoid);\n/**\n * Softplus activation function.\n */\nexport class Softplus extends Activation {\n    apply(x) {\n        return tfc.softplus(x);\n    }\n}\n/** @nocollapse */\nSoftplus.className = 'softplus';\nserialization.registerClass(Softplus);\n/**\n * Softsign activation function.\n */\nexport class Softsign extends Activation {\n    apply(x) {\n        return K.softsign(x);\n    }\n}\n/** @nocollapse */\nSoftsign.className = 'softsign';\nserialization.registerClass(Softsign);\n/**\n * Hyperbolic tangent function.\n */\nexport class Tanh extends Activation {\n    apply(x) {\n        return tfc.tanh(x);\n    }\n}\n/** @nocollapse */\nTanh.className = 'tanh';\nserialization.registerClass(Tanh);\n/**\n * Softmax activation function\n */\nexport class Softmax extends Activation {\n    /**\n     * Calculate the activation function.\n     *\n     * @param x Tensor.\n     * @param axis Integer, axis along which the softmax normalization is applied.\n     * Invalid if < 2, as softmax across 1 (the batch dimension) is assumed to be\n     * an error.\n     *\n     * @returns a Tensor of the same shape as x\n     *\n     * @throws ValueError: In case `dim(x) < 2`.\n     */\n    apply(x, axis = (-1)) {\n        return tfc.softmax(x, axis);\n    }\n}\n/** @nocollapse */\nSoftmax.className = 'softmax';\nserialization.registerClass(Softmax);\n/**\n * Log softmax activation function\n */\nexport class LogSoftmax extends Activation {\n    /**\n     * Calculate the activation function of log softmax:\n     * log( exp(x_i) / sum(exp(x)) )\n     *\n     * @param x Tensor.\n     * @param axis Integer, axis along which the softmax normalization is applied.\n     * Invalid if < 2, as softmax across 1 (the batch dimension) is assumed to be\n     * an error.\n     *\n     * @returns a Tensor of the same shape as x\n     *\n     * @throws ValueError: In case `dim(x) < 2`.\n     */\n    apply(x, axis = (-1)) {\n        return tfc.logSoftmax(x, axis);\n    }\n}\n/** @nocollapse */\nLogSoftmax.className = 'logSoftmax';\nserialization.registerClass(LogSoftmax);\n/**\n * Swish activation function\n */\nexport class Swish extends Activation {\n    /**\n     * Calculate the activation function.\n     *\n     * @param x Tensor.\n     * @param alpha Scaling factor for the sigmoid function.\n     * @returns a Tensor of the same shape as x\n     */\n    apply(x, alpha = 1) {\n        return tidy(() => tfc.mul(tfc.sigmoid(tfc.mul(x, alpha)), x));\n    }\n}\n/** @nocollapse */\nSwish.className = 'swish';\nserialization.registerClass(Swish);\n/**\n * Mish activation function\n */\nexport class Mish extends Activation {\n    /**\n     * Calculate the activation function.\n     *\n     * @param x Tensor.\n     * @returns a Tensor of the same shape as x\n     */\n    apply(x) {\n        return tidy(() => tfc.mul(x, tfc.tanh(tfc.softplus(x))));\n    }\n}\n/** @nocollapse */\nMish.className = 'mish';\nserialization.registerClass(Mish);\nexport function serializeActivation(activation) {\n    return activation.getClassName();\n}\nexport function deserializeActivation(config, customObjects = {}) {\n    return deserializeKerasObject(config, serialization.SerializationMap.getMap().classNameMap, customObjects, 'activation');\n}\nexport function getActivation(identifier) {\n    if (identifier == null) {\n        const config = {};\n        config['className'] = 'linear';\n        config['config'] = {};\n        return deserializeActivation(config);\n    }\n    if (typeof identifier === 'string') {\n        const config = {};\n        config['className'] = identifier;\n        config['config'] = {};\n        return deserializeActivation(config);\n    }\n    else if (identifier instanceof Activation) {\n        return identifier;\n    }\n    else {\n        return deserializeActivation(identifier);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWN0aXZhdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvYWN0aXZhdGlvbnMudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFFSCw2QkFBNkI7QUFDN0IsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsYUFBYSxFQUFVLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ2xFLE9BQU8sS0FBSyxDQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFFNUMsT0FBTyxFQUFDLHNCQUFzQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFN0Q7Ozs7OztHQU1HO0FBQ0gsTUFBTSxPQUFnQixVQUFXLFNBQVEsYUFBYSxDQUFDLFlBQVk7SUFFakUsU0FBUztRQUNQLE9BQU8sRUFBRSxDQUFDO0lBQ1osQ0FBQztDQUNGO0FBRUQ7OztHQUdHO0FBQ0gsTUFBTSxPQUFPLEdBQUksU0FBUSxVQUFVO0lBR2pDOzs7Ozs7T0FNRztJQUNILEtBQUssQ0FBQyxDQUFTLEVBQUUsS0FBSyxHQUFHLENBQUM7UUFDeEIsT0FBTyxDQUFDLENBQUMsR0FBRyxDQUFDLENBQUMsRUFBRSxLQUFLLENBQUMsQ0FBQztJQUN6QixDQUFDOztBQVhELGtCQUFrQjtBQUNGLGFBQVMsR0FBRyxLQUFLLENBQUM7QUFZcEMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxHQUFHLENBQUMsQ0FBQztBQUVqQzs7Ozs7O0dBTUc7QUFDSCxNQUFNLE9BQU8sSUFBSyxTQUFRLFVBQVU7SUFHbEMsS0FBSyxDQUFDLENBQVM7UUFDYixPQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDckIsQ0FBQzs7QUFKRCxrQkFBa0I7QUFDRixjQUFTLEdBQUcsTUFBTSxDQUFDO0FBS3JDLGFBQWEsQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLENBQUM7QUFFbEM7O0dBRUc7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b3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vLyBMYXllciBhY3RpdmF0aW9uIGZ1bmN0aW9uc1xuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge3NlcmlhbGl6YXRpb24sIFRlbnNvciwgdGlkeX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCAqIGFzIEsgZnJvbSAnLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge0FjdGl2YXRpb25JZGVudGlmaWVyfSBmcm9tICcuL2tlcmFzX2Zvcm1hdC9hY3RpdmF0aW9uX2NvbmZpZyc7XG5pbXBvcnQge2Rlc2VyaWFsaXplS2VyYXNPYmplY3R9IGZyb20gJy4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgQWN0aXZhdGlvbnMuXG4gKlxuICogU3BlY2lhbCBub3RlOiBkdWUgdG8gY3Jvc3MtbGFuZ3VhZ2UgY29tcGF0aWJpbGl0eSByZWFzb25zLCB0aGVcbiAqIHN0YXRpYyByZWFkb25seSBjbGFzc05hbWUgZmllbGQgaW4gdGhpcyBmYW1pbHkgb2YgY2xhc3NlcyBtdXN0IGJlIHNldCB0b1xuICogdGhlIGluaXRpYWxMb3dlckNhbWVsQ2FzZSBuYW1lIG9mIHRoZSBhY3RpdmF0aW9uLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQWN0aXZhdGlvbiBleHRlbmRzIHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlIHtcbiAgYWJzdHJhY3QgYXBwbHkodGVuc29yOiBUZW5zb3IsIGF4aXM/OiBudW1iZXIpOiBUZW5zb3I7XG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIHJldHVybiB7fTtcbiAgfVxufVxuXG4vKipcbiAqIEV4cG9uZW50aWFsIGxpbmVhciB1bml0IChFTFUpLlxuICogUmVmZXJlbmNlOiBodHRwczovL2FyeGl2Lm9yZy9hYnMvMTUxMS4wNzI4OVxuICovXG5leHBvcnQgY2xhc3MgRWx1IGV4dGVuZHMgQWN0aXZhdGlvbiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ2VsdSc7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGFjdGl2YXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB4OiBJbnB1dC5cbiAgICogQHBhcmFtIGFscGhhOiBTY2FsaW5nIGZhY3RvciB0aGUgbmVnYXRpdmUgc2VjdGlvbi5cbiAgICogQHJldHVybiBPdXRwdXQgb2YgdGhlIEVMVSBhY3RpdmF0aW9uLlxuICAgKi9cbiAgYXBwbHkoeDogVGVuc29yLCBhbHBoYSA9IDEpOiBUZW5zb3Ige1xuICAgIHJldHVybiBLLmVsdSh4LCBhbHBoYSk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhFbHUpO1xuXG4vKipcbiAqIFNjYWxlZCBFeHBvbmVudGlhbCBMaW5lYXIgVW5pdC4gKEtsYW1iYXVlciBldCBhbC4sIDIwMTcpLlxuICogUmVmZXJlbmNlOiBTZWxmLU5vcm1hbGl6aW5nIE5ldXJhbCBOZXR3b3JrcywgaHR0cHM6Ly9hcnhpdi5vcmcvYWJzLzE3MDYuMDI1MTVcbiAqIE5vdGVzOlxuICogICAtIFRvIGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgaW5pdGlhbGl6YXRpb24gXCJsZWN1bk5vcm1hbFwiLlxuICogICAtIFRvIGJlIHVzZWQgdG9nZXRoZXIgd2l0aCB0aGUgZHJvcG91dCB2YXJpYW50IFwiQWxwaGFEcm9wb3V0XCIuXG4gKi9cbmV4cG9ydCBjbGFzcyBTZWx1IGV4dGVuZHMgQWN0aXZhdGlvbiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ3NlbHUnO1xuICBhcHBseSh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0ZmMuc2VsdSh4KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNlbHUpO1xuXG4vKipcbiAqICBSZWN0aWZpZWQgbGluZWFyIHVuaXRcbiAqL1xuZXhwb3J0IGNsYXNzIFJlbHUgZXh0ZW5kcyBBY3RpdmF0aW9uIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyByZWFkb25seSBjbGFzc05hbWUgPSAncmVsdSc7XG4gIGFwcGx5KHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRmYy5yZWx1KHgpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVsdSk7XG5cbi8qKlxuICogUmVjdGlmaWVkIGxpbmVhciB1bml0IGFjdGl2YXRpb24gbWF4aW5nIG91dCBhdCA2LjAuXG4gKi9cbmV4cG9ydCBjbGFzcyBSZWx1NiBleHRlbmRzIEFjdGl2YXRpb24ge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIHJlYWRvbmx5IGNsYXNzTmFtZSA9ICdyZWx1Nic7XG4gIGFwcGx5KHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4gdGZjLm1pbmltdW0oNi4wLCB0ZmMucmVsdSh4KSkpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVsdTYpO1xuXG4vLyogTGluZWFyIGFjdGl2YXRpb24gKG5vLW9wKSAqL1xuZXhwb3J0IGNsYXNzIExpbmVhciBleHRlbmRzIEFjdGl2YXRpb24ge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIHJlYWRvbmx5IGNsYXNzTmFtZSA9ICdsaW5lYXInO1xuICBhcHBseSh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB4O1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTGluZWFyKTtcblxuLyoqXG4gKiBTaWdtb2lkIGFjdGl2YXRpb24gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTaWdtb2lkIGV4dGVuZHMgQWN0aXZhdGlvbiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ3NpZ21vaWQnO1xuICBhcHBseSh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0ZmMuc2lnbW9pZCh4KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNpZ21vaWQpO1xuXG4vKipcbiAqIFNlZ21lbnQtd2lzZSBsaW5lYXIgYXBwcm94aW1hdGlvbiBvZiBzaWdtb2lkLlxuICovXG5leHBvcnQgY2xhc3MgSGFyZFNpZ21vaWQgZXh0ZW5kcyBBY3RpdmF0aW9uIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyByZWFkb25seSBjbGFzc05hbWUgPSAnaGFyZFNpZ21vaWQnO1xuICBhcHBseSh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiBLLmhhcmRTaWdtb2lkKHgpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoSGFyZFNpZ21vaWQpO1xuXG4vKipcbiAqIFNvZnRwbHVzIGFjdGl2YXRpb24gZnVuY3Rpb24uXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2Z0cGx1cyBleHRlbmRzIEFjdGl2YXRpb24ge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIHJlYWRvbmx5IGNsYXNzTmFtZSA9ICdzb2Z0cGx1cyc7XG4gIGFwcGx5KHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRmYy5zb2Z0cGx1cyh4KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNvZnRwbHVzKTtcblxuLyoqXG4gKiBTb2Z0c2lnbiBhY3RpdmF0aW9uIGZ1bmN0aW9uLlxuICovXG5leHBvcnQgY2xhc3MgU29mdHNpZ24gZXh0ZW5kcyBBY3RpdmF0aW9uIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyByZWFkb25seSBjbGFzc05hbWUgPSAnc29mdHNpZ24nO1xuICBhcHBseSh4OiBUZW5zb3IpOiBUZW5zb3Ige1xuICAgIHJldHVybiBLLnNvZnRzaWduKHgpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU29mdHNpZ24pO1xuXG4vKipcbiAqIEh5cGVyYm9saWMgdGFuZ2VudCBmdW5jdGlvbi5cbiAqL1xuZXhwb3J0IGNsYXNzIFRhbmggZXh0ZW5kcyBBY3RpdmF0aW9uIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyByZWFkb25seSBjbGFzc05hbWUgPSAndGFuaCc7XG4gIGFwcGx5KHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRmYy50YW5oKHgpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGFuaCk7XG5cbi8qKlxuICogU29mdG1heCBhY3RpdmF0aW9uIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBTb2Z0bWF4IGV4dGVuZHMgQWN0aXZhdGlvbiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ3NvZnRtYXgnO1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBhY3RpdmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geCBUZW5zb3IuXG4gICAqIEBwYXJhbSBheGlzIEludGVnZXIsIGF4aXMgYWxvbmcgd2hpY2ggdGhlIHNvZnRtYXggbm9ybWFsaXphdGlvbiBpcyBhcHBsaWVkLlxuICAgKiBJbnZhbGlkIGlmIDwgMiwgYXMgc29mdG1heCBhY3Jvc3MgMSAodGhlIGJhdGNoIGRpbWVuc2lvbikgaXMgYXNzdW1lZCB0byBiZVxuICAgKiBhbiBlcnJvci5cbiAgICpcbiAgICogQHJldHVybnMgYSBUZW5zb3Igb2YgdGhlIHNhbWUgc2hhcGUgYXMgeFxuICAgKlxuICAgKiBAdGhyb3dzIFZhbHVlRXJyb3I6IEluIGNhc2UgYGRpbSh4KSA8IDJgLlxuICAgKi9cbiAgYXBwbHkoeDogVGVuc29yLCBheGlzOiBudW1iZXIgPSAoLTEpKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGZjLnNvZnRtYXgoeCwgYXhpcyk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0bWF4KTtcblxuLyoqXG4gKiBMb2cgc29mdG1heCBhY3RpdmF0aW9uIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBMb2dTb2Z0bWF4IGV4dGVuZHMgQWN0aXZhdGlvbiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ2xvZ1NvZnRtYXgnO1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBhY3RpdmF0aW9uIGZ1bmN0aW9uIG9mIGxvZyBzb2Z0bWF4OlxuICAgKiBsb2coIGV4cCh4X2kpIC8gc3VtKGV4cCh4KSkgKVxuICAgKlxuICAgKiBAcGFyYW0geCBUZW5zb3IuXG4gICAqIEBwYXJhbSBheGlzIEludGVnZXIsIGF4aXMgYWxvbmcgd2hpY2ggdGhlIHNvZnRtYXggbm9ybWFsaXphdGlvbiBpcyBhcHBsaWVkLlxuICAgKiBJbnZhbGlkIGlmIDwgMiwgYXMgc29mdG1heCBhY3Jvc3MgMSAodGhlIGJhdGNoIGRpbWVuc2lvbikgaXMgYXNzdW1lZCB0byBiZVxuICAgKiBhbiBlcnJvci5cbiAgICpcbiAgICogQHJldHVybnMgYSBUZW5zb3Igb2YgdGhlIHNhbWUgc2hhcGUgYXMgeFxuICAgKlxuICAgKiBAdGhyb3dzIFZhbHVlRXJyb3I6IEluIGNhc2UgYGRpbSh4KSA8IDJgLlxuICAgKi9cbiAgYXBwbHkoeDogVGVuc29yLCBheGlzOiBudW1iZXIgPSAoLTEpKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGZjLmxvZ1NvZnRtYXgoeCwgYXhpcyk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMb2dTb2Z0bWF4KTtcblxuLyoqXG4gKiBTd2lzaCBhY3RpdmF0aW9uIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBTd2lzaCBleHRlbmRzIEFjdGl2YXRpb24ge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIHJlYWRvbmx5IGNsYXNzTmFtZSA9ICdzd2lzaCc7XG4gIC8qKlxuICAgKiBDYWxjdWxhdGUgdGhlIGFjdGl2YXRpb24gZnVuY3Rpb24uXG4gICAqXG4gICAqIEBwYXJhbSB4IFRlbnNvci5cbiAgICogQHBhcmFtIGFscGhhIFNjYWxpbmcgZmFjdG9yIGZvciB0aGUgc2lnbW9pZCBmdW5jdGlvbi5cbiAgICogQHJldHVybnMgYSBUZW5zb3Igb2YgdGhlIHNhbWUgc2hhcGUgYXMgeFxuICAgKi9cbiAgYXBwbHkoeDogVGVuc29yLCBhbHBoYSA9IDEpOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aWR5KCgpID0+IHRmYy5tdWwodGZjLnNpZ21vaWQodGZjLm11bCh4LCBhbHBoYSkpLCB4KSk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTd2lzaCk7XG5cbi8qKlxuICogTWlzaCBhY3RpdmF0aW9uIGZ1bmN0aW9uXG4gKi9cbmV4cG9ydCBjbGFzcyBNaXNoIGV4dGVuZHMgQWN0aXZhdGlvbiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgcmVhZG9ubHkgY2xhc3NOYW1lID0gJ21pc2gnO1xuICAvKipcbiAgICogQ2FsY3VsYXRlIHRoZSBhY3RpdmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0geCBUZW5zb3IuXG4gICAqIEByZXR1cm5zIGEgVGVuc29yIG9mIHRoZSBzYW1lIHNoYXBlIGFzIHhcbiAgICovXG4gIGFwcGx5KHg6IFRlbnNvcik6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4gdGZjLm11bCh4LCB0ZmMudGFuaCh0ZmMuc29mdHBsdXMoeCkpKSk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNaXNoKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZUFjdGl2YXRpb24oYWN0aXZhdGlvbjogQWN0aXZhdGlvbik6IHN0cmluZyB7XG4gIHJldHVybiBhY3RpdmF0aW9uLmdldENsYXNzTmFtZSgpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVzZXJpYWxpemVBY3RpdmF0aW9uKFxuICAgIGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0LFxuICAgIGN1c3RvbU9iamVjdHM6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt9KTogQWN0aXZhdGlvbiB7XG4gIHJldHVybiBkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0KFxuICAgICAgY29uZmlnLCBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YXRpb25NYXAuZ2V0TWFwKCkuY2xhc3NOYW1lTWFwLFxuICAgICAgY3VzdG9tT2JqZWN0cywgJ2FjdGl2YXRpb24nKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEFjdGl2YXRpb24oaWRlbnRpZmllcjogQWN0aXZhdGlvbklkZW50aWZpZXJ8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3R8QWN0aXZhdGlvbik6IEFjdGl2YXRpb24ge1xuICBpZiAoaWRlbnRpZmllciA9PSBudWxsKSB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7fTtcbiAgICBjb25maWdbJ2NsYXNzTmFtZSddID0gJ2xpbmVhcic7XG4gICAgY29uZmlnWydjb25maWcnXSA9IHt9O1xuICAgIHJldHVybiBkZXNlcmlhbGl6ZUFjdGl2YXRpb24oY29uZmlnKTtcbiAgfVxuICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7fTtcbiAgICBjb25maWdbJ2NsYXNzTmFtZSddID0gaWRlbnRpZmllcjtcbiAgICBjb25maWdbJ2NvbmZpZyddID0ge307XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplQWN0aXZhdGlvbihjb25maWcpO1xuICB9IGVsc2UgaWYgKGlkZW50aWZpZXIgaW5zdGFuY2VvZiBBY3RpdmF0aW9uKSB7XG4gICAgcmV0dXJuIGlkZW50aWZpZXI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplQWN0aXZhdGlvbihpZGVudGlmaWVyKTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/* original source: keras/regularizers.py */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { abs, add, serialization, sum, tidy, zeros } from '@tensorflow/tfjs-core';\nimport * as K from './backend/tfjs_backend';\nimport { deserializeKerasObject, serializeKerasObject } from './utils/generic_utils';\nfunction assertObjectArgs(args) {\n    if (args != null && typeof args !== 'object') {\n        throw new Error(`Argument to L1L2 regularizer's constructor is expected to be an ` +\n            `object, but received: ${args}`);\n    }\n}\n/**\n * Regularizer base class.\n */\nexport class Regularizer extends serialization.Serializable {\n}\nexport class L1L2 extends Regularizer {\n    constructor(args) {\n        super();\n        assertObjectArgs(args);\n        this.l1 = args == null || args.l1 == null ? 0.01 : args.l1;\n        this.l2 = args == null || args.l2 == null ? 0.01 : args.l2;\n        this.hasL1 = this.l1 !== 0;\n        this.hasL2 = this.l2 !== 0;\n    }\n    /**\n     * Porting note: Renamed from __call__.\n     * @param x Variable of which to calculate the regularization score.\n     */\n    apply(x) {\n        return tidy(() => {\n            let regularization = zeros([1]);\n            if (this.hasL1) {\n                regularization = add(regularization, sum(tfc.mul(this.l1, abs(x))));\n            }\n            if (this.hasL2) {\n                regularization =\n                    add(regularization, sum(tfc.mul(this.l2, K.square(x))));\n            }\n            return tfc.reshape(regularization, []);\n        });\n    }\n    getConfig() {\n        return { 'l1': this.l1, 'l2': this.l2 };\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        return new cls({ l1: config['l1'], l2: config['l2'] });\n    }\n}\n/** @nocollapse */\nL1L2.className = 'L1L2';\nserialization.registerClass(L1L2);\nexport function l1(args) {\n    assertObjectArgs(args);\n    return new L1L2({ l1: args != null ? args.l1 : null, l2: 0 });\n}\nexport function l2(args) {\n    assertObjectArgs(args);\n    return new L1L2({ l2: args != null ? args.l2 : null, l1: 0 });\n}\n// Maps the JavaScript-like identifier keys to the corresponding keras symbols.\nexport const REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP = {\n    'l1l2': 'L1L2'\n};\nexport function serializeRegularizer(constraint) {\n    return serializeKerasObject(constraint);\n}\nexport function deserializeRegularizer(config, customObjects = {}) {\n    return deserializeKerasObject(config, serialization.SerializationMap.getMap().classNameMap, customObjects, 'regularizer');\n}\nexport function getRegularizer(identifier) {\n    if (identifier == null) {\n        return null;\n    }\n    if (typeof identifier === 'string') {\n        const className = identifier in REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP ?\n            REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP[identifier] :\n            identifier;\n        const config = { className, config: {} };\n        return deserializeRegularizer(config);\n    }\n    else if (identifier instanceof Regularizer) {\n        return identifier;\n    }\n    else {\n        return deserializeRegularizer(identifier);\n    }\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVndWxhcml6ZXJzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL3JlZ3VsYXJpemVycy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVILDRDQUE0QztBQUU1QyxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxHQUFHLEVBQUUsR0FBRyxFQUFVLGFBQWEsRUFBRSxHQUFHLEVBQVUsSUFBSSxFQUFFLEtBQUssRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ2hHLE9BQU8sS0FBSyxDQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDNUMsT0FBTyxFQUFDLHNCQUFzQixFQUFFLG9CQUFvQixFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFbkYsU0FBUyxnQkFBZ0IsQ0FBQyxJQUE0QjtJQUNwRCxJQUFJLElBQUksSUFBSSxJQUFJLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFO1FBQzVDLE1BQU0sSUFBSSxLQUFLLENBQ1gsa0VBQWtFO1lBQ2xFLHlCQUF5QixJQUFJLEVBQUUsQ0FBQyxDQUFDO0tBQ3RDO0FBQ0gsQ0FBQztBQUVEOztHQUVHO0FBQ0gsTUFBTSxPQUFnQixXQUFZLFNBQVEsYUFBYSxDQUFDLFlBQVk7Q0FFbkU7QUFtQkQsTUFBTSxPQUFPLElBQUssU0FBUSxXQUFXO0lBUW5DLFlBQVksSUFBZTtRQUN6QixLQUFLLEVBQUUsQ0FBQztRQUVSLGdCQUFnQixDQUFDLElBQUksQ0FBQyxDQUFDO1FBRXZCLElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDO1FBQzNELElBQUksQ0FBQyxFQUFFLEdBQUcsSUFBSSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMs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QUFDLFlBQVksRUFDNUQsYUFBYSxFQUFFLGFBQWEsQ0FBQyxDQUFDO0FBQ3BDLENBQUM7QUFFRCxNQUFNLFVBQVUsY0FBYyxDQUFDLFVBRVc7SUFDeEMsSUFBSSxVQUFVLElBQUksSUFBSSxFQUFFO1FBQ3RCLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFDRCxJQUFJLE9BQU8sVUFBVSxLQUFLLFFBQVEsRUFBRTtRQUNsQyxNQUFNLFNBQVMsR0FBRyxVQUFVLElBQUksMENBQTBDLENBQUMsQ0FBQztZQUN4RSwwQ0FBMEMsQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO1lBQ3hELFVBQVUsQ0FBQztRQUNmLE1BQU0sTUFBTSxHQUFHLEVBQUMsU0FBUyxFQUFFLE1BQU0sRUFBRSxFQUFFLEVBQUMsQ0FBQztRQUN2QyxPQUFPLHNCQUFzQixDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ3ZDO1NBQU0sSUFBSSxVQUFVLFlBQVksV0FBVyxFQUFFO1FBQzVDLE9BQU8sVUFBVSxDQUFDO0tBQ25CO1NBQU07UUFDTCxPQUFPLHNCQUFzQixDQUFDLFVBQVUsQ0FBQyxDQUFDO0tBQzNDO0FBQ0gsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qIG9yaWdpbmFsIHNvdXJjZToga2VyYXMvcmVndWxhcml6ZXJzLnB5ICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHthYnMsIGFkZCwgU2NhbGFyLCBzZXJpYWxpemF0aW9uLCBzdW0sIFRlbnNvciwgdGlkeSwgemVyb3N9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQgKiBhcyBLIGZyb20gJy4vYmFja2VuZC90ZmpzX2JhY2tlbmQnO1xuaW1wb3J0IHtkZXNlcmlhbGl6ZUtlcmFzT2JqZWN0LCBzZXJpYWxpemVLZXJhc09iamVjdH0gZnJvbSAnLi91dGlscy9nZW5lcmljX3V0aWxzJztcblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0QXJncyhhcmdzOiBMMUFyZ3N8TDJBcmdzfEwxTDJBcmdzKTogdm9pZCB7XG4gIGlmIChhcmdzICE9IG51bGwgJiYgdHlwZW9mIGFyZ3MgIT09ICdvYmplY3QnKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBgQXJndW1lbnQgdG8gTDFMMiByZWd1bGFyaXplcidzIGNvbnN0cnVjdG9yIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGAgK1xuICAgICAgICBgb2JqZWN0LCBidXQgcmVjZWl2ZWQ6ICR7YXJnc31gKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlZ3VsYXJpemVyIGJhc2UgY2xhc3MuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSZWd1bGFyaXplciBleHRlbmRzIHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlIHtcbiAgYWJzdHJhY3QgYXBwbHkoeDogVGVuc29yKTogU2NhbGFyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIEwxTDJBcmdzIHtcbiAgLyoqIEwxIHJlZ3VsYXJpemF0aW9uIHJhdGUuIERlZmF1bHRzIHRvIDAuMDEuICovXG4gIGwxPzogbnVtYmVyO1xuICAvKiogTDIgcmVndWxhcml6YXRpb24gcmF0ZS4gRGVmYXVsdHMgdG8gMC4wMS4gKi9cbiAgbDI/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTDFBcmdzIHtcbiAgLyoqIEwxIHJlZ3VsYXJpemF0aW9uIHJhdGUuIERlZmF1bHRzIHRvIDAuMDEuICovXG4gIGwxOiBudW1iZXI7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTDJBcmdzIHtcbiAgLyoqIEwyIHJlZ3VsYXJpemF0aW9uIHJhdGUuIERlZmF1bHRzIHRvIDAuMDEuICovXG4gIGwyOiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBMMUwyIGV4dGVuZHMgUmVndWxhcml6ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdMMUwyJztcblxuICBwcml2YXRlIHJlYWRvbmx5IGwxOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbDI6IG51bWJlcjtcbiAgcHJpdmF0ZSByZWFkb25seSBoYXNMMTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBoYXNMMjogYm9vbGVhbjtcbiAgY29uc3RydWN0b3IoYXJncz86IEwxTDJBcmdzKSB7XG4gICAgc3VwZXIoKTtcblxuICAgIGFzc2VydE9iamVjdEFyZ3MoYXJncyk7XG5cbiAgICB0aGlzLmwxID0gYXJncyA9PSBudWxsIHx8IGFyZ3MubDEgPT0gbnVsbCA/IDAuMDEgOiBhcmdzLmwxO1xuICAgIHRoaXMubDIgPSBhcmdzID09IG51bGwgfHwgYXJncy5sMiA9PSBudWxsID8gMC4wMSA6IGFyZ3MubDI7XG4gICAgdGhpcy5oYXNMMSA9IHRoaXMubDEgIT09IDA7XG4gICAgdGhpcy5oYXNMMiA9IHRoaXMubDIgIT09IDA7XG4gIH1cblxuICAvKipcbiAgICogUG9ydGluZyBub3RlOiBSZW5hbWVkIGZyb20gX19jYWxsX18uXG4gICAqIEBwYXJhbSB4IFZhcmlhYmxlIG9mIHdoaWNoIHRvIGNhbGN1bGF0ZSB0aGUgcmVndWxhcml6YXRpb24gc2NvcmUuXG4gICAqL1xuICBhcHBseSh4OiBUZW5zb3IpOiBTY2FsYXIge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGxldCByZWd1bGFyaXphdGlvbjogVGVuc29yID0gemVyb3MoWzFdKTtcbiAgICAgIGlmICh0aGlzLmhhc0wxKSB7XG4gICAgICAgIHJlZ3VsYXJpemF0aW9uID0gYWRkKHJlZ3VsYXJpemF0aW9uLCBzdW0odGZjLm11bCh0aGlzLmwxLCBhYnMoeCkpKSk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5oYXNMMikge1xuICAgICAgICByZWd1bGFyaXphdGlvbiA9XG4gICAgICAgICAgICBhZGQocmVndWxhcml6YXRpb24sIHN1bSh0ZmMubXVsKHRoaXMubDIsIEsuc3F1YXJlKHgpKSkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRmYy5yZXNoYXBlKHJlZ3VsYXJpemF0aW9uLCBbXSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICByZXR1cm4geydsMSc6IHRoaXMubDEsICdsMic6IHRoaXMubDJ9O1xuICB9XG5cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlQ29uc3RydWN0b3I8VD4sXG4gICAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCk6IFQge1xuICAgIHJldHVybiBuZXcgY2xzKHtsMTogY29uZmlnWydsMSddIGFzIG51bWJlciwgbDI6IGNvbmZpZ1snbDInXSBhcyBudW1iZXJ9KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEwxTDIpO1xuXG5leHBvcnQgZnVuY3Rpb24gbDEoYXJncz86IEwxQXJncykge1xuICBhc3NlcnRPYmplY3RBcmdzKGFyZ3MpO1xuICByZXR1cm4gbmV3IEwxTDIoe2wxOiBhcmdzICE9IG51bGwgPyBhcmdzLmwxIDogbnVsbCwgbDI6IDB9KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGwyKGFyZ3M6IEwyQXJncykge1xuICBhc3NlcnRPYmplY3RBcmdzKGFyZ3MpO1xuICByZXR1cm4gbmV3IEwxTDIoe2wyOiBhcmdzICE9IG51bGwgPyBhcmdzLmwyIDogbnVsbCwgbDE6IDB9KTtcbn1cblxuLyoqIEBkb2NpbmxpbmUgKi9cbmV4cG9ydCB0eXBlIFJlZ3VsYXJpemVySWRlbnRpZmllciA9ICdsMWwyJ3xzdHJpbmc7XG5cbi8vIE1hcHMgdGhlIEphdmFTY3JpcHQtbGlrZSBpZGVudGlmaWVyIGtleXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcga2VyYXMgc3ltYm9scy5cbmV4cG9ydCBjb25zdCBSRUdVTEFSSVpFUl9JREVOVElGSUVSX1JFR0lTVFJZX1NZTUJPTF9NQVA6XG4gICAge1tpZGVudGlmaWVyIGluIFJlZ3VsYXJpemVySWRlbnRpZmllcl06IHN0cmluZ30gPSB7XG4gICAgICAnbDFsMic6ICdMMUwyJ1xuICAgIH07XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXJpYWxpemVSZWd1bGFyaXplcihjb25zdHJhaW50OiBSZWd1bGFyaXplcik6XG4gICAgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0VmFsdWUge1xuICByZXR1cm4gc2VyaWFsaXplS2VyYXNPYmplY3QoY29uc3RyYWludCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZXNlcmlhbGl6ZVJlZ3VsYXJpemVyKFxuICAgIGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0LFxuICAgIGN1c3RvbU9iamVjdHM6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt9KTogUmVndWxhcml6ZXIge1xuICByZXR1cm4gZGVzZXJpYWxpemVLZXJhc09iamVjdChcbiAgICAgIGNvbmZpZywgc2VyaWFsaXphdGlvbi5TZXJpYWxpemF0aW9uTWFwLmdldE1hcCgpLmNsYXNzTmFtZU1hcCxcbiAgICAgIGN1c3RvbU9iamVjdHMsICdyZWd1bGFyaXplcicpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0UmVndWxhcml6ZXIoaWRlbnRpZmllcjogUmVndWxhcml6ZXJJZGVudGlmaWVyfFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBSZWd1bGFyaXplcik6IFJlZ3VsYXJpemVyIHtcbiAgaWYgKGlkZW50aWZpZXIgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGlmICh0eXBlb2YgaWRlbnRpZmllciA9PT0gJ3N0cmluZycpIHtcbiAgICBjb25zdCBjbGFzc05hbWUgPSBpZGVudGlmaWVyIGluIFJFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUCA/XG4gICAgICAgIFJFR1VMQVJJWkVSX0lERU5USUZJRVJfUkVHSVNUUllfU1lNQk9MX01BUFtpZGVudGlmaWVyXSA6XG4gICAgICAgIGlkZW50aWZpZXI7XG4gICAgY29uc3QgY29uZmlnID0ge2NsYXNzTmFtZSwgY29uZmlnOiB7fX07XG4gICAgcmV0dXJuIGRlc2VyaWFsaXplUmVndWxhcml6ZXIoY29uZmlnKTtcbiAgfSBlbHNlIGlmIChpZGVudGlmaWVyIGluc3RhbmNlb2YgUmVndWxhcml6ZXIpIHtcbiAgICByZXR1cm4gaWRlbnRpZmllcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZGVzZXJpYWxpemVSZWd1bGFyaXplcihpZGVudGlmaWVyKTtcbiAgfVxufVxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n *  Advanced activation layers.\n */\nimport { cast, clipByValue, elu, greater, leakyRelu, mul, prelu, relu, serialization } from '@tensorflow/tfjs-core';\nimport { Softmax as softmaxActivation } from '../activations';\nimport { getConstraint, serializeConstraint } from '../constraints';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { getInitializer, serializeInitializer } from '../initializers';\nimport { getRegularizer, serializeRegularizer } from '../regularizers';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nexport class ReLU extends Layer {\n    constructor(args) {\n        super(args == null ? {} : args);\n        this.supportsMasking = true;\n        if (args != null) {\n            this.maxValue = args.maxValue;\n        }\n    }\n    call(inputs, kwargs) {\n        inputs = getExactlyOneTensor(inputs);\n        let output = relu(inputs);\n        if (this.maxValue != null) {\n            output = clipByValue(output, 0, this.maxValue);\n        }\n        return output;\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const config = { maxValue: this.maxValue };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nReLU.className = 'ReLU';\nserialization.registerClass(ReLU);\nexport class LeakyReLU extends Layer {\n    constructor(args) {\n        super(args == null ? {} : args);\n        this.DEFAULT_ALPHA = 0.3;\n        if (args == null) {\n            args = {};\n        }\n        this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;\n    }\n    call(inputs, kwargs) {\n        const x = getExactlyOneTensor(inputs);\n        return leakyRelu(x, this.alpha);\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const config = { alpha: this.alpha };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nLeakyReLU.className = 'LeakyReLU';\nserialization.registerClass(LeakyReLU);\nexport class PReLU extends Layer {\n    constructor(args) {\n        super(args == null ? {} : args);\n        this.DEFAULT_ALPHA_INITIALIZER = 'zeros';\n        if (args == null) {\n            args = {};\n        }\n        this.supportsMasking = true;\n        this.alphaInitializer =\n            getInitializer(args.alphaInitializer || this.DEFAULT_ALPHA_INITIALIZER);\n        this.alphaRegularizer = getRegularizer(args.alphaRegularizer);\n        this.alphaConstraint = getConstraint(args.alphaConstraint);\n        if (args.sharedAxes == null) {\n            this.sharedAxes = null;\n        }\n        else if (Array.isArray(args.sharedAxes)) {\n            this.sharedAxes = args.sharedAxes;\n        }\n        else if (typeof args.sharedAxes === 'number') {\n            this.sharedAxes = [args.sharedAxes];\n        }\n        else {\n            throw new ValueError(`Expected sharedAxes to be a number or an array of numbers, ` +\n                `but got ${args.sharedAxes}`);\n        }\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const paramShape = inputShape.slice(1);\n        if (this.sharedAxes != null) {\n            for (const i of this.sharedAxes) {\n                paramShape[i - 1] = 1;\n            }\n        }\n        this.alpha = this.addWeight('alpha', paramShape, 'float32', this.alphaInitializer, this.alphaRegularizer, true, this.alphaConstraint);\n        // Set input spec.\n        const axes = {};\n        if (this.sharedAxes != null) {\n            for (let i = 1; i < inputShape.length; ++i) {\n                axes[i] = inputShape[i];\n            }\n        }\n        this.inputSpec = [new InputSpec({\n                ndim: inputShape.length,\n                axes,\n            })];\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        inputs = getExactlyOneTensor(inputs);\n        return prelu(inputs, this.alpha.read());\n    }\n    getConfig() {\n        const config = {\n            alphaInitializer: serializeInitializer(this.alphaInitializer),\n            alphaRegularizer: serializeRegularizer(this.alphaRegularizer),\n            alphaConstraint: serializeConstraint(this.alphaConstraint),\n            sharedAxes: this.sharedAxes\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nPReLU.className = 'PReLU';\nserialization.registerClass(PReLU);\nexport class ELU extends Layer {\n    constructor(args) {\n        super(args == null ? {} : args);\n        this.DEFAULT_ALPHA = 1.0;\n        if (args == null) {\n            args = {};\n        }\n        if (args.alpha != null && args.alpha !== this.DEFAULT_ALPHA) {\n            throw new NotImplementedError(`Non-default alpha value (${args.alpha}) is not supported by the ` +\n                `ELU layer yet.`);\n        }\n        this.alpha = args.alpha == null ? this.DEFAULT_ALPHA : args.alpha;\n    }\n    call(inputs, kwargs) {\n        const x = getExactlyOneTensor(inputs);\n        return elu(x);\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const config = { alpha: this.alpha };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nELU.className = 'ELU';\nserialization.registerClass(ELU);\nexport class ThresholdedReLU extends Layer {\n    constructor(args) {\n        super(args == null ? {} : args);\n        this.DEFAULT_THETA = 1.0;\n        if (args == null) {\n            args = {};\n        }\n        this.theta = args.theta == null ? this.DEFAULT_THETA : args.theta;\n    }\n    call(inputs, kwargs) {\n        const x = getExactlyOneTensor(inputs);\n        return mul(x, cast(greater(x, this.theta), 'float32'));\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const config = { theta: this.theta };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nThresholdedReLU.className = 'ThresholdedReLU';\nserialization.registerClass(ThresholdedReLU);\nexport class Softmax extends Layer {\n    constructor(args) {\n        super(args == null ? {} : args);\n        this.DEFAULT_AXIS = 1.0;\n        if (args == null) {\n            args = {};\n        }\n        this.softmax = new softmaxActivation().apply;\n        this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;\n    }\n    call(inputs, kwargs) {\n        const x = getExactlyOneTensor(inputs);\n        return this.softmax(x, this.axis);\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const config = { axis: this.axis };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nSoftmax.className = 'Softmax';\nserialization.registerClass(Softmax);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYWR2YW5jZWRfYWN0aXZhdGlvbnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvbGF5ZXJzL2FkdmFuY2VkX2FjdGl2YXRpb25zLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEVBQUMsSUFBSSxFQUFFLFdBQVcsRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLFNBQVMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLElBQUksRUFBRSxhQUFhLEVBQVMsTUFBTSx1QkFBdUIsQ0FBQztBQUUxSCxPQUFPLEVBQUMsT0FBTyxJQUFJLGlCQUFpQixFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDNUQsT0FBTyxFQUFhLGFBQWEsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQzlFLE9BQU8sRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFZLE1BQU0sb0JBQW9CLENBQUM7QUFDL0QsT0FBTyxFQUFDLG1CQUFtQixFQUFFLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUMxRCxPQUFPLEVBQUMsY0FBYyxFQUFzQyxvQkFBb0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRXpHLE9BQU8sRUFBQyxjQUFjLEVBQWUsb0JBQW9CLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUVsRixPQUFPLEVBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQVU3RSxNQUFNLE9BQU8sSUFBSyxTQUFRLEtBQUs7SUFLN0IsWUFBWSxJQUFvQjtRQUM5QixLQUFLLENBQUMsSUFBSSxJQUFJLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsQ0FBQztRQUNoQyxJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztRQUM1QixJQUFJLElBQUksSUFBSSxJQUFJLEVBQUU7WUFDaEIs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LE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNsQyxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztBQTdCRCxrQkFBa0I7QUFDWCxpQkFBUyxHQUFHLFNBQVMsQ0FBQztBQThCL0IsYUFBYSxDQUFDLGFBQWEsQ0FBQyxPQUFPLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogIEFkdmFuY2VkIGFjdGl2YXRpb24gbGF5ZXJzLlxuICovXG5cbmltcG9ydCB7Y2FzdCwgY2xpcEJ5VmFsdWUsIGVsdSwgZ3JlYXRlciwgbGVha3lSZWx1LCBtdWwsIHByZWx1LCByZWx1LCBzZXJpYWxpemF0aW9uLCBUZW5zb3J9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7U29mdG1heCBhcyBzb2Z0bWF4QWN0aXZhdGlvbn0gZnJvbSAnLi4vYWN0aXZhdGlvbnMnO1xuaW1wb3J0IHtDb25zdHJhaW50LCBnZXRDb25zdHJhaW50LCBzZXJpYWxpemVDb25zdHJhaW50fSBmcm9tICcuLi9jb25zdHJhaW50cyc7XG5pbXBvcnQge0lucHV0U3BlYywgTGF5ZXIsIExheWVyQXJnc30gZnJvbSAnLi4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7Tm90SW1wbGVtZW50ZWRFcnJvciwgVmFsdWVFcnJvcn0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7Z2V0SW5pdGlhbGl6ZXIsIEluaXRpYWxpemVyLCBJbml0aWFsaXplcklkZW50aWZpZXIsIHNlcmlhbGl6ZUluaXRpYWxpemVyfSBmcm9tICcuLi9pbml0aWFsaXplcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge2dldFJlZ3VsYXJpemVyLCBSZWd1bGFyaXplciwgc2VyaWFsaXplUmVndWxhcml6ZXJ9IGZyb20gJy4uL3JlZ3VsYXJpemVycyc7XG5pbXBvcnQge0t3YXJnc30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtnZXRFeGFjdGx5T25lU2hhcGUsIGdldEV4YWN0bHlPbmVUZW5zb3J9IGZyb20gJy4uL3V0aWxzL3R5cGVzX3V0aWxzJztcbmltcG9ydCB7TGF5ZXJWYXJpYWJsZX0gZnJvbSAnLi4vdmFyaWFibGVzJztcblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFJlTFVMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogRmxvYXQsIHRoZSBtYXhpbXVtIG91dHB1dCB2YWx1ZS5cbiAgICovXG4gIG1heFZhbHVlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgUmVMVSBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnUmVMVSc7XG4gIG1heFZhbHVlOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoYXJncz86IFJlTFVMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzID09IG51bGwgPyB7fSA6IGFyZ3MpO1xuICAgIHRoaXMuc3VwcG9ydHNNYXNraW5nID0gdHJ1ZTtcbiAgICBpZiAoYXJncyAhPSBudWxsKSB7XG4gICAgICB0aGlzLm1heFZhbHVlID0gYXJncy5tYXhWYWx1ZTtcbiAgICB9XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgaW5wdXRzID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgIGxldCBvdXRwdXQgPSByZWx1KGlucHV0cyk7XG4gICAgaWYgKHRoaXMubWF4VmFsdWUgIT0gbnVsbCkge1xuICAgICAgb3V0cHV0ID0gY2xpcEJ5VmFsdWUob3V0cHV0LCAwLCB0aGlzLm1heFZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgcmV0dXJuIGlucHV0U2hhcGU7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHttYXhWYWx1ZTogdGhpcy5tYXhWYWx1ZX07XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoUmVMVSk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBMZWFreVJlTFVMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogRmxvYXQgYD49IDBgLiBOZWdhdGl2ZSBzbG9wZSBjb2VmZmljaWVudC4gRGVmYXVsdHMgdG8gYDAuM2AuXG4gICAqL1xuICBhbHBoYT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIExlYWt5UmVMVSBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTGVha3lSZUxVJztcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcblxuICByZWFkb25seSBERUZBVUxUX0FMUEhBID0gMC4zO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBMZWFreVJlTFVMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzID09IG51bGwgPyB7fSA6IGFyZ3MpO1xuICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG4gICAgdGhpcy5hbHBoYSA9IGFyZ3MuYWxwaGEgPT0gbnVsbCA/IHRoaXMuREVGQVVMVF9BTFBIQSA6IGFyZ3MuYWxwaGE7XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgY29uc3QgeCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICByZXR1cm4gbGVha3lSZWx1KHgsIHRoaXMuYWxwaGEpO1xuICB9XG5cbiAgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiBTaGFwZXxTaGFwZVtdIHtcbiAgICByZXR1cm4gaW5wdXRTaGFwZTtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge2FscGhhOiB0aGlzLmFscGhhfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhMZWFreVJlTFUpO1xuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgUFJlTFVMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgZm9yIHRoZSBsZWFybmFibGUgYWxwaGEuXG4gICAqL1xuICBhbHBoYUluaXRpYWxpemVyPzogSW5pdGlhbGl6ZXJ8SW5pdGlhbGl6ZXJJZGVudGlmaWVyO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmb3IgdGhlIGxlYXJuYWJsZSBhbHBoYS5cbiAgICovXG4gIGFscGhhUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcjtcblxuICAvKipcbiAgICogQ29uc3RyYWludCBmb3IgdGhlIGxlYXJuYWJsZSBhbHBoYS5cbiAgICovXG4gIGFscGhhQ29uc3RyYWludD86IENvbnN0cmFpbnQ7XG5cbiAgLyoqXG4gICAqIFRoZSBheGVzIGFsb25nIHdoaWNoIHRvIHNoYXJlIGxlYXJuYWJsZSBwYXJhbWV0ZXJzIGZvciB0aGUgYWN0aXZhdGlvblxuICAgKiBmdW5jdGlvbi4gRm9yIGV4YW1wbGUsIGlmIHRoZSBpbmNvbWluZyBmZWF0dXJlIG1hcHMgYXJlIGZyb20gYSAyRFxuICAgKiBjb252b2x1dGlvbiB3aXRoIG91dHB1dCBzaGFwZSBgW251bUV4YW1wbGVzLCBoZWlnaHQsIHdpZHRoLCBjaGFubmVsc11gLFxuICAgKiBhbmQgeW91IHdpc2ggdG8gc2hhcmUgcGFyYW1ldGVycyBhY3Jvc3Mgc3BhY2UgKGhlaWdodCBhbmQgd2lkdGgpIHNvIHRoYXRcbiAgICogZWFjaCBmaWx0ZXIgY2hhbm5lbHMgaGFzIG9ubHkgb25lIHNldCBvZiBwYXJhbWV0ZXJzLCBzZXRcbiAgICogYHNoYXJlZF9heGVzOiBbMSwgMl1gLlxuICAgKi9cbiAgc2hhcmVkQXhlcz86IG51bWJlcnxudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNsYXNzIFBSZUxVIGV4dGVuZHMgTGF5ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdQUmVMVSc7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWxwaGFJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWxwaGFSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgYWxwaGFDb25zdHJhaW50OiBDb25zdHJhaW50O1xuICBwcml2YXRlIHJlYWRvbmx5IHNoYXJlZEF4ZXM6IG51bWJlcltdO1xuICBwcml2YXRlIGFscGhhOiBMYXllclZhcmlhYmxlO1xuXG4gIHJlYWRvbmx5IERFRkFVTFRfQUxQSEFfSU5JVElBTElaRVI6IEluaXRpYWxpemVySWRlbnRpZmllciA9ICd6ZXJvcyc7XG5cbiAgY29uc3RydWN0b3IoYXJncz86IFBSZUxVTGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyA9PSBudWxsID8ge30gOiBhcmdzKTtcbiAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICBhcmdzID0ge307XG4gICAgfVxuXG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgIHRoaXMuYWxwaGFJbml0aWFsaXplciA9XG4gICAgICAgIGdldEluaXRpYWxpemVyKGFyZ3MuYWxwaGFJbml0aWFsaXplciB8fCB0aGlzLkRFRkFVTFRfQUxQSEFfSU5JVElBTElaRVIpO1xuICAgIHRoaXMuYWxwaGFSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3MuYWxwaGFSZWd1bGFyaXplcik7XG4gICAgdGhpcy5hbHBoYUNvbnN0cmFpbnQgPSBnZXRDb25zdHJhaW50KGFyZ3MuYWxwaGFDb25zdHJhaW50KTtcbiAgICBpZiAoYXJncy5zaGFyZWRBeGVzID09IG51bGwpIHtcbiAgICAgIHRoaXMuc2hhcmVkQXhlcyA9IG51bGw7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3Muc2hhcmVkQXhlcykpIHtcbiAgICAgIHRoaXMuc2hhcmVkQXhlcyA9IGFyZ3Muc2hhcmVkQXhlcztcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzLnNoYXJlZEF4ZXMgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnNoYXJlZEF4ZXMgPSBbYXJncy5zaGFyZWRBeGVzXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYEV4cGVjdGVkIHNoYXJlZEF4ZXMgdG8gYmUgYSBudW1iZXIgb3IgYW4gYXJyYXkgb2YgbnVtYmVycywgYCArXG4gICAgICAgICAgYGJ1dCBnb3QgJHthcmdzLnNoYXJlZEF4ZXN9YCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSkge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgY29uc3QgcGFyYW1TaGFwZTogU2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKDEpO1xuICAgIGlmICh0aGlzLnNoYXJlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgZm9yIChjb25zdCBpIG9mIHRoaXMuc2hhcmVkQXhlcykge1xuICAgICAgICBwYXJhbVNoYXBlW2kgLSAxXSA9IDE7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuYWxwaGEgPSB0aGlzLmFkZFdlaWdodChcbiAgICAgICAgJ2FscGhhJywgcGFyYW1TaGFwZSwgJ2Zsb2F0MzInLCB0aGlzLmFscGhhSW5pdGlhbGl6ZXIsXG4gICAgICAgIHRoaXMuYWxwaGFSZWd1bGFyaXplciwgdHJ1ZSwgdGhpcy5hbHBoYUNvbnN0cmFpbnQpO1xuICAgIC8vIFNldCBpbnB1dCBzcGVjLlxuICAgIGNvbnN0IGF4ZXM6IHtbYXhpczogbnVtYmVyXTogbnVtYmVyfSA9IHt9O1xuICAgIGlmICh0aGlzLnNoYXJlZEF4ZXMgIT0gbnVsbCkge1xuICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGF4ZXNbaV0gPSBpbnB1dFNoYXBlW2ldO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmlucHV0U3BlYyA9IFtuZXcgSW5wdXRTcGVjKHtcbiAgICAgIG5kaW06IGlucHV0U2hhcGUubGVuZ3RoLFxuICAgICAgYXhlcyxcbiAgICB9KV07XG4gICAgdGhpcy5idWlsdCA9IHRydWU7XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgaW5wdXRzID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgIHJldHVybiBwcmVsdShpbnB1dHMsIHRoaXMuYWxwaGEucmVhZCgpKTtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge1xuICAgICAgYWxwaGFJbml0aWFsaXplcjogc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5hbHBoYUluaXRpYWxpemVyKSxcbiAgICAgIGFscGhhUmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWxwaGFSZWd1bGFyaXplciksXG4gICAgICBhbHBoYUNvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5hbHBoYUNvbnN0cmFpbnQpLFxuICAgICAgc2hhcmVkQXhlczogdGhpcy5zaGFyZWRBeGVzXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhQUmVMVSk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBFTFVMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogRmxvYXQgYD49IDBgLiBOZWdhdGl2ZSBzbG9wZSBjb2VmZmljaWVudC4gRGVmYXVsdHMgdG8gYDEuMGAuXG4gICAqL1xuICBhbHBoYT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIEVMVSBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnRUxVJztcbiAgcmVhZG9ubHkgYWxwaGE6IG51bWJlcjtcblxuICByZWFkb25seSBERUZBVUxUX0FMUEhBID0gMS4wO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBFTFVMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzID09IG51bGwgPyB7fSA6IGFyZ3MpO1xuICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoYXJncy5hbHBoYSAhPSBudWxsICYmIGFyZ3MuYWxwaGEgIT09IHRoaXMuREVGQVVMVF9BTFBIQSkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgYE5vbi1kZWZhdWx0IGFscGhhIHZhbHVlICgke2FyZ3MuYWxwaGF9KSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgICtcbiAgICAgICAgICBgRUxVIGxheWVyIHlldC5gKTtcbiAgICB9XG5cbiAgICB0aGlzLmFscGhhID0gYXJncy5hbHBoYSA9PSBudWxsID8gdGhpcy5ERUZBVUxUX0FMUEhBIDogYXJncy5hbHBoYTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICBjb25zdCB4ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgIHJldHVybiBlbHUoeCk7XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIHJldHVybiBpbnB1dFNoYXBlO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7YWxwaGE6IHRoaXMuYWxwaGF9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEVMVSk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBUaHJlc2hvbGRlZFJlTFVMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogRmxvYXQgPj0gMC4gVGhyZXNob2xkIGxvY2F0aW9uIG9mIGFjdGl2YXRpb24uXG4gICAqL1xuICB0aGV0YT86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFRocmVzaG9sZGVkUmVMVSBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnVGhyZXNob2xkZWRSZUxVJztcbiAgcmVhZG9ubHkgdGhldGE6IG51bWJlcjtcblxuICByZWFkb25seSBERUZBVUxUX1RIRVRBID0gMS4wO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBUaHJlc2hvbGRlZFJlTFVMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzID09IG51bGwgPyB7fSA6IGFyZ3MpO1xuICAgIGlmIChhcmdzID09IG51bGwpIHtcbiAgICAgIGFyZ3MgPSB7fTtcbiAgICB9XG5cbiAgICB0aGlzLnRoZXRhID0gYXJncy50aGV0YSA9PSBudWxsID8gdGhpcy5ERUZBVUxUX1RIRVRBIDogYXJncy50aGV0YTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICBjb25zdCB4ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgIHJldHVybiBtdWwoeCwgY2FzdChncmVhdGVyKHgsIHRoaXMudGhldGEpLCAnZmxvYXQzMicpKTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgcmV0dXJuIGlucHV0U2hhcGU7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt0aGV0YTogdGhpcy50aGV0YX07XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoVGhyZXNob2xkZWRSZUxVKTtcblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFNvZnRtYXhMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogSW50ZWdlciwgYXhpcyBhbG9uZyB3aGljaCB0aGUgc29mdG1heCBub3JtYWxpemF0aW9uIGlzIGFwcGxpZWQuXG4gICAqIERlZmF1bHRzIHRvIGAtMWAgKGkuZS4sIHRoZSBsYXN0IGF4aXMpLlxuICAgKi9cbiAgYXhpcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIFNvZnRtYXggZXh0ZW5kcyBMYXllciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ1NvZnRtYXgnO1xuICByZWFkb25seSBheGlzOiBudW1iZXI7XG4gIHJlYWRvbmx5IHNvZnRtYXg6ICh0OiBUZW5zb3IsIGE/OiBudW1iZXIpID0+IFRlbnNvcjtcbiAgcmVhZG9ubHkgREVGQVVMVF9BWElTID0gMS4wO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBTb2Z0bWF4TGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyA9PSBudWxsID8ge30gOiBhcmdzKTtcbiAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICBhcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuc29mdG1heCA9IG5ldyBzb2Z0bWF4QWN0aXZhdGlvbigpLmFwcGx5O1xuICAgIHRoaXMuYXhpcyA9IGFyZ3MuYXhpcyA9PSBudWxsID8gdGhpcy5ERUZBVUxUX0FYSVMgOiBhcmdzLmF4aXM7XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgY29uc3QgeCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICByZXR1cm4gdGhpcy5zb2Z0bWF4KHgsIHRoaXMuYXhpcyk7XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIHJldHVybiBpbnB1dFNoYXBlO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7YXhpczogdGhpcy5heGlzfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTb2Z0bWF4KTtcbiJdfQ==","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nimport { ValueError } from '../errors';\nimport { pyListRepeat } from './generic_utils';\nimport { isInteger, max } from './math_utils';\n/**\n * Transforms a single number of array of numbers into an array of numbers.\n * @param value\n * @param n: The size of the tuple to be returned.\n * @param name: Name of the parameter, used for generating error messages.\n * @returns An array of numbers.\n */\nexport function normalizeArray(value, n, name) {\n    if (typeof value === 'number') {\n        return pyListRepeat(value, n);\n    }\n    else {\n        if (value.length !== n) {\n            throw new ValueError(`The ${name} argument must be an integer or tuple of ${n} integers.` +\n                ` Received: ${value.length} elements.`);\n        }\n        for (let i = 0; i < n; ++i) {\n            const singleValue = value[i];\n            if (!isInteger(singleValue)) {\n                throw new ValueError(`The ${name} argument must be an integer or tuple of ${n}` +\n                    ` integers. Received: ${JSON.stringify(value)} including a` +\n                    ` non-integer number ${singleValue}`);\n            }\n        }\n        return value;\n    }\n}\n/**\n * Determines output length of a convolution given input length.\n * @param inputLength\n * @param filterSize\n * @param padding\n * @param stride\n * @param dilation: dilation rate.\n */\nexport function convOutputLength(inputLength, filterSize, padding, stride, dilation = 1) {\n    if (inputLength == null) {\n        return inputLength;\n    }\n    const dilatedFilterSize = filterSize + (filterSize - 1) * (dilation - 1);\n    let outputLength;\n    if (padding === 'same') {\n        outputLength = inputLength;\n    }\n    else { // VALID\n        outputLength = inputLength - dilatedFilterSize + 1;\n    }\n    return Math.floor((outputLength + stride - 1) / stride);\n}\nexport function deconvLength(dimSize, strideSize, kernelSize, padding) {\n    if (dimSize == null) {\n        return null;\n    }\n    if (padding === 'valid') {\n        dimSize = dimSize * strideSize + max([kernelSize - strideSize, 0]);\n    }\n    else if (padding === 'same') {\n        dimSize = dimSize * strideSize;\n    }\n    else {\n        throw new ValueError(`Unsupport padding mode: ${padding}.`);\n    }\n    return dimSize;\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udl91dGlscy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy91dGlscy9jb252X3V0aWxzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUgsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUdyQyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFDN0MsT0FBTyxFQUFDLFNBQVMsRUFBRSxHQUFHLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFFNUM7Ozs7OztHQU1HO0FBQ0gsTUFBTSxVQUFVLGNBQWMsQ0FDMUIsS0FBc0IsRUFBRSxDQUFTLEVBQUUsSUFBWTtJQUNqRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsRUFBRTtRQUM3QixPQUFPLFlBQVksQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7S0FDL0I7U0FBTTtRQUNMLElBQUksS0FBSyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDdEIsTUFBTSxJQUFJLFVBQVUsQ0FDaEIsT0FBTyxJQUFJLDRDQUE0QyxDQUFDLFlBQVk7Z0JBQ3BFLGNBQWMsS0FBSyxDQUFDLE1BQU0sWUFBWSxDQUFDLENBQUM7U0FDN0M7UUFDRCxLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsQ0FBQyxFQUFFLEVBQUUsQ0FBQyxFQUFFO1lBQzFCLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUM3QixJQUFJLENBQUMsU0FBUyxDQUFDLFdBQVcsQ0FBQyxFQUFFO2dCQUMzQixNQUFNLElBQUksVUFBVSxDQUNoQixPQUFPLElBQUksNENBQTRDLENBQUMsRUFBRTtvQkFDMUQsd0JBQXdCLElBQUksQ0FBQyxTQUFTLENBQUMsS0FBSyxDQUFDLGNBQWM7b0JBQzNELHVCQUF1QixXQUFXLEVBQUUsQ0FBQyxDQUFDO2FBQzNDO1NBQ0Y7UUFDRCxPQUFPLEtBQUssQ0FBQztLQUNkO0FBQ0gsQ0FBQztBQUVEOzs7Ozs7O0dBT0c7QUFDSCxNQUFNLFVBQVUsZ0JBQWdCLENBQzVCLFdBQW1CLEVBQUUsVUFBa0IsRUFBRSxPQUFvQixFQUM3RCxNQUFjLEVBQUUsUUFBUSxHQUFHLENBQUM7SUFDOUIsSUFBSSxXQUFXLElBQUksSUFBSSxFQUFFO1FBQ3ZCLE9BQU8sV0FBVyxDQUFDO0tBQ3BCO0lBQ0QsTUFBTSxpQkFBaUIsR0FBRyxVQUFVLEdBQUcsQ0FBQyxVQUFVLEdBQUcsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxRQUFRLEdBQUcsQ0FBQyxDQUFDLENBQUM7SUFDekUsSUFBSSxZQUFvQixDQUFDO0lBQ3pCLElBQUksT0FBTyxLQUFLLE1BQU0sRUFBRTtRQUN0QixZQUFZLEdBQUcsV0FBVyxDQUFDO0tBQzVCO1NBQU0sRUFBRyxRQUFRO1FBQ2hCLFlBQVksR0FBRyxXQUFXLEdBQUcsaUJBQWlCLEdBQUcsQ0FBQyxDQUFDO0tBQ3BEO0lBQ0QsT0FBTyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUMsWUFBWSxHQUFHLE1BQU0sR0FBRyxDQUFDLENBQUMsR0FBRyxNQUFNLENBQUMsQ0FBQztBQUMxRCxDQUFDO0FBRUQsTUFBTSxVQUFVLFlBQVksQ0FDeEIsT0FBZSxFQUFFLFVBQWtCLEVBQUUsVUFBa0IsRUFDdkQsT0FBb0I7SUFDdEIsSUFBSSxPQUFPLElBQUksSUFBSSxFQUFFO1FBQ25CLE9BQU8sSUFBSSxDQUFDO0tBQ2I7SUFFRCxJQUFJLE9BQU8sS0FBSyxPQUFPLEVBQUU7UUFDdkIsT0FBTyxHQUFHLE9BQU8sR0FBRyxVQUFVLEdBQUcsR0FBRyxDQUFDLENBQUMsVUFBVSxHQUFHLFVBQVUsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBQ3BFO1NBQU0sSUFBSSxPQUFPLEtBQUssTUFBTSxFQUFFO1FBQzdCLE9BQU8sR0FBRyxPQUFPLEdBQUcsVUFBVSxDQUFDO0tBQ2hDO1NBQU07UUFDTCxNQUFNLElBQUksVUFBVSxDQUFDLDJCQUEyQixPQUFPLEdBQUcsQ0FBQyxDQUFDO0tBQzdEO0lBQ0QsT0FBTyxPQUFPLENBQUM7QUFDakIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbmltcG9ydCB7VmFsdWVFcnJvcn0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7UGFkZGluZ01vZGV9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuXG5pbXBvcnQge3B5TGlzdFJlcGVhdH0gZnJvbSAnLi9nZW5lcmljX3V0aWxzJztcbmltcG9ydCB7aXNJbnRlZ2VyLCBtYXh9IGZyb20gJy4vbWF0aF91dGlscyc7XG5cbi8qKlxuICogVHJhbnNmb3JtcyBhIHNpbmdsZSBudW1iZXIgb2YgYXJyYXkgb2YgbnVtYmVycyBpbnRvIGFuIGFycmF5IG9mIG51bWJlcnMuXG4gKiBAcGFyYW0gdmFsdWVcbiAqIEBwYXJhbSBuOiBUaGUgc2l6ZSBvZiB0aGUgdHVwbGUgdG8gYmUgcmV0dXJuZWQuXG4gKiBAcGFyYW0gbmFtZTogTmFtZSBvZiB0aGUgcGFyYW1ldGVyLCB1c2VkIGZvciBnZW5lcmF0aW5nIGVycm9yIG1lc3NhZ2VzLlxuICogQHJldHVybnMgQW4gYXJyYXkgb2YgbnVtYmVycy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KFxuICAgIHZhbHVlOiBudW1iZXJ8bnVtYmVyW10sIG46IG51bWJlciwgbmFtZTogc3RyaW5nKTogbnVtYmVyW10ge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHJldHVybiBweUxpc3RSZXBlYXQodmFsdWUsIG4pO1xuICB9IGVsc2Uge1xuICAgIGlmICh2YWx1ZS5sZW5ndGggIT09IG4pIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBUaGUgJHtuYW1lfSBhcmd1bWVudCBtdXN0IGJlIGFuIGludGVnZXIgb3IgdHVwbGUgb2YgJHtufSBpbnRlZ2Vycy5gICtcbiAgICAgICAgICBgIFJlY2VpdmVkOiAke3ZhbHVlLmxlbmd0aH0gZWxlbWVudHMuYCk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbjsgKytpKSB7XG4gICAgICBjb25zdCBzaW5nbGVWYWx1ZSA9IHZhbHVlW2ldO1xuICAgICAgaWYgKCFpc0ludGVnZXIoc2luZ2xlVmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYFRoZSAke25hbWV9IGFyZ3VtZW50IG11c3QgYmUgYW4gaW50ZWdlciBvciB0dXBsZSBvZiAke259YCArXG4gICAgICAgICAgICBgIGludGVnZXJzLiBSZWNlaXZlZDogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9IGluY2x1ZGluZyBhYCArXG4gICAgICAgICAgICBgIG5vbi1pbnRlZ2VyIG51bWJlciAke3NpbmdsZVZhbHVlfWApO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbn1cblxuLyoqXG4gKiBEZXRlcm1pbmVzIG91dHB1dCBsZW5ndGggb2YgYSBjb252b2x1dGlvbiBnaXZlbiBpbnB1dCBsZW5ndGguXG4gKiBAcGFyYW0gaW5wdXRMZW5ndGhcbiAqIEBwYXJhbSBmaWx0ZXJTaXplXG4gKiBAcGFyYW0gcGFkZGluZ1xuICogQHBhcmFtIHN0cmlkZVxuICogQHBhcmFtIGRpbGF0aW9uOiBkaWxhdGlvbiByYXRlLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udk91dHB1dExlbmd0aChcbiAgICBpbnB1dExlbmd0aDogbnVtYmVyLCBmaWx0ZXJTaXplOiBudW1iZXIsIHBhZGRpbmc6IFBhZGRpbmdNb2RlLFxuICAgIHN0cmlkZTogbnVtYmVyLCBkaWxhdGlvbiA9IDEpOiBudW1iZXIge1xuICBpZiAoaW5wdXRMZW5ndGggPT0gbnVsbCkge1xuICAgIHJldHVybiBpbnB1dExlbmd0aDtcbiAgfVxuICBjb25zdCBkaWxhdGVkRmlsdGVyU2l6ZSA9IGZpbHRlclNpemUgKyAoZmlsdGVyU2l6ZSAtIDEpICogKGRpbGF0aW9uIC0gMSk7XG4gIGxldCBvdXRwdXRMZW5ndGg6IG51bWJlcjtcbiAgaWYgKHBhZGRpbmcgPT09ICdzYW1lJykge1xuICAgIG91dHB1dExlbmd0aCA9IGlucHV0TGVuZ3RoO1xuICB9IGVsc2UgeyAgLy8gVkFMSURcbiAgICBvdXRwdXRMZW5ndGggPSBpbnB1dExlbmd0aCAtIGRpbGF0ZWRGaWx0ZXJTaXplICsgMTtcbiAgfVxuICByZXR1cm4gTWF0aC5mbG9vcigob3V0cHV0TGVuZ3RoICsgc3RyaWRlIC0gMSkgLyBzdHJpZGUpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVjb252TGVuZ3RoKFxuICAgIGRpbVNpemU6IG51bWJlciwgc3RyaWRlU2l6ZTogbnVtYmVyLCBrZXJuZWxTaXplOiBudW1iZXIsXG4gICAgcGFkZGluZzogUGFkZGluZ01vZGUpOiBudW1iZXIge1xuICBpZiAoZGltU2l6ZSA9PSBudWxsKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAocGFkZGluZyA9PT0gJ3ZhbGlkJykge1xuICAgIGRpbVNpemUgPSBkaW1TaXplICogc3RyaWRlU2l6ZSArIG1heChba2VybmVsU2l6ZSAtIHN0cmlkZVNpemUsIDBdKTtcbiAgfSBlbHNlIGlmIChwYWRkaW5nID09PSAnc2FtZScpIHtcbiAgICBkaW1TaXplID0gZGltU2l6ZSAqIHN0cmlkZVNpemU7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoYFVuc3VwcG9ydCBwYWRkaW5nIG1vZGU6ICR7cGFkZGluZ30uYCk7XG4gIH1cbiAgcmV0dXJuIGRpbVNpemU7XG59XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Convolutional Layers\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { getActivation, serializeActivation } from '../activations';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkInterpolationFormat, checkPaddingMode } from '../common';\nimport { getConstraint, serializeConstraint } from '../constraints';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { getInitializer, serializeInitializer } from '../initializers';\nimport { getRegularizer, serializeRegularizer } from '../regularizers';\nimport { convOutputLength, deconvLength, normalizeArray } from '../utils/conv_utils';\nimport * as generic_utils from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\n/**\n * Transpose and cast the input before the conv2d.\n * @param x Input image tensor.\n * @param dataFormat\n */\nexport function preprocessConv2DInput(x, dataFormat) {\n    // TODO(cais): Cast type to float32 if not.\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        if (dataFormat === 'channelsFirst') {\n            return tfc.transpose(x, [0, 2, 3, 1]); // NCHW -> NHWC.\n        }\n        else {\n            return x;\n        }\n    });\n}\n/**\n * Transpose and cast the input before the conv3d.\n * @param x Input image tensor.\n * @param dataFormat\n */\nexport function preprocessConv3DInput(x, dataFormat) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        if (dataFormat === 'channelsFirst') {\n            return tfc.transpose(x, [0, 2, 3, 4, 1]); // NCDHW -> NDHWC.\n        }\n        else {\n            return x;\n        }\n    });\n}\n/**\n * 1D-convolution with bias added.\n *\n * Porting Note: This function does not exist in the Python Keras backend.\n *   It is exactly the same as `conv2d`, except the added `bias`.\n *\n * @param x Input tensor, rank-3, of shape `[batchSize, width, inChannels]`.\n * @param kernel Kernel, rank-3, of shape `[filterWidth, inDepth, outDepth]`.\n * @param bias Bias, rank-3, of shape `[outDepth]`.\n * @param strides\n * @param padding Padding mode.\n * @param dataFormat Data format.\n * @param dilationRate\n * @returns The result of the 1D convolution.\n * @throws ValueError, if `x`, `kernel` or `bias` is not of the correct rank.\n */\nexport function conv1dWithBias(x, kernel, bias, strides = 1, padding = 'valid', dataFormat, dilationRate = 1) {\n    return tidy(() => {\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        checkDataFormat(dataFormat);\n        // Check the ranks of x, kernel and bias.\n        if (x.shape.length !== 3) {\n            throw new ValueError(`The input of a conv1dWithBias operation should be 3, but is ` +\n                `${x.shape.length} instead.`);\n        }\n        if (kernel.shape.length !== 3) {\n            throw new ValueError(`The kernel for a conv1dWithBias operation should be 3, but is ` +\n                `${kernel.shape.length} instead`);\n        }\n        if (bias != null && bias.shape.length !== 1) {\n            throw new ValueError(`The bias for a conv1dWithBias operation should be 1, but is ` +\n                `${kernel.shape.length} instead`);\n        }\n        // TODO(cais): Support CAUSAL padding mode.\n        if (dataFormat === 'channelsFirst') {\n            x = tfc.transpose(x, [0, 2, 1]); // NCW -> NWC.\n        }\n        if (padding === 'causal') {\n            throw new NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' +\n                'implemented yet.');\n        }\n        let y = tfc.conv1d(x, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NWC', dilationRate);\n        if (bias != null) {\n            y = K.biasAdd(y, bias);\n        }\n        return y;\n    });\n}\n/**\n * 1D-convolution.\n *\n * @param x Input tensor, rank-3, of shape `[batchSize, width, inChannels]`.\n * @param kernel Kernel, rank-3, of shape `[filterWidth, inDepth, outDepth]`.s\n * @param strides\n * @param padding Padding mode.\n * @param dataFormat Data format.\n * @param dilationRate\n * @returns The result of the 1D convolution.\n * @throws ValueError, if `x`, `kernel` or `bias` is not of the correct rank.\n */\nexport function conv1d(x, kernel, strides = 1, padding = 'valid', dataFormat, dilationRate = 1) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        return conv1dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);\n    });\n}\n/**\n * 2D Convolution\n * @param x\n * @param kernel kernel of the convolution.\n * @param strides strides array.\n * @param padding padding mode. Default to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param dilationRate dilation rate array.\n * @returns Result of the 2D pooling.\n */\nexport function conv2d(x, kernel, strides = [1, 1], padding = 'valid', dataFormat, dilationRate) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        return conv2dWithBiasActivation(x, kernel, null, strides, padding, dataFormat, dilationRate);\n    });\n}\n/**\n * 2D Convolution with an added bias and optional activation.\n * Note: This function does not exist in the Python Keras Backend. This function\n * is exactly the same as `conv2d`, except the added `bias`.\n */\nexport function conv2dWithBiasActivation(x, kernel, bias, strides = [1, 1], padding = 'valid', dataFormat, dilationRate, activation = null) {\n    return tidy(() => {\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        checkDataFormat(dataFormat);\n        if (x.rank !== 3 && x.rank !== 4) {\n            throw new ValueError(`conv2dWithBiasActivation expects input to be of rank 3 or 4, ` +\n                `but received ${x.rank}.`);\n        }\n        if (kernel.rank !== 3 && kernel.rank !== 4) {\n            throw new ValueError(`conv2dWithBiasActivation expects kernel to be of rank 3 or 4, ` +\n                `but received ${x.rank}.`);\n        }\n        let y = preprocessConv2DInput(x, dataFormat);\n        if (padding === 'causal') {\n            throw new NotImplementedError('The support for CAUSAL padding mode in conv1dWithBias is not ' +\n                'implemented yet.');\n        }\n        y = tfc.fused.conv2d({\n            x: y,\n            filter: kernel,\n            strides: strides,\n            pad: padding === 'same' ? 'same' : 'valid',\n            dilations: dilationRate,\n            dataFormat: 'NHWC',\n            bias,\n            activation\n        });\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 3, 1, 2]);\n        }\n        return y;\n    });\n}\n/**\n * 3D Convolution.\n * @param x\n * @param kernel kernel of the convolution.\n * @param strides strides array.\n * @param padding padding mode. Default to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param dilationRate dilation rate array.\n * @returns Result of the 3D convolution.\n */\nexport function conv3d(x, kernel, strides = [1, 1, 1], padding = 'valid', dataFormat, dilationRate) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        return conv3dWithBias(x, kernel, null, strides, padding, dataFormat, dilationRate);\n    });\n}\n/**\n * 3D Convolution with an added bias.\n * Note: This function does not exist in the Python Keras Backend. This function\n * is exactly the same as `conv3d`, except the added `bias`.\n */\nexport function conv3dWithBias(x, kernel, bias, strides = [1, 1, 1], padding = 'valid', dataFormat, dilationRate) {\n    return tidy(() => {\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        checkDataFormat(dataFormat);\n        if (x.rank !== 4 && x.rank !== 5) {\n            throw new ValueError(`conv3dWithBias expects input to be of rank 4 or 5, but received ` +\n                `${x.rank}.`);\n        }\n        if (kernel.rank !== 4 && kernel.rank !== 5) {\n            throw new ValueError(`conv3dWithBias expects kernel to be of rank 4 or 5, but received ` +\n                `${x.rank}.`);\n        }\n        let y = preprocessConv3DInput(x, dataFormat);\n        if (padding === 'causal') {\n            throw new NotImplementedError('The support for CAUSAL padding mode in conv3dWithBias is not ' +\n                'implemented yet.');\n        }\n        y = tfc.conv3d(y, kernel, strides, padding === 'same' ? 'same' : 'valid', 'NDHWC', dilationRate);\n        if (bias != null) {\n            y = K.biasAdd(y, bias);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 4, 1, 2, 3]);\n        }\n        return y;\n    });\n}\n/**\n * Abstract convolution layer.\n */\nexport class BaseConv extends Layer {\n    constructor(rank, args) {\n        super(args);\n        this.bias = null;\n        this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        BaseConv.verifyArgs(args);\n        this.rank = rank;\n        generic_utils.assertPositiveInteger(this.rank, 'rank');\n        if (this.rank !== 1 && this.rank !== 2 && this.rank !== 3) {\n            throw new NotImplementedError(`Convolution layer for rank other than 1, 2, or 3 (${this.rank}) is ` +\n                `not implemented yet.`);\n        }\n        this.kernelSize = normalizeArray(args.kernelSize, rank, 'kernelSize');\n        this.strides = normalizeArray(args.strides == null ? 1 : args.strides, rank, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        checkPaddingMode(this.padding);\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        this.activation = getActivation(args.activation);\n        this.useBias = args.useBias == null ? true : args.useBias;\n        this.biasInitializer =\n            getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);\n        this.biasConstraint = getConstraint(args.biasConstraint);\n        this.biasRegularizer = getRegularizer(args.biasRegularizer);\n        this.activityRegularizer = getRegularizer(args.activityRegularizer);\n        this.dilationRate = normalizeArray(args.dilationRate == null ? 1 : args.dilationRate, rank, 'dilationRate');\n        if (this.rank === 1 &&\n            (Array.isArray(this.dilationRate) && this.dilationRate.length !== 1)) {\n            throw new ValueError(`dilationRate must be a number or an array of a single number ` +\n                `for 1D convolution, but received ` +\n                `${JSON.stringify(this.dilationRate)}`);\n        }\n        else if (this.rank === 2) {\n            if (typeof this.dilationRate === 'number') {\n                this.dilationRate = [this.dilationRate, this.dilationRate];\n            }\n            else if (this.dilationRate.length !== 2) {\n                throw new ValueError(`dilationRate must be a number or array of two numbers for 2D ` +\n                    `convolution, but received ${JSON.stringify(this.dilationRate)}`);\n            }\n        }\n        else if (this.rank === 3) {\n            if (typeof this.dilationRate === 'number') {\n                this.dilationRate =\n                    [this.dilationRate, this.dilationRate, this.dilationRate];\n            }\n            else if (this.dilationRate.length !== 3) {\n                throw new ValueError(`dilationRate must be a number or array of three numbers for 3D ` +\n                    `convolution, but received ${JSON.stringify(this.dilationRate)}`);\n            }\n        }\n    }\n    static verifyArgs(args) {\n        // Check config.kernelSize type and shape.\n        generic_utils.assert('kernelSize' in args, `required key 'kernelSize' not in config`);\n        if (typeof args.kernelSize !== 'number' &&\n            !generic_utils.checkArrayTypeAndLength(args.kernelSize, 'number', 1, 3)) {\n            throw new ValueError(`BaseConv expects config.kernelSize to be number or number[] with ` +\n                `length 1, 2, or 3, but received ${JSON.stringify(args.kernelSize)}.`);\n        }\n    }\n    getConfig() {\n        const config = {\n            kernelSize: this.kernelSize,\n            strides: this.strides,\n            padding: this.padding,\n            dataFormat: this.dataFormat,\n            dilationRate: this.dilationRate,\n            activation: serializeActivation(this.activation),\n            useBias: this.useBias,\n            biasInitializer: serializeInitializer(this.biasInitializer),\n            biasRegularizer: serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: serializeRegularizer(this.activityRegularizer),\n            biasConstraint: serializeConstraint(this.biasConstraint)\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/**\n * Abstract nD convolution layer.  Ancestor of convolution layers which reduce\n * across channels, i.e., Conv1D and Conv2D, but not DepthwiseConv2D.\n */\nexport class Conv extends BaseConv {\n    constructor(rank, args) {\n        super(rank, args);\n        this.kernel = null;\n        Conv.verifyArgs(args);\n        this.filters = args.filters;\n        generic_utils.assertPositiveInteger(this.filters, 'filters');\n        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n        this.kernelConstraint = getConstraint(args.kernelConstraint);\n        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null) {\n            throw new ValueError(`The channel dimension of the input should be defined. ` +\n                `Found ${inputShape[channelAxis]}`);\n        }\n        const inputDim = inputShape[channelAxis];\n        const kernelShape = this.kernelSize.concat([inputDim, this.filters]);\n        this.kernel = this.addWeight('kernel', kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.filters], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        this.inputSpec = [{ ndim: this.rank + 2, axes: { [channelAxis]: inputDim } }];\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = getExactlyOneTensor(inputs);\n            let outputs;\n            const biasValue = this.bias == null ? null : this.bias.read();\n            const fusedActivationName = generic_utils.mapActivationToFusedKernel(this.activation.getClassName());\n            if (fusedActivationName != null && this.rank === 2) {\n                outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate, fusedActivationName);\n            }\n            else {\n                if (this.rank === 1) {\n                    outputs = conv1dWithBias(inputs, this.kernel.read(), biasValue, this.strides[0], this.padding, this.dataFormat, this.dilationRate[0]);\n                }\n                else if (this.rank === 2) {\n                    // TODO(cais): Move up to constructor.\n                    outputs = conv2dWithBiasActivation(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);\n                }\n                else if (this.rank === 3) {\n                    outputs = conv3dWithBias(inputs, this.kernel.read(), biasValue, this.strides, this.padding, this.dataFormat, this.dilationRate);\n                }\n                else {\n                    throw new NotImplementedError('convolutions greater than 3D are not implemented yet.');\n                }\n                if (this.activation != null) {\n                    outputs = this.activation.apply(outputs);\n                }\n            }\n            return outputs;\n        });\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const newSpace = [];\n        const space = (this.dataFormat === 'channelsLast') ?\n            inputShape.slice(1, inputShape.length - 1) :\n            inputShape.slice(2);\n        for (let i = 0; i < space.length; ++i) {\n            const newDim = convOutputLength(space[i], this.kernelSize[i], this.padding, this.strides[i], typeof this.dilationRate === 'number' ? this.dilationRate :\n                this.dilationRate[i]);\n            newSpace.push(newDim);\n        }\n        let outputShape = [inputShape[0]];\n        if (this.dataFormat === 'channelsLast') {\n            outputShape = outputShape.concat(newSpace);\n            outputShape.push(this.filters);\n        }\n        else {\n            outputShape.push(this.filters);\n            outputShape = outputShape.concat(newSpace);\n        }\n        return outputShape;\n    }\n    getConfig() {\n        const config = {\n            filters: this.filters,\n            kernelInitializer: serializeInitializer(this.kernelInitializer),\n            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n            kernelConstraint: serializeConstraint(this.kernelConstraint)\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n    static verifyArgs(args) {\n        // Check config.filters type, shape, and value.\n        if (!('filters' in args) || typeof args.filters !== 'number' ||\n            args.filters < 1) {\n            throw new ValueError(`Convolution layer expected config.filters to be a 'number' > 0 ` +\n                `but got ${JSON.stringify(args.filters)}`);\n        }\n    }\n}\nexport class Conv2D extends Conv {\n    constructor(args) {\n        super(2, args);\n        Conv2D.verifyArgs(args);\n    }\n    getConfig() {\n        const config = super.getConfig();\n        delete config['rank'];\n        return config;\n    }\n    static verifyArgs(args) {\n        // config.kernelSize must be a number or array of numbers.\n        if ((typeof args.kernelSize !== 'number') &&\n            !generic_utils.checkArrayTypeAndLength(args.kernelSize, 'number', 1, 2)) {\n            throw new ValueError(`Conv2D expects config.kernelSize to be number or number[] with ` +\n                `length 1 or 2, but received ${JSON.stringify(args.kernelSize)}.`);\n        }\n    }\n}\n/** @nocollapse */\nConv2D.className = 'Conv2D';\nserialization.registerClass(Conv2D);\nexport class Conv3D extends Conv {\n    constructor(args) {\n        super(3, args);\n        Conv3D.verifyArgs(args);\n    }\n    getConfig() {\n        const config = super.getConfig();\n        delete config['rank'];\n        return config;\n    }\n    static verifyArgs(args) {\n        // config.kernelSize must be a number or array of numbers.\n        if (typeof args.kernelSize !== 'number') {\n            if (!(Array.isArray(args.kernelSize) &&\n                (args.kernelSize.length === 1 || args.kernelSize.length === 3))) {\n                throw new ValueError(`Conv3D expects config.kernelSize to be number or` +\n                    ` [number, number, number], but received ${JSON.stringify(args.kernelSize)}.`);\n            }\n        }\n    }\n}\n/** @nocollapse */\nConv3D.className = 'Conv3D';\nserialization.registerClass(Conv3D);\nexport class Conv2DTranspose extends Conv2D {\n    constructor(args) {\n        super(args);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n        if (this.padding !== 'same' && this.padding !== 'valid') {\n            throw new ValueError(`Conv2DTranspose currently supports only padding modes 'same' ` +\n                `and 'valid', but received padding mode ${this.padding}`);\n        }\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        if (inputShape.length !== 4) {\n            throw new ValueError('Input should have rank 4; Received input shape: ' +\n                JSON.stringify(inputShape));\n        }\n        const channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null) {\n            throw new ValueError('The channel dimension of the inputs should be defined. ' +\n                'Found `None`.');\n        }\n        const inputDim = inputShape[channelAxis];\n        const kernelShape = this.kernelSize.concat([this.filters, inputDim]);\n        this.kernel = this.addWeight('kernel', kernelShape, 'float32', this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        // Set input spec.\n        this.inputSpec =\n            [new InputSpec({ ndim: 4, axes: { [channelAxis]: inputDim } })];\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tfc.tidy(() => {\n            let input = getExactlyOneTensor(inputs);\n            if (input.shape.length !== 4) {\n                throw new ValueError(`Conv2DTranspose.call() expects input tensor to be rank-4, but ` +\n                    `received a tensor of rank-${input.shape.length}`);\n            }\n            const inputShape = input.shape;\n            const batchSize = inputShape[0];\n            let hAxis;\n            let wAxis;\n            if (this.dataFormat === 'channelsFirst') {\n                hAxis = 2;\n                wAxis = 3;\n            }\n            else {\n                hAxis = 1;\n                wAxis = 2;\n            }\n            const height = inputShape[hAxis];\n            const width = inputShape[wAxis];\n            const kernelH = this.kernelSize[0];\n            const kernelW = this.kernelSize[1];\n            const strideH = this.strides[0];\n            const strideW = this.strides[1];\n            // Infer the dynamic output shape.\n            const outHeight = deconvLength(height, strideH, kernelH, this.padding);\n            const outWidth = deconvLength(width, strideW, kernelW, this.padding);\n            // Porting Note: We don't branch based on `this.dataFormat` here,\n            // because\n            //   the tjfs-core function `conv2dTranspose` called below always\n            //   assumes channelsLast.\n            const outputShape = [batchSize, outHeight, outWidth, this.filters];\n            if (this.dataFormat !== 'channelsLast') {\n                input = tfc.transpose(input, [0, 2, 3, 1]);\n            }\n            let outputs = tfc.conv2dTranspose(input, this.kernel.read(), outputShape, this.strides, this.padding);\n            if (this.dataFormat !== 'channelsLast') {\n                outputs = tfc.transpose(outputs, [0, 3, 1, 2]);\n            }\n            if (this.bias != null) {\n                outputs =\n                    K.biasAdd(outputs, this.bias.read(), this.dataFormat);\n            }\n            if (this.activation != null) {\n                outputs = this.activation.apply(outputs);\n            }\n            return outputs;\n        });\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const outputShape = inputShape.slice();\n        let channelAxis;\n        let heightAxis;\n        let widthAxis;\n        if (this.dataFormat === 'channelsFirst') {\n            channelAxis = 1;\n            heightAxis = 2;\n            widthAxis = 3;\n        }\n        else {\n            channelAxis = 3;\n            heightAxis = 1;\n            widthAxis = 2;\n        }\n        const kernelH = this.kernelSize[0];\n        const kernelW = this.kernelSize[1];\n        const strideH = this.strides[0];\n        const strideW = this.strides[1];\n        outputShape[channelAxis] = this.filters;\n        outputShape[heightAxis] =\n            deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);\n        outputShape[widthAxis] =\n            deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);\n        return outputShape;\n    }\n    getConfig() {\n        const config = super.getConfig();\n        delete config['dilationRate'];\n        return config;\n    }\n}\n/** @nocollapse */\nConv2DTranspose.className = 'Conv2DTranspose';\nserialization.registerClass(Conv2DTranspose);\nexport class Conv3DTranspose extends Conv3D {\n    constructor(args) {\n        super(args);\n        this.inputSpec = [new InputSpec({ ndim: 5 })];\n        if (this.padding !== 'same' && this.padding !== 'valid') {\n            throw new ValueError(`Conv3DTranspose currently supports only padding modes 'same' ` +\n                `and 'valid', but received padding mode ${this.padding}`);\n        }\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        if (inputShape.length !== 5) {\n            throw new ValueError('Input should have rank 5; Received input shape: ' +\n                JSON.stringify(inputShape));\n        }\n        const channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null) {\n            throw new ValueError('The channel dimension of the inputs should be defined. ' +\n                'Found `None`.');\n        }\n        const inputDim = inputShape[channelAxis];\n        const kernelShape = this.kernelSize.concat([this.filters, inputDim]);\n        this.kernel = this.addWeight('kernel', kernelShape, 'float32', this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        // Set input spec.\n        this.inputSpec =\n            [new InputSpec({ ndim: 5, axes: { [channelAxis]: inputDim } })];\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tfc.tidy(() => {\n            let input = getExactlyOneTensor(inputs);\n            if (input.shape.length !== 5) {\n                throw new ValueError(`Conv3DTranspose.call() expects input tensor to be rank-4, but ` +\n                    `received a tensor of rank-${input.shape.length}`);\n            }\n            const inputShape = input.shape;\n            const batchSize = inputShape[0];\n            let hAxis;\n            let wAxis;\n            let dAxis;\n            if (this.dataFormat === 'channelsFirst') {\n                dAxis = 2;\n                hAxis = 3;\n                wAxis = 4;\n            }\n            else {\n                dAxis = 1;\n                hAxis = 2;\n                wAxis = 3;\n            }\n            const depth = inputShape[dAxis];\n            const height = inputShape[hAxis];\n            const width = inputShape[wAxis];\n            const kernelD = this.kernelSize[0];\n            const kernelH = this.kernelSize[1];\n            const kernelW = this.kernelSize[2];\n            const strideD = this.strides[0];\n            const strideH = this.strides[1];\n            const strideW = this.strides[2];\n            // Infer the dynamic output shape.\n            const outDepth = deconvLength(depth, strideD, kernelD, this.padding);\n            const outHeight = deconvLength(height, strideH, kernelH, this.padding);\n            const outWidth = deconvLength(width, strideW, kernelW, this.padding);\n            // Same as `conv2dTranspose`. We always assumes channelsLast.\n            const outputShape = [batchSize, outDepth, outHeight, outWidth, this.filters];\n            if (this.dataFormat !== 'channelsLast') {\n                input = tfc.transpose(input, [0, 2, 3, 4, 1]);\n            }\n            let outputs = tfc.conv3dTranspose(input, this.kernel.read(), outputShape, this.strides, this.padding);\n            if (this.dataFormat !== 'channelsLast') {\n                outputs = tfc.transpose(outputs, [0, 4, 1, 2, 3]);\n            }\n            if (this.bias !== null) {\n                outputs =\n                    K.biasAdd(outputs, this.bias.read(), this.dataFormat);\n            }\n            if (this.activation !== null) {\n                outputs = this.activation.apply(outputs);\n            }\n            return outputs;\n        });\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const outputShape = inputShape.slice();\n        let channelAxis;\n        let depthAxis;\n        let heightAxis;\n        let widthAxis;\n        if (this.dataFormat === 'channelsFirst') {\n            channelAxis = 1;\n            depthAxis = 2;\n            heightAxis = 3;\n            widthAxis = 4;\n        }\n        else {\n            channelAxis = 4;\n            depthAxis = 1;\n            heightAxis = 2;\n            widthAxis = 3;\n        }\n        const kernelD = this.kernelSize[0];\n        const kernelH = this.kernelSize[1];\n        const kernelW = this.kernelSize[2];\n        const strideD = this.strides[0];\n        const strideH = this.strides[1];\n        const strideW = this.strides[2];\n        outputShape[channelAxis] = this.filters;\n        outputShape[depthAxis] =\n            deconvLength(outputShape[depthAxis], strideD, kernelD, this.padding);\n        outputShape[heightAxis] =\n            deconvLength(outputShape[heightAxis], strideH, kernelH, this.padding);\n        outputShape[widthAxis] =\n            deconvLength(outputShape[widthAxis], strideW, kernelW, this.padding);\n        return outputShape;\n    }\n    getConfig() {\n        const config = super.getConfig();\n        delete config['dilationRate'];\n        return config;\n    }\n}\n/** @nocollapse */\nConv3DTranspose.className = 'Conv3DTranspose';\nserialization.registerClass(Conv3DTranspose);\nexport class SeparableConv extends Conv {\n    constructor(rank, config) {\n        super(rank, config);\n        this.DEFAULT_DEPTHWISE_INITIALIZER = 'glorotUniform';\n        this.DEFAULT_POINTWISE_INITIALIZER = 'glorotUniform';\n        this.depthwiseKernel = null;\n        this.pointwiseKernel = null;\n        if (config.filters == null) {\n            throw new ValueError('The `filters` configuration field is required by SeparableConv, ' +\n                'but is unspecified.');\n        }\n        if (config.kernelInitializer != null || config.kernelRegularizer != null ||\n            config.kernelConstraint != null) {\n            throw new ValueError('Fields kernelInitializer, kernelRegularizer and kernelConstraint ' +\n                'are invalid for SeparableConv2D. Use depthwiseInitializer, ' +\n                'depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, ' +\n                'pointwiseRegularizer and pointwiseConstraint instead.');\n        }\n        if (config.padding != null && config.padding !== 'same' &&\n            config.padding !== 'valid') {\n            throw new ValueError(`SeparableConv${this.rank}D supports only padding modes: ` +\n                `'same' and 'valid', but received ${JSON.stringify(config.padding)}`);\n        }\n        this.depthMultiplier =\n            config.depthMultiplier == null ? 1 : config.depthMultiplier;\n        this.depthwiseInitializer = getInitializer(config.depthwiseInitializer || this.DEFAULT_DEPTHWISE_INITIALIZER);\n        this.depthwiseRegularizer = getRegularizer(config.depthwiseRegularizer);\n        this.depthwiseConstraint = getConstraint(config.depthwiseConstraint);\n        this.pointwiseInitializer = getInitializer(config.depthwiseInitializer || this.DEFAULT_POINTWISE_INITIALIZER);\n        this.pointwiseRegularizer = getRegularizer(config.pointwiseRegularizer);\n        this.pointwiseConstraint = getConstraint(config.pointwiseConstraint);\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        if (inputShape.length < this.rank + 2) {\n            throw new ValueError(`Inputs to SeparableConv${this.rank}D should have rank ` +\n                `${this.rank + 2}, but received input shape: ` +\n                `${JSON.stringify(inputShape)}`);\n        }\n        const channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {\n            throw new ValueError(`The channel dimension of the inputs should be defined, ` +\n                `but found ${JSON.stringify(inputShape[channelAxis])}`);\n        }\n        const inputDim = inputShape[channelAxis];\n        const depthwiseKernelShape = this.kernelSize.concat([inputDim, this.depthMultiplier]);\n        const pointwiseKernelShape = [];\n        for (let i = 0; i < this.rank; ++i) {\n            pointwiseKernelShape.push(1);\n        }\n        pointwiseKernelShape.push(inputDim * this.depthMultiplier, this.filters);\n        const trainable = true;\n        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, 'float32', this.depthwiseInitializer, this.depthwiseRegularizer, trainable, this.depthwiseConstraint);\n        this.pointwiseKernel = this.addWeight('pointwise_kernel', pointwiseKernelShape, 'float32', this.pointwiseInitializer, this.pointwiseRegularizer, trainable, this.pointwiseConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.filters], 'float32', this.biasInitializer, this.biasRegularizer, trainable, this.biasConstraint);\n        }\n        else {\n            this.bias = null;\n        }\n        this.inputSpec =\n            [new InputSpec({ ndim: this.rank + 2, axes: { [channelAxis]: inputDim } })];\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = getExactlyOneTensor(inputs);\n            let output;\n            if (this.rank === 1) {\n                throw new NotImplementedError('1D separable convolution is not implemented yet.');\n            }\n            else if (this.rank === 2) {\n                if (this.dataFormat === 'channelsFirst') {\n                    inputs = tfc.transpose(inputs, [0, 2, 3, 1]); // NCHW -> NHWC.\n                }\n                output = tfc.separableConv2d(inputs, this.depthwiseKernel.read(), this.pointwiseKernel.read(), this.strides, this.padding, this.dilationRate, 'NHWC');\n            }\n            if (this.useBias) {\n                output = K.biasAdd(output, this.bias.read(), this.dataFormat);\n            }\n            if (this.activation != null) {\n                output = this.activation.apply(output);\n            }\n            if (this.dataFormat === 'channelsFirst') {\n                output = tfc.transpose(output, [0, 3, 1, 2]); // NHWC -> NCHW.\n            }\n            return output;\n        });\n    }\n    getConfig() {\n        const config = super.getConfig();\n        delete config['rank'];\n        delete config['kernelInitializer'];\n        delete config['kernelRegularizer'];\n        delete config['kernelConstraint'];\n        config['depthwiseInitializer'] =\n            serializeInitializer(this.depthwiseInitializer);\n        config['pointwiseInitializer'] =\n            serializeInitializer(this.pointwiseInitializer);\n        config['depthwiseRegularizer'] =\n            serializeRegularizer(this.depthwiseRegularizer);\n        config['pointwiseRegularizer'] =\n            serializeRegularizer(this.pointwiseRegularizer);\n        config['depthwiseConstraint'] =\n            serializeConstraint(this.depthwiseConstraint);\n        config['pointwiseConstraint'] =\n            serializeConstraint(this.pointwiseConstraint);\n        return config;\n    }\n}\n/** @nocollapse */\nSeparableConv.className = 'SeparableConv';\nexport class SeparableConv2D extends SeparableConv {\n    constructor(args) {\n        super(2, args);\n    }\n}\n/** @nocollapse */\nSeparableConv2D.className = 'SeparableConv2D';\nserialization.registerClass(SeparableConv2D);\nexport class Conv1D extends Conv {\n    constructor(args) {\n        super(1, args);\n        Conv1D.verifyArgs(args);\n        this.inputSpec = [{ ndim: 3 }];\n    }\n    getConfig() {\n        const config = super.getConfig();\n        delete config['rank'];\n        delete config['dataFormat'];\n        return config;\n    }\n    static verifyArgs(args) {\n        // config.kernelSize must be a number or array of numbers.\n        if (typeof args.kernelSize !== 'number' &&\n            !generic_utils.checkArrayTypeAndLength(args.kernelSize, 'number', 1, 1)) {\n            throw new ValueError(`Conv1D expects config.kernelSize to be number or number[] with ` +\n                `length 1, but received ${JSON.stringify(args.kernelSize)}.`);\n        }\n    }\n}\n/** @nocollapse */\nConv1D.className = 'Conv1D';\nserialization.registerClass(Conv1D);\nexport class Cropping2D extends Layer {\n    constructor(args) {\n        super(args);\n        if (typeof args.cropping === 'number') {\n            this.cropping =\n                [[args.cropping, args.cropping], [args.cropping, args.cropping]];\n        }\n        else if (typeof args.cropping[0] === 'number') {\n            this.cropping = [\n                [args.cropping[0], args.cropping[0]],\n                [args.cropping[1], args.cropping[1]]\n            ];\n        }\n        else {\n            this.cropping = args.cropping;\n        }\n        this.dataFormat =\n            args.dataFormat === undefined ? 'channelsLast' : args.dataFormat;\n        this.inputSpec = [{ ndim: 4 }];\n    }\n    computeOutputShape(inputShape) {\n        if (this.dataFormat === 'channelsFirst') {\n            return [\n                inputShape[0], inputShape[1],\n                inputShape[2] - this.cropping[0][0] - this.cropping[0][1],\n                inputShape[3] - this.cropping[1][0] - this.cropping[1][1]\n            ];\n        }\n        else {\n            return [\n                inputShape[0],\n                inputShape[1] - this.cropping[0][0] - this.cropping[0][1],\n                inputShape[2] - this.cropping[1][0] - this.cropping[1][1], inputShape[3]\n            ];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                const hSliced = K.sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[1] - this.cropping[0][0] - this.cropping[0][1], 2);\n                return K.sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[2] - this.cropping[1][1] - this.cropping[1][0], 3);\n            }\n            else {\n                const hSliced = K.sliceAlongAxis(inputs, this.cropping[0][0], inputs.shape[2] - this.cropping[0][0] - this.cropping[0][1], 3);\n                return K.sliceAlongAxis(hSliced, this.cropping[1][0], inputs.shape[3] - this.cropping[1][1] - this.cropping[1][0], 4);\n            }\n        });\n    }\n    getConfig() {\n        const config = { cropping: this.cropping, dataFormat: this.dataFormat };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nCropping2D.className = 'Cropping2D';\nserialization.registerClass(Cropping2D);\nexport class UpSampling2D extends Layer {\n    constructor(args) {\n        super(args);\n        this.DEFAULT_SIZE = [2, 2];\n        this.inputSpec = [{ ndim: 4 }];\n        this.size = args.size == null ? this.DEFAULT_SIZE : args.size;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        this.interpolation =\n            args.interpolation == null ? 'nearest' : args.interpolation;\n        checkInterpolationFormat(this.interpolation);\n    }\n    computeOutputShape(inputShape) {\n        if (this.dataFormat === 'channelsFirst') {\n            const height = inputShape[2] == null ? null : this.size[0] * inputShape[2];\n            const width = inputShape[3] == null ? null : this.size[1] * inputShape[3];\n            return [inputShape[0], inputShape[1], height, width];\n        }\n        else {\n            const height = inputShape[1] == null ? null : this.size[0] * inputShape[1];\n            const width = inputShape[2] == null ? null : this.size[1] * inputShape[2];\n            return [inputShape[0], height, width, inputShape[3]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tfc.tidy(() => {\n            let input = getExactlyOneTensor(inputs);\n            const inputShape = input.shape;\n            if (this.dataFormat === 'channelsFirst') {\n                input = tfc.transpose(input, [0, 2, 3, 1]);\n                const height = this.size[0] * inputShape[2];\n                const width = this.size[1] * inputShape[3];\n                const resized = this.interpolation === 'nearest' ?\n                    tfc.image.resizeNearestNeighbor(input, [height, width]) :\n                    tfc.image.resizeBilinear(input, [height, width]);\n                return tfc.transpose(resized, [0, 3, 1, 2]);\n            }\n            else {\n                const height = this.size[0] * inputShape[1];\n                const width = this.size[1] * inputShape[2];\n                return this.interpolation === 'nearest' ?\n                    tfc.image.resizeNearestNeighbor(input, [height, width]) :\n                    tfc.image.resizeBilinear(input, [height, width]);\n            }\n        });\n    }\n    getConfig() {\n        const config = {\n            size: this.size,\n            dataFormat: this.dataFormat,\n            interpolation: this.interpolation\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nUpSampling2D.className = 'UpSampling2D';\nserialization.registerClass(UpSampling2D);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udm9sdXRpb25hbC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvY29udm9sdXRpb25hbC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQVEsYUFBYSxFQUE0RCxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUUzSCxPQUFPLEVBQWEsYUFBYSxFQUFFLG1CQUFtQixFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDOUUsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQ2xELE9BQU8sS0FBSyxDQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDN0MsT0FBTyxFQUFDLGVBQWUsRUFBRSx3QkFBd0IsRUFBRSxnQkFBZ0IsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUN0RixPQUFPLEVBQW1DLGFBQWEsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3BHLE9BQU8sRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFZLE1BQU0sb0JBQW9CLENBQUM7QUFDL0QsT0FBTyxFQUFDLG1CQUFtQixFQUFFLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUMxRCxPQUFPLEVBQUMsY0FBYyxFQUFzQyxvQkFBb0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBR3pHLE9BQU8sRUFBQyxjQUFjLEVBQXNDLG9CQUFvQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFekcsT0FBTyxFQUFDLGdCQUFnQixFQUFFLFlBQVksRUFBRSxjQUFjLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNuRixPQUFPLEtBQUssYUFBYSxNQUFNLHdCQUF3QixDQUFDO0FBQ3hELE9BQU8sRUFBQyxrQkFBa0IsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLHNCQUFzQixD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QUFDLEtBQUssQ0FBQyxjQUFjLENBQUMsS0FBSyxFQUFFLENBQUMsTUFBTSxFQUFFLEtBQUssQ0FBQyxDQUFDLENBQUM7YUFDdEQ7UUFDSCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxTQUFTO1FBQ1AsTUFBTSxNQUFNLEdBQUc7WUFDWCxJQUFJLEVBQUUsSUFBSSxDQUFDLElBQUk7WUFDZixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVU7WUFDM0IsYUFBYSxFQUFFLElBQUksQ0FBQyxhQUFhO1NBQ3BDLENBQUM7UUFDRixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDckMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDbEMsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7QUFsRUQsa0JBQWtCO0FBQ1gsc0JBQVMsR0FBRyxjQUFjLENBQUM7QUFtRXBDLGFBQWEsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIFRlbnNvckZsb3cuanMgTGF5ZXJzOiBDb252b2x1dGlvbmFsIExheWVyc1xuICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtmdXNlZCwgc2VyaWFsaXphdGlvbiwgVGVuc29yLCBUZW5zb3IxRCwgVGVuc29yMkQsIFRlbnNvcjNELCBUZW5zb3I0RCwgVGVuc29yNUQsIHRpZHl9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7QWN0aXZhdGlvbiwgZ2V0QWN0aXZhdGlvbiwgc2VyaWFsaXplQWN0aXZhdGlvbn0gZnJvbSAnLi4vYWN0aXZhdGlvbnMnO1xuaW1wb3J0IHtpbWFnZURhdGFGb3JtYXR9IGZyb20gJy4uL2JhY2tlbmQvY29tbW9uJztcbmltcG9ydCAqIGFzIEsgZnJvbSAnLi4vYmFja2VuZC90ZmpzX2JhY2tlbmQnO1xuaW1wb3J0IHtjaGVja0RhdGFGb3JtYXQsIGNoZWNrSW50ZXJwb2xhdGlvbkZvcm1hdCwgY2hlY2tQYWRkaW5nTW9kZX0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7Q29uc3RyYWludCwgQ29uc3RyYWludElkZW50aWZpZXIsIGdldENvbnN0cmFpbnQsIHNlcmlhbGl6ZUNvbnN0cmFpbnR9IGZyb20gJy4uL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7SW5wdXRTcGVjLCBMYXllciwgTGF5ZXJBcmdzfSBmcm9tICcuLi9lbmdpbmUvdG9wb2xvZ3knO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtnZXRJbml0aWFsaXplciwgSW5pdGlhbGl6ZXIsIEluaXRpYWxpemVySWRlbnRpZmllciwgc2VyaWFsaXplSW5pdGlhbGl6ZXJ9IGZyb20gJy4uL2luaXRpYWxpemVycyc7XG5pbXBvcnQge0FjdGl2YXRpb25JZGVudGlmaWVyfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvYWN0aXZhdGlvbl9jb25maWcnO1xuaW1wb3J0IHtEYXRhRm9ybWF0LCBJbnRlcnBvbGF0aW9uRm9ybWF0LCBQYWRkaW5nTW9kZSwgU2hhcGV9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuaW1wb3J0IHtnZXRSZWd1bGFyaXplciwgUmVndWxhcml6ZXIsIFJlZ3VsYXJpemVySWRlbnRpZmllciwgc2VyaWFsaXplUmVndWxhcml6ZXJ9IGZyb20gJy4uL3JlZ3VsYXJpemVycyc7XG5pbXBvcnQge0t3YXJnc30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtjb252T3V0cHV0TGVuZ3RoLCBkZWNvbnZMZW5ndGgsIG5vcm1hbGl6ZUFycmF5fSBmcm9tICcuLi91dGlscy9jb252X3V0aWxzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQge2dldEV4YWN0bHlPbmVTaGFwZSwgZ2V0RXhhY3RseU9uZVRlbnNvcn0gZnJvbSAnLi4vdXRpbHMvdHlwZXNfdXRpbHMnO1xuaW1wb3J0IHtMYXllclZhcmlhYmxlfSBmcm9tICcuLi92YXJpYWJsZXMnO1xuXG4vKipcbiAqIFRyYW5zcG9zZSBhbmQgY2FzdCB0aGUgaW5wdXQgYmVmb3JlIHRoZSBjb252MmQuXG4gKiBAcGFyYW0geCBJbnB1dCBpbWFnZSB0ZW5zb3IuXG4gKiBAcGFyYW0gZGF0YUZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2Vzc0NvbnYyRElucHV0KFxuICAgIHg6IFRlbnNvciwgZGF0YUZvcm1hdDogRGF0YUZvcm1hdCk6IFRlbnNvciB7XG4gIC8vIFRPRE8oY2Fpcyk6IENhc3QgdHlwZSB0byBmbG9hdDMyIGlmIG5vdC5cbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICByZXR1cm4gdGZjLnRyYW5zcG9zZSh4LCBbMCwgMiwgMywgMV0pOyAgLy8gTkNIVyAtPiBOSFdDLlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIFRyYW5zcG9zZSBhbmQgY2FzdCB0aGUgaW5wdXQgYmVmb3JlIHRoZSBjb252M2QuXG4gKiBAcGFyYW0geCBJbnB1dCBpbWFnZSB0ZW5zb3IuXG4gKiBAcGFyYW0gZGF0YUZvcm1hdFxuICovXG5leHBvcnQgZnVuY3Rpb24gcHJlcHJvY2Vzc0NvbnYzRElucHV0KFxuICAgIHg6IFRlbnNvciwgZGF0YUZvcm1hdDogRGF0YUZvcm1hdCk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgcmV0dXJuIHRmYy50cmFuc3Bvc2UoeCwgWzAsIDIsIDMsIDQsIDFdKTsgIC8vIE5DREhXIC0+IE5ESFdDLlxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4geDtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIDFELWNvbnZvbHV0aW9uIHdpdGggYmlhcyBhZGRlZC5cbiAqXG4gKiBQb3J0aW5nIE5vdGU6IFRoaXMgZnVuY3Rpb24gZG9lcyBub3QgZXhpc3QgaW4gdGhlIFB5dGhvbiBLZXJhcyBiYWNrZW5kLlxuICogICBJdCBpcyBleGFjdGx5IHRoZSBzYW1lIGFzIGBjb252MmRgLCBleGNlcHQgdGhlIGFkZGVkIGBiaWFzYC5cbiAqXG4gKiBAcGFyYW0geCBJbnB1dCB0ZW5zb3IsIHJhbmstMywgb2Ygc2hhcGUgYFtiYXRjaFNpemUsIHdpZHRoLCBpbkNoYW5uZWxzXWAuXG4gKiBAcGFyYW0ga2VybmVsIEtlcm5lbCwgcmFuay0zLCBvZiBzaGFwZSBgW2ZpbHRlcldpZHRoLCBpbkRlcHRoLCBvdXREZXB0aF1gLlxuICogQHBhcmFtIGJpYXMgQmlhcywgcmFuay0zLCBvZiBzaGFwZSBgW291dERlcHRoXWAuXG4gKiBAcGFyYW0gc3RyaWRlc1xuICogQHBhcmFtIHBhZGRpbmcgUGFkZGluZyBtb2RlLlxuICogQHBhcmFtIGRhdGFGb3JtYXQgRGF0YSBmb3JtYXQuXG4gKiBAcGFyYW0gZGlsYXRpb25SYXRlXG4gKiBAcmV0dXJucyBUaGUgcmVzdWx0IG9mIHRoZSAxRCBjb252b2x1dGlvbi5cbiAqIEB0aHJvd3MgVmFsdWVFcnJvciwgaWYgYHhgLCBga2VybmVsYCBvciBgYmlhc2AgaXMgbm90IG9mIHRoZSBjb3JyZWN0IHJhbmsuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252MWRXaXRoQmlhcyhcbiAgICB4OiBUZW5zb3IsIGtlcm5lbDogVGVuc29yLCBiaWFzOiBUZW5zb3IsIHN0cmlkZXMgPSAxLCBwYWRkaW5nID0gJ3ZhbGlkJyxcbiAgICBkYXRhRm9ybWF0PzogRGF0YUZvcm1hdCwgZGlsYXRpb25SYXRlID0gMSk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICBkYXRhRm9ybWF0ID0gaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgfVxuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICAvLyBDaGVjayB0aGUgcmFua3Mgb2YgeCwga2VybmVsIGFuZCBiaWFzLlxuICAgIGlmICh4LnNoYXBlLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYFRoZSBpbnB1dCBvZiBhIGNvbnYxZFdpdGhCaWFzIG9wZXJhdGlvbiBzaG91bGQgYmUgMywgYnV0IGlzIGAgK1xuICAgICAgICAgIGAke3guc2hhcGUubGVuZ3RofSBpbnN0ZWFkLmApO1xuICAgIH1cbiAgICBpZiAoa2VybmVsLnNoYXBlLmxlbmd0aCAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYFRoZSBrZXJuZWwgZm9yIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAzLCBidXQgaXMgYCArXG4gICAgICAgICAgYCR7a2VybmVsLnNoYXBlLmxlbmd0aH0gaW5zdGVhZGApO1xuICAgIH1cbiAgICBpZiAoYmlhcyAhPSBudWxsICYmIGJpYXMuc2hhcGUubGVuZ3RoICE9PSAxKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgVGhlIGJpYXMgZm9yIGEgY29udjFkV2l0aEJpYXMgb3BlcmF0aW9uIHNob3VsZCBiZSAxLCBidXQgaXMgYCArXG4gICAgICAgICAgYCR7a2VybmVsLnNoYXBlLmxlbmd0aH0gaW5zdGVhZGApO1xuICAgIH1cbiAgICAvLyBUT0RPKGNhaXMpOiBTdXBwb3J0IENBVVNBTCBwYWRkaW5nIG1vZGUuXG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgeCA9IHRmYy50cmFuc3Bvc2UoeCwgWzAsIDIsIDFdKTsgIC8vIE5DVyAtPiBOV0MuXG4gICAgfVxuICAgIGlmIChwYWRkaW5nID09PSAnY2F1c2FsJykge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ1RoZSBzdXBwb3J0IGZvciBDQVVTQUwgcGFkZGluZyBtb2RlIGluIGNvbnYxZFdpdGhCaWFzIGlzIG5vdCAnICtcbiAgICAgICAgICAnaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH1cbiAgICBsZXQgeTogVGVuc29yID0gdGZjLmNvbnYxZChcbiAgICAgICAgeCBhcyBUZW5zb3IyRCB8IFRlbnNvcjNELCBrZXJuZWwgYXMgVGVuc29yM0QsIHN0cmlkZXMsXG4gICAgICAgIHBhZGRpbmcgPT09ICdzYW1lJyA/ICdzYW1lJyA6ICd2YWxpZCcsICdOV0MnLCBkaWxhdGlvblJhdGUpO1xuICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgIHkgPSBLLmJpYXNBZGQoeSwgYmlhcyk7XG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9KTtcbn1cblxuLyoqXG4gKiAxRC1jb252b2x1dGlvbi5cbiAqXG4gKiBAcGFyYW0geCBJbnB1dCB0ZW5zb3IsIHJhbmstMywgb2Ygc2hhcGUgYFtiYXRjaFNpemUsIHdpZHRoLCBpbkNoYW5uZWxzXWAuXG4gKiBAcGFyYW0ga2VybmVsIEtlcm5lbCwgcmFuay0zLCBvZiBzaGFwZSBgW2ZpbHRlcldpZHRoLCBpbkRlcHRoLCBvdXREZXB0aF1gLnNcbiAqIEBwYXJhbSBzdHJpZGVzXG4gKiBAcGFyYW0gcGFkZGluZyBQYWRkaW5nIG1vZGUuXG4gKiBAcGFyYW0gZGF0YUZvcm1hdCBEYXRhIGZvcm1hdC5cbiAqIEBwYXJhbSBkaWxhdGlvblJhdGVcbiAqIEByZXR1cm5zIFRoZSByZXN1bHQgb2YgdGhlIDFEIGNvbnZvbHV0aW9uLlxuICogQHRocm93cyBWYWx1ZUVycm9yLCBpZiBgeGAsIGBrZXJuZWxgIG9yIGBiaWFzYCBpcyBub3Qgb2YgdGhlIGNvcnJlY3QgcmFuay5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnYxZChcbiAgICB4OiBUZW5zb3IsIGtlcm5lbDogVGVuc29yLCBzdHJpZGVzID0gMSwgcGFkZGluZyA9ICd2YWxpZCcsXG4gICAgZGF0YUZvcm1hdD86IERhdGFGb3JtYXQsIGRpbGF0aW9uUmF0ZSA9IDEpOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgIHJldHVybiBjb252MWRXaXRoQmlhcyhcbiAgICAgICAgeCwga2VybmVsLCBudWxsLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCBkaWxhdGlvblJhdGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiAyRCBDb252b2x1dGlvblxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSBrZXJuZWwga2VybmVsIG9mIHRoZSBjb252b2x1dGlvbi5cbiAqIEBwYXJhbSBzdHJpZGVzIHN0cmlkZXMgYXJyYXkuXG4gKiBAcGFyYW0gcGFkZGluZyBwYWRkaW5nIG1vZGUuIERlZmF1bHQgdG8gJ3ZhbGlkJy5cbiAqIEBwYXJhbSBkYXRhRm9ybWF0IGRhdGEgZm9ybWF0LiBEZWZhdWx0cyB0byAnY2hhbm5lbHNMYXN0Jy5cbiAqIEBwYXJhbSBkaWxhdGlvblJhdGUgZGlsYXRpb24gcmF0ZSBhcnJheS5cbiAqIEByZXR1cm5zIFJlc3VsdCBvZiB0aGUgMkQgcG9vbGluZy5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGNvbnYyZChcbiAgICB4OiBUZW5zb3IsIGtlcm5lbDogVGVuc29yLCBzdHJpZGVzID0gWzEsIDFdLCBwYWRkaW5nID0gJ3ZhbGlkJyxcbiAgICBkYXRhRm9ybWF0PzogRGF0YUZvcm1hdCwgZGlsYXRpb25SYXRlPzogW251bWJlciwgbnVtYmVyXSk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBjaGVja0RhdGFGb3JtYXQoZGF0YUZvcm1hdCk7XG4gICAgcmV0dXJuIGNvbnYyZFdpdGhCaWFzQWN0aXZhdGlvbihcbiAgICAgICAgeCwga2VybmVsLCBudWxsLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCBkaWxhdGlvblJhdGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiAyRCBDb252b2x1dGlvbiB3aXRoIGFuIGFkZGVkIGJpYXMgYW5kIG9wdGlvbmFsIGFjdGl2YXRpb24uXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0IGluIHRoZSBQeXRob24gS2VyYXMgQmFja2VuZC4gVGhpcyBmdW5jdGlvblxuICogaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBgY29udjJkYCwgZXhjZXB0IHRoZSBhZGRlZCBgYmlhc2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252MmRXaXRoQmlhc0FjdGl2YXRpb24oXG4gICAgeDogVGVuc29yLCBrZXJuZWw6IFRlbnNvciwgYmlhczogVGVuc29yLCBzdHJpZGVzID0gWzEsIDFdLFxuICAgIHBhZGRpbmcgPSAndmFsaWQnLCBkYXRhRm9ybWF0PzogRGF0YUZvcm1hdCwgZGlsYXRpb25SYXRlPzogW251bWJlciwgbnVtYmVyXSxcbiAgICBhY3RpdmF0aW9uOiBmdXNlZC5BY3RpdmF0aW9uID0gbnVsbCk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICBkYXRhRm9ybWF0ID0gaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgfVxuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBpZiAoeC5yYW5rICE9PSAzICYmIHgucmFuayAhPT0gNCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYGNvbnYyZFdpdGhCaWFzQWN0aXZhdGlvbiBleHBlY3RzIGlucHV0IHRvIGJlIG9mIHJhbmsgMyBvciA0LCBgICtcbiAgICAgICAgICBgYnV0IHJlY2VpdmVkICR7eC5yYW5rfS5gKTtcbiAgICB9XG4gICAgaWYgKGtlcm5lbC5yYW5rICE9PSAzICYmIGtlcm5lbC5yYW5rICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgY29udjJkV2l0aEJpYXNBY3RpdmF0aW9uIGV4cGVjdHMga2VybmVsIHRvIGJlIG9mIHJhbmsgMyBvciA0LCBgICtcbiAgICAgICAgICBgYnV0IHJlY2VpdmVkICR7eC5yYW5rfS5gKTtcbiAgICB9XG4gICAgbGV0IHkgPSBwcmVwcm9jZXNzQ29udjJESW5wdXQoeCwgZGF0YUZvcm1hdCk7XG4gICAgaWYgKHBhZGRpbmcgPT09ICdjYXVzYWwnKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAnVGhlIHN1cHBvcnQgZm9yIENBVVNBTCBwYWRkaW5nIG1vZGUgaW4gY29udjFkV2l0aEJpYXMgaXMgbm90ICcgK1xuICAgICAgICAgICdpbXBsZW1lbnRlZCB5ZXQuJyk7XG4gICAgfVxuICAgIHkgPSB0ZmMuZnVzZWQuY29udjJkKHtcbiAgICAgIHg6IHkgYXMgVGVuc29yM0QgfCBUZW5zb3I0RCxcbiAgICAgIGZpbHRlcjoga2VybmVsIGFzIFRlbnNvcjRELFxuICAgICAgc3RyaWRlczogc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgcGFkOiBwYWRkaW5nID09PSAnc2FtZScgPyAnc2FtZScgOiAndmFsaWQnLFxuICAgICAgZGlsYXRpb25zOiBkaWxhdGlvblJhdGUsXG4gICAgICBkYXRhRm9ybWF0OiAnTkhXQycsXG4gICAgICBiaWFzLFxuICAgICAgYWN0aXZhdGlvblxuICAgIH0pO1xuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgIHkgPSB0ZmMudHJhbnNwb3NlKHksIFswLCAzLCAxLCAyXSk7XG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9KTtcbn1cblxuLyoqXG4gKiAzRCBDb252b2x1dGlvbi5cbiAqIEBwYXJhbSB4XG4gKiBAcGFyYW0ga2VybmVsIGtlcm5lbCBvZiB0aGUgY29udm9sdXRpb24uXG4gKiBAcGFyYW0gc3RyaWRlcyBzdHJpZGVzIGFycmF5LlxuICogQHBhcmFtIHBhZGRpbmcgcGFkZGluZyBtb2RlLiBEZWZhdWx0IHRvICd2YWxpZCcuXG4gKiBAcGFyYW0gZGF0YUZvcm1hdCBkYXRhIGZvcm1hdC4gRGVmYXVsdHMgdG8gJ2NoYW5uZWxzTGFzdCcuXG4gKiBAcGFyYW0gZGlsYXRpb25SYXRlIGRpbGF0aW9uIHJhdGUgYXJyYXkuXG4gKiBAcmV0dXJucyBSZXN1bHQgb2YgdGhlIDNEIGNvbnZvbHV0aW9uLlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29udjNkKFxuICAgIHg6IFRlbnNvciwga2VybmVsOiBUZW5zb3IsIHN0cmlkZXMgPSBbMSwgMSwgMV0sIHBhZGRpbmcgPSAndmFsaWQnLFxuICAgIGRhdGFGb3JtYXQ/OiBEYXRhRm9ybWF0LCBkaWxhdGlvblJhdGU/OiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0pOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgIHJldHVybiBjb252M2RXaXRoQmlhcyhcbiAgICAgICAgeCwga2VybmVsLCBudWxsLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCBkaWxhdGlvblJhdGUpO1xuICB9KTtcbn1cblxuLyoqXG4gKiAzRCBDb252b2x1dGlvbiB3aXRoIGFuIGFkZGVkIGJpYXMuXG4gKiBOb3RlOiBUaGlzIGZ1bmN0aW9uIGRvZXMgbm90IGV4aXN0IGluIHRoZSBQeXRob24gS2VyYXMgQmFja2VuZC4gVGhpcyBmdW5jdGlvblxuICogaXMgZXhhY3RseSB0aGUgc2FtZSBhcyBgY29udjNkYCwgZXhjZXB0IHRoZSBhZGRlZCBgYmlhc2AuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBjb252M2RXaXRoQmlhcyhcbiAgICB4OiBUZW5zb3IsIGtlcm5lbDogVGVuc29yLCBiaWFzOiBUZW5zb3IsIHN0cmlkZXMgPSBbMSwgMSwgMV0sXG4gICAgcGFkZGluZyA9ICd2YWxpZCcsIGRhdGFGb3JtYXQ/OiBEYXRhRm9ybWF0LFxuICAgIGRpbGF0aW9uUmF0ZT86IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICBkYXRhRm9ybWF0ID0gaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgfVxuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBpZiAoeC5yYW5rICE9PSA0ICYmIHgucmFuayAhPT0gNSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYGNvbnYzZFdpdGhCaWFzIGV4cGVjdHMgaW5wdXQgdG8gYmUgb2YgcmFuayA0IG9yIDUsIGJ1dCByZWNlaXZlZCBgICtcbiAgICAgICAgICBgJHt4LnJhbmt9LmApO1xuICAgIH1cbiAgICBpZiAoa2VybmVsLnJhbmsgIT09IDQgJiYga2VybmVsLnJhbmsgIT09IDUpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBjb252M2RXaXRoQmlhcyBleHBlY3RzIGtlcm5lbCB0byBiZSBvZiByYW5rIDQgb3IgNSwgYnV0IHJlY2VpdmVkIGAgK1xuICAgICAgICAgIGAke3gucmFua30uYCk7XG4gICAgfVxuICAgIGxldCB5ID0gcHJlcHJvY2Vzc0NvbnYzRElucHV0KHgsIGRhdGFGb3JtYXQpO1xuICAgIGlmIChwYWRkaW5nID09PSAnY2F1c2FsJykge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ1RoZSBzdXBwb3J0IGZvciBDQVVTQUwgcGFkZGluZyBtb2RlIGluIGNvbnYzZFdpdGhCaWFzIGlzIG5vdCAnICtcbiAgICAgICAgICAnaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgIH1cbiAgICB5ID0gdGZjLmNvbnYzZChcbiAgICAgICAgeSBhcyBUZW5zb3I0RCB8IHRmYy5UZW5zb3I8dGZjLlJhbmsuUjU+LFxuICAgICAgICBrZXJuZWwgYXMgdGZjLlRlbnNvcjx0ZmMuUmFuay5SNT4sIHN0cmlkZXMgYXMgW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICBwYWRkaW5nID09PSAnc2FtZScgPyAnc2FtZScgOiAndmFsaWQnLCAnTkRIV0MnLCBkaWxhdGlvblJhdGUpO1xuICAgIGlmIChiaWFzICE9IG51bGwpIHtcbiAgICAgIHkgPSBLLmJpYXNBZGQoeSwgYmlhcyBhcyBUZW5zb3IxRCk7XG4gICAgfVxuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgIHkgPSB0ZmMudHJhbnNwb3NlKHksIFswLCA0LCAxLCAyLCAzXSk7XG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9KTtcbn1cblxuLyoqXG4gKiBCYXNlIExheWVyQ29uZmlnIGZvciBkZXB0aHdpc2UgYW5kIG5vbi1kZXB0aHdpc2UgY29udm9sdXRpb25hbCBsYXllcnMuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBCYXNlQ29udkxheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBUaGUgZGltZW5zaW9ucyBvZiB0aGUgY29udm9sdXRpb24gd2luZG93LiBJZiBrZXJuZWxTaXplIGlzIGEgbnVtYmVyLCB0aGVcbiAgICogY29udm9sdXRpb25hbCB3aW5kb3cgd2lsbCBiZSBzcXVhcmUuXG4gICAqL1xuICBrZXJuZWxTaXplOiBudW1iZXJ8bnVtYmVyW107XG5cbiAgLyoqXG4gICAqIFRoZSBzdHJpZGVzIG9mIHRoZSBjb252b2x1dGlvbiBpbiBlYWNoIGRpbWVuc2lvbi4gSWYgc3RyaWRlcyBpcyBhIG51bWJlcixcbiAgICogc3RyaWRlcyBpbiBib3RoIGRpbWVuc2lvbnMgYXJlIGVxdWFsLlxuICAgKlxuICAgKiBTcGVjaWZ5aW5nIGFueSBzdHJpZGUgdmFsdWUgIT0gMSBpcyBpbmNvbXBhdGlibGUgd2l0aCBzcGVjaWZ5aW5nIGFueVxuICAgKiBgZGlsYXRpb25SYXRlYCB2YWx1ZSAhPSAxLlxuICAgKi9cbiAgc3RyaWRlcz86IG51bWJlcnxudW1iZXJbXTtcblxuICAvKipcbiAgICogUGFkZGluZyBtb2RlLlxuICAgKi9cbiAgcGFkZGluZz86IFBhZGRpbmdNb2RlO1xuXG4gIC8qKlxuICAgKiBGb3JtYXQgb2YgdGhlIGRhdGEsIHdoaWNoIGRldGVybWluZXMgdGhlIG9yZGVyaW5nIG9mIHRoZSBkaW1lbnNpb25zIGluXG4gICAqIHRoZSBpbnB1dHMuXG4gICAqXG4gICAqIGBjaGFubmVsc19sYXN0YCBjb3JyZXNwb25kcyB0byBpbnB1dHMgd2l0aCBzaGFwZVxuICAgKiAgIGAoYmF0Y2gsIC4uLiwgY2hhbm5lbHMpYFxuICAgKlxuICAgKiAgYGNoYW5uZWxzX2ZpcnN0YCBjb3JyZXNwb25kcyB0byBpbnB1dHMgd2l0aCBzaGFwZSBgKGJhdGNoLCBjaGFubmVscyxcbiAgICogLi4uKWAuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGBjaGFubmVsc19sYXN0YC5cbiAgICovXG4gIGRhdGFGb3JtYXQ/OiBEYXRhRm9ybWF0O1xuXG4gIC8qKlxuICAgKiBUaGUgZGlsYXRpb24gcmF0ZSB0byB1c2UgZm9yIHRoZSBkaWxhdGVkIGNvbnZvbHV0aW9uIGluIGVhY2ggZGltZW5zaW9uLlxuICAgKiBTaG91bGQgYmUgYW4gaW50ZWdlciBvciBhcnJheSBvZiB0d28gb3IgdGhyZWUgaW50ZWdlcnMuXG4gICAqXG4gICAqIEN1cnJlbnRseSwgc3BlY2lmeWluZyBhbnkgYGRpbGF0aW9uUmF0ZWAgdmFsdWUgIT0gMSBpcyBpbmNvbXBhdGlibGUgd2l0aFxuICAgKiBzcGVjaWZ5aW5nIGFueSBgc3RyaWRlc2AgdmFsdWUgIT0gMS5cbiAgICovXG4gIGRpbGF0aW9uUmF0ZT86IG51bWJlcnxbbnVtYmVyXXxbbnVtYmVyLCBudW1iZXJdfFtudW1iZXIsIG51bWJlciwgbnVtYmVyXTtcblxuICAvKipcbiAgICogQWN0aXZhdGlvbiBmdW5jdGlvbiBvZiB0aGUgbGF5ZXIuXG4gICAqXG4gICAqIElmIHlvdSBkb24ndCBzcGVjaWZ5IHRoZSBhY3RpdmF0aW9uLCBub25lIGlzIGFwcGxpZWQuXG4gICAqL1xuICBhY3RpdmF0aW9uPzogQWN0aXZhdGlvbklkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdGhlIGxheWVyIHVzZXMgYSBiaWFzIHZlY3Rvci4gRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgdXNlQmlhcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIGZvciB0aGUgY29udm9sdXRpb25hbCBrZXJuZWwgd2VpZ2h0cyBtYXRyaXguXG4gICAqL1xuICBrZXJuZWxJbml0aWFsaXplcj86IEluaXRpYWxpemVySWRlbnRpZmllcnxJbml0aWFsaXplcjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgZm9yIHRoZSBiaWFzIHZlY3Rvci5cbiAgICovXG4gIGJpYXNJbml0aWFsaXplcj86IEluaXRpYWxpemVySWRlbnRpZmllcnxJbml0aWFsaXplcjtcblxuICAvKipcbiAgICogQ29uc3RyYWludCBmb3IgdGhlIGNvbnZvbHV0aW9uYWwga2VybmVsIHdlaWdodHMuXG4gICAqL1xuICBrZXJuZWxDb25zdHJhaW50PzogQ29uc3RyYWludElkZW50aWZpZXJ8Q29uc3RyYWludDtcblxuICAvKipcbiAgICogQ29uc3RyYWludCBmb3IgdGhlIGJpYXMgdmVjdG9yLlxuICAgKi9cbiAgYmlhc0NvbnN0cmFpbnQ/OiBDb25zdHJhaW50SWRlbnRpZmllcnxDb25zdHJhaW50O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBrZXJuZWwgd2VpZ2h0cyBtYXRyaXguXG4gICAqL1xuICBrZXJuZWxSZWd1bGFyaXplcj86IFJlZ3VsYXJpemVySWRlbnRpZmllcnxSZWd1bGFyaXplcjtcblxuICAvKipcbiAgICogUmVndWxhcml6ZXIgZnVuY3Rpb24gYXBwbGllZCB0byB0aGUgYmlhcyB2ZWN0b3IuXG4gICAqL1xuICBiaWFzUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXJ8UmVndWxhcml6ZXI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXJpemVyIGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGFjdGl2YXRpb24uXG4gICAqL1xuICBhY3Rpdml0eVJlZ3VsYXJpemVyPzogUmVndWxhcml6ZXJJZGVudGlmaWVyfFJlZ3VsYXJpemVyO1xufVxuXG4vKipcbiAqIExheWVyQ29uZmlnIGZvciBub24tZGVwdGh3aXNlIGNvbnZvbHV0aW9uYWwgbGF5ZXJzLlxuICogQXBwbGllcyB0byBub24tZGVwdGh3aXNlIGNvbnZvbHV0aW9uIG9mIGFsbCByYW5rcyAoZS5nLCBDb252MUQsIENvbnYyRCxcbiAqIENvbnYzRCkuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBDb252TGF5ZXJBcmdzIGV4dGVuZHMgQmFzZUNvbnZMYXllckFyZ3Mge1xuICAvKipcbiAgICogVGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBvdXRwdXQgc3BhY2UgKGkuZS4gdGhlIG51bWJlciBvZiBmaWx0ZXJzIGluIHRoZVxuICAgKiBjb252b2x1dGlvbikuXG4gICAqL1xuICBmaWx0ZXJzOiBudW1iZXI7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY29udm9sdXRpb24gbGF5ZXIuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBCYXNlQ29udiBleHRlbmRzIExheWVyIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHJhbms6IG51bWJlcjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGtlcm5lbFNpemU6IG51bWJlcltdO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc3RyaWRlczogbnVtYmVyW107XG4gIHByb3RlY3RlZCByZWFkb25seSBwYWRkaW5nOiBQYWRkaW5nTW9kZTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRhdGFGb3JtYXQ6IERhdGFGb3JtYXQ7XG4gIHByb3RlY3RlZCByZWFkb25seSBhY3RpdmF0aW9uOiBBY3RpdmF0aW9uO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgdXNlQmlhczogYm9vbGVhbjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRpbGF0aW9uUmF0ZTogbnVtYmVyW107XG5cbiAgLy8gQmlhcy1yZWxhdGVkIG1lbWJlcnMgYXJlIGhlcmUgYmVjYXVzZSBhbGwgY29udm9sdXRpb24gc3ViY2xhc3NlcyB1c2UgdGhlXG4gIC8vIHNhbWUgY29uZmlndXJhdGlvbiBwYXJtZXRlcnMgdG8gY29udHJvbCBiaWFzLiAgS2VybmVsLXJlbGF0ZWQgbWVtYmVyc1xuICAvLyBhcmUgaW4gc3ViY2xhc3MgYENvbnZgIGJlY2F1c2Ugc29tZSBzdWJjbGFzc2VzIHVzZSBkaWZmZXJlbnQgcGFyYW1ldGVycyB0b1xuICAvLyBjb250cm9sIGtlcm5lbCBwcm9wZXJ0aWVzLCBmb3IgaW5zdGFuY2UsIGBEZXB0aHdpc2VDb252MkRgIHVzZXNcbiAgLy8gYGRlcHRod2lzZUluaXRpYWxpemVyYCBpbnN0ZWFkIG9mIGBrZXJuZWxJbml0aWFsaXplcmAuXG4gIHByb3RlY3RlZCByZWFkb25seSBiaWFzSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGJpYXNDb25zdHJhaW50PzogQ29uc3RyYWludDtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGJpYXNSZWd1bGFyaXplcj86IFJlZ3VsYXJpemVyO1xuXG4gIHByb3RlY3RlZCBiaWFzOiBMYXllclZhcmlhYmxlID0gbnVsbDtcblxuICByZWFkb25seSBERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUjogSW5pdGlhbGl6ZXJJZGVudGlmaWVyID0gJ2dsb3JvdE5vcm1hbCc7XG4gIHJlYWRvbmx5IERFRkFVTFRfQklBU19JTklUSUFMSVpFUjogSW5pdGlhbGl6ZXJJZGVudGlmaWVyID0gJ3plcm9zJztcblxuICBjb25zdHJ1Y3RvcihyYW5rOiBudW1iZXIsIGFyZ3M6IEJhc2VDb252TGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyBhcyBMYXllckFyZ3MpO1xuICAgIEJhc2VDb252LnZlcmlmeUFyZ3MoYXJncyk7XG4gICAgdGhpcy5yYW5rID0gcmFuaztcbiAgICBnZW5lcmljX3V0aWxzLmFzc2VydFBvc2l0aXZlSW50ZWdlcih0aGlzLnJhbmssICdyYW5rJyk7XG4gICAgaWYgKHRoaXMucmFuayAhPT0gMSAmJiB0aGlzLnJhbmsgIT09IDIgJiYgdGhpcy5yYW5rICE9PSAzKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICBgQ29udm9sdXRpb24gbGF5ZXIgZm9yIHJhbmsgb3RoZXIgdGhhbiAxLCAyLCBvciAzICgke1xuICAgICAgICAgICAgICB0aGlzLnJhbmt9KSBpcyBgICtcbiAgICAgICAgICBgbm90IGltcGxlbWVudGVkIHlldC5gKTtcbiAgICB9XG4gICAgdGhpcy5rZXJuZWxTaXplID0gbm9ybWFsaXplQXJyYXkoYXJncy5rZXJuZWxTaXplLCByYW5rLCAna2VybmVsU2l6ZScpO1xuICAgIHRoaXMuc3RyaWRlcyA9IG5vcm1hbGl6ZUFycmF5KFxuICAgICAgICBhcmdzLnN0cmlkZXMgPT0gbnVsbCA/IDEgOiBhcmdzLnN0cmlkZXMsIHJhbmssICdzdHJpZGVzJyk7XG4gICAgdGhpcy5wYWRkaW5nID0gYXJncy5wYWRkaW5nID09IG51bGwgPyAndmFsaWQnIDogYXJncy5wYWRkaW5nO1xuICAgIGNoZWNrUGFkZGluZ01vZGUodGhpcy5wYWRkaW5nKTtcbiAgICB0aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICBhcmdzLmRhdGFGb3JtYXQgPT0gbnVsbCA/ICdjaGFubmVsc0xhc3QnIDogYXJncy5kYXRhRm9ybWF0O1xuICAgIGNoZWNrRGF0YUZvcm1hdCh0aGlzLmRhdGFGb3JtYXQpO1xuICAgIHRoaXMuYWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb24oYXJncy5hY3RpdmF0aW9uKTtcbiAgICB0aGlzLnVzZUJpYXMgPSBhcmdzLnVzZUJpYXMgPT0gbnVsbCA/IHRydWUgOiBhcmdzLnVzZUJpYXM7XG4gICAgdGhpcy5iaWFzSW5pdGlhbGl6ZXIgPVxuICAgICAgICBnZXRJbml0aWFsaXplcihhcmdzLmJpYXNJbml0aWFsaXplciB8fCB0aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUik7XG4gICAgdGhpcy5iaWFzQ29uc3RyYWludCA9IGdldENvbnN0cmFpbnQoYXJncy5iaWFzQ29uc3RyYWludCk7XG4gICAgdGhpcy5iaWFzUmVndWxhcml6ZXIgPSBnZXRSZWd1bGFyaXplcihhcmdzLmJpYXNSZWd1bGFyaXplcik7XG4gICAgdGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyID0gZ2V0UmVndWxhcml6ZXIoYXJncy5hY3Rpdml0eVJlZ3VsYXJpemVyKTtcbiAgICB0aGlzLmRpbGF0aW9uUmF0ZSA9IG5vcm1hbGl6ZUFycmF5KFxuICAgICAgICBhcmdzLmRpbGF0aW9uUmF0ZSA9PSBudWxsID8gMSA6IGFyZ3MuZGlsYXRpb25SYXRlLCByYW5rLFxuICAgICAgICAnZGlsYXRpb25SYXRlJyk7XG4gICAgaWYgKHRoaXMucmFuayA9PT0gMSAmJlxuICAgICAgICAoQXJyYXkuaXNBcnJheSh0aGlzLmRpbGF0aW9uUmF0ZSkgJiYgdGhpcy5kaWxhdGlvblJhdGUubGVuZ3RoICE9PSAxKSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYGRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIGFycmF5IG9mIGEgc2luZ2xlIG51bWJlciBgICtcbiAgICAgICAgICBgZm9yIDFEIGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgYCArXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkodGhpcy5kaWxhdGlvblJhdGUpfWApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5yYW5rID09PSAyKSB7XG4gICAgICBpZiAodHlwZW9mIHRoaXMuZGlsYXRpb25SYXRlID09PSAnbnVtYmVyJykge1xuICAgICAgICB0aGlzLmRpbGF0aW9uUmF0ZSA9IFt0aGlzLmRpbGF0aW9uUmF0ZSwgdGhpcy5kaWxhdGlvblJhdGVdO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmRpbGF0aW9uUmF0ZS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgZGlsYXRpb25SYXRlIG11c3QgYmUgYSBudW1iZXIgb3IgYXJyYXkgb2YgdHdvIG51bWJlcnMgZm9yIDJEIGAgK1xuICAgICAgICAgICAgYGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRpbGF0aW9uUmF0ZSl9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0aGlzLnJhbmsgPT09IDMpIHtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5kaWxhdGlvblJhdGUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuZGlsYXRpb25SYXRlID1cbiAgICAgICAgICAgIFt0aGlzLmRpbGF0aW9uUmF0ZSwgdGhpcy5kaWxhdGlvblJhdGUsIHRoaXMuZGlsYXRpb25SYXRlXTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5kaWxhdGlvblJhdGUubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYGRpbGF0aW9uUmF0ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFycmF5IG9mIHRocmVlIG51bWJlcnMgZm9yIDNEIGAgK1xuICAgICAgICAgICAgYGNvbnZvbHV0aW9uLCBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmRpbGF0aW9uUmF0ZSl9YCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIHN0YXRpYyB2ZXJpZnlBcmdzKGFyZ3M6IEJhc2VDb252TGF5ZXJBcmdzKSB7XG4gICAgLy8gQ2hlY2sgY29uZmlnLmtlcm5lbFNpemUgdHlwZSBhbmQgc2hhcGUuXG4gICAgZ2VuZXJpY191dGlscy5hc3NlcnQoXG4gICAgICAgICdrZXJuZWxTaXplJyBpbiBhcmdzLCBgcmVxdWlyZWQga2V5ICdrZXJuZWxTaXplJyBub3QgaW4gY29uZmlnYCk7XG4gICAgaWYgKHR5cGVvZiBhcmdzLmtlcm5lbFNpemUgIT09ICdudW1iZXInICYmXG4gICAgICAgICFnZW5lcmljX3V0aWxzLmNoZWNrQXJyYXlUeXBlQW5kTGVuZ3RoKFxuICAgICAgICAgICAgYXJncy5rZXJuZWxTaXplLCAnbnVtYmVyJywgMSwgMykpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBCYXNlQ29udiBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvciBudW1iZXJbXSB3aXRoIGAgK1xuICAgICAgICAgIGBsZW5ndGggMSwgMiwgb3IgMywgYnV0IHJlY2VpdmVkICR7XG4gICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGFyZ3Mua2VybmVsU2l6ZSl9LmApO1xuICAgIH1cbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge1xuICAgICAga2VybmVsU2l6ZTogdGhpcy5rZXJuZWxTaXplLFxuICAgICAgc3RyaWRlczogdGhpcy5zdHJpZGVzLFxuICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxuICAgICAgZGF0YUZvcm1hdDogdGhpcy5kYXRhRm9ybWF0LFxuICAgICAgZGlsYXRpb25SYXRlOiB0aGlzLmRpbGF0aW9uUmF0ZSxcbiAgICAgIGFjdGl2YXRpb246IHNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxcbiAgICAgIHVzZUJpYXM6IHRoaXMudXNlQmlhcyxcbiAgICAgIGJpYXNJbml0aWFsaXplcjogc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLFxuICAgICAgYmlhc1JlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksXG4gICAgICBhY3Rpdml0eVJlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLFxuICAgICAgYmlhc0NvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludClcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuXG4vKipcbiAqIEFic3RyYWN0IG5EIGNvbnZvbHV0aW9uIGxheWVyLiAgQW5jZXN0b3Igb2YgY29udm9sdXRpb24gbGF5ZXJzIHdoaWNoIHJlZHVjZVxuICogYWNyb3NzIGNoYW5uZWxzLCBpLmUuLCBDb252MUQgYW5kIENvbnYyRCwgYnV0IG5vdCBEZXB0aHdpc2VDb252MkQuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBDb252IGV4dGVuZHMgQmFzZUNvbnYge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZmlsdGVyczogbnVtYmVyO1xuXG4gIHByb3RlY3RlZCBrZXJuZWw6IExheWVyVmFyaWFibGUgPSBudWxsO1xuXG4gIC8vIEJpYXMtcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZSBzdG9yZWQgaW4gdGhlIHN1cGVyY2xhc3MgYEJhc2VDb252YCBiZWNhdXNlIGFsbFxuICAvLyBjb252b2x1dGlvbiBzdWJjbGFzc2VzIHVzZSB0aGUgc2FtZSBjb25maWd1cmF0aW9uIHBhcmFtZXRlcnMgdG8gY29udHJvbFxuICAvLyBiaWFzLiBLZXJuZWwtcmVsYXRlZCBwcm9wZXJ0aWVzIGFyZSBkZWZpbmVkIGhlcmUgcmF0aGVyIHRoYW4gaW4gdGhlXG4gIC8vIHN1cGVyY2xhc3MgYmVjYXVzZSBzb21lIGNvbnZvbHV0aW9uIHN1YmNsYXNzZXMgdXNlIGRpZmZlcmVudCBuYW1lcyBhbmRcbiAgLy8gY29uZmlndXJhdGlvbiBwYXJhbWV0ZXJzIGZvciB0aGVpciBpbnRlcm5hbCBrZXJuZWwgc3RhdGUuXG4gIHByb3RlY3RlZCByZWFkb25seSBrZXJuZWxJbml0aWFsaXplcj86IEluaXRpYWxpemVyO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkga2VybmVsQ29uc3RyYWludD86IENvbnN0cmFpbnQ7XG4gIHByb3RlY3RlZCByZWFkb25seSBrZXJuZWxSZWd1bGFyaXplcj86IFJlZ3VsYXJpemVyO1xuXG4gIGNvbnN0cnVjdG9yKHJhbms6IG51bWJlciwgYXJnczogQ29udkxheWVyQXJncykge1xuICAgIHN1cGVyKHJhbmssIGFyZ3MgYXMgQmFzZUNvbnZMYXllckFyZ3MpO1xuICAgIENvbnYudmVyaWZ5QXJncyhhcmdzKTtcbiAgICB0aGlzLmZpbHRlcnMgPSBhcmdzLmZpbHRlcnM7XG4gICAgZ2VuZXJpY191dGlscy5hc3NlcnRQb3NpdGl2ZUludGVnZXIodGhpcy5maWx0ZXJzLCAnZmlsdGVycycpO1xuICAgIHRoaXMua2VybmVsSW5pdGlhbGl6ZXIgPSBnZXRJbml0aWFsaXplcihcbiAgICAgICAgYXJncy5rZXJuZWxJbml0aWFsaXplciB8fCB0aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICB0aGlzLmtlcm5lbENvbnN0cmFpbnQgPSBnZXRDb25zdHJhaW50KGFyZ3Mua2VybmVsQ29uc3RyYWludCk7XG4gICAgdGhpcy5rZXJuZWxSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3Mua2VybmVsUmVndWxhcml6ZXIpO1xuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgY29uc3QgY2hhbm5lbEF4aXMgPVxuICAgICAgICB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IDEgOiBpbnB1dFNoYXBlLmxlbmd0aCAtIDE7XG4gICAgaWYgKGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0IHNob3VsZCBiZSBkZWZpbmVkLiBgICtcbiAgICAgICAgICBgRm91bmQgJHtpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXX1gKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXTtcblxuICAgIGNvbnN0IGtlcm5lbFNoYXBlID0gdGhpcy5rZXJuZWxTaXplLmNvbmNhdChbaW5wdXREaW0sIHRoaXMuZmlsdGVyc10pO1xuXG4gICAgdGhpcy5rZXJuZWwgPSB0aGlzLmFkZFdlaWdodChcbiAgICAgICAgJ2tlcm5lbCcsIGtlcm5lbFNoYXBlLCBudWxsLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLFxuICAgICAgICB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgIGlmICh0aGlzLnVzZUJpYXMpIHtcbiAgICAgIHRoaXMuYmlhcyA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAgICdiaWFzJywgW3RoaXMuZmlsdGVyc10sIG51bGwsIHRoaXMuYmlhc0luaXRpYWxpemVyLFxuICAgICAgICAgIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICB9XG5cbiAgICB0aGlzLmlucHV0U3BlYyA9IFt7bmRpbTogdGhpcy5yYW5rICsgMiwgYXhlczoge1tjaGFubmVsQXhpc106IGlucHV0RGltfX1dO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlucHV0cyA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgIGxldCBvdXRwdXRzOiBUZW5zb3I7XG4gICAgICBjb25zdCBiaWFzVmFsdWUgPSB0aGlzLmJpYXMgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmJpYXMucmVhZCgpO1xuICAgICAgY29uc3QgZnVzZWRBY3RpdmF0aW9uTmFtZSA9IGdlbmVyaWNfdXRpbHMubWFwQWN0aXZhdGlvblRvRnVzZWRLZXJuZWwoXG4gICAgICAgICAgdGhpcy5hY3RpdmF0aW9uLmdldENsYXNzTmFtZSgpKTtcblxuICAgICAgaWYgKGZ1c2VkQWN0aXZhdGlvbk5hbWUgIT0gbnVsbCAmJiB0aGlzLnJhbmsgPT09IDIpIHtcbiAgICAgICAgb3V0cHV0cyA9IGNvbnYyZFdpdGhCaWFzQWN0aXZhdGlvbihcbiAgICAgICAgICAgIGlucHV0cywgdGhpcy5rZXJuZWwucmVhZCgpLCBiaWFzVmFsdWUsIHRoaXMuc3RyaWRlcywgdGhpcy5wYWRkaW5nLFxuICAgICAgICAgICAgdGhpcy5kYXRhRm9ybWF0LCB0aGlzLmRpbGF0aW9uUmF0ZSBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgICAgZnVzZWRBY3RpdmF0aW9uTmFtZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5yYW5rID09PSAxKSB7XG4gICAgICAgICAgb3V0cHV0cyA9IGNvbnYxZFdpdGhCaWFzKFxuICAgICAgICAgICAgICBpbnB1dHMsIHRoaXMua2VybmVsLnJlYWQoKSwgYmlhc1ZhbHVlLCB0aGlzLnN0cmlkZXNbMF0sXG4gICAgICAgICAgICAgIHRoaXMucGFkZGluZywgdGhpcy5kYXRhRm9ybWF0LCB0aGlzLmRpbGF0aW9uUmF0ZVswXSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5yYW5rID09PSAyKSB7XG4gICAgICAgICAgLy8gVE9ETyhjYWlzKTogTW92ZSB1cCB0byBjb25zdHJ1Y3Rvci5cbiAgICAgICAgICBvdXRwdXRzID0gY29udjJkV2l0aEJpYXNBY3RpdmF0aW9uKFxuICAgICAgICAgICAgICBpbnB1dHMsIHRoaXMua2VybmVsLnJlYWQoKSwgYmlhc1ZhbHVlLCB0aGlzLnN0cmlkZXMsIHRoaXMucGFkZGluZyxcbiAgICAgICAgICAgICAgdGhpcy5kYXRhRm9ybWF0LCB0aGlzLmRpbGF0aW9uUmF0ZSBhcyBbbnVtYmVyLCBudW1iZXJdKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnJhbmsgPT09IDMpIHtcbiAgICAgICAgICBvdXRwdXRzID0gY29udjNkV2l0aEJpYXMoXG4gICAgICAgICAgICAgIGlucHV0cywgdGhpcy5rZXJuZWwucmVhZCgpLCBiaWFzVmFsdWUsIHRoaXMuc3RyaWRlcywgdGhpcy5wYWRkaW5nLFxuICAgICAgICAgICAgICB0aGlzLmRhdGFGb3JtYXQsIHRoaXMuZGlsYXRpb25SYXRlIGFzIFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgICAgICdjb252b2x1dGlvbnMgZ3JlYXRlciB0aGFuIDNEIGFyZSBub3QgaW1wbGVtZW50ZWQgeWV0LicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgICAgb3V0cHV0cyA9IHRoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBjb25zdCBuZXdTcGFjZTogbnVtYmVyW10gPSBbXTtcbiAgICBjb25zdCBzcGFjZSA9ICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSA/XG4gICAgICAgIGlucHV0U2hhcGUuc2xpY2UoMSwgaW5wdXRTaGFwZS5sZW5ndGggLSAxKSA6XG4gICAgICAgIGlucHV0U2hhcGUuc2xpY2UoMik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzcGFjZS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgbmV3RGltID0gY29udk91dHB1dExlbmd0aChcbiAgICAgICAgICBzcGFjZVtpXSwgdGhpcy5rZXJuZWxTaXplW2ldLCB0aGlzLnBhZGRpbmcsIHRoaXMuc3RyaWRlc1tpXSxcbiAgICAgICAgICB0eXBlb2YgdGhpcy5kaWxhdGlvblJhdGUgPT09ICdudW1iZXInID8gdGhpcy5kaWxhdGlvblJhdGUgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpbGF0aW9uUmF0ZVtpXSk7XG4gICAgICBuZXdTcGFjZS5wdXNoKG5ld0RpbSk7XG4gICAgfVxuXG4gICAgbGV0IG91dHB1dFNoYXBlID0gW2lucHV0U2hhcGVbMF1dO1xuICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICBvdXRwdXRTaGFwZSA9IG91dHB1dFNoYXBlLmNvbmNhdChuZXdTcGFjZSk7XG4gICAgICBvdXRwdXRTaGFwZS5wdXNoKHRoaXMuZmlsdGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFNoYXBlLnB1c2godGhpcy5maWx0ZXJzKTtcbiAgICAgIG91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGUuY29uY2F0KG5ld1NwYWNlKTtcbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgZmlsdGVyczogdGhpcy5maWx0ZXJzLFxuICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IHNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAga2VybmVsUmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLFxuICAgICAga2VybmVsQ29uc3RyYWludDogc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIHZlcmlmeUFyZ3MoYXJnczogQ29udkxheWVyQXJncykge1xuICAgIC8vIENoZWNrIGNvbmZpZy5maWx0ZXJzIHR5cGUsIHNoYXBlLCBhbmQgdmFsdWUuXG4gICAgaWYgKCEoJ2ZpbHRlcnMnIGluIGFyZ3MpIHx8IHR5cGVvZiBhcmdzLmZpbHRlcnMgIT09ICdudW1iZXInIHx8XG4gICAgICAgIGFyZ3MuZmlsdGVycyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBDb252b2x1dGlvbiBsYXllciBleHBlY3RlZCBjb25maWcuZmlsdGVycyB0byBiZSBhICdudW1iZXInID4gMCBgICtcbiAgICAgICAgICBgYnV0IGdvdCAke0pTT04uc3RyaW5naWZ5KGFyZ3MuZmlsdGVycyl9YCk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBDb252MkQgZXh0ZW5kcyBDb252IHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQ29udjJEJztcbiAgY29uc3RydWN0b3IoYXJnczogQ29udkxheWVyQXJncykge1xuICAgIHN1cGVyKDIsIGFyZ3MpO1xuICAgIENvbnYyRC52ZXJpZnlBcmdzKGFyZ3MpO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgZGVsZXRlIGNvbmZpZ1sncmFuayddO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIHZlcmlmeUFyZ3MoYXJnczogQ29udkxheWVyQXJncykge1xuICAgIC8vIGNvbmZpZy5rZXJuZWxTaXplIG11c3QgYmUgYSBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVycy5cbiAgICBpZiAoKHR5cGVvZiBhcmdzLmtlcm5lbFNpemUgIT09ICdudW1iZXInKSAmJlxuICAgICAgICAhZ2VuZXJpY191dGlscy5jaGVja0FycmF5VHlwZUFuZExlbmd0aChcbiAgICAgICAgICAgIGFyZ3Mua2VybmVsU2l6ZSwgJ251bWJlcicsIDEsIDIpKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgQ29udjJEIGV4cGVjdHMgY29uZmlnLmtlcm5lbFNpemUgdG8gYmUgbnVtYmVyIG9yIG51bWJlcltdIHdpdGggYCArXG4gICAgICAgICAgYGxlbmd0aCAxIG9yIDIsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGFyZ3Mua2VybmVsU2l6ZSl9LmApO1xuICAgIH1cbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYyRCk7XG5cbmV4cG9ydCBjbGFzcyBDb252M0QgZXh0ZW5kcyBDb252IHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQ29udjNEJztcbiAgY29uc3RydWN0b3IoYXJnczogQ29udkxheWVyQXJncykge1xuICAgIHN1cGVyKDMsIGFyZ3MpO1xuICAgIENvbnYzRC52ZXJpZnlBcmdzKGFyZ3MpO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgZGVsZXRlIGNvbmZpZ1sncmFuayddO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RhdGljIHZlcmlmeUFyZ3MoYXJnczogQ29udkxheWVyQXJncykge1xuICAgIC8vIGNvbmZpZy5rZXJuZWxTaXplIG11c3QgYmUgYSBudW1iZXIgb3IgYXJyYXkgb2YgbnVtYmVycy5cbiAgICBpZiAodHlwZW9mIGFyZ3Mua2VybmVsU2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgIGlmICghKEFycmF5LmlzQXJyYXkoYXJncy5rZXJuZWxTaXplKSAmJlxuICAgICAgICAgICAgKGFyZ3Mua2VybmVsU2l6ZS5sZW5ndGggPT09IDEgfHwgYXJncy5rZXJuZWxTaXplLmxlbmd0aCA9PT0gMykpKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYENvbnYzRCBleHBlY3RzIGNvbmZpZy5rZXJuZWxTaXplIHRvIGJlIG51bWJlciBvcmAgK1xuICAgICAgICAgICAgYCBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sIGJ1dCByZWNlaXZlZCAke1xuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KGFyZ3Mua2VybmVsU2l6ZSl9LmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYzRCk7XG5cbmV4cG9ydCBjbGFzcyBDb252MkRUcmFuc3Bvc2UgZXh0ZW5kcyBDb252MkQge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdDb252MkRUcmFuc3Bvc2UnO1xuICBpbnB1dFNwZWM6IElucHV0U3BlY1tdO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IENvbnZMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLmlucHV0U3BlYyA9IFtuZXcgSW5wdXRTcGVjKHtuZGltOiA0fSldO1xuXG4gICAgaWYgKHRoaXMucGFkZGluZyAhPT0gJ3NhbWUnICYmIHRoaXMucGFkZGluZyAhPT0gJ3ZhbGlkJykge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYENvbnYyRFRyYW5zcG9zZSBjdXJyZW50bHkgc3VwcG9ydHMgb25seSBwYWRkaW5nIG1vZGVzICdzYW1lJyBgICtcbiAgICAgICAgICBgYW5kICd2YWxpZCcsIGJ1dCByZWNlaXZlZCBwYWRkaW5nIG1vZGUgJHt0aGlzLnBhZGRpbmd9YCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG5cbiAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdJbnB1dCBzaG91bGQgaGF2ZSByYW5rIDQ7IFJlY2VpdmVkIGlucHV0IHNoYXBlOiAnICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbm5lbEF4aXMgPVxuICAgICAgICB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IDEgOiBpbnB1dFNoYXBlLmxlbmd0aCAtIDE7XG4gICAgaWYgKGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyBzaG91bGQgYmUgZGVmaW5lZC4gJyArXG4gICAgICAgICAgJ0ZvdW5kIGBOb25lYC4nKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXTtcbiAgICBjb25zdCBrZXJuZWxTaGFwZSA9IHRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycywgaW5wdXREaW1dKTtcblxuICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICdrZXJuZWwnLCBrZXJuZWxTaGFwZSwgJ2Zsb2F0MzInLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLFxuICAgICAgICB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgIGlmICh0aGlzLnVzZUJpYXMpIHtcbiAgICAgIHRoaXMuYmlhcyA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAgICdiaWFzJywgW3RoaXMuZmlsdGVyc10sICdmbG9hdDMyJywgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsXG4gICAgICAgICAgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgIH1cblxuICAgIC8vIFNldCBpbnB1dCBzcGVjLlxuICAgIHRoaXMuaW5wdXRTcGVjID1cbiAgICAgICAgW25ldyBJbnB1dFNwZWMoe25kaW06IDQsIGF4ZXM6IHtbY2hhbm5lbEF4aXNdOiBpbnB1dERpbX19KV07XG4gICAgdGhpcy5idWlsdCA9IHRydWU7XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRmYy50aWR5KCgpID0+IHtcbiAgICAgIGxldCBpbnB1dCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgIGlmIChpbnB1dC5zaGFwZS5sZW5ndGggIT09IDQpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgQ29udjJEVHJhbnNwb3NlLmNhbGwoKSBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSByYW5rLTQsIGJ1dCBgICtcbiAgICAgICAgICAgIGByZWNlaXZlZCBhIHRlbnNvciBvZiByYW5rLSR7aW5wdXQuc2hhcGUubGVuZ3RofWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXQuc2hhcGU7XG4gICAgICBjb25zdCBiYXRjaFNpemUgPSBpbnB1dFNoYXBlWzBdO1xuXG4gICAgICBsZXQgaEF4aXM6IG51bWJlcjtcbiAgICAgIGxldCB3QXhpczogbnVtYmVyO1xuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgIGhBeGlzID0gMjtcbiAgICAgICAgd0F4aXMgPSAzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaEF4aXMgPSAxO1xuICAgICAgICB3QXhpcyA9IDI7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGhlaWdodCA9IGlucHV0U2hhcGVbaEF4aXNdO1xuICAgICAgY29uc3Qgd2lkdGggPSBpbnB1dFNoYXBlW3dBeGlzXTtcbiAgICAgIGNvbnN0IGtlcm5lbEggPSB0aGlzLmtlcm5lbFNpemVbMF07XG4gICAgICBjb25zdCBrZXJuZWxXID0gdGhpcy5rZXJuZWxTaXplWzFdO1xuICAgICAgY29uc3Qgc3RyaWRlSCA9IHRoaXMuc3RyaWRlc1swXTtcbiAgICAgIGNvbnN0IHN0cmlkZVcgPSB0aGlzLnN0cmlkZXNbMV07XG5cbiAgICAgIC8vIEluZmVyIHRoZSBkeW5hbWljIG91dHB1dCBzaGFwZS5cbiAgICAgIGNvbnN0IG91dEhlaWdodCA9IGRlY29udkxlbmd0aChoZWlnaHQsIHN0cmlkZUgsIGtlcm5lbEgsIHRoaXMucGFkZGluZyk7XG4gICAgICBjb25zdCBvdXRXaWR0aCA9IGRlY29udkxlbmd0aCh3aWR0aCwgc3RyaWRlVywga2VybmVsVywgdGhpcy5wYWRkaW5nKTtcblxuICAgICAgLy8gUG9ydGluZyBOb3RlOiBXZSBkb24ndCBicmFuY2ggYmFzZWQgb24gYHRoaXMuZGF0YUZvcm1hdGAgaGVyZSxcbiAgICAgIC8vIGJlY2F1c2VcbiAgICAgIC8vICAgdGhlIHRqZnMtY29yZSBmdW5jdGlvbiBgY29udjJkVHJhbnNwb3NlYCBjYWxsZWQgYmVsb3cgYWx3YXlzXG4gICAgICAvLyAgIGFzc3VtZXMgY2hhbm5lbHNMYXN0LlxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXJdID1cbiAgICAgICAgICBbYmF0Y2hTaXplLCBvdXRIZWlnaHQsIG91dFdpZHRoLCB0aGlzLmZpbHRlcnNdO1xuXG4gICAgICBpZiAodGhpcy5kYXRhRm9ybWF0ICE9PSAnY2hhbm5lbHNMYXN0Jykge1xuICAgICAgICBpbnB1dCA9IHRmYy50cmFuc3Bvc2UoaW5wdXQsIFswLCAyLCAzLCAxXSk7XG4gICAgICB9XG4gICAgICBsZXQgb3V0cHV0cyA9IHRmYy5jb252MmRUcmFuc3Bvc2UoXG4gICAgICAgICAgaW5wdXQgYXMgVGVuc29yNEQsIHRoaXMua2VybmVsLnJlYWQoKSBhcyBUZW5zb3I0RCwgb3V0cHV0U2hhcGUsXG4gICAgICAgICAgdGhpcy5zdHJpZGVzIGFzIFtudW1iZXIsIG51bWJlcl0sIHRoaXMucGFkZGluZyBhcyAnc2FtZScgfCAndmFsaWQnKTtcbiAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgIT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIG91dHB1dHMgPSB0ZmMudHJhbnNwb3NlKG91dHB1dHMsIFswLCAzLCAxLCAyXSk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLmJpYXMgIT0gbnVsbCkge1xuICAgICAgICBvdXRwdXRzID1cbiAgICAgICAgICAgIEsuYmlhc0FkZChvdXRwdXRzLCB0aGlzLmJpYXMucmVhZCgpLCB0aGlzLmRhdGFGb3JtYXQpIGFzIFRlbnNvcjREO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIG91dHB1dHMgPSB0aGlzLmFjdGl2YXRpb24uYXBwbHkob3V0cHV0cykgYXMgVGVuc29yNEQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcblxuICAgIGxldCBjaGFubmVsQXhpczogbnVtYmVyO1xuICAgIGxldCBoZWlnaHRBeGlzOiBudW1iZXI7XG4gICAgbGV0IHdpZHRoQXhpczogbnVtYmVyO1xuICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgY2hhbm5lbEF4aXMgPSAxO1xuICAgICAgaGVpZ2h0QXhpcyA9IDI7XG4gICAgICB3aWR0aEF4aXMgPSAzO1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsQXhpcyA9IDM7XG4gICAgICBoZWlnaHRBeGlzID0gMTtcbiAgICAgIHdpZHRoQXhpcyA9IDI7XG4gICAgfVxuXG4gICAgY29uc3Qga2VybmVsSCA9IHRoaXMua2VybmVsU2l6ZVswXTtcbiAgICBjb25zdCBrZXJuZWxXID0gdGhpcy5rZXJuZWxTaXplWzFdO1xuICAgIGNvbnN0IHN0cmlkZUggPSB0aGlzLnN0cmlkZXNbMF07XG4gICAgY29uc3Qgc3RyaWRlVyA9IHRoaXMuc3RyaWRlc1sxXTtcblxuICAgIG91dHB1dFNoYXBlW2NoYW5uZWxBeGlzXSA9IHRoaXMuZmlsdGVycztcbiAgICBvdXRwdXRTaGFwZVtoZWlnaHRBeGlzXSA9XG4gICAgICAgIGRlY29udkxlbmd0aChvdXRwdXRTaGFwZVtoZWlnaHRBeGlzXSwgc3RyaWRlSCwga2VybmVsSCwgdGhpcy5wYWRkaW5nKTtcbiAgICBvdXRwdXRTaGFwZVt3aWR0aEF4aXNdID1cbiAgICAgICAgZGVjb252TGVuZ3RoKG91dHB1dFNoYXBlW3dpZHRoQXhpc10sIHN0cmlkZVcsIGtlcm5lbFcsIHRoaXMucGFkZGluZyk7XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgZGVsZXRlIGNvbmZpZ1snZGlsYXRpb25SYXRlJ107XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYyRFRyYW5zcG9zZSk7XG5cbmV4cG9ydCBjbGFzcyBDb252M0RUcmFuc3Bvc2UgZXh0ZW5kcyBDb252M0Qge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdDb252M0RUcmFuc3Bvc2UnO1xuICBpbnB1dFNwZWM6IElucHV0U3BlY1tdO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IENvbnZMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLmlucHV0U3BlYyA9IFtuZXcgSW5wdXRTcGVjKHtuZGltOiA1fSldO1xuXG4gICAgaWYgKHRoaXMucGFkZGluZyAhPT0gJ3NhbWUnICYmIHRoaXMucGFkZGluZyAhPT0gJ3ZhbGlkJykge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYENvbnYzRFRyYW5zcG9zZSBjdXJyZW50bHkgc3VwcG9ydHMgb25seSBwYWRkaW5nIG1vZGVzICdzYW1lJyBgICtcbiAgICAgICAgICBgYW5kICd2YWxpZCcsIGJ1dCByZWNlaXZlZCBwYWRkaW5nIG1vZGUgJHt0aGlzLnBhZGRpbmd9YCk7XG4gICAgfVxuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG5cbiAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggIT09IDUpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdJbnB1dCBzaG91bGQgaGF2ZSByYW5rIDU7IFJlY2VpdmVkIGlucHV0IHNoYXBlOiAnICtcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKSk7XG4gICAgfVxuXG4gICAgY29uc3QgY2hhbm5lbEF4aXMgPVxuICAgICAgICB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IDEgOiBpbnB1dFNoYXBlLmxlbmd0aCAtIDE7XG4gICAgaWYgKGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdUaGUgY2hhbm5lbCBkaW1lbnNpb24gb2YgdGhlIGlucHV0cyBzaG91bGQgYmUgZGVmaW5lZC4gJyArXG4gICAgICAgICAgJ0ZvdW5kIGBOb25lYC4nKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXTtcbiAgICBjb25zdCBrZXJuZWxTaGFwZSA9IHRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycywgaW5wdXREaW1dKTtcblxuICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICdrZXJuZWwnLCBrZXJuZWxTaGFwZSwgJ2Zsb2F0MzInLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLFxuICAgICAgICB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgIGlmICh0aGlzLnVzZUJpYXMpIHtcbiAgICAgIHRoaXMuYmlhcyA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAgICdiaWFzJywgW3RoaXMuZmlsdGVyc10sICdmbG9hdDMyJywgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsXG4gICAgICAgICAgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgIH1cblxuICAgIC8vIFNldCBpbnB1dCBzcGVjLlxuICAgIHRoaXMuaW5wdXRTcGVjID1cbiAgICAgICAgW25ldyBJbnB1dFNwZWMoe25kaW06IDUsIGF4ZXM6IHtbY2hhbm5lbEF4aXNdOiBpbnB1dERpbX19KV07XG4gICAgdGhpcy5idWlsdCA9IHRydWU7XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRmYy50aWR5PHRmYy5UZW5zb3I1RD4oKCkgPT4ge1xuICAgICAgbGV0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgaWYgKGlucHV0LnNoYXBlLmxlbmd0aCAhPT0gNSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBDb252M0RUcmFuc3Bvc2UuY2FsbCgpIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIHJhbmstNCwgYnV0IGAgK1xuICAgICAgICAgICAgYHJlY2VpdmVkIGEgdGVuc29yIG9mIHJhbmstJHtpbnB1dC5zaGFwZS5sZW5ndGh9YCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5zaGFwZTtcbiAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IGlucHV0U2hhcGVbMF07XG5cbiAgICAgIGxldCBoQXhpczogbnVtYmVyO1xuICAgICAgbGV0IHdBeGlzOiBudW1iZXI7XG4gICAgICBsZXQgZEF4aXM6IG51bWJlcjtcblxuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICAgIGRBeGlzID0gMjtcbiAgICAgICAgaEF4aXMgPSAzO1xuICAgICAgICB3QXhpcyA9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBkQXhpcyA9IDE7XG4gICAgICAgIGhBeGlzID0gMjtcbiAgICAgICAgd0F4aXMgPSAzO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBkZXB0aCA9IGlucHV0U2hhcGVbZEF4aXNdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gaW5wdXRTaGFwZVtoQXhpc107XG4gICAgICBjb25zdCB3aWR0aCA9IGlucHV0U2hhcGVbd0F4aXNdO1xuICAgICAgY29uc3Qga2VybmVsRCA9IHRoaXMua2VybmVsU2l6ZVswXTtcbiAgICAgIGNvbnN0IGtlcm5lbEggPSB0aGlzLmtlcm5lbFNpemVbMV07XG4gICAgICBjb25zdCBrZXJuZWxXID0gdGhpcy5rZXJuZWxTaXplWzJdO1xuICAgICAgY29uc3Qgc3RyaWRlRCA9IHRoaXMuc3RyaWRlc1swXTtcbiAgICAgIGNvbnN0IHN0cmlkZUggPSB0aGlzLnN0cmlkZXNbMV07XG4gICAgICBjb25zdCBzdHJpZGVXID0gdGhpcy5zdHJpZGVzWzJdO1xuXG4gICAgICAvLyBJbmZlciB0aGUgZHluYW1pYyBvdXRwdXQgc2hhcGUuXG4gICAgICBjb25zdCBvdXREZXB0aCA9IGRlY29udkxlbmd0aChkZXB0aCwgc3RyaWRlRCwga2VybmVsRCwgdGhpcy5wYWRkaW5nKTtcbiAgICAgIGNvbnN0IG91dEhlaWdodCA9IGRlY29udkxlbmd0aChoZWlnaHQsIHN0cmlkZUgsIGtlcm5lbEgsIHRoaXMucGFkZGluZyk7XG4gICAgICBjb25zdCBvdXRXaWR0aCA9IGRlY29udkxlbmd0aCh3aWR0aCwgc3RyaWRlVywga2VybmVsVywgdGhpcy5wYWRkaW5nKTtcblxuICAgICAgLy8gU2FtZSBhcyBgY29udjJkVHJhbnNwb3NlYC4gV2UgYWx3YXlzIGFzc3VtZXMgY2hhbm5lbHNMYXN0LlxuICAgICAgY29uc3Qgb3V0cHV0U2hhcGU6IFtudW1iZXIsIG51bWJlciwgbnVtYmVyLCBudW1iZXIsIG51bWJlcl0gPVxuICAgICAgICAgIFtiYXRjaFNpemUsIG91dERlcHRoLCBvdXRIZWlnaHQsIG91dFdpZHRoLCB0aGlzLmZpbHRlcnNdO1xuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCAhPT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgaW5wdXQgPSB0ZmMudHJhbnNwb3NlKGlucHV0LCBbMCwgMiwgMywgNCwgMV0pO1xuICAgICAgfVxuICAgICAgbGV0IG91dHB1dHMgPSB0ZmMuY29udjNkVHJhbnNwb3NlKFxuICAgICAgICAgIGlucHV0IGFzIFRlbnNvcjVELCB0aGlzLmtlcm5lbC5yZWFkKCkgYXMgVGVuc29yNUQsIG91dHB1dFNoYXBlLFxuICAgICAgICAgIHRoaXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgICAgICAgdGhpcy5wYWRkaW5nIGFzICdzYW1lJyB8ICd2YWxpZCcpO1xuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCAhPT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgb3V0cHV0cyA9IHRmYy50cmFuc3Bvc2Uob3V0cHV0cywgWzAsIDQsIDEsIDIsIDNdKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuYmlhcyAhPT0gbnVsbCkge1xuICAgICAgICBvdXRwdXRzID1cbiAgICAgICAgICAgIEsuYmlhc0FkZChvdXRwdXRzLCB0aGlzLmJpYXMucmVhZCgpLCB0aGlzLmRhdGFGb3JtYXQpIGFzIFRlbnNvcjVEO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvbiAhPT0gbnVsbCkge1xuICAgICAgICBvdXRwdXRzID0gdGhpcy5hY3RpdmF0aW9uLmFwcGx5KG91dHB1dHMpIGFzIFRlbnNvcjVEO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dHM7XG4gICAgfSk7XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgY29uc3Qgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlLnNsaWNlKCk7XG5cbiAgICBsZXQgY2hhbm5lbEF4aXM6IG51bWJlcjtcbiAgICBsZXQgZGVwdGhBeGlzOiBudW1iZXI7XG4gICAgbGV0IGhlaWdodEF4aXM6IG51bWJlcjtcbiAgICBsZXQgd2lkdGhBeGlzOiBudW1iZXI7XG4gICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICBjaGFubmVsQXhpcyA9IDE7XG4gICAgICBkZXB0aEF4aXMgPSAyO1xuICAgICAgaGVpZ2h0QXhpcyA9IDM7XG4gICAgICB3aWR0aEF4aXMgPSA0O1xuICAgIH0gZWxzZSB7XG4gICAgICBjaGFubmVsQXhpcyA9IDQ7XG4gICAgICBkZXB0aEF4aXMgPSAxO1xuICAgICAgaGVpZ2h0QXhpcyA9IDI7XG4gICAgICB3aWR0aEF4aXMgPSAzO1xuICAgIH1cblxuICAgIGNvbnN0IGtlcm5lbEQgPSB0aGlzLmtlcm5lbFNpemVbMF07XG4gICAgY29uc3Qga2VybmVsSCA9IHRoaXMua2VybmVsU2l6ZVsxXTtcbiAgICBjb25zdCBrZXJuZWxXID0gdGhpcy5rZXJuZWxTaXplWzJdO1xuICAgIGNvbnN0IHN0cmlkZUQgPSB0aGlzLnN0cmlkZXNbMF07XG4gICAgY29uc3Qgc3RyaWRlSCA9IHRoaXMuc3RyaWRlc1sxXTtcbiAgICBjb25zdCBzdHJpZGVXID0gdGhpcy5zdHJpZGVzWzJdO1xuXG4gICAgb3V0cHV0U2hhcGVbY2hhbm5lbEF4aXNdID0gdGhpcy5maWx0ZXJzO1xuICAgIG91dHB1dFNoYXBlW2RlcHRoQXhpc10gPVxuICAgICAgICBkZWNvbnZMZW5ndGgob3V0cHV0U2hhcGVbZGVwdGhBeGlzXSwgc3RyaWRlRCwga2VybmVsRCwgdGhpcy5wYWRkaW5nKTtcbiAgICBvdXRwdXRTaGFwZVtoZWlnaHRBeGlzXSA9XG4gICAgICAgIGRlY29udkxlbmd0aChvdXRwdXRTaGFwZVtoZWlnaHRBeGlzXSwgc3RyaWRlSCwga2VybmVsSCwgdGhpcy5wYWRkaW5nKTtcbiAgICBvdXRwdXRTaGFwZVt3aWR0aEF4aXNdID1cbiAgICAgICAgZGVjb252TGVuZ3RoKG91dHB1dFNoYXBlW3dpZHRoQXhpc10sIHN0cmlkZVcsIGtlcm5lbFcsIHRoaXMucGFkZGluZyk7XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgZGVsZXRlIGNvbmZpZ1snZGlsYXRpb25SYXRlJ107XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYzRFRyYW5zcG9zZSk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBTZXBhcmFibGVDb252TGF5ZXJBcmdzIGV4dGVuZHMgQ29udkxheWVyQXJncyB7XG4gIC8qKlxuICAgKiBUaGUgbnVtYmVyIG9mIGRlcHRod2lzZSBjb252b2x1dGlvbiBvdXRwdXQgY2hhbm5lbHMgZm9yIGVhY2ggaW5wdXRcbiAgICogY2hhbm5lbC5cbiAgICogVGhlIHRvdGFsIG51bWJlciBvZiBkZXB0aHdpc2UgY29udm9sdXRpb24gb3V0cHV0IGNoYW5uZWxzIHdpbGwgYmUgZXF1YWxcbiAgICogdG8gYGZpbHRlcnNJbiAqIGRlcHRoTXVsdGlwbGllcmAuIERlZmF1bHQ6IDEuXG4gICAqL1xuICBkZXB0aE11bHRpcGxpZXI/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIGZvciB0aGUgZGVwdGh3aXNlIGtlcm5lbCBtYXRyaXguXG4gICAqL1xuICBkZXB0aHdpc2VJbml0aWFsaXplcj86IEluaXRpYWxpemVySWRlbnRpZmllcnxJbml0aWFsaXplcjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgZm9yIHRoZSBwb2ludHdpc2Uga2VybmVsIG1hdHJpeC5cbiAgICovXG4gIHBvaW50d2lzZUluaXRpYWxpemVyPzogSW5pdGlhbGl6ZXJJZGVudGlmaWVyfEluaXRpYWxpemVyO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBkZXB0aHdpc2Uga2VybmVsIG1hdHJpeC5cbiAgICovXG4gIGRlcHRod2lzZVJlZ3VsYXJpemVyPzogUmVndWxhcml6ZXJJZGVudGlmaWVyfFJlZ3VsYXJpemVyO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBwb2ludHdpc2Uga2VybmVsIG1hdHJpeC5cbiAgICovXG4gIHBvaW50d2lzZVJlZ3VsYXJpemVyPzogUmVndWxhcml6ZXJJZGVudGlmaWVyfFJlZ3VsYXJpemVyO1xuXG4gIC8qKlxuICAgKiBDb25zdHJhaW50IGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGRlcHRod2lzZSBrZXJuZWwgbWF0cml4LlxuICAgKi9cbiAgZGVwdGh3aXNlQ29uc3RyYWludD86IENvbnN0cmFpbnRJZGVudGlmaWVyfENvbnN0cmFpbnQ7XG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbnQgZnVuY3Rpb24gYXBwbGllZCB0byB0aGUgcG9pbnR3aXNlIGtlcm5lbCBtYXRyaXguXG4gICAqL1xuICBwb2ludHdpc2VDb25zdHJhaW50PzogQ29uc3RyYWludElkZW50aWZpZXJ8Q29uc3RyYWludDtcbn1cblxuZXhwb3J0IGNsYXNzIFNlcGFyYWJsZUNvbnYgZXh0ZW5kcyBDb252IHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnU2VwYXJhYmxlQ29udic7XG5cbiAgcmVhZG9ubHkgZGVwdGhNdWx0aXBsaWVyOiBudW1iZXI7XG5cbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRlcHRod2lzZUluaXRpYWxpemVyPzogSW5pdGlhbGl6ZXI7XG4gIHByb3RlY3RlZCByZWFkb25seSBkZXB0aHdpc2VSZWd1bGFyaXplcj86IFJlZ3VsYXJpemVyO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGVwdGh3aXNlQ29uc3RyYWludD86IENvbnN0cmFpbnQ7XG4gIHByb3RlY3RlZCByZWFkb25seSBwb2ludHdpc2VJbml0aWFsaXplcj86IEluaXRpYWxpemVyO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcG9pbnR3aXNlUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcjtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHBvaW50d2lzZUNvbnN0cmFpbnQ/OiBDb25zdHJhaW50O1xuXG4gIHJlYWRvbmx5IERFRkFVTFRfREVQVEhXSVNFX0lOSVRJQUxJWkVSOiBJbml0aWFsaXplcklkZW50aWZpZXIgPVxuICAgICAgJ2dsb3JvdFVuaWZvcm0nO1xuICByZWFkb25seSBERUZBVUxUX1BPSU5UV0lTRV9JTklUSUFMSVpFUjogSW5pdGlhbGl6ZXJJZGVudGlmaWVyID1cbiAgICAgICdnbG9yb3RVbmlmb3JtJztcblxuICBwcm90ZWN0ZWQgZGVwdGh3aXNlS2VybmVsOiBMYXllclZhcmlhYmxlID0gbnVsbDtcbiAgcHJvdGVjdGVkIHBvaW50d2lzZUtlcm5lbDogTGF5ZXJWYXJpYWJsZSA9IG51bGw7XG5cbiAgY29uc3RydWN0b3IocmFuazogbnVtYmVyLCBjb25maWc/OiBTZXBhcmFibGVDb252TGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIocmFuaywgY29uZmlnKTtcblxuICAgIGlmIChjb25maWcuZmlsdGVycyA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnVGhlIGBmaWx0ZXJzYCBjb25maWd1cmF0aW9uIGZpZWxkIGlzIHJlcXVpcmVkIGJ5IFNlcGFyYWJsZUNvbnYsICcgK1xuICAgICAgICAgICdidXQgaXMgdW5zcGVjaWZpZWQuJyk7XG4gICAgfVxuICAgIGlmIChjb25maWcua2VybmVsSW5pdGlhbGl6ZXIgIT0gbnVsbCB8fCBjb25maWcua2VybmVsUmVndWxhcml6ZXIgIT0gbnVsbCB8fFxuICAgICAgICBjb25maWcua2VybmVsQ29uc3RyYWludCAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnRmllbGRzIGtlcm5lbEluaXRpYWxpemVyLCBrZXJuZWxSZWd1bGFyaXplciBhbmQga2VybmVsQ29uc3RyYWludCAnICtcbiAgICAgICAgICAnYXJlIGludmFsaWQgZm9yIFNlcGFyYWJsZUNvbnYyRC4gVXNlIGRlcHRod2lzZUluaXRpYWxpemVyLCAnICtcbiAgICAgICAgICAnZGVwdGh3aXNlUmVndWxhcml6ZXIsIGRlcHRod2lzZUNvbnN0cmFpbnQsIHBvaW50d2lzZUluaXRpYWxpemVyLCAnICtcbiAgICAgICAgICAncG9pbnR3aXNlUmVndWxhcml6ZXIgYW5kIHBvaW50d2lzZUNvbnN0cmFpbnQgaW5zdGVhZC4nKTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5wYWRkaW5nICE9IG51bGwgJiYgY29uZmlnLnBhZGRpbmcgIT09ICdzYW1lJyAmJlxuICAgICAgICBjb25maWcucGFkZGluZyAhPT0gJ3ZhbGlkJykge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYFNlcGFyYWJsZUNvbnYke3RoaXMucmFua31EIHN1cHBvcnRzIG9ubHkgcGFkZGluZyBtb2RlczogYCArXG4gICAgICAgICAgYCdzYW1lJyBhbmQgJ3ZhbGlkJywgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkoY29uZmlnLnBhZGRpbmcpfWApO1xuICAgIH1cblxuICAgIHRoaXMuZGVwdGhNdWx0aXBsaWVyID1cbiAgICAgICAgY29uZmlnLmRlcHRoTXVsdGlwbGllciA9PSBudWxsID8gMSA6IGNvbmZpZy5kZXB0aE11bHRpcGxpZXI7XG4gICAgdGhpcy5kZXB0aHdpc2VJbml0aWFsaXplciA9IGdldEluaXRpYWxpemVyKFxuICAgICAgICBjb25maWcuZGVwdGh3aXNlSW5pdGlhbGl6ZXIgfHwgdGhpcy5ERUZBVUxUX0RFUFRIV0lTRV9JTklUSUFMSVpFUik7XG4gICAgdGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGNvbmZpZy5kZXB0aHdpc2VSZWd1bGFyaXplcik7XG4gICAgdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50ID0gZ2V0Q29uc3RyYWludChjb25maWcuZGVwdGh3aXNlQ29uc3RyYWludCk7XG4gICAgdGhpcy5wb2ludHdpc2VJbml0aWFsaXplciA9IGdldEluaXRpYWxpemVyKFxuICAgICAgICBjb25maWcuZGVwdGh3aXNlSW5pdGlhbGl6ZXIgfHwgdGhpcy5ERUZBVUxUX1BPSU5UV0lTRV9JTklUSUFMSVpFUik7XG4gICAgdGhpcy5wb2ludHdpc2VSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGNvbmZpZy5wb2ludHdpc2VSZWd1bGFyaXplcik7XG4gICAgdGhpcy5wb2ludHdpc2VDb25zdHJhaW50ID0gZ2V0Q29uc3RyYWludChjb25maWcucG9pbnR3aXNlQ29uc3RyYWludCk7XG4gIH1cblxuICBidWlsZChpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogdm9pZCB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPCB0aGlzLnJhbmsgKyAyKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgSW5wdXRzIHRvIFNlcGFyYWJsZUNvbnYke3RoaXMucmFua31EIHNob3VsZCBoYXZlIHJhbmsgYCArXG4gICAgICAgICAgYCR7dGhpcy5yYW5rICsgMn0sIGJ1dCByZWNlaXZlZCBpbnB1dCBzaGFwZTogYCArXG4gICAgICAgICAgYCR7SlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSl9YCk7XG4gICAgfVxuICAgIGNvbnN0IGNoYW5uZWxBeGlzID1cbiAgICAgICAgdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyAxIDogaW5wdXRTaGFwZS5sZW5ndGggLSAxO1xuICAgIGlmIChpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSA9PSBudWxsIHx8IGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYFRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHNob3VsZCBiZSBkZWZpbmVkLCBgICtcbiAgICAgICAgICBgYnV0IGZvdW5kICR7SlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZVtjaGFubmVsQXhpc10pfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0RGltID0gaW5wdXRTaGFwZVtjaGFubmVsQXhpc107XG4gICAgY29uc3QgZGVwdGh3aXNlS2VybmVsU2hhcGUgPVxuICAgICAgICB0aGlzLmtlcm5lbFNpemUuY29uY2F0KFtpbnB1dERpbSwgdGhpcy5kZXB0aE11bHRpcGxpZXJdKTtcbiAgICBjb25zdCBwb2ludHdpc2VLZXJuZWxTaGFwZSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5yYW5rOyArK2kpIHtcbiAgICAgIHBvaW50d2lzZUtlcm5lbFNoYXBlLnB1c2goMSk7XG4gICAgfVxuICAgIHBvaW50d2lzZUtlcm5lbFNoYXBlLnB1c2goaW5wdXREaW0gKiB0aGlzLmRlcHRoTXVsdGlwbGllciwgdGhpcy5maWx0ZXJzKTtcblxuICAgIGNvbnN0IHRyYWluYWJsZSA9IHRydWU7XG4gICAgdGhpcy5kZXB0aHdpc2VLZXJuZWwgPSB0aGlzLmFkZFdlaWdodChcbiAgICAgICAgJ2RlcHRod2lzZV9rZXJuZWwnLCBkZXB0aHdpc2VLZXJuZWxTaGFwZSwgJ2Zsb2F0MzInLFxuICAgICAgICB0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyLCB0aGlzLmRlcHRod2lzZVJlZ3VsYXJpemVyLCB0cmFpbmFibGUsXG4gICAgICAgIHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCk7XG4gICAgdGhpcy5wb2ludHdpc2VLZXJuZWwgPSB0aGlzLmFkZFdlaWdodChcbiAgICAgICAgJ3BvaW50d2lzZV9rZXJuZWwnLCBwb2ludHdpc2VLZXJuZWxTaGFwZSwgJ2Zsb2F0MzInLFxuICAgICAgICB0aGlzLnBvaW50d2lzZUluaXRpYWxpemVyLCB0aGlzLnBvaW50d2lzZVJlZ3VsYXJpemVyLCB0cmFpbmFibGUsXG4gICAgICAgIHRoaXMucG9pbnR3aXNlQ29uc3RyYWludCk7XG4gICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICAgJ2JpYXMnLCBbdGhpcy5maWx0ZXJzXSwgJ2Zsb2F0MzInLCB0aGlzLmJpYXNJbml0aWFsaXplcixcbiAgICAgICAgICB0aGlzLmJpYXNSZWd1bGFyaXplciwgdHJhaW5hYmxlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaWFzID0gbnVsbDtcbiAgICB9XG5cbiAgICB0aGlzLmlucHV0U3BlYyA9XG4gICAgICAgIFtuZXcgSW5wdXRTcGVjKHtuZGltOiB0aGlzLnJhbmsgKyAyLCBheGVzOiB7W2NoYW5uZWxBeGlzXTogaW5wdXREaW19fSldO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlucHV0cyA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcblxuICAgICAgbGV0IG91dHB1dDogVGVuc29yO1xuICAgICAgaWYgKHRoaXMucmFuayA9PT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAgICcxRCBzZXBhcmFibGUgY29udm9sdXRpb24gaXMgbm90IGltcGxlbWVudGVkIHlldC4nKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5yYW5rID09PSAyKSB7XG4gICAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICAgIGlucHV0cyA9IHRmYy50cmFuc3Bvc2UoaW5wdXRzLCBbMCwgMiwgMywgMV0pOyAgLy8gTkNIVyAtPiBOSFdDLlxuICAgICAgICB9XG5cbiAgICAgICAgb3V0cHV0ID0gdGZjLnNlcGFyYWJsZUNvbnYyZChcbiAgICAgICAgICAgIGlucHV0cyBhcyBUZW5zb3I0RCwgdGhpcy5kZXB0aHdpc2VLZXJuZWwucmVhZCgpIGFzIFRlbnNvcjRELFxuICAgICAgICAgICAgdGhpcy5wb2ludHdpc2VLZXJuZWwucmVhZCgpIGFzIFRlbnNvcjRELFxuICAgICAgICAgICAgdGhpcy5zdHJpZGVzIGFzIFtudW1iZXIsIG51bWJlcl0sIHRoaXMucGFkZGluZyBhcyAnc2FtZScgfCAndmFsaWQnLFxuICAgICAgICAgICAgdGhpcy5kaWxhdGlvblJhdGUgYXMgW251bWJlciwgbnVtYmVyXSwgJ05IV0MnKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICBvdXRwdXQgPSBLLmJpYXNBZGQob3V0cHV0LCB0aGlzLmJpYXMucmVhZCgpLCB0aGlzLmRhdGFGb3JtYXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIG91dHB1dCA9IHRoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgICAgb3V0cHV0ID0gdGZjLnRyYW5zcG9zZShvdXRwdXQsIFswLCAzLCAxLCAyXSk7ICAvLyBOSFdDIC0+IE5DSFcuXG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgZGVsZXRlIGNvbmZpZ1sncmFuayddO1xuICAgIGRlbGV0ZSBjb25maWdbJ2tlcm5lbEluaXRpYWxpemVyJ107XG4gICAgZGVsZXRlIGNvbmZpZ1sna2VybmVsUmVndWxhcml6ZXInXTtcbiAgICBkZWxldGUgY29uZmlnWydrZXJuZWxDb25zdHJhaW50J107XG4gICAgY29uZmlnWydkZXB0aHdpc2VJbml0aWFsaXplciddID1cbiAgICAgICAgc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcik7XG4gICAgY29uZmlnWydwb2ludHdpc2VJbml0aWFsaXplciddID1cbiAgICAgICAgc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5wb2ludHdpc2VJbml0aWFsaXplcik7XG4gICAgY29uZmlnWydkZXB0aHdpc2VSZWd1bGFyaXplciddID1cbiAgICAgICAgc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplcik7XG4gICAgY29uZmlnWydwb2ludHdpc2VSZWd1bGFyaXplciddID1cbiAgICAgICAgc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5wb2ludHdpc2VSZWd1bGFyaXplcik7XG4gICAgY29uZmlnWydkZXB0aHdpc2VDb25zdHJhaW50J10gPVxuICAgICAgICBzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCk7XG4gICAgY29uZmlnWydwb2ludHdpc2VDb25zdHJhaW50J10gPVxuICAgICAgICBzZXJpYWxpemVDb25zdHJhaW50KHRoaXMucG9pbnR3aXNlQ29uc3RyYWludCk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgU2VwYXJhYmxlQ29udjJEIGV4dGVuZHMgU2VwYXJhYmxlQ29udiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ1NlcGFyYWJsZUNvbnYyRCc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBTZXBhcmFibGVDb252TGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoMiwgYXJncyk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhTZXBhcmFibGVDb252MkQpO1xuXG5leHBvcnQgY2xhc3MgQ29udjFEIGV4dGVuZHMgQ29udiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ0NvbnYxRCc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IENvbnZMYXllckFyZ3MpIHtcbiAgICBzdXBlcigxLCBhcmdzKTtcbiAgICBDb252MUQudmVyaWZ5QXJncyhhcmdzKTtcbiAgICB0aGlzLmlucHV0U3BlYyA9IFt7bmRpbTogM31dO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgZGVsZXRlIGNvbmZpZ1sncmFuayddO1xuICAgIGRlbGV0ZSBjb25maWdbJ2RhdGFGb3JtYXQnXTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgcHJvdGVjdGVkIHN0YXRpYyB2ZXJpZnlBcmdzKGFyZ3M6IENvbnZMYXllckFyZ3MpIHtcbiAgICAvLyBjb25maWcua2VybmVsU2l6ZSBtdXN0IGJlIGEgbnVtYmVyIG9yIGFycmF5IG9mIG51bWJlcnMuXG4gICAgaWYgKHR5cGVvZiBhcmdzLmtlcm5lbFNpemUgIT09ICdudW1iZXInICYmXG4gICAgICAgICFnZW5lcmljX3V0aWxzLmNoZWNrQXJyYXlUeXBlQW5kTGVuZ3RoKFxuICAgICAgICAgICAgYXJncy5rZXJuZWxTaXplLCAnbnVtYmVyJywgMSwgMSkpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBDb252MUQgZXhwZWN0cyBjb25maWcua2VybmVsU2l6ZSB0byBiZSBudW1iZXIgb3IgbnVtYmVyW10gd2l0aCBgICtcbiAgICAgICAgICBgbGVuZ3RoIDEsIGJ1dCByZWNlaXZlZCAke0pTT04uc3RyaW5naWZ5KGFyZ3Mua2VybmVsU2l6ZSl9LmApO1xuICAgIH1cbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnYxRCk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBDcm9wcGluZzJETGF5ZXJBcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcbiAgLyoqXG4gICAqIERpbWVuc2lvbiBvZiB0aGUgY3JvcHBpbmcgYWxvbmcgdGhlIHdpZHRoIGFuZCB0aGUgaGVpZ2h0LlxuICAgKiAtIElmIGludGVnZXI6IHRoZSBzYW1lIHN5bW1ldHJpYyBjcm9wcGluZ1xuICAgKiAgaXMgYXBwbGllZCB0byB3aWR0aCBhbmQgaGVpZ2h0LlxuICAgKiAtIElmIGxpc3Qgb2YgMiBpbnRlZ2VyczpcbiAgICogICBpbnRlcnByZXRlZCBhcyB0d28gZGlmZmVyZW50XG4gICAqICAgc3ltbWV0cmljIGNyb3BwaW5nIHZhbHVlcyBmb3IgaGVpZ2h0IGFuZCB3aWR0aDpcbiAgICogICBgW3N5bW1ldHJpY19oZWlnaHRfY3JvcCwgc3ltbWV0cmljX3dpZHRoX2Nyb3BdYC5cbiAgICogLSBJZiBhIGxpc3Qgb2YgMiBsaXN0IG9mIDIgaW50ZWdlcnM6XG4gICAqICAgaW50ZXJwcmV0ZWQgYXNcbiAgICogICBgW1t0b3BfY3JvcCwgYm90dG9tX2Nyb3BdLCBbbGVmdF9jcm9wLCByaWdodF9jcm9wXV1gXG4gICAqL1xuICBjcm9wcGluZzogbnVtYmVyfFtudW1iZXIsIG51bWJlcl18W1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dO1xuXG4gIC8qKlxuICAgKiBGb3JtYXQgb2YgdGhlIGRhdGEsIHdoaWNoIGRldGVybWluZXMgdGhlIG9yZGVyaW5nIG9mIHRoZSBkaW1lbnNpb25zIGluXG4gICAqIHRoZSBpbnB1dHMuXG4gICAqXG4gICAqIGBjaGFubmVsc19sYXN0YCBjb3JyZXNwb25kcyB0byBpbnB1dHMgd2l0aCBzaGFwZVxuICAgKiAgIGAoYmF0Y2gsIC4uLiwgY2hhbm5lbHMpYFxuICAgKlxuICAgKiBgY2hhbm5lbHNfZmlyc3RgIGNvcnJlc3BvbmRzIHRvIGlucHV0cyB3aXRoIHNoYXBlXG4gICAqICAgYChiYXRjaCwgY2hhbm5lbHMsIC4uLilgXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGBjaGFubmVsc19sYXN0YC5cbiAgICovXG4gIGRhdGFGb3JtYXQ/OiBEYXRhRm9ybWF0O1xufVxuXG5leHBvcnQgY2xhc3MgQ3JvcHBpbmcyRCBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQ3JvcHBpbmcyRCc7XG4gIHByb3RlY3RlZCByZWFkb25seSBjcm9wcGluZzogW1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgZGF0YUZvcm1hdDogRGF0YUZvcm1hdDtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBDcm9wcGluZzJETGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgaWYgKHR5cGVvZiBhcmdzLmNyb3BwaW5nID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jcm9wcGluZyA9XG4gICAgICAgICAgW1thcmdzLmNyb3BwaW5nLCBhcmdzLmNyb3BwaW5nXSwgW2FyZ3MuY3JvcHBpbmcsIGFyZ3MuY3JvcHBpbmddXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzLmNyb3BwaW5nWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5jcm9wcGluZyA9IFtcbiAgICAgICAgW2FyZ3MuY3JvcHBpbmdbMF0sIGFyZ3MuY3JvcHBpbmdbMF1dLFxuICAgICAgICBbYXJncy5jcm9wcGluZ1sxXSBhcyBudW1iZXIsIGFyZ3MuY3JvcHBpbmdbMV0gYXMgbnVtYmVyXVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jcm9wcGluZyA9IGFyZ3MuY3JvcHBpbmcgYXMgW1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dO1xuICAgIH1cbiAgICB0aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICBhcmdzLmRhdGFGb3JtYXQgPT09IHVuZGVmaW5lZCA/ICdjaGFubmVsc0xhc3QnIDogYXJncy5kYXRhRm9ybWF0O1xuICAgIHRoaXMuaW5wdXRTcGVjID0gW3tuZGltOiA0fV07XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGUpOiBTaGFwZSB7XG4gICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICByZXR1cm4gW1xuICAgICAgICBpbnB1dFNoYXBlWzBdLCBpbnB1dFNoYXBlWzFdLFxuICAgICAgICBpbnB1dFNoYXBlWzJdIC0gdGhpcy5jcm9wcGluZ1swXVswXSAtIHRoaXMuY3JvcHBpbmdbMF1bMV0sXG4gICAgICAgIGlucHV0U2hhcGVbM10gLSB0aGlzLmNyb3BwaW5nWzFdWzBdIC0gdGhpcy5jcm9wcGluZ1sxXVsxXVxuICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFtcbiAgICAgICAgaW5wdXRTaGFwZVswXSxcbiAgICAgICAgaW5wdXRTaGFwZVsxXSAtIHRoaXMuY3JvcHBpbmdbMF1bMF0gLSB0aGlzLmNyb3BwaW5nWzBdWzFdLFxuICAgICAgICBpbnB1dFNoYXBlWzJdIC0gdGhpcy5jcm9wcGluZ1sxXVswXSAtIHRoaXMuY3JvcHBpbmdbMV1bMV0sIGlucHV0U2hhcGVbM11cbiAgICAgIF07XG4gICAgfVxuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlucHV0cyA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcblxuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgY29uc3QgaFNsaWNlZCA9IEsuc2xpY2VBbG9uZ0F4aXMoXG4gICAgICAgICAgICBpbnB1dHMsIHRoaXMuY3JvcHBpbmdbMF1bMF0sXG4gICAgICAgICAgICBpbnB1dHMuc2hhcGVbMV0gLSB0aGlzLmNyb3BwaW5nWzBdWzBdIC0gdGhpcy5jcm9wcGluZ1swXVsxXSwgMik7XG4gICAgICAgIHJldHVybiBLLnNsaWNlQWxvbmdBeGlzKFxuICAgICAgICAgICAgaFNsaWNlZCwgdGhpcy5jcm9wcGluZ1sxXVswXSxcbiAgICAgICAgICAgIGlucHV0cy5zaGFwZVsyXSAtIHRoaXMuY3JvcHBpbmdbMV1bMV0gLSB0aGlzLmNyb3BwaW5nWzFdWzBdLCAzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGhTbGljZWQgPSBLLnNsaWNlQWxvbmdBeGlzKFxuICAgICAgICAgICAgaW5wdXRzLCB0aGlzLmNyb3BwaW5nWzBdWzBdLFxuICAgICAgICAgICAgaW5wdXRzLnNoYXBlWzJdIC0gdGhpcy5jcm9wcGluZ1swXVswXSAtIHRoaXMuY3JvcHBpbmdbMF1bMV0sIDMpO1xuICAgICAgICByZXR1cm4gSy5zbGljZUFsb25nQXhpcyhcbiAgICAgICAgICAgIGhTbGljZWQsIHRoaXMuY3JvcHBpbmdbMV1bMF0sXG4gICAgICAgICAgICBpbnB1dHMuc2hhcGVbM10gLSB0aGlzLmNyb3BwaW5nWzFdWzFdIC0gdGhpcy5jcm9wcGluZ1sxXVswXSwgNCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSB7Y3JvcHBpbmc6IHRoaXMuY3JvcHBpbmcsIGRhdGFGb3JtYXQ6IHRoaXMuZGF0YUZvcm1hdH07XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQ3JvcHBpbmcyRCk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBVcFNhbXBsaW5nMkRMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogVGhlIHVwc2FtcGxpbmcgZmFjdG9ycyBmb3Igcm93cyBhbmQgY29sdW1ucy5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYFsyLCAyXWAuXG4gICAqL1xuICBzaXplPzogbnVtYmVyW107XG4gIC8qKlxuICAgKiBGb3JtYXQgb2YgdGhlIGRhdGEsIHdoaWNoIGRldGVybWluZXMgdGhlIG9yZGVyaW5nIG9mIHRoZSBkaW1lbnNpb25zIGluXG4gICAqIHRoZSBpbnB1dHMuXG4gICAqXG4gICAqIGBcImNoYW5uZWxzTGFzdFwiYCBjb3JyZXNwb25kcyB0byBpbnB1dHMgd2l0aCBzaGFwZVxuICAgKiAgIGBbYmF0Y2gsIC4uLiwgY2hhbm5lbHNdYFxuICAgKlxuICAgKiAgYFwiY2hhbm5lbHNGaXJzdFwiYCBjb3JyZXNwb25kcyB0byBpbnB1dHMgd2l0aCBzaGFwZSBgW2JhdGNoLCBjaGFubmVscyxcbiAgICogLi4uXWAuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGBcImNoYW5uZWxzTGFzdFwiYC5cbiAgICovXG4gIGRhdGFGb3JtYXQ/OiBEYXRhRm9ybWF0O1xuICAvKipcbiAgICogVGhlIGludGVycG9sYXRpb24gbWVjaGFuaXNtLCBvbmUgb2YgYFwibmVhcmVzdFwiYCBvciBgXCJiaWxpbmVhclwiYCwgZGVmYXVsdFxuICAgKiB0byBgXCJuZWFyZXN0XCJgLlxuICAgKi9cbiAgaW50ZXJwb2xhdGlvbj86IEludGVycG9sYXRpb25Gb3JtYXQ7XG59XG5cbmV4cG9ydCBjbGFzcyBVcFNhbXBsaW5nMkQgZXh0ZW5kcyBMYXllciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ1VwU2FtcGxpbmcyRCc7XG4gIHByb3RlY3RlZCByZWFkb25seSBERUZBVUxUX1NJWkUgPSBbMiwgMl07XG4gIHByb3RlY3RlZCByZWFkb25seSBzaXplOiBudW1iZXJbXTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IGRhdGFGb3JtYXQ6IERhdGFGb3JtYXQ7XG4gIHByb3RlY3RlZCByZWFkb25seSBpbnRlcnBvbGF0aW9uOiBJbnRlcnBvbGF0aW9uRm9ybWF0O1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFVwU2FtcGxpbmcyRExheWVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMuaW5wdXRTcGVjID0gW3tuZGltOiA0fV07XG4gICAgdGhpcy5zaXplID0gYXJncy5zaXplID09IG51bGwgPyB0aGlzLkRFRkFVTFRfU0laRSA6IGFyZ3Muc2l6ZTtcbiAgICB0aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICBhcmdzLmRhdGFGb3JtYXQgPT0gbnVsbCA/ICdjaGFubmVsc0xhc3QnIDogYXJncy5kYXRhRm9ybWF0O1xuICAgIGNoZWNrRGF0YUZvcm1hdCh0aGlzLmRhdGFGb3JtYXQpO1xuICAgIHRoaXMuaW50ZXJwb2xhdGlvbiA9XG4gICAgICAgIGFyZ3MuaW50ZXJwb2xhdGlvbiA9PSBudWxsID8gJ25lYXJlc3QnIDogYXJncy5pbnRlcnBvbGF0aW9uO1xuICAgIGNoZWNrSW50ZXJwb2xhdGlvbkZvcm1hdCh0aGlzLmludGVycG9sYXRpb24pO1xuICB9XG5cbiAgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlKTogU2hhcGUge1xuICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgY29uc3QgaGVpZ2h0ID1cbiAgICAgICAgICBpbnB1dFNoYXBlWzJdID09IG51bGwgPyBudWxsIDogdGhpcy5zaXplWzBdICogaW5wdXRTaGFwZVsyXTtcbiAgICAgIGNvbnN0IHdpZHRoID0gaW5wdXRTaGFwZVszXSA9PSBudWxsID8gbnVsbCA6IHRoaXMuc2l6ZVsxXSAqIGlucHV0U2hhcGVbM107XG4gICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGlucHV0U2hhcGVbMV0sIGhlaWdodCwgd2lkdGhdO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPVxuICAgICAgICAgIGlucHV0U2hhcGVbMV0gPT0gbnVsbCA/IG51bGwgOiB0aGlzLnNpemVbMF0gKiBpbnB1dFNoYXBlWzFdO1xuICAgICAgY29uc3Qgd2lkdGggPSBpbnB1dFNoYXBlWzJdID09IG51bGwgPyBudWxsIDogdGhpcy5zaXplWzFdICogaW5wdXRTaGFwZVsyXTtcbiAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaGVpZ2h0LCB3aWR0aCwgaW5wdXRTaGFwZVszXV07XG4gICAgfVxuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0ZmMudGlkeSgoKSA9PiB7XG4gICAgICBsZXQgaW5wdXQgPSBnZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cykgYXMgVGVuc29yNEQ7XG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXQuc2hhcGU7XG5cbiAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgICBpbnB1dCA9IHRmYy50cmFuc3Bvc2UoaW5wdXQsIFswLCAyLCAzLCAxXSk7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuc2l6ZVswXSAqIGlucHV0U2hhcGVbMl07XG4gICAgICAgIGNvbnN0IHdpZHRoID0gdGhpcy5zaXplWzFdICogaW5wdXRTaGFwZVszXTtcblxuICAgICAgICBjb25zdCByZXNpemVkID0gdGhpcy5pbnRlcnBvbGF0aW9uID09PSAnbmVhcmVzdCcgP1xuICAgICAgICAgICAgdGZjLmltYWdlLnJlc2l6ZU5lYXJlc3ROZWlnaGJvcihpbnB1dCwgW2hlaWdodCwgd2lkdGhdKSA6XG4gICAgICAgICAgICB0ZmMuaW1hZ2UucmVzaXplQmlsaW5lYXIoaW5wdXQsIFtoZWlnaHQsIHdpZHRoXSk7XG4gICAgICAgIHJldHVybiB0ZmMudHJhbnNwb3NlKHJlc2l6ZWQsIFswLCAzLCAxLCAyXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBoZWlnaHQgPSB0aGlzLnNpemVbMF0gKiBpbnB1dFNoYXBlWzFdO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHRoaXMuc2l6ZVsxXSAqIGlucHV0U2hhcGVbMl07XG4gICAgICAgIHJldHVybiB0aGlzLmludGVycG9sYXRpb24gPT09ICduZWFyZXN0JyA/XG4gICAgICAgICAgICB0ZmMuaW1hZ2UucmVzaXplTmVhcmVzdE5laWdoYm9yKGlucHV0LCBbaGVpZ2h0LCB3aWR0aF0pIDpcbiAgICAgICAgICAgIHRmYy5pbWFnZS5yZXNpemVCaWxpbmVhcihpbnB1dCwgW2hlaWdodCwgd2lkdGhdKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgc2l6ZTogdGhpcy5zaXplLCBcbiAgICAgICAgZGF0YUZvcm1hdDogdGhpcy5kYXRhRm9ybWF0LCBcbiAgICAgICAgaW50ZXJwb2xhdGlvbjogdGhpcy5pbnRlcnBvbGF0aW9uXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhVcFNhbXBsaW5nMkQpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Depthwise Convolutional Layers\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat } from '../common';\nimport { getConstraint, serializeConstraint } from '../constraints';\nimport { ValueError } from '../errors';\nimport { getInitializer, serializeInitializer } from '../initializers';\nimport { getRegularizer, serializeRegularizer } from '../regularizers';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { BaseConv, preprocessConv2DInput } from './convolutional';\n/**\n * 2D convolution with separable filters.\n * @param x Input tensor.\n * @param depthwiseKernel Convolution kernel for depthwise convolution.\n * @param strides Strides (Array of two integers).\n * @param padding Padding model.\n * @param dataFormat Data format.\n * @param dilationRate Array of two integers, dilation rates for the separable\n *   convolution.\n * @returns Output tensor.\n * @throws ValueError If depthwiseKernel is not a 4D array.\n */\nexport function depthwiseConv2d(x, depthwiseKernel, strides = [1, 1], padding = 'valid', dataFormat, dilationRate) {\n    return tidy(() => {\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        checkDataFormat(dataFormat);\n        let y = preprocessConv2DInput(x, dataFormat);\n        if (x.rank !== 4) {\n            throw new ValueError(`Input for depthwiseConv2d is required to be 4-D, but is instead ` +\n                `${x.rank}-D`);\n        }\n        if (depthwiseKernel.rank !== 4) {\n            throw new ValueError(`depthwiseKernel is required to be 4-D, but is instead ` +\n                `${depthwiseKernel.rank}-D`);\n        }\n        y = tfc.depthwiseConv2d(y, depthwiseKernel, strides, padding === 'same' ? 'same' : 'valid', 'NHWC', dilationRate);\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 3, 1, 2]);\n        }\n        return y;\n    });\n}\nexport class DepthwiseConv2D extends BaseConv {\n    constructor(args) {\n        super(2, args);\n        this.depthwiseKernel = null;\n        this.depthMultiplier =\n            args.depthMultiplier == null ? 1 : args.depthMultiplier;\n        this.depthwiseInitializer = getInitializer(args.depthwiseInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n        this.depthwiseConstraint = getConstraint(args.depthwiseConstraint);\n        this.depthwiseRegularizer = getRegularizer(args.depthwiseRegularizer);\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        if (inputShape.length < 4) {\n            throw new ValueError(`Inputs to DepthwiseConv2D should have rank 4. ` +\n                `Received input shape: ${JSON.stringify(inputShape)}.`);\n        }\n        const channelAxis = this.dataFormat === 'channelsFirst' ? 1 : 3;\n        if (inputShape[channelAxis] == null || inputShape[channelAxis] < 0) {\n            throw new ValueError('The channel dimension of the inputs to DepthwiseConv2D should ' +\n                `be defined, but is not (${inputShape[channelAxis]}).`);\n        }\n        const inputDim = inputShape[channelAxis];\n        const depthwiseKernelShape = [\n            this.kernelSize[0], this.kernelSize[1], inputDim, this.depthMultiplier\n        ];\n        this.depthwiseKernel = this.addWeight('depthwise_kernel', depthwiseKernelShape, null, this.depthwiseInitializer, this.depthwiseRegularizer, true, this.depthwiseConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [inputDim * this.depthMultiplier], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        else {\n            this.bias = null;\n        }\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = getExactlyOneTensor(inputs);\n            let outputs = depthwiseConv2d(inputs, this.depthwiseKernel.read(), this.strides, this.padding, this.dataFormat, null);\n            // TODO(cais): Add support for dilation.\n            if (this.useBias) {\n                outputs = K.biasAdd(outputs, this.bias.read(), this.dataFormat);\n            }\n            if (this.activation != null) {\n                outputs = this.activation.apply(outputs);\n            }\n            return outputs;\n        });\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        const cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        const outFilters = this.dataFormat === 'channelsFirst' ?\n            inputShape[1] * this.depthMultiplier :\n            inputShape[3] * this.depthMultiplier;\n        const outRows = convOutputLength(rows, this.kernelSize[0], this.padding, this.strides[0]);\n        const outCols = convOutputLength(cols, this.kernelSize[1], this.padding, this.strides[1]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], outFilters, outRows, outCols];\n        }\n        else {\n            // In this case, assume 'channelsLast'.\n            return [inputShape[0], outRows, outCols, outFilters];\n        }\n    }\n    getConfig() {\n        const config = super.getConfig();\n        config['depthMultiplier'] = this.depthMultiplier;\n        config['depthwiseInitializer'] =\n            serializeInitializer(this.depthwiseInitializer);\n        config['depthwiseRegularizer'] =\n            serializeRegularizer(this.depthwiseRegularizer);\n        config['depthwiseConstraint'] =\n            serializeConstraint(this.depthwiseRegularizer);\n        return config;\n    }\n}\n/** @nocollapse */\nDepthwiseConv2D.className = 'DepthwiseConv2D';\nserialization.registerClass(DepthwiseConv2D);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udm9sdXRpb25hbF9kZXB0aHdpc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvbGF5ZXJzL2NvbnZvbHV0aW9uYWxfZGVwdGh3aXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxhQUFhLEVBQW9CLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRTVFLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxtQkFBbUIsQ0FBQztBQUNsRCxPQUFPLEtBQUssQ0FBQyxNQUFNLHlCQUF5QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxlQUFlLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDMUMsT0FBTyxFQUFtQyxhQUFhLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ3JDLE9BQU8sRUFBQyxjQUFjLEVBQXNDLG9CQUFvQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFekcsT0FBTyxFQUFDLGNBQWMsRUFBc0Msb0JBQW9CLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUV6RyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNyRCxPQUFPLEVBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUc3RSxPQUFPLEVBQUMsUUFBUSxFQUFvQyxxQkFBcUIsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRWxHOzs7Ozs7Ozs7OztHQVdHO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FDM0IsQ0FBUyxFQUFFLGVBQXVCLEVBQUUsVUFBNEIsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQ3RFLE9BQU8sR0FBRyxPQUFPLEVB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Q0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDLEVBQUUsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7UUFDN0QsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLGVBQWUsRUFBRTtZQUN2QyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLFVBQVUsRUFBRSxPQUFPLEVBQUUsT0FBTyxDQUFDLENBQUM7U0FDdEQ7YUFBTTtZQUNMLHVDQUF1QztZQUN2QyxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLE9BQU8sRUFBRSxPQUFPLEVBQUUsVUFBVSxDQUFDLENBQUM7U0FDdEQ7SUFDSCxDQUFDO0lBRUQsU0FBUztRQUNQLE1BQU0sTUFBTSxHQUFHLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNqQyxNQUFNLENBQUMsaUJBQWlCLENBQUMsR0FBRyxJQUFJLENBQUMsZUFBZSxDQUFDO1FBQ2pELE1BQU0sQ0FBQyxzQkFBc0IsQ0FBQztZQUMxQixvQkFBb0IsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUNwRCxNQUFNLENBQUMsc0JBQXNCLENBQUM7WUFDMUIsb0JBQW9CLENBQUMsSUFBSSxDQUFDLG9CQUFvQixDQUFDLENBQUM7UUFDcEQsTUFBTSxDQUFDLHFCQUFxQixDQUFDO1lBQ3pCLG1CQUFtQixDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQ25ELE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0FBbkdELGtCQUFrQjtBQUNYLHlCQUFTLEdBQUcsaUJBQWlCLENBQUM7QUFvR3ZDLGFBQWEsQ0FBQyxhQUFhLENBQUMsZUFBZSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIFRlbnNvckZsb3cuanMgTGF5ZXJzOiBEZXB0aHdpc2UgQ29udm9sdXRpb25hbCBMYXllcnNcbiAqL1xuXG5pbXBvcnQgKiBhcyB0ZmMgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7c2VyaWFsaXphdGlvbiwgVGVuc29yLCBUZW5zb3I0RCwgdGlkeX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtpbWFnZURhdGFGb3JtYXR9IGZyb20gJy4uL2JhY2tlbmQvY29tbW9uJztcbmltcG9ydCAqIGFzIEsgZnJvbSAnLi4vYmFja2VuZC90ZmpzX2JhY2tlbmQnO1xuaW1wb3J0IHtjaGVja0RhdGFGb3JtYXR9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge0NvbnN0cmFpbnQsIENvbnN0cmFpbnRJZGVudGlmaWVyLCBnZXRDb25zdHJhaW50LCBzZXJpYWxpemVDb25zdHJhaW50fSBmcm9tICcuLi9jb25zdHJhaW50cyc7XG5pbXBvcnQge1ZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2dldEluaXRpYWxpemVyLCBJbml0aWFsaXplciwgSW5pdGlhbGl6ZXJJZGVudGlmaWVyLCBzZXJpYWxpemVJbml0aWFsaXplcn0gZnJvbSAnLi4vaW5pdGlhbGl6ZXJzJztcbmltcG9ydCB7RGF0YUZvcm1hdCwgU2hhcGV9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuaW1wb3J0IHtnZXRSZWd1bGFyaXplciwgUmVndWxhcml6ZXIsIFJlZ3VsYXJpemVySWRlbnRpZmllciwgc2VyaWFsaXplUmVndWxhcml6ZXJ9IGZyb20gJy4uL3JlZ3VsYXJpemVycyc7XG5pbXBvcnQge0t3YXJnc30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtjb252T3V0cHV0TGVuZ3RofSBmcm9tICcuLi91dGlscy9jb252X3V0aWxzJztcbmltcG9ydCB7Z2V0RXhhY3RseU9uZVNoYXBlLCBnZXRFeGFjdGx5T25lVGVuc29yfSBmcm9tICcuLi91dGlscy90eXBlc191dGlscyc7XG5pbXBvcnQge0xheWVyVmFyaWFibGV9IGZyb20gJy4uL3ZhcmlhYmxlcyc7XG5cbmltcG9ydCB7QmFzZUNvbnYsIEJhc2VDb252TGF5ZXJBcmdzLCBDb252TGF5ZXJBcmdzLCBwcmVwcm9jZXNzQ29udjJESW5wdXR9IGZyb20gJy4vY29udm9sdXRpb25hbCc7XG5cbi8qKlxuICogMkQgY29udm9sdXRpb24gd2l0aCBzZXBhcmFibGUgZmlsdGVycy5cbiAqIEBwYXJhbSB4IElucHV0IHRlbnNvci5cbiAqIEBwYXJhbSBkZXB0aHdpc2VLZXJuZWwgQ29udm9sdXRpb24ga2VybmVsIGZvciBkZXB0aHdpc2UgY29udm9sdXRpb24uXG4gKiBAcGFyYW0gc3RyaWRlcyBTdHJpZGVzIChBcnJheSBvZiB0d28gaW50ZWdlcnMpLlxuICogQHBhcmFtIHBhZGRpbmcgUGFkZGluZyBtb2RlbC5cbiAqIEBwYXJhbSBkYXRhRm9ybWF0IERhdGEgZm9ybWF0LlxuICogQHBhcmFtIGRpbGF0aW9uUmF0ZSBBcnJheSBvZiB0d28gaW50ZWdlcnMsIGRpbGF0aW9uIHJhdGVzIGZvciB0aGUgc2VwYXJhYmxlXG4gKiAgIGNvbnZvbHV0aW9uLlxuICogQHJldHVybnMgT3V0cHV0IHRlbnNvci5cbiAqIEB0aHJvd3MgVmFsdWVFcnJvciBJZiBkZXB0aHdpc2VLZXJuZWwgaXMgbm90IGEgNEQgYXJyYXkuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBkZXB0aHdpc2VDb252MmQoXG4gICAgeDogVGVuc29yLCBkZXB0aHdpc2VLZXJuZWw6IFRlbnNvciwgc3RyaWRlczogW251bWJlciwgbnVtYmVyXSA9IFsxLCAxXSxcbiAgICBwYWRkaW5nID0gJ3ZhbGlkJywgZGF0YUZvcm1hdD86IERhdGFGb3JtYXQsXG4gICAgZGlsYXRpb25SYXRlPzogW251bWJlciwgbnVtYmVyXSk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICBkYXRhRm9ybWF0ID0gaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgfVxuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBsZXQgeSA9IHByZXByb2Nlc3NDb252MkRJbnB1dCh4LCBkYXRhRm9ybWF0KTtcbiAgICBpZiAoeC5yYW5rICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgSW5wdXQgZm9yIGRlcHRod2lzZUNvbnYyZCBpcyByZXF1aXJlZCB0byBiZSA0LUQsIGJ1dCBpcyBpbnN0ZWFkIGAgK1xuICAgICAgICAgIGAke3gucmFua30tRGApO1xuICAgIH1cbiAgICBpZiAoZGVwdGh3aXNlS2VybmVsLnJhbmsgIT09IDQpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBkZXB0aHdpc2VLZXJuZWwgaXMgcmVxdWlyZWQgdG8gYmUgNC1ELCBidXQgaXMgaW5zdGVhZCBgICtcbiAgICAgICAgICBgJHtkZXB0aHdpc2VLZXJuZWwucmFua30tRGApO1xuICAgIH1cbiAgICB5ID0gdGZjLmRlcHRod2lzZUNvbnYyZChcbiAgICAgICAgeSBhcyBUZW5zb3I0RCwgZGVwdGh3aXNlS2VybmVsIGFzIFRlbnNvcjRELCBzdHJpZGVzLFxuICAgICAgICBwYWRkaW5nID09PSAnc2FtZScgPyAnc2FtZScgOiAndmFsaWQnLCAnTkhXQycsIGRpbGF0aW9uUmF0ZSk7XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgeSA9IHRmYy50cmFuc3Bvc2UoeSwgWzAsIDMsIDEsIDJdKTtcbiAgICB9XG4gICAgcmV0dXJuIHk7XG4gIH0pO1xufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgRGVwdGh3aXNlQ29udjJETGF5ZXJBcmdzIGV4dGVuZHMgQmFzZUNvbnZMYXllckFyZ3Mge1xuICAvKipcbiAgICogQW4gaW50ZWdlciBvciBBcnJheSBvZiAyIGludGVnZXJzLCBzcGVjaWZ5aW5nIHRoZSB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZVxuICAgKiAyRCBjb252b2x1dGlvbiB3aW5kb3cuIENhbiBiZSBhIHNpbmdsZSBpbnRlZ2VyIHRvIHNwZWNpZnkgdGhlIHNhbWUgdmFsdWVcbiAgICogZm9yIGFsbCBzcGF0aWFsIGRpbWVuc2lvbnMuXG4gICAqL1xuICBrZXJuZWxTaXplOiBudW1iZXJ8W251bWJlciwgbnVtYmVyXTtcblxuICAvKipcbiAgICogVGhlIG51bWJlciBvZiBkZXB0aHdpc2UgY29udm9sdXRpb24gb3V0cHV0IGNoYW5uZWxzIGZvciBlYWNoIGlucHV0XG4gICAqIGNoYW5uZWwuXG4gICAqIFRoZSB0b3RhbCBudW1iZXIgb2YgZGVwdGh3aXNlIGNvbnZvbHV0aW9uIG91dHB1dCBjaGFubmVscyB3aWxsIGJlIGVxdWFsIHRvXG4gICAqIGBmaWx0ZXJzSW4gKiBkZXB0aE11bHRpcGxpZXJgLlxuICAgKiBEZWZhdWx0OiAxLlxuICAgKi9cbiAgZGVwdGhNdWx0aXBsaWVyPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBmb3IgdGhlIGRlcHRod2lzZSBrZXJuZWwgbWF0cml4LlxuICAgKiBEZWZhdWx0OiBHbG9yb3ROb3JtYWwuXG4gICAqL1xuICBkZXB0aHdpc2VJbml0aWFsaXplcj86IEluaXRpYWxpemVySWRlbnRpZmllcnxJbml0aWFsaXplcjtcblxuICAvKipcbiAgICogQ29uc3RyYWludCBmb3IgdGhlIGRlcHRod2lzZSBrZXJuZWwgbWF0cml4LlxuICAgKi9cbiAgZGVwdGh3aXNlQ29uc3RyYWludD86IENvbnN0cmFpbnRJZGVudGlmaWVyfENvbnN0cmFpbnQ7XG5cbiAgLyoqXG4gICAqIFJlZ3VsemFyaXplciBmdW5jdGlvbiBmb3IgdGhlIGRlcHRod2lzZSBrZXJuZWwgbWF0cml4LlxuICAgKi9cbiAgZGVwdGh3aXNlUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXJ8UmVndWxhcml6ZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBEZXB0aHdpc2VDb252MkQgZXh0ZW5kcyBCYXNlQ29udiB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ0RlcHRod2lzZUNvbnYyRCc7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVwdGhNdWx0aXBsaWVyOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVwdGh3aXNlSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGRlcHRod2lzZUNvbnN0cmFpbnQ6IENvbnN0cmFpbnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgZGVwdGh3aXNlUmVndWxhcml6ZXI6IFJlZ3VsYXJpemVyO1xuXG4gIHByaXZhdGUgZGVwdGh3aXNlS2VybmVsOiBMYXllclZhcmlhYmxlID0gbnVsbDtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBEZXB0aHdpc2VDb252MkRMYXllckFyZ3MpIHtcbiAgICBzdXBlcigyLCBhcmdzIGFzIENvbnZMYXllckFyZ3MpO1xuICAgIHRoaXMuZGVwdGhNdWx0aXBsaWVyID1cbiAgICAgICAgYXJncy5kZXB0aE11bHRpcGxpZXIgPT0gbnVsbCA/IDEgOiBhcmdzLmRlcHRoTXVsdGlwbGllcjtcbiAgICB0aGlzLmRlcHRod2lzZUluaXRpYWxpemVyID0gZ2V0SW5pdGlhbGl6ZXIoXG4gICAgICAgIGFyZ3MuZGVwdGh3aXNlSW5pdGlhbGl6ZXIgfHwgdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUik7XG4gICAgdGhpcy5kZXB0aHdpc2VDb25zdHJhaW50ID0gZ2V0Q29uc3RyYWludChhcmdzLmRlcHRod2lzZUNvbnN0cmFpbnQpO1xuICAgIHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIgPSBnZXRSZWd1bGFyaXplcihhcmdzLmRlcHRod2lzZVJlZ3VsYXJpemVyKTtcbiAgfVxuXG4gIGJ1aWxkKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiB2b2lkIHtcbiAgICBpbnB1dFNoYXBlID0gZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA8IDQpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBJbnB1dHMgdG8gRGVwdGh3aXNlQ29udjJEIHNob3VsZCBoYXZlIHJhbmsgNC4gYCArXG4gICAgICAgICAgYFJlY2VpdmVkIGlucHV0IHNoYXBlOiAke0pTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpfS5gKTtcbiAgICB9XG4gICAgY29uc3QgY2hhbm5lbEF4aXMgPSB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IDEgOiAzO1xuICAgIGlmIChpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXSA9PSBudWxsIHx8IGlucHV0U2hhcGVbY2hhbm5lbEF4aXNdIDwgMCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ1RoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXRzIHRvIERlcHRod2lzZUNvbnYyRCBzaG91bGQgJyArXG4gICAgICAgICAgYGJlIGRlZmluZWQsIGJ1dCBpcyBub3QgKCR7aW5wdXRTaGFwZVtjaGFubmVsQXhpc119KS5gKTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXREaW0gPSBpbnB1dFNoYXBlW2NoYW5uZWxBeGlzXTtcbiAgICBjb25zdCBkZXB0aHdpc2VLZXJuZWxTaGFwZTogU2hhcGUgPSBbXG4gICAgICB0aGlzLmtlcm5lbFNpemVbMF0sIHRoaXMua2VybmVsU2l6ZVsxXSwgaW5wdXREaW0sIHRoaXMuZGVwdGhNdWx0aXBsaWVyXG4gICAgXTtcblxuICAgIHRoaXMuZGVwdGh3aXNlS2VybmVsID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICdkZXB0aHdpc2Vfa2VybmVsJywgZGVwdGh3aXNlS2VybmVsU2hhcGUsIG51bGwsXG4gICAgICAgIHRoaXMuZGVwdGh3aXNlSW5pdGlhbGl6ZXIsIHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIsIHRydWUsXG4gICAgICAgIHRoaXMuZGVwdGh3aXNlQ29uc3RyYWludCk7XG4gICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICAgJ2JpYXMnLCBbaW5wdXREaW0gKiB0aGlzLmRlcHRoTXVsdGlwbGllcl0sIG51bGwsIHRoaXMuYmlhc0luaXRpYWxpemVyLFxuICAgICAgICAgIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5iaWFzID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5idWlsdCA9IHRydWU7XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgaW5wdXRzID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgbGV0IG91dHB1dHMgPSBkZXB0aHdpc2VDb252MmQoXG4gICAgICAgICAgaW5wdXRzLCB0aGlzLmRlcHRod2lzZUtlcm5lbC5yZWFkKCksIHRoaXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAgIHRoaXMucGFkZGluZywgdGhpcy5kYXRhRm9ybWF0LCBudWxsKTtcbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBzdXBwb3J0IGZvciBkaWxhdGlvbi5cbiAgICAgIGlmICh0aGlzLnVzZUJpYXMpIHtcbiAgICAgICAgb3V0cHV0cyA9IEsuYmlhc0FkZChvdXRwdXRzLCB0aGlzLmJpYXMucmVhZCgpLCB0aGlzLmRhdGFGb3JtYXQpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIG91dHB1dHMgPSB0aGlzLmFjdGl2YXRpb24uYXBwbHkob3V0cHV0cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0cztcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBjb25zdCByb3dzID1cbiAgICAgICAgdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyBpbnB1dFNoYXBlWzJdIDogaW5wdXRTaGFwZVsxXTtcbiAgICBjb25zdCBjb2xzID1cbiAgICAgICAgdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyBpbnB1dFNoYXBlWzNdIDogaW5wdXRTaGFwZVsyXTtcbiAgICBjb25zdCBvdXRGaWx0ZXJzID0gdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgP1xuICAgICAgICBpbnB1dFNoYXBlWzFdICogdGhpcy5kZXB0aE11bHRpcGxpZXIgOlxuICAgICAgICBpbnB1dFNoYXBlWzNdICogdGhpcy5kZXB0aE11bHRpcGxpZXI7XG4gICAgY29uc3Qgb3V0Um93cyA9IGNvbnZPdXRwdXRMZW5ndGgoXG4gICAgICAgIHJvd3MsIHRoaXMua2VybmVsU2l6ZVswXSwgdGhpcy5wYWRkaW5nLCB0aGlzLnN0cmlkZXNbMF0pO1xuICAgIGNvbnN0IG91dENvbHMgPSBjb252T3V0cHV0TGVuZ3RoKFxuICAgICAgICBjb2xzLCB0aGlzLmtlcm5lbFNpemVbMV0sIHRoaXMucGFkZGluZywgdGhpcy5zdHJpZGVzWzFdKTtcbiAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgb3V0RmlsdGVycywgb3V0Um93cywgb3V0Q29sc107XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEluIHRoaXMgY2FzZSwgYXNzdW1lICdjaGFubmVsc0xhc3QnLlxuICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBvdXRSb3dzLCBvdXRDb2xzLCBvdXRGaWx0ZXJzXTtcbiAgICB9XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBjb25maWdbJ2RlcHRoTXVsdGlwbGllciddID0gdGhpcy5kZXB0aE11bHRpcGxpZXI7XG4gICAgY29uZmlnWydkZXB0aHdpc2VJbml0aWFsaXplciddID1cbiAgICAgICAgc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5kZXB0aHdpc2VJbml0aWFsaXplcik7XG4gICAgY29uZmlnWydkZXB0aHdpc2VSZWd1bGFyaXplciddID1cbiAgICAgICAgc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5kZXB0aHdpc2VSZWd1bGFyaXplcik7XG4gICAgY29uZmlnWydkZXB0aHdpc2VDb25zdHJhaW50J10gPVxuICAgICAgICBzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuZGVwdGh3aXNlUmVndWxhcml6ZXIpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhEZXB0aHdpc2VDb252MkQpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Recurrent Neural Network Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy, util } from '@tensorflow/tfjs-core';\nimport { getActivation, serializeActivation } from '../activations';\nimport * as K from '../backend/tfjs_backend';\nimport { nameScope } from '../common';\nimport { getConstraint, serializeConstraint } from '../constraints';\nimport { InputSpec, SymbolicTensor } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { AttributeError, NotImplementedError, ValueError } from '../errors';\nimport { getInitializer, Initializer, Ones, serializeInitializer } from '../initializers';\nimport { getRegularizer, serializeRegularizer } from '../regularizers';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport * as math_utils from '../utils/math_utils';\nimport { getExactlyOneShape, getExactlyOneTensor, isArrayOfShapes } from '../utils/types_utils';\nimport { batchGetValue, batchSetValue } from '../variables';\nimport { deserialize } from './serialization';\n/**\n * Standardize `apply()` args to a single list of tensor inputs.\n *\n * When running a model loaded from file, the input tensors `initialState` and\n * `constants` are passed to `RNN.apply()` as part of `inputs` instead of the\n * dedicated kwargs fields. `inputs` consists of\n * `[inputs, initialState0, initialState1, ..., constant0, constant1]` in this\n * case.\n * This method makes sure that arguments are\n * separated and that `initialState` and `constants` are `Array`s of tensors\n * (or None).\n *\n * @param inputs Tensor or `Array` of  tensors.\n * @param initialState Tensor or `Array` of tensors or `null`/`undefined`.\n * @param constants Tensor or `Array` of tensors or `null`/`undefined`.\n * @returns An object consisting of\n *   inputs: A tensor.\n *   initialState: `Array` of tensors or `null`.\n *   constants: `Array` of tensors or `null`.\n * @throws ValueError, if `inputs` is an `Array` but either `initialState` or\n *   `constants` is provided.\n */\nexport function standardizeArgs(inputs, initialState, constants, numConstants) {\n    if (Array.isArray(inputs)) {\n        if (initialState != null || constants != null) {\n            throw new ValueError('When inputs is an array, neither initialState or constants ' +\n                'should be provided');\n        }\n        if (numConstants != null) {\n            constants = inputs.slice(inputs.length - numConstants, inputs.length);\n            inputs = inputs.slice(0, inputs.length - numConstants);\n        }\n        if (inputs.length > 1) {\n            initialState = inputs.slice(1, inputs.length);\n        }\n        inputs = inputs[0];\n    }\n    function toListOrNull(x) {\n        if (x == null || Array.isArray(x)) {\n            return x;\n        }\n        else {\n            return [x];\n        }\n    }\n    initialState = toListOrNull(initialState);\n    constants = toListOrNull(constants);\n    return { inputs, initialState, constants };\n}\n/**\n * Iterates over the time dimension of a tensor.\n *\n * @param stepFunction RNN step function.\n *   Parameters:\n *     inputs: tensor with shape `[samples, ...]` (no time dimension),\n *       representing input for the batch of samples at a certain time step.\n *     states: an Array of tensors.\n *   Returns:\n *     outputs: tensor with shape `[samples, outputDim]` (no time dimension).\n *     newStates: list of tensors, same length and shapes as `states`. The first\n *       state in the list must be the output tensor at the previous timestep.\n * @param inputs Tensor of temporal data of shape `[samples, time, ...]` (at\n *   least 3D).\n * @param initialStates Tensor with shape `[samples, outputDim]` (no time\n *   dimension), containing the initial values of the states used in the step\n *   function.\n * @param goBackwards If `true`, do the iteration over the time dimension in\n *   reverse order and return the reversed sequence.\n * @param mask Binary tensor with shape `[sample, time, 1]`, with a zero for\n *   every element that is masked.\n * @param constants An Array of constant values passed at each step.\n * @param unroll Whether to unroll the RNN or to use a symbolic loop. *Not*\n *   applicable to this imperative deeplearn.js backend. Its value is ignored.\n * @param needPerStepOutputs Whether the per-step outputs are to be\n *   concatenated into a single tensor and returned (as the second return\n *   value). Default: `false`. This arg is included so that the relatively\n *   expensive concatenation of the stepwise outputs can be omitted unless\n *   the stepwise outputs need to be kept (e.g., for an LSTM layer of which\n *   `returnSequence` is `true`.)\n * @returns An Array: `[lastOutput, outputs, newStates]`.\n *   lastOutput: the lastest output of the RNN, of shape `[samples, ...]`.\n *   outputs: tensor with shape `[samples, time, ...]` where each entry\n *     `output[s, t]` is the output of the step function at time `t` for sample\n *     `s`. This return value is provided if and only if the\n *     `needPerStepOutputs` is set as `true`. If it is set as `false`, this\n *     return value will be `undefined`.\n *   newStates: Array of tensors, latest states returned by the step function,\n *      of shape `(samples, ...)`.\n * @throws ValueError If input dimension is less than 3.\n *\n * TODO(nielsene): This needs to be tidy-ed.\n */\nexport function rnn(stepFunction, inputs, initialStates, goBackwards = false, mask, constants, unroll = false, needPerStepOutputs = false) {\n    return tfc.tidy(() => {\n        const ndim = inputs.shape.length;\n        if (ndim < 3) {\n            throw new ValueError(`Input should be at least 3D, but is ${ndim}D.`);\n        }\n        // Transpose to time-major, i.e., from [batch, time, ...] to [time, batch,\n        // ...].\n        const axes = [1, 0].concat(math_utils.range(2, ndim));\n        inputs = tfc.transpose(inputs, axes);\n        if (constants != null) {\n            throw new NotImplementedError('The rnn() functoin of the deeplearn.js backend does not support ' +\n                'constants yet.');\n        }\n        // Porting Note: the unroll option is ignored by the imperative backend.\n        if (unroll) {\n            console.warn('Backend rnn(): the unroll = true option is not applicable to the ' +\n                'imperative deeplearn.js backend.');\n        }\n        if (mask != null) {\n            mask = tfc.cast(tfc.cast(mask, 'bool'), 'float32');\n            if (mask.rank === ndim - 1) {\n                mask = tfc.expandDims(mask, -1);\n            }\n            mask = tfc.transpose(mask, axes);\n        }\n        if (goBackwards) {\n            inputs = tfc.reverse(inputs, 0);\n            if (mask != null) {\n                mask = tfc.reverse(mask, 0);\n            }\n        }\n        // Porting Note: PyKeras with TensorFlow backend uses a symbolic loop\n        //   (tf.while_loop). But for the imperative deeplearn.js backend, we just\n        //   use the usual TypeScript control flow to iterate over the time steps in\n        //   the inputs.\n        // Porting Note: PyKeras patches a \"_use_learning_phase\" attribute to\n        // outputs.\n        //   This is not idiomatic in TypeScript. The info regarding whether we are\n        //   in a learning (i.e., training) phase for RNN is passed in a different\n        //   way.\n        const perStepOutputs = [];\n        let lastOutput;\n        let states = initialStates;\n        const timeSteps = inputs.shape[0];\n        const perStepInputs = tfc.unstack(inputs);\n        let perStepMasks;\n        if (mask != null) {\n            perStepMasks = tfc.unstack(mask);\n        }\n        for (let t = 0; t < timeSteps; ++t) {\n            const currentInput = perStepInputs[t];\n            const stepOutputs = tfc.tidy(() => stepFunction(currentInput, states));\n            if (mask == null) {\n                lastOutput = stepOutputs[0];\n                states = stepOutputs[1];\n            }\n            else {\n                const maskedOutputs = tfc.tidy(() => {\n                    const stepMask = perStepMasks[t];\n                    const negStepMask = tfc.sub(tfc.onesLike(stepMask), stepMask);\n                    // TODO(cais): Would tfc.where() be better for performance?\n                    const output = tfc.add(tfc.mul(stepOutputs[0], stepMask), tfc.mul(states[0], negStepMask));\n                    const newStates = states.map((state, i) => {\n                        return tfc.add(tfc.mul(stepOutputs[1][i], stepMask), tfc.mul(state, negStepMask));\n                    });\n                    return { output, newStates };\n                });\n                lastOutput = maskedOutputs.output;\n                states = maskedOutputs.newStates;\n            }\n            if (needPerStepOutputs) {\n                perStepOutputs.push(lastOutput);\n            }\n        }\n        let outputs;\n        if (needPerStepOutputs) {\n            const axis = 1;\n            outputs = tfc.stack(perStepOutputs, axis);\n        }\n        return [lastOutput, outputs, states];\n    });\n}\nexport class RNN extends Layer {\n    constructor(args) {\n        super(args);\n        let cell;\n        if (args.cell == null) {\n            throw new ValueError('cell property is missing for the constructor of RNN.');\n        }\n        else if (Array.isArray(args.cell)) {\n            cell = new StackedRNNCells({ cells: args.cell });\n        }\n        else {\n            cell = args.cell;\n        }\n        if (cell.stateSize == null) {\n            throw new ValueError('The RNN cell should have an attribute `stateSize` (tuple of ' +\n                'integers, one integer per RNN state).');\n        }\n        this.cell = cell;\n        this.returnSequences =\n            args.returnSequences == null ? false : args.returnSequences;\n        this.returnState = args.returnState == null ? false : args.returnState;\n        this.goBackwards = args.goBackwards == null ? false : args.goBackwards;\n        this._stateful = args.stateful == null ? false : args.stateful;\n        this.unroll = args.unroll == null ? false : args.unroll;\n        this.supportsMasking = true;\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n        this.stateSpec = null;\n        this.states_ = null;\n        // TODO(cais): Add constantsSpec and numConstants.\n        this.numConstants = null;\n        // TODO(cais): Look into the use of initial_state in the kwargs of the\n        //   constructor.\n        this.keptStates = [];\n    }\n    // Porting Note: This is the equivalent of `RNN.states` property getter in\n    //   PyKeras.\n    getStates() {\n        if (this.states_ == null) {\n            const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;\n            return math_utils.range(0, numStates).map(x => null);\n        }\n        else {\n            return this.states_;\n        }\n    }\n    // Porting Note: This is the equivalent of the `RNN.states` property setter in\n    //   PyKeras.\n    setStates(states) {\n        this.states_ = states;\n    }\n    computeOutputShape(inputShape) {\n        if (isArrayOfShapes(inputShape)) {\n            inputShape = inputShape[0];\n        }\n        inputShape = inputShape;\n        // TODO(cais): Remove the casting once stacked RNN cells become supported.\n        let stateSize = this.cell.stateSize;\n        if (!Array.isArray(stateSize)) {\n            stateSize = [stateSize];\n        }\n        const outputDim = stateSize[0];\n        let outputShape;\n        if (this.returnSequences) {\n            outputShape = [inputShape[0], inputShape[1], outputDim];\n        }\n        else {\n            outputShape = [inputShape[0], outputDim];\n        }\n        if (this.returnState) {\n            const stateShape = [];\n            for (const dim of stateSize) {\n                stateShape.push([inputShape[0], dim]);\n            }\n            return [outputShape].concat(stateShape);\n        }\n        else {\n            return outputShape;\n        }\n    }\n    computeMask(inputs, mask) {\n        return tfc.tidy(() => {\n            if (Array.isArray(mask)) {\n                mask = mask[0];\n            }\n            const outputMask = this.returnSequences ? mask : null;\n            if (this.returnState) {\n                const stateMask = this.states.map(s => null);\n                return [outputMask].concat(stateMask);\n            }\n            else {\n                return outputMask;\n            }\n        });\n    }\n    /**\n     * Get the current state tensors of the RNN.\n     *\n     * If the state hasn't been set, return an array of `null`s of the correct\n     * length.\n     */\n    get states() {\n        if (this.states_ == null) {\n            const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;\n            const output = [];\n            for (let i = 0; i < numStates; ++i) {\n                output.push(null);\n            }\n            return output;\n        }\n        else {\n            return this.states_;\n        }\n    }\n    set states(s) {\n        this.states_ = s;\n    }\n    build(inputShape) {\n        // Note inputShape will be an Array of Shapes of initial states and\n        // constants if these are passed in apply().\n        const constantShape = null;\n        if (this.numConstants != null) {\n            throw new NotImplementedError('Constants support is not implemented in RNN yet.');\n        }\n        if (isArrayOfShapes(inputShape)) {\n            inputShape = inputShape[0];\n        }\n        inputShape = inputShape;\n        const batchSize = this.stateful ? inputShape[0] : null;\n        const inputDim = inputShape.slice(2);\n        this.inputSpec[0] = new InputSpec({ shape: [batchSize, null, ...inputDim] });\n        // Allow cell (if RNNCell Layer) to build before we set or validate\n        // stateSpec.\n        const stepInputShape = [inputShape[0]].concat(inputShape.slice(2));\n        if (constantShape != null) {\n            throw new NotImplementedError('Constants support is not implemented in RNN yet.');\n        }\n        else {\n            this.cell.build(stepInputShape);\n        }\n        // Set or validate stateSpec.\n        let stateSize;\n        if (Array.isArray(this.cell.stateSize)) {\n            stateSize = this.cell.stateSize;\n        }\n        else {\n            stateSize = [this.cell.stateSize];\n        }\n        if (this.stateSpec != null) {\n            if (!util.arraysEqual(this.stateSpec.map(spec => spec.shape[spec.shape.length - 1]), stateSize)) {\n                throw new ValueError(`An initialState was passed that is not compatible with ` +\n                    `cell.stateSize. Received stateSpec=${this.stateSpec}; ` +\n                    `However cell.stateSize is ${this.cell.stateSize}`);\n            }\n        }\n        else {\n            this.stateSpec =\n                stateSize.map(dim => new InputSpec({ shape: [null, dim] }));\n        }\n        if (this.stateful) {\n            this.resetStates();\n        }\n    }\n    /**\n     * Reset the state tensors of the RNN.\n     *\n     * If the `states` argument is `undefined` or `null`, will set the\n     * state tensor(s) of the RNN to all-zero tensors of the appropriate\n     * shape(s).\n     *\n     * If `states` is provided, will set the state tensors of the RNN to its\n     * value.\n     *\n     * @param states Optional externally-provided initial states.\n     * @param training Whether this call is done during training. For stateful\n     *   RNNs, this affects whether the old states are kept or discarded. In\n     *   particular, if `training` is `true`, the old states will be kept so\n     *   that subsequent backpropgataion through time (BPTT) may work properly.\n     *   Else, the old states will be discarded.\n     */\n    resetStates(states, training = false) {\n        tidy(() => {\n            if (!this.stateful) {\n                throw new AttributeError('Cannot call resetStates() on an RNN Layer that is not stateful.');\n            }\n            const batchSize = this.inputSpec[0].shape[0];\n            if (batchSize == null) {\n                throw new ValueError('If an RNN is stateful, it needs to know its batch size. Specify ' +\n                    'the batch size of your input tensors: \\n' +\n                    '- If using a Sequential model, specify the batch size by ' +\n                    'passing a `batchInputShape` option to your first layer.\\n' +\n                    '- If using the functional API, specify the batch size by ' +\n                    'passing a `batchShape` option to your Input layer.');\n            }\n            // Initialize state if null.\n            if (this.states_ == null) {\n                if (Array.isArray(this.cell.stateSize)) {\n                    this.states_ =\n                        this.cell.stateSize.map(dim => tfc.zeros([batchSize, dim]));\n                }\n                else {\n                    this.states_ = [tfc.zeros([batchSize, this.cell.stateSize])];\n                }\n            }\n            else if (states == null) {\n                // Dispose old state tensors.\n                tfc.dispose(this.states_);\n                // For stateful RNNs, fully dispose kept old states.\n                if (this.keptStates != null) {\n                    tfc.dispose(this.keptStates);\n                    this.keptStates = [];\n                }\n                if (Array.isArray(this.cell.stateSize)) {\n                    this.states_ =\n                        this.cell.stateSize.map(dim => tfc.zeros([batchSize, dim]));\n                }\n                else {\n                    this.states_[0] = tfc.zeros([batchSize, this.cell.stateSize]);\n                }\n            }\n            else {\n                if (!Array.isArray(states)) {\n                    states = [states];\n                }\n                if (states.length !== this.states_.length) {\n                    throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), ` +\n                        `but it received ${states.length} state value(s). Input ` +\n                        `received: ${states}`);\n                }\n                if (training === true) {\n                    // Store old state tensors for complete disposal later, i.e., during\n                    // the next no-arg call to this method. We do not dispose the old\n                    // states immediately because that BPTT (among other things) require\n                    // them.\n                    this.keptStates.push(this.states_.slice());\n                }\n                else {\n                    tfc.dispose(this.states_);\n                }\n                for (let index = 0; index < this.states_.length; ++index) {\n                    const value = states[index];\n                    const dim = Array.isArray(this.cell.stateSize) ?\n                        this.cell.stateSize[index] :\n                        this.cell.stateSize;\n                    const expectedShape = [batchSize, dim];\n                    if (!util.arraysEqual(value.shape, expectedShape)) {\n                        throw new ValueError(`State ${index} is incompatible with layer ${this.name}: ` +\n                            `expected shape=${expectedShape}, received shape=${value.shape}`);\n                    }\n                    this.states_[index] = value;\n                }\n            }\n            this.states_ = this.states_.map(state => tfc.keep(state.clone()));\n        });\n    }\n    apply(inputs, kwargs) {\n        // TODO(cais): Figure out whether initialState is in kwargs or inputs.\n        let initialState = kwargs == null ? null : kwargs['initialState'];\n        let constants = kwargs == null ? null : kwargs['constants'];\n        if (kwargs == null) {\n            kwargs = {};\n        }\n        const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);\n        inputs = standardized.inputs;\n        initialState = standardized.initialState;\n        constants = standardized.constants;\n        // If any of `initial_state` or `constants` are specified and are\n        // `tf.SymbolicTensor`s, then add them to the inputs and temporarily modify\n        // the input_spec to include them.\n        let additionalInputs = [];\n        let additionalSpecs = [];\n        if (initialState != null) {\n            kwargs['initialState'] = initialState;\n            additionalInputs = additionalInputs.concat(initialState);\n            this.stateSpec = [];\n            for (const state of initialState) {\n                this.stateSpec.push(new InputSpec({ shape: state.shape }));\n            }\n            // TODO(cais): Use the following instead.\n            // this.stateSpec = initialState.map(state => new InputSpec({shape:\n            // state.shape}));\n            additionalSpecs = additionalSpecs.concat(this.stateSpec);\n        }\n        if (constants != null) {\n            kwargs['constants'] = constants;\n            additionalInputs = additionalInputs.concat(constants);\n            // TODO(cais): Add this.constantsSpec.\n            this.numConstants = constants.length;\n        }\n        const isTensor = additionalInputs[0] instanceof SymbolicTensor;\n        if (isTensor) {\n            // Compute full input spec, including state and constants.\n            const fullInput = [inputs].concat(additionalInputs);\n            const fullInputSpec = this.inputSpec.concat(additionalSpecs);\n            // Perform the call with temporarily replaced inputSpec.\n            const originalInputSpec = this.inputSpec;\n            this.inputSpec = fullInputSpec;\n            const output = super.apply(fullInput, kwargs);\n            this.inputSpec = originalInputSpec;\n            return output;\n        }\n        else {\n            return super.apply(inputs, kwargs);\n        }\n    }\n    // tslint:disable-next-line:no-any\n    call(inputs, kwargs) {\n        // Input shape: `[samples, time (padded with zeros), input_dim]`.\n        // Note that the .build() method of subclasses **must** define\n        // this.inputSpec and this.stateSpec owith complete input shapes.\n        return tidy(() => {\n            const mask = kwargs == null ? null : kwargs['mask'];\n            const training = kwargs == null ? null : kwargs['training'];\n            let initialState = kwargs == null ? null : kwargs['initialState'];\n            inputs = getExactlyOneTensor(inputs);\n            if (initialState == null) {\n                if (this.stateful) {\n                    initialState = this.states_;\n                }\n                else {\n                    initialState = this.getInitialState(inputs);\n                }\n            }\n            const numStates = Array.isArray(this.cell.stateSize) ? this.cell.stateSize.length : 1;\n            if (initialState.length !== numStates) {\n                throw new ValueError(`RNN Layer has ${numStates} state(s) but was passed ` +\n                    `${initialState.length} initial state(s).`);\n            }\n            if (this.unroll) {\n                console.warn('Ignoring unroll = true for RNN layer, due to imperative backend.');\n            }\n            const cellCallKwargs = { training };\n            // TODO(cais): Add support for constants.\n            const step = (inputs, states) => {\n                // `inputs` and `states` are concatenated to form a single `Array` of\n                // `tf.Tensor`s as the input to `cell.call()`.\n                const outputs = this.cell.call([inputs].concat(states), cellCallKwargs);\n                // Marshall the return value into output and new states.\n                return [outputs[0], outputs.slice(1)];\n            };\n            // TODO(cais): Add support for constants.\n            const rnnOutputs = rnn(step, inputs, initialState, this.goBackwards, mask, null, this.unroll, this.returnSequences);\n            const lastOutput = rnnOutputs[0];\n            const outputs = rnnOutputs[1];\n            const states = rnnOutputs[2];\n            if (this.stateful) {\n                this.resetStates(states, training);\n            }\n            const output = this.returnSequences ? outputs : lastOutput;\n            // TODO(cais): Porperty set learning phase flag.\n            if (this.returnState) {\n                return [output].concat(states);\n            }\n            else {\n                return output;\n            }\n        });\n    }\n    getInitialState(inputs) {\n        return tidy(() => {\n            // Build an all-zero tensor of shape [samples, outputDim].\n            // [Samples, timeSteps, inputDim].\n            let initialState = tfc.zeros(inputs.shape);\n            // [Samples].\n            initialState = tfc.sum(initialState, [1, 2]);\n            initialState = K.expandDims(initialState); // [Samples, 1].\n            if (Array.isArray(this.cell.stateSize)) {\n                return this.cell.stateSize.map(dim => dim > 1 ? K.tile(initialState, [1, dim]) : initialState);\n            }\n            else {\n                return this.cell.stateSize > 1 ?\n                    [K.tile(initialState, [1, this.cell.stateSize])] :\n                    [initialState];\n            }\n        });\n    }\n    get trainableWeights() {\n        if (!this.trainable) {\n            return [];\n        }\n        // Porting Note: In TypeScript, `this` is always an instance of `Layer`.\n        return this.cell.trainableWeights;\n    }\n    get nonTrainableWeights() {\n        // Porting Note: In TypeScript, `this` is always an instance of `Layer`.\n        if (!this.trainable) {\n            return this.cell.weights;\n        }\n        return this.cell.nonTrainableWeights;\n    }\n    setFastWeightInitDuringBuild(value) {\n        super.setFastWeightInitDuringBuild(value);\n        if (this.cell != null) {\n            this.cell.setFastWeightInitDuringBuild(value);\n        }\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const config = {\n            returnSequences: this.returnSequences,\n            returnState: this.returnState,\n            goBackwards: this.goBackwards,\n            stateful: this.stateful,\n            unroll: this.unroll,\n        };\n        if (this.numConstants != null) {\n            config['numConstants'] = this.numConstants;\n        }\n        const cellConfig = this.cell.getConfig();\n        if (this.getClassName() === RNN.className) {\n            config['cell'] = {\n                'className': this.cell.getClassName(),\n                'config': cellConfig,\n            };\n        }\n        // this order is necessary, to prevent cell name from replacing layer name\n        return Object.assign({}, cellConfig, baseConfig, config);\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}) {\n        const cellConfig = config['cell'];\n        const cell = deserialize(cellConfig, customObjects);\n        return new cls(Object.assign(config, { cell }));\n    }\n}\n/** @nocollapse */\nRNN.className = 'RNN';\nserialization.registerClass(RNN);\n// Porting Note: This is a common parent class for RNN cells. There is no\n// equivalent of this in PyKeras. Having a common parent class forgoes the\n//  need for `has_attr(cell, ...)` checks or its TypeScript equivalent.\n/**\n * An RNNCell layer.\n *\n * @doc {heading: 'Layers', subheading: 'Classes'}\n */\nexport class RNNCell extends Layer {\n}\nexport class SimpleRNNCell extends RNNCell {\n    constructor(args) {\n        super(args);\n        this.DEFAULT_ACTIVATION = 'tanh';\n        this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n        this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        this.units = args.units;\n        assertPositiveInteger(this.units, `units`);\n        this.activation = getActivation(args.activation == null ? this.DEFAULT_ACTIVATION : args.activation);\n        this.useBias = args.useBias == null ? true : args.useBias;\n        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n        this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);\n        this.biasInitializer =\n            getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);\n        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);\n        this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);\n        this.biasRegularizer = getRegularizer(args.biasRegularizer);\n        this.kernelConstraint = getConstraint(args.kernelConstraint);\n        this.recurrentConstraint = getConstraint(args.recurrentConstraint);\n        this.biasConstraint = getConstraint(args.biasConstraint);\n        this.dropout = math_utils.min([1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n        this.recurrentDropout = math_utils.min([\n            1,\n            math_utils.max([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n        ]);\n        this.dropoutFunc = args.dropoutFunc;\n        this.stateSize = this.units;\n        this.dropoutMask = null;\n        this.recurrentDropoutMask = null;\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        // TODO(cais): Use regularizer.\n        this.kernel = this.addWeight('kernel', [inputShape[inputShape.length - 1], this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        else {\n            this.bias = null;\n        }\n        this.built = true;\n    }\n    // Porting Note: PyKeras' equivalent of this method takes two tensor inputs:\n    //   `inputs` and `states`. Here, the two tensors are combined into an\n    //   `Tensor[]` Array as the first input argument.\n    //   Similarly, PyKeras' equivalent of this method returns two values:\n    //    `output` and `[output]`. Here the two are combined into one length-2\n    //    `Tensor[]`, consisting of `output` repeated.\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = inputs;\n            if (inputs.length !== 2) {\n                throw new ValueError(`SimpleRNNCell expects 2 input Tensors, got ${inputs.length}.`);\n            }\n            let prevOutput = inputs[1];\n            inputs = inputs[0];\n            const training = kwargs['training'] == null ? false : kwargs['training'];\n            if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n                this.dropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(inputs),\n                    rate: this.dropout,\n                    training,\n                    dropoutFunc: this.dropoutFunc,\n                });\n            }\n            if (0 < this.recurrentDropout && this.recurrentDropout < 1 &&\n                this.recurrentDropoutMask == null) {\n                this.recurrentDropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(prevOutput),\n                    rate: this.recurrentDropout,\n                    training,\n                    dropoutFunc: this.dropoutFunc,\n                });\n            }\n            let h;\n            const dpMask = this.dropoutMask;\n            const recDpMask = this.recurrentDropoutMask;\n            if (dpMask != null) {\n                h = K.dot(tfc.mul(inputs, dpMask), this.kernel.read());\n            }\n            else {\n                h = K.dot(inputs, this.kernel.read());\n            }\n            if (this.bias != null) {\n                h = K.biasAdd(h, this.bias.read());\n            }\n            if (recDpMask != null) {\n                prevOutput = tfc.mul(prevOutput, recDpMask);\n            }\n            let output = tfc.add(h, K.dot(prevOutput, this.recurrentKernel.read()));\n            if (this.activation != null) {\n                output = this.activation.apply(output);\n            }\n            // TODO(cais): Properly set learning phase on output tensor?\n            return [output, output];\n        });\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const config = {\n            units: this.units,\n            activation: serializeActivation(this.activation),\n            useBias: this.useBias,\n            kernelInitializer: serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n            biasInitializer: serializeInitializer(this.biasInitializer),\n            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n            biasConstraint: serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n        };\n        return Object.assign({}, baseConfig, config);\n    }\n}\n/** @nocollapse */\nSimpleRNNCell.className = 'SimpleRNNCell';\nserialization.registerClass(SimpleRNNCell);\nexport class SimpleRNN extends RNN {\n    constructor(args) {\n        args.cell = new SimpleRNNCell(args);\n        super(args);\n        // TODO(cais): Add activityRegularizer.\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            if (this.cell.dropoutMask != null) {\n                tfc.dispose(this.cell.dropoutMask);\n                this.cell.dropoutMask = null;\n            }\n            if (this.cell.recurrentDropoutMask != null) {\n                tfc.dispose(this.cell.recurrentDropoutMask);\n                this.cell.recurrentDropoutMask = null;\n            }\n            const mask = kwargs == null ? null : kwargs['mask'];\n            const training = kwargs == null ? null : kwargs['training'];\n            const initialState = kwargs == null ? null : kwargs['initialState'];\n            return super.call(inputs, { mask, training, initialState });\n        });\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        return new cls(config);\n    }\n}\n/** @nocollapse */\nSimpleRNN.className = 'SimpleRNN';\nserialization.registerClass(SimpleRNN);\nexport class GRUCell extends RNNCell {\n    constructor(args) {\n        super(args);\n        this.DEFAULT_ACTIVATION = 'tanh';\n        this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';\n        this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n        this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        if (args.resetAfter) {\n            throw new ValueError(`GRUCell does not support reset_after parameter set to true.`);\n        }\n        this.units = args.units;\n        assertPositiveInteger(this.units, 'units');\n        this.activation = getActivation(args.activation === undefined ? this.DEFAULT_ACTIVATION :\n            args.activation);\n        this.recurrentActivation = getActivation(args.recurrentActivation === undefined ?\n            this.DEFAULT_RECURRENT_ACTIVATION :\n            args.recurrentActivation);\n        this.useBias = args.useBias == null ? true : args.useBias;\n        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n        this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);\n        this.biasInitializer =\n            getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);\n        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);\n        this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);\n        this.biasRegularizer = getRegularizer(args.biasRegularizer);\n        this.kernelConstraint = getConstraint(args.kernelConstraint);\n        this.recurrentConstraint = getConstraint(args.recurrentConstraint);\n        this.biasConstraint = getConstraint(args.biasConstraint);\n        this.dropout = math_utils.min([1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n        this.recurrentDropout = math_utils.min([\n            1,\n            math_utils.max([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n        ]);\n        this.dropoutFunc = args.dropoutFunc;\n        this.implementation = args.implementation;\n        this.stateSize = this.units;\n        this.dropoutMask = null;\n        this.recurrentDropoutMask = null;\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const inputDim = inputShape[inputShape.length - 1];\n        this.kernel = this.addWeight('kernel', [inputDim, this.units * 3], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 3], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n        if (this.useBias) {\n            this.bias = this.addWeight('bias', [this.units * 3], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        else {\n            this.bias = null;\n        }\n        // Porting Notes: Unlike the PyKeras implementation, we perform slicing\n        //   of the weights and bias in the call() method, at execution time.\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = inputs;\n            if (inputs.length !== 2) {\n                throw new ValueError(`GRUCell expects 2 input Tensors (inputs, h, c), got ` +\n                    `${inputs.length}.`);\n            }\n            const training = kwargs['training'] == null ? false : kwargs['training'];\n            let hTMinus1 = inputs[1]; // Previous memory state.\n            inputs = inputs[0];\n            // Note: For superior performance, TensorFlow.js always uses\n            // implementation 2, regardless of the actual value of\n            // config.implementation.\n            if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n                this.dropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(inputs),\n                    rate: this.dropout,\n                    training,\n                    count: 3,\n                    dropoutFunc: this.dropoutFunc,\n                });\n            }\n            if (0 < this.recurrentDropout && this.recurrentDropout < 1 &&\n                this.recurrentDropoutMask == null) {\n                this.recurrentDropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(hTMinus1),\n                    rate: this.recurrentDropout,\n                    training,\n                    count: 3,\n                    dropoutFunc: this.dropoutFunc,\n                });\n            }\n            const dpMask = this.dropoutMask;\n            const recDpMask = this.recurrentDropoutMask;\n            let z;\n            let r;\n            let hh;\n            if (0 < this.dropout && this.dropout < 1) {\n                inputs = tfc.mul(inputs, dpMask[0]);\n            }\n            let matrixX = K.dot(inputs, this.kernel.read());\n            if (this.useBias) {\n                matrixX = K.biasAdd(matrixX, this.bias.read());\n            }\n            if (0 < this.recurrentDropout && this.recurrentDropout < 1) {\n                hTMinus1 = tfc.mul(hTMinus1, recDpMask[0]);\n            }\n            const recurrentKernelValue = this.recurrentKernel.read();\n            const [rk1, rk2] = tfc.split(recurrentKernelValue, [2 * this.units, this.units], recurrentKernelValue.rank - 1);\n            const matrixInner = K.dot(hTMinus1, rk1);\n            const [xZ, xR, xH] = tfc.split(matrixX, 3, matrixX.rank - 1);\n            const [recurrentZ, recurrentR] = tfc.split(matrixInner, 2, matrixInner.rank - 1);\n            z = this.recurrentActivation.apply(tfc.add(xZ, recurrentZ));\n            r = this.recurrentActivation.apply(tfc.add(xR, recurrentR));\n            const recurrentH = K.dot(tfc.mul(r, hTMinus1), rk2);\n            hh = this.activation.apply(tfc.add(xH, recurrentH));\n            const h = tfc.add(tfc.mul(z, hTMinus1), tfc.mul(tfc.add(1, tfc.neg(z)), hh));\n            // TODO(cais): Add use_learning_phase flag properly.\n            return [h, h];\n        });\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const config = {\n            units: this.units,\n            activation: serializeActivation(this.activation),\n            recurrentActivation: serializeActivation(this.recurrentActivation),\n            useBias: this.useBias,\n            kernelInitializer: serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n            biasInitializer: serializeInitializer(this.biasInitializer),\n            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n            biasConstraint: serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n            implementation: this.implementation,\n            resetAfter: false\n        };\n        return Object.assign({}, baseConfig, config);\n    }\n}\n/** @nocollapse */\nGRUCell.className = 'GRUCell';\nserialization.registerClass(GRUCell);\nexport class GRU extends RNN {\n    constructor(args) {\n        if (args.implementation === 0) {\n            console.warn('`implementation=0` has been deprecated, and now defaults to ' +\n                '`implementation=1`. Please update your layer call.');\n        }\n        args.cell = new GRUCell(args);\n        super(args);\n        // TODO(cais): Add activityRegularizer.\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            if (this.cell.dropoutMask != null) {\n                tfc.dispose(this.cell.dropoutMask);\n                this.cell.dropoutMask = null;\n            }\n            if (this.cell.recurrentDropoutMask != null) {\n                tfc.dispose(this.cell.recurrentDropoutMask);\n                this.cell.recurrentDropoutMask = null;\n            }\n            const mask = kwargs == null ? null : kwargs['mask'];\n            const training = kwargs == null ? null : kwargs['training'];\n            const initialState = kwargs == null ? null : kwargs['initialState'];\n            return super.call(inputs, { mask, training, initialState });\n        });\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        if (config['implmentation'] === 0) {\n            config['implementation'] = 1;\n        }\n        return new cls(config);\n    }\n}\n/** @nocollapse */\nGRU.className = 'GRU';\nserialization.registerClass(GRU);\nexport class LSTMCell extends RNNCell {\n    constructor(args) {\n        super(args);\n        this.DEFAULT_ACTIVATION = 'tanh';\n        this.DEFAULT_RECURRENT_ACTIVATION = 'hardSigmoid';\n        this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        this.DEFAULT_RECURRENT_INITIALIZER = 'orthogonal';\n        this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        this.units = args.units;\n        assertPositiveInteger(this.units, 'units');\n        this.activation = getActivation(args.activation === undefined ? this.DEFAULT_ACTIVATION :\n            args.activation);\n        this.recurrentActivation = getActivation(args.recurrentActivation === undefined ?\n            this.DEFAULT_RECURRENT_ACTIVATION :\n            args.recurrentActivation);\n        this.useBias = args.useBias == null ? true : args.useBias;\n        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n        this.recurrentInitializer = getInitializer(args.recurrentInitializer || this.DEFAULT_RECURRENT_INITIALIZER);\n        this.biasInitializer =\n            getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);\n        this.unitForgetBias = args.unitForgetBias;\n        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);\n        this.recurrentRegularizer = getRegularizer(args.recurrentRegularizer);\n        this.biasRegularizer = getRegularizer(args.biasRegularizer);\n        this.kernelConstraint = getConstraint(args.kernelConstraint);\n        this.recurrentConstraint = getConstraint(args.recurrentConstraint);\n        this.biasConstraint = getConstraint(args.biasConstraint);\n        this.dropout = math_utils.min([1, math_utils.max([0, args.dropout == null ? 0 : args.dropout])]);\n        this.recurrentDropout = math_utils.min([\n            1,\n            math_utils.max([0, args.recurrentDropout == null ? 0 : args.recurrentDropout])\n        ]);\n        this.dropoutFunc = args.dropoutFunc;\n        this.implementation = args.implementation;\n        this.stateSize = [this.units, this.units];\n        this.dropoutMask = null;\n        this.recurrentDropoutMask = null;\n    }\n    build(inputShape) {\n        var _a;\n        inputShape = getExactlyOneShape(inputShape);\n        const inputDim = inputShape[inputShape.length - 1];\n        this.kernel = this.addWeight('kernel', [inputDim, this.units * 4], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        this.recurrentKernel = this.addWeight('recurrent_kernel', [this.units, this.units * 4], null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n        let biasInitializer;\n        if (this.useBias) {\n            if (this.unitForgetBias) {\n                const capturedBiasInit = this.biasInitializer;\n                const capturedUnits = this.units;\n                biasInitializer = new (_a = class CustomInit extends Initializer {\n                        apply(shape, dtype) {\n                            // TODO(cais): More informative variable names?\n                            const bI = capturedBiasInit.apply([capturedUnits]);\n                            const bF = (new Ones()).apply([capturedUnits]);\n                            const bCAndH = capturedBiasInit.apply([capturedUnits * 2]);\n                            return K.concatAlongFirstAxis(K.concatAlongFirstAxis(bI, bF), bCAndH);\n                        }\n                    },\n                    /** @nocollapse */\n                    _a.className = 'CustomInit',\n                    _a)();\n            }\n            else {\n                biasInitializer = this.biasInitializer;\n            }\n            this.bias = this.addWeight('bias', [this.units * 4], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        else {\n            this.bias = null;\n        }\n        // Porting Notes: Unlike the PyKeras implementation, we perform slicing\n        //   of the weights and bias in the call() method, at execution time.\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const training = kwargs['training'] == null ? false : kwargs['training'];\n            inputs = inputs;\n            if (inputs.length !== 3) {\n                throw new ValueError(`LSTMCell expects 3 input Tensors (inputs, h, c), got ` +\n                    `${inputs.length}.`);\n            }\n            let hTMinus1 = inputs[1]; // Previous memory state.\n            const cTMinus1 = inputs[2]; // Previous carry state.\n            inputs = inputs[0];\n            if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n                this.dropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(inputs),\n                    rate: this.dropout,\n                    training,\n                    count: 4,\n                    dropoutFunc: this.dropoutFunc\n                });\n            }\n            if (0 < this.recurrentDropout && this.recurrentDropout < 1 &&\n                this.recurrentDropoutMask == null) {\n                this.recurrentDropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(hTMinus1),\n                    rate: this.recurrentDropout,\n                    training,\n                    count: 4,\n                    dropoutFunc: this.dropoutFunc\n                });\n            }\n            const dpMask = this.dropoutMask;\n            const recDpMask = this.recurrentDropoutMask;\n            // Note: For superior performance, TensorFlow.js always uses\n            // implementation 2 regardless of the actual value of\n            // config.implementation.\n            let i;\n            let f;\n            let c;\n            let o;\n            if (0 < this.dropout && this.dropout < 1) {\n                inputs = tfc.mul(inputs, dpMask[0]);\n            }\n            let z = K.dot(inputs, this.kernel.read());\n            if (0 < this.recurrentDropout && this.recurrentDropout < 1) {\n                hTMinus1 = tfc.mul(hTMinus1, recDpMask[0]);\n            }\n            z = tfc.add(z, K.dot(hTMinus1, this.recurrentKernel.read()));\n            if (this.useBias) {\n                z = K.biasAdd(z, this.bias.read());\n            }\n            const [z0, z1, z2, z3] = tfc.split(z, 4, z.rank - 1);\n            i = this.recurrentActivation.apply(z0);\n            f = this.recurrentActivation.apply(z1);\n            c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, this.activation.apply(z2)));\n            o = this.recurrentActivation.apply(z3);\n            const h = tfc.mul(o, this.activation.apply(c));\n            // TODO(cais): Add use_learning_phase flag properly.\n            return [h, h, c];\n        });\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const config = {\n            units: this.units,\n            activation: serializeActivation(this.activation),\n            recurrentActivation: serializeActivation(this.recurrentActivation),\n            useBias: this.useBias,\n            kernelInitializer: serializeInitializer(this.kernelInitializer),\n            recurrentInitializer: serializeInitializer(this.recurrentInitializer),\n            biasInitializer: serializeInitializer(this.biasInitializer),\n            unitForgetBias: this.unitForgetBias,\n            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n            recurrentRegularizer: serializeRegularizer(this.recurrentRegularizer),\n            biasRegularizer: serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: serializeConstraint(this.kernelConstraint),\n            recurrentConstraint: serializeConstraint(this.recurrentConstraint),\n            biasConstraint: serializeConstraint(this.biasConstraint),\n            dropout: this.dropout,\n            recurrentDropout: this.recurrentDropout,\n            implementation: this.implementation,\n        };\n        return Object.assign({}, baseConfig, config);\n    }\n}\n/** @nocollapse */\nLSTMCell.className = 'LSTMCell';\nserialization.registerClass(LSTMCell);\nexport class LSTM extends RNN {\n    constructor(args) {\n        if (args.implementation === 0) {\n            console.warn('`implementation=0` has been deprecated, and now defaults to ' +\n                '`implementation=1`. Please update your layer call.');\n        }\n        args.cell = new LSTMCell(args);\n        super(args);\n        // TODO(cais): Add activityRegularizer.\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            if (this.cell.dropoutMask != null) {\n                tfc.dispose(this.cell.dropoutMask);\n                this.cell.dropoutMask = null;\n            }\n            if (this.cell.recurrentDropoutMask != null) {\n                tfc.dispose(this.cell.recurrentDropoutMask);\n                this.cell.recurrentDropoutMask = null;\n            }\n            const mask = kwargs == null ? null : kwargs['mask'];\n            const training = kwargs == null ? null : kwargs['training'];\n            const initialState = kwargs == null ? null : kwargs['initialState'];\n            return super.call(inputs, { mask, training, initialState });\n        });\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        if (config['implmentation'] === 0) {\n            config['implementation'] = 1;\n        }\n        return new cls(config);\n    }\n}\n/** @nocollapse */\nLSTM.className = 'LSTM';\nserialization.registerClass(LSTM);\nexport class StackedRNNCells extends RNNCell {\n    constructor(args) {\n        super(args);\n        this.cells = args.cells;\n    }\n    get stateSize() {\n        // States are a flat list in reverse order of the cell stack.\n        // This allows perserving the requirement `stack.statesize[0] ===\n        // outputDim`. E.g., states of a 2-layer LSTM would be `[h2, c2, h1, c1]`,\n        // assuming one LSTM has states `[h, c]`.\n        const stateSize = [];\n        for (const cell of this.cells.slice().reverse()) {\n            if (Array.isArray(cell.stateSize)) {\n                stateSize.push(...cell.stateSize);\n            }\n            else {\n                stateSize.push(cell.stateSize);\n            }\n        }\n        return stateSize;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = inputs;\n            let states = inputs.slice(1);\n            // Recover per-cell states.\n            const nestedStates = [];\n            for (const cell of this.cells.slice().reverse()) {\n                if (Array.isArray(cell.stateSize)) {\n                    nestedStates.push(states.splice(0, cell.stateSize.length));\n                }\n                else {\n                    nestedStates.push(states.splice(0, 1));\n                }\n            }\n            nestedStates.reverse();\n            // Call the cells in order and store the returned states.\n            const newNestedStates = [];\n            let callInputs;\n            for (let i = 0; i < this.cells.length; ++i) {\n                const cell = this.cells[i];\n                states = nestedStates[i];\n                // TODO(cais): Take care of constants.\n                if (i === 0) {\n                    callInputs = [inputs[0]].concat(states);\n                }\n                else {\n                    callInputs = [callInputs[0]].concat(states);\n                }\n                callInputs = cell.call(callInputs, kwargs);\n                newNestedStates.push(callInputs.slice(1));\n            }\n            // Format the new states as a flat list in reverse cell order.\n            states = [];\n            for (const cellStates of newNestedStates.slice().reverse()) {\n                states.push(...cellStates);\n            }\n            return [callInputs[0]].concat(states);\n        });\n    }\n    build(inputShape) {\n        if (isArrayOfShapes(inputShape)) {\n            // TODO(cais): Take care of input constants.\n            // const constantShape = inputShape.slice(1);\n            inputShape = inputShape[0];\n        }\n        inputShape = inputShape;\n        let outputDim;\n        this.cells.forEach((cell, i) => {\n            nameScope(`RNNCell_${i}`, () => {\n                // TODO(cais): Take care of input constants.\n                cell.build(inputShape);\n                if (Array.isArray(cell.stateSize)) {\n                    outputDim = cell.stateSize[0];\n                }\n                else {\n                    outputDim = cell.stateSize;\n                }\n                inputShape = [inputShape[0], outputDim];\n            });\n        });\n        this.built = true;\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const getCellConfig = (cell) => {\n            return {\n                'className': cell.getClassName(),\n                'config': cell.getConfig(),\n            };\n        };\n        const cellConfigs = this.cells.map(getCellConfig);\n        const config = { 'cells': cellConfigs };\n        return Object.assign({}, baseConfig, config);\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}) {\n        const cells = [];\n        for (const cellConfig of config['cells']) {\n            cells.push(deserialize(cellConfig, customObjects));\n        }\n        return new cls({ cells });\n    }\n    get trainableWeights() {\n        if (!this.trainable) {\n            return [];\n        }\n        const weights = [];\n        for (const cell of this.cells) {\n            weights.push(...cell.trainableWeights);\n        }\n        return weights;\n    }\n    get nonTrainableWeights() {\n        const weights = [];\n        for (const cell of this.cells) {\n            weights.push(...cell.nonTrainableWeights);\n        }\n        if (!this.trainable) {\n            const trainableWeights = [];\n            for (const cell of this.cells) {\n                trainableWeights.push(...cell.trainableWeights);\n            }\n            return trainableWeights.concat(weights);\n        }\n        return weights;\n    }\n    /**\n     * Retrieve the weights of a the model.\n     *\n     * @returns A flat `Array` of `tf.Tensor`s.\n     */\n    getWeights() {\n        const weights = [];\n        for (const cell of this.cells) {\n            weights.push(...cell.weights);\n        }\n        return batchGetValue(weights);\n    }\n    /**\n     * Set the weights of the model.\n     *\n     * @param weights An `Array` of `tf.Tensor`s with shapes and types matching\n     *     the output of `getWeights()`.\n     */\n    setWeights(weights) {\n        const tuples = [];\n        for (const cell of this.cells) {\n            const numParams = cell.weights.length;\n            const inputWeights = weights.splice(numParams);\n            for (let i = 0; i < cell.weights.length; ++i) {\n                tuples.push([cell.weights[i], inputWeights[i]]);\n            }\n        }\n        batchSetValue(tuples);\n    }\n}\n/** @nocollapse */\nStackedRNNCells.className = 'StackedRNNCells';\nserialization.registerClass(StackedRNNCells);\nexport function generateDropoutMask(args) {\n    const { ones, rate, training = false, count = 1, dropoutFunc } = args;\n    const droppedInputs = () => dropoutFunc != null ? dropoutFunc(ones(), rate) : K.dropout(ones(), rate);\n    const createMask = () => K.inTrainPhase(droppedInputs, ones, training);\n    // just in case count is provided with null or undefined\n    if (!count || count <= 1) {\n        return tfc.keep(createMask().clone());\n    }\n    const masks = Array(count).fill(undefined).map(createMask);\n    return masks.map(m => tfc.keep(m.clone()));\n}\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVjdXJyZW50LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vdGZqcy1sYXllcnMvc3JjL2xheWVycy9yZWN1cnJlbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7O0dBUUc7QUFFSDs7R0FFRztBQUVILE9BQU8sS0FBSyxHQUFHLE1BQU0sdUJBQXVCLENBQUM7QUFDN0MsT0FBTyxFQUFXLGFBQWEsRUFBVSxJQUFJLEVBQUUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFbEYsT0FBTyxFQUFhLGFBQWEsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQzlFLE9BQU8sS0FBSyxDQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDN0MsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNwQyxPQUFPLEVBQW1DLGFBQWEsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3BHLE9BQU8sRUFBQyxTQUFTLEVBQUUsY0FBYyxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDN0QsT0FBTyxFQUFDLEtBQUssRUFBWSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BELE9BQU8sRUFBQyxjQUFjLEVBQUUsbUJBQW1CLEVBQUUsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQzFFLE9BQU8sRUFBQyxjQUFjLEVBQUUsV0FBVyxFQUF5QixJQUFJLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUcvRyxPQUFPLEVBQUMsY0FBYyxFQUFzQyxvQkFBb0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRXpHLE9BQU8sRUFBQyxxQkFBcUIsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQzdELE9BQU8sS0FBSyxVQUFVLE1BQU0scUJBQXFCLENBQUM7QUFDbEQsT0FBTyxFQUFDLGtCQUFrQixFQUFFLG1CQUFtQixFQUFFLGVBQWUsRUFBQyxNQUFNLHNCQUFzQixDQUFD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QUFDO0lBRXZFLHdEQUF3RDtJQUN4RCxJQUFJLENBQUMsS0FBSyxJQUFJLEtBQUssSUFBSSxDQUFDLEVBQUU7UUFDeEIsT0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUM7S0FDdkM7SUFFRCxNQUFNLEtBQUssR0FBRyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDLEdBQUcsQ0FBQyxVQUFVLENBQUMsQ0FBQztJQUUzRCxPQUFPLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLENBQUM7QUFDN0MsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogVGVuc29yRmxvdy5qcyBMYXllcnM6IFJlY3VycmVudCBOZXVyYWwgTmV0d29yayBMYXllcnMuXG4gKi9cblxuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge0RhdGFUeXBlLCBzZXJpYWxpemF0aW9uLCBUZW5zb3IsIHRpZHksIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7QWN0aXZhdGlvbiwgZ2V0QWN0aXZhdGlvbiwgc2VyaWFsaXplQWN0aXZhdGlvbn0gZnJvbSAnLi4vYWN0aXZhdGlvbnMnO1xuaW1wb3J0ICogYXMgSyBmcm9tICcuLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge25hbWVTY29wZX0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7Q29uc3RyYWludCwgQ29uc3RyYWludElkZW50aWZpZXIsIGdldENvbnN0cmFpbnQsIHNlcmlhbGl6ZUNvbnN0cmFpbnR9IGZyb20gJy4uL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7SW5wdXRTcGVjLCBTeW1ib2xpY1RlbnNvcn0gZnJvbSAnLi4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7TGF5ZXIsIExheWVyQXJnc30gZnJvbSAnLi4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7QXR0cmlidXRlRXJyb3IsIE5vdEltcGxlbWVudGVkRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2dldEluaXRpYWxpemVyLCBJbml0aWFsaXplciwgSW5pdGlhbGl6ZXJJZGVudGlmaWVyLCBPbmVzLCBzZXJpYWxpemVJbml0aWFsaXplcn0gZnJvbSAnLi4vaW5pdGlhbGl6ZXJzJztcbmltcG9ydCB7QWN0aXZhdGlvbklkZW50aWZpZXJ9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9hY3RpdmF0aW9uX2NvbmZpZyc7XG5pbXBvcnQge1NoYXBlfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvY29tbW9uJztcbmltcG9ydCB7Z2V0UmVndWxhcml6ZXIsIFJlZ3VsYXJpemVyLCBSZWd1bGFyaXplcklkZW50aWZpZXIsIHNlcmlhbGl6ZVJlZ3VsYXJpemVyfSBmcm9tICcuLi9yZWd1bGFyaXplcnMnO1xuaW1wb3J0IHtLd2FyZ3MsIFJublN0ZXBGdW5jdGlvbn0gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHthc3NlcnRQb3NpdGl2ZUludGVnZXJ9IGZyb20gJy4uL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuaW1wb3J0ICogYXMgbWF0aF91dGlscyBmcm9tICcuLi91dGlscy9tYXRoX3V0aWxzJztcbmltcG9ydCB7Z2V0RXhhY3RseU9uZVNoYXBlLCBnZXRFeGFjdGx5T25lVGVuc29yLCBpc0FycmF5T2ZTaGFwZXN9IGZyb20gJy4uL3V0aWxzL3R5cGVzX3V0aWxzJztcbmltcG9ydCB7YmF0Y2hHZXRWYWx1ZSwgYmF0Y2hTZXRWYWx1ZSwgTGF5ZXJWYXJpYWJsZX0gZnJvbSAnLi4vdmFyaWFibGVzJztcblxuaW1wb3J0IHtkZXNlcmlhbGl6ZX0gZnJvbSAnLi9zZXJpYWxpemF0aW9uJztcblxuLyoqXG4gKiBTdGFuZGFyZGl6ZSBgYXBwbHkoKWAgYXJncyB0byBhIHNpbmdsZSBsaXN0IG9mIHRlbnNvciBpbnB1dHMuXG4gKlxuICogV2hlbiBydW5uaW5nIGEgbW9kZWwgbG9hZGVkIGZyb20gZmlsZSwgdGhlIGlucHV0IHRlbnNvcnMgYGluaXRpYWxTdGF0ZWAgYW5kXG4gKiBgY29uc3RhbnRzYCBhcmUgcGFzc2VkIHRvIGBSTk4uYXBwbHkoKWAgYXMgcGFydCBvZiBgaW5wdXRzYCBpbnN0ZWFkIG9mIHRoZVxuICogZGVkaWNhdGVkIGt3YXJncyBmaWVsZHMuIGBpbnB1dHNgIGNvbnNpc3RzIG9mXG4gKiBgW2lucHV0cywgaW5pdGlhbFN0YXRlMCwgaW5pdGlhbFN0YXRlMSwgLi4uLCBjb25zdGFudDAsIGNvbnN0YW50MV1gIGluIHRoaXNcbiAqIGNhc2UuXG4gKiBUaGlzIG1ldGhvZCBtYWtlcyBzdXJlIHRoYXQgYXJndW1lbnRzIGFyZVxuICogc2VwYXJhdGVkIGFuZCB0aGF0IGBpbml0aWFsU3RhdGVgIGFuZCBgY29uc3RhbnRzYCBhcmUgYEFycmF5YHMgb2YgdGVuc29yc1xuICogKG9yIE5vbmUpLlxuICpcbiAqIEBwYXJhbSBpbnB1dHMgVGVuc29yIG9yIGBBcnJheWAgb2YgIHRlbnNvcnMuXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlIFRlbnNvciBvciBgQXJyYXlgIG9mIHRlbnNvcnMgb3IgYG51bGxgL2B1bmRlZmluZWRgLlxuICogQHBhcmFtIGNvbnN0YW50cyBUZW5zb3Igb3IgYEFycmF5YCBvZiB0ZW5zb3JzIG9yIGBudWxsYC9gdW5kZWZpbmVkYC5cbiAqIEByZXR1cm5zIEFuIG9iamVjdCBjb25zaXN0aW5nIG9mXG4gKiAgIGlucHV0czogQSB0ZW5zb3IuXG4gKiAgIGluaXRpYWxTdGF0ZTogYEFycmF5YCBvZiB0ZW5zb3JzIG9yIGBudWxsYC5cbiAqICAgY29uc3RhbnRzOiBgQXJyYXlgIG9mIHRlbnNvcnMgb3IgYG51bGxgLlxuICogQHRocm93cyBWYWx1ZUVycm9yLCBpZiBgaW5wdXRzYCBpcyBhbiBgQXJyYXlgIGJ1dCBlaXRoZXIgYGluaXRpYWxTdGF0ZWAgb3JcbiAqICAgYGNvbnN0YW50c2AgaXMgcHJvdmlkZWQuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzdGFuZGFyZGl6ZUFyZ3MoXG4gICAgaW5wdXRzOiBUZW5zb3J8VGVuc29yW118U3ltYm9saWNUZW5zb3J8U3ltYm9saWNUZW5zb3JbXSxcbiAgICBpbml0aWFsU3RhdGU6IFRlbnNvcnxUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcnxTeW1ib2xpY1RlbnNvcltdLFxuICAgIGNvbnN0YW50czogVGVuc29yfFRlbnNvcltdfFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW10sXG4gICAgbnVtQ29uc3RhbnRzPzogbnVtYmVyKToge1xuICBpbnB1dHM6IFRlbnNvcnxTeW1ib2xpY1RlbnNvcixcbiAgaW5pdGlhbFN0YXRlOiBUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcltdLFxuICBjb25zdGFudHM6IFRlbnNvcltdfFN5bWJvbGljVGVuc29yW11cbn0ge1xuICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgaWYgKGluaXRpYWxTdGF0ZSAhPSBudWxsIHx8IGNvbnN0YW50cyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnV2hlbiBpbnB1dHMgaXMgYW4gYXJyYXksIG5laXRoZXIgaW5pdGlhbFN0YXRlIG9yIGNvbnN0YW50cyAnICtcbiAgICAgICAgICAnc2hvdWxkIGJlIHByb3ZpZGVkJyk7XG4gICAgfVxuICAgIGlmIChudW1Db25zdGFudHMgIT0gbnVsbCkge1xuICAgICAgY29uc3RhbnRzID0gaW5wdXRzLnNsaWNlKGlucHV0cy5sZW5ndGggLSBudW1Db25zdGFudHMsIGlucHV0cy5sZW5ndGgpO1xuICAgICAgaW5wdXRzID0gaW5wdXRzLnNsaWNlKDAsIGlucHV0cy5sZW5ndGggLSBudW1Db25zdGFudHMpO1xuICAgIH1cbiAgICBpZiAoaW5wdXRzLmxlbmd0aCA+IDEpIHtcbiAgICAgIGluaXRpYWxTdGF0ZSA9IGlucHV0cy5zbGljZSgxLCBpbnB1dHMubGVuZ3RoKTtcbiAgICB9XG4gICAgaW5wdXRzID0gaW5wdXRzWzBdO1xuICB9XG5cbiAgZnVuY3Rpb24gdG9MaXN0T3JOdWxsKHg6IFRlbnNvcnxUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcnxcbiAgICAgICAgICAgICAgICAgICAgICAgIFN5bWJvbGljVGVuc29yW10pOiBUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcltdIHtcbiAgICBpZiAoeCA9PSBudWxsIHx8IEFycmF5LmlzQXJyYXkoeCkpIHtcbiAgICAgIHJldHVybiB4IGFzIFRlbnNvcltdIHwgU3ltYm9saWNUZW5zb3JbXTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFt4XSBhcyBUZW5zb3JbXSB8IFN5bWJvbGljVGVuc29yW107XG4gICAgfVxuICB9XG5cbiAgaW5pdGlhbFN0YXRlID0gdG9MaXN0T3JOdWxsKGluaXRpYWxTdGF0ZSk7XG4gIGNvbnN0YW50cyA9IHRvTGlzdE9yTnVsbChjb25zdGFudHMpO1xuXG4gIHJldHVybiB7aW5wdXRzLCBpbml0aWFsU3RhdGUsIGNvbnN0YW50c307XG59XG5cbi8qKlxuICogSXRlcmF0ZXMgb3ZlciB0aGUgdGltZSBkaW1lbnNpb24gb2YgYSB0ZW5zb3IuXG4gKlxuICogQHBhcmFtIHN0ZXBGdW5jdGlvbiBSTk4gc3RlcCBmdW5jdGlvbi5cbiAqICAgUGFyYW1ldGVyczpcbiAqICAgICBpbnB1dHM6IHRlbnNvciB3aXRoIHNoYXBlIGBbc2FtcGxlcywgLi4uXWAgKG5vIHRpbWUgZGltZW5zaW9uKSxcbiAqICAgICAgIHJlcHJlc2VudGluZyBpbnB1dCBmb3IgdGhlIGJhdGNoIG9mIHNhbXBsZXMgYXQgYSBjZXJ0YWluIHRpbWUgc3RlcC5cbiAqICAgICBzdGF0ZXM6IGFuIEFycmF5IG9mIHRlbnNvcnMuXG4gKiAgIFJldHVybnM6XG4gKiAgICAgb3V0cHV0czogdGVuc29yIHdpdGggc2hhcGUgYFtzYW1wbGVzLCBvdXRwdXREaW1dYCAobm8gdGltZSBkaW1lbnNpb24pLlxuICogICAgIG5ld1N0YXRlczogbGlzdCBvZiB0ZW5zb3JzLCBzYW1lIGxlbmd0aCBhbmQgc2hhcGVzIGFzIGBzdGF0ZXNgLiBUaGUgZmlyc3RcbiAqICAgICAgIHN0YXRlIGluIHRoZSBsaXN0IG11c3QgYmUgdGhlIG91dHB1dCB0ZW5zb3IgYXQgdGhlIHByZXZpb3VzIHRpbWVzdGVwLlxuICogQHBhcmFtIGlucHV0cyBUZW5zb3Igb2YgdGVtcG9yYWwgZGF0YSBvZiBzaGFwZSBgW3NhbXBsZXMsIHRpbWUsIC4uLl1gIChhdFxuICogICBsZWFzdCAzRCkuXG4gKiBAcGFyYW0gaW5pdGlhbFN0YXRlcyBUZW5zb3Igd2l0aCBzaGFwZSBgW3NhbXBsZXMsIG91dHB1dERpbV1gIChubyB0aW1lXG4gKiAgIGRpbWVuc2lvbiksIGNvbnRhaW5pbmcgdGhlIGluaXRpYWwgdmFsdWVzIG9mIHRoZSBzdGF0ZXMgdXNlZCBpbiB0aGUgc3RlcFxuICogICBmdW5jdGlvbi5cbiAqIEBwYXJhbSBnb0JhY2t3YXJkcyBJZiBgdHJ1ZWAsIGRvIHRoZSBpdGVyYXRpb24gb3ZlciB0aGUgdGltZSBkaW1lbnNpb24gaW5cbiAqICAgcmV2ZXJzZSBvcmRlciBhbmQgcmV0dXJuIHRoZSByZXZlcnNlZCBzZXF1ZW5jZS5cbiAqIEBwYXJhbSBtYXNrIEJpbmFyeSB0ZW5zb3Igd2l0aCBzaGFwZSBgW3NhbXBsZSwgdGltZSwgMV1gLCB3aXRoIGEgemVybyBmb3JcbiAqICAgZXZlcnkgZWxlbWVudCB0aGF0IGlzIG1hc2tlZC5cbiAqIEBwYXJhbSBjb25zdGFudHMgQW4gQXJyYXkgb2YgY29uc3RhbnQgdmFsdWVzIHBhc3NlZCBhdCBlYWNoIHN0ZXAuXG4gKiBAcGFyYW0gdW5yb2xsIFdoZXRoZXIgdG8gdW5yb2xsIHRoZSBSTk4gb3IgdG8gdXNlIGEgc3ltYm9saWMgbG9vcC4gKk5vdCpcbiAqICAgYXBwbGljYWJsZSB0byB0aGlzIGltcGVyYXRpdmUgZGVlcGxlYXJuLmpzIGJhY2tlbmQuIEl0cyB2YWx1ZSBpcyBpZ25vcmVkLlxuICogQHBhcmFtIG5lZWRQZXJTdGVwT3V0cHV0cyBXaGV0aGVyIHRoZSBwZXItc3RlcCBvdXRwdXRzIGFyZSB0byBiZVxuICogICBjb25jYXRlbmF0ZWQgaW50byBhIHNpbmdsZSB0ZW5zb3IgYW5kIHJldHVybmVkIChhcyB0aGUgc2Vjb25kIHJldHVyblxuICogICB2YWx1ZSkuIERlZmF1bHQ6IGBmYWxzZWAuIFRoaXMgYXJnIGlzIGluY2x1ZGVkIHNvIHRoYXQgdGhlIHJlbGF0aXZlbHlcbiAqICAgZXhwZW5zaXZlIGNvbmNhdGVuYXRpb24gb2YgdGhlIHN0ZXB3aXNlIG91dHB1dHMgY2FuIGJlIG9taXR0ZWQgdW5sZXNzXG4gKiAgIHRoZSBzdGVwd2lzZSBvdXRwdXRzIG5lZWQgdG8gYmUga2VwdCAoZS5nLiwgZm9yIGFuIExTVE0gbGF5ZXIgb2Ygd2hpY2hcbiAqICAgYHJldHVyblNlcXVlbmNlYCBpcyBgdHJ1ZWAuKVxuICogQHJldHVybnMgQW4gQXJyYXk6IGBbbGFzdE91dHB1dCwgb3V0cHV0cywgbmV3U3RhdGVzXWAuXG4gKiAgIGxhc3RPdXRwdXQ6IHRoZSBsYXN0ZXN0IG91dHB1dCBvZiB0aGUgUk5OLCBvZiBzaGFwZSBgW3NhbXBsZXMsIC4uLl1gLlxuICogICBvdXRwdXRzOiB0ZW5zb3Igd2l0aCBzaGFwZSBgW3NhbXBsZXMsIHRpbWUsIC4uLl1gIHdoZXJlIGVhY2ggZW50cnlcbiAqICAgICBgb3V0cHV0W3MsIHRdYCBpcyB0aGUgb3V0cHV0IG9mIHRoZSBzdGVwIGZ1bmN0aW9uIGF0IHRpbWUgYHRgIGZvciBzYW1wbGVcbiAqICAgICBgc2AuIFRoaXMgcmV0dXJuIHZhbHVlIGlzIHByb3ZpZGVkIGlmIGFuZCBvbmx5IGlmIHRoZVxuICogICAgIGBuZWVkUGVyU3RlcE91dHB1dHNgIGlzIHNldCBhcyBgdHJ1ZWAuIElmIGl0IGlzIHNldCBhcyBgZmFsc2VgLCB0aGlzXG4gKiAgICAgcmV0dXJuIHZhbHVlIHdpbGwgYmUgYHVuZGVmaW5lZGAuXG4gKiAgIG5ld1N0YXRlczogQXJyYXkgb2YgdGVuc29ycywgbGF0ZXN0IHN0YXRlcyByZXR1cm5lZCBieSB0aGUgc3RlcCBmdW5jdGlvbixcbiAqICAgICAgb2Ygc2hhcGUgYChzYW1wbGVzLCAuLi4pYC5cbiAqIEB0aHJvd3MgVmFsdWVFcnJvciBJZiBpbnB1dCBkaW1lbnNpb24gaXMgbGVzcyB0aGFuIDMuXG4gKlxuICogVE9ETyhuaWVsc2VuZSk6IFRoaXMgbmVlZHMgdG8gYmUgdGlkeS1lZC5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIHJubihcbiAgICBzdGVwRnVuY3Rpb246IFJublN0ZXBGdW5jdGlvbiwgaW5wdXRzOiBUZW5zb3IsIGluaXRpYWxTdGF0ZXM6IFRlbnNvcltdLFxuICAgIGdvQmFja3dhcmRzID0gZmFsc2UsIG1hc2s/OiBUZW5zb3IsIGNvbnN0YW50cz86IFRlbnNvcltdLCB1bnJvbGwgPSBmYWxzZSxcbiAgICBuZWVkUGVyU3RlcE91dHB1dHMgPSBmYWxzZSk6IFtUZW5zb3IsIFRlbnNvciwgVGVuc29yW11dIHtcbiAgcmV0dXJuIHRmYy50aWR5KCgpID0+IHtcbiAgICBjb25zdCBuZGltID0gaW5wdXRzLnNoYXBlLmxlbmd0aDtcbiAgICBpZiAobmRpbSA8IDMpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGBJbnB1dCBzaG91bGQgYmUgYXQgbGVhc3QgM0QsIGJ1dCBpcyAke25kaW19RC5gKTtcbiAgICB9XG5cbiAgICAvLyBUcmFuc3Bvc2UgdG8gdGltZS1tYWpvciwgaS5lLiwgZnJvbSBbYmF0Y2gsIHRpbWUsIC4uLl0gdG8gW3RpbWUsIGJhdGNoLFxuICAgIC8vIC4uLl0uXG4gICAgY29uc3QgYXhlcyA9IFsxLCAwXS5jb25jYXQobWF0aF91dGlscy5yYW5nZSgyLCBuZGltKSk7XG4gICAgaW5wdXRzID0gdGZjLnRyYW5zcG9zZShpbnB1dHMsIGF4ZXMpO1xuXG4gICAgaWYgKGNvbnN0YW50cyAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAnVGhlIHJubigpIGZ1bmN0b2luIG9mIHRoZSBkZWVwbGVhcm4uanMgYmFja2VuZCBkb2VzIG5vdCBzdXBwb3J0ICcgK1xuICAgICAgICAgICdjb25zdGFudHMgeWV0LicpO1xuICAgIH1cblxuICAgIC8vIFBvcnRpbmcgTm90ZTogdGhlIHVucm9sbCBvcHRpb24gaXMgaWdub3JlZCBieSB0aGUgaW1wZXJhdGl2ZSBiYWNrZW5kLlxuICAgIGlmICh1bnJvbGwpIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnQmFja2VuZCBybm4oKTogdGhlIHVucm9sbCA9IHRydWUgb3B0aW9uIGlzIG5vdCBhcHBsaWNhYmxlIHRvIHRoZSAnICtcbiAgICAgICAgICAnaW1wZXJhdGl2ZSBkZWVwbGVhcm4uanMgYmFja2VuZC4nKTtcbiAgICB9XG5cbiAgICBpZiAobWFzayAhPSBudWxsKSB7XG4gICAgICBtYXNrID0gdGZjLmNhc3QodGZjLmNhc3QobWFzaywgJ2Jvb2wnKSwgJ2Zsb2F0MzInKTtcbiAgICAgIGlmIChtYXNrLnJhbmsgPT09IG5kaW0gLSAxKSB7XG4gICAgICAgIG1hc2sgPSB0ZmMuZXhwYW5kRGltcyhtYXNrLCAtMSk7XG4gICAgICB9XG4gICAgICBtYXNrID0gdGZjLnRyYW5zcG9zZShtYXNrLCBheGVzKTtcbiAgICB9XG5cbiAgICBpZiAoZ29CYWNrd2FyZHMpIHtcbiAgICAgIGlucHV0cyA9IHRmYy5yZXZlcnNlKGlucHV0cywgMCk7XG4gICAgICBpZiAobWFzayAhPSBudWxsKSB7XG4gICAgICAgIG1hc2sgPSB0ZmMucmV2ZXJzZShtYXNrLCAwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBQb3J0aW5nIE5vdGU6IFB5S2VyYXMgd2l0aCBUZW5zb3JGbG93IGJhY2tlbmQgdXNlcyBhIHN5bWJvbGljIGxvb3BcbiAgICAvLyAgICh0Zi53aGlsZV9sb29wKS4gQnV0IGZvciB0aGUgaW1wZXJhdGl2ZSBkZWVwbGVhcm4uanMgYmFja2VuZCwgd2UganVzdFxuICAgIC8vICAgdXNlIHRoZSB1c3VhbCBUeXBlU2NyaXB0IGNvbnRyb2wgZmxvdyB0byBpdGVyYXRlIG92ZXIgdGhlIHRpbWUgc3RlcHMgaW5cbiAgICAvLyAgIHRoZSBpbnB1dHMuXG4gICAgLy8gUG9ydGluZyBOb3RlOiBQeUtlcmFzIHBhdGNoZXMgYSBcIl91c2VfbGVhcm5pbmdfcGhhc2VcIiBhdHRyaWJ1dGUgdG9cbiAgICAvLyBvdXRwdXRzLlxuICAgIC8vICAgVGhpcyBpcyBub3QgaWRpb21hdGljIGluIFR5cGVTY3JpcHQuIFRoZSBpbmZvIHJlZ2FyZGluZyB3aGV0aGVyIHdlIGFyZVxuICAgIC8vICAgaW4gYSBsZWFybmluZyAoaS5lLiwgdHJhaW5pbmcpIHBoYXNlIGZvciBSTk4gaXMgcGFzc2VkIGluIGEgZGlmZmVyZW50XG4gICAgLy8gICB3YXkuXG5cbiAgICBjb25zdCBwZXJTdGVwT3V0cHV0czogVGVuc29yW10gPSBbXTtcbiAgICBsZXQgbGFzdE91dHB1dDogVGVuc29yO1xuICAgIGxldCBzdGF0ZXMgPSBpbml0aWFsU3RhdGVzO1xuICAgIGNvbnN0IHRpbWVTdGVwcyA9IGlucHV0cy5zaGFwZVswXTtcbiAgICBjb25zdCBwZXJTdGVwSW5wdXRzID0gdGZjLnVuc3RhY2soaW5wdXRzKTtcbiAgICBsZXQgcGVyU3RlcE1hc2tzOiBUZW5zb3JbXTtcbiAgICBpZiAobWFzayAhPSBudWxsKSB7XG4gICAgICBwZXJTdGVwTWFza3MgPSB0ZmMudW5zdGFjayhtYXNrKTtcbiAgICB9XG5cbiAgICBmb3IgKGxldCB0ID0gMDsgdCA8IHRpbWVTdGVwczsgKyt0KSB7XG4gICAgICBjb25zdCBjdXJyZW50SW5wdXQgPSBwZXJTdGVwSW5wdXRzW3RdO1xuICAgICAgY29uc3Qgc3RlcE91dHB1dHMgPSB0ZmMudGlkeSgoKSA9PiBzdGVwRnVuY3Rpb24oY3VycmVudElucHV0LCBzdGF0ZXMpKTtcblxuICAgICAgaWYgKG1hc2sgPT0gbnVsbCkge1xuICAgICAgICBsYXN0T3V0cHV0ID0gc3RlcE91dHB1dHNbMF07XG4gICAgICAgIHN0YXRlcyA9IHN0ZXBPdXRwdXRzWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgbWFza2VkT3V0cHV0cyA9IHRmYy50aWR5KCgpID0+IHtcbiAgICAgICAgICBjb25zdCBzdGVwTWFzayA9IHBlclN0ZXBNYXNrc1t0XTtcbiAgICAgICAgICBjb25zdCBuZWdTdGVwTWFzayA9IHRmYy5zdWIodGZjLm9uZXNMaWtlKHN0ZXBNYXNrKSwgc3RlcE1hc2spO1xuICAgICAgICAgIC8vIFRPRE8oY2Fpcyk6IFdvdWxkIHRmYy53aGVyZSgpIGJlIGJldHRlciBmb3IgcGVyZm9ybWFuY2U/XG4gICAgICAgICAgY29uc3Qgb3V0cHV0ID0gdGZjLmFkZChcbiAgICAgICAgICAgICAgdGZjLm11bChzdGVwT3V0cHV0c1swXSwgc3RlcE1hc2spLFxuICAgICAgICAgICAgICB0ZmMubXVsKHN0YXRlc1swXSwgbmVnU3RlcE1hc2spKTtcbiAgICAgICAgICBjb25zdCBuZXdTdGF0ZXMgPSBzdGF0ZXMubWFwKChzdGF0ZSwgaSkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRmYy5hZGQoXG4gICAgICAgICAgICAgICAgdGZjLm11bChzdGVwT3V0cHV0c1sxXVtpXSwgc3RlcE1hc2spLFxuICAgICAgICAgICAgICAgIHRmYy5tdWwoc3RhdGUsIG5lZ1N0ZXBNYXNrKSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmV0dXJuIHtvdXRwdXQsIG5ld1N0YXRlc307XG4gICAgICAgIH0pO1xuICAgICAgICBsYXN0T3V0cHV0ID0gbWFza2VkT3V0cHV0cy5vdXRwdXQ7XG4gICAgICAgIHN0YXRlcyA9IG1hc2tlZE91dHB1dHMubmV3U3RhdGVzO1xuICAgICAgfVxuXG4gICAgICBpZiAobmVlZFBlclN0ZXBPdXRwdXRzKSB7XG4gICAgICAgIHBlclN0ZXBPdXRwdXRzLnB1c2gobGFzdE91dHB1dCk7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBvdXRwdXRzOiBUZW5zb3I7XG4gICAgaWYgKG5lZWRQZXJTdGVwT3V0cHV0cykge1xuICAgICAgY29uc3QgYXhpcyA9IDE7XG4gICAgICBvdXRwdXRzID0gdGZjLnN0YWNrKHBlclN0ZXBPdXRwdXRzLCBheGlzKTtcbiAgICB9XG4gICAgcmV0dXJuIFtsYXN0T3V0cHV0LCBvdXRwdXRzLCBzdGF0ZXNdIGFzIFtUZW5zb3IsIFRlbnNvciwgVGVuc29yW11dO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIEJhc2VSTk5MYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogQSBSTk4gY2VsbCBpbnN0YW5jZS4gQSBSTk4gY2VsbCBpcyBhIGNsYXNzIHRoYXQgaGFzOlxuICAgKiAgIC0gYSBgY2FsbCgpYCBtZXRob2QsIHdoaWNoIHRha2VzIGBbVGVuc29yLCBUZW5zb3JdYCBhcyB0aGVcbiAgICogICAgIGZpcnN0IGlucHV0IGFyZ3VtZW50LiBUaGUgZmlyc3QgaXRlbSBpcyB0aGUgaW5wdXQgYXQgdGltZSB0LCBhbmRcbiAgICogICAgIHNlY29uZCBpdGVtIGlzIHRoZSBjZWxsIHN0YXRlIGF0IHRpbWUgdC5cbiAgICogICAgIFRoZSBgY2FsbCgpYCBtZXRob2QgcmV0dXJucyBgW291dHB1dEF0VCwgc3RhdGVzQXRUUGx1czFdYC5cbiAgICogICAgIFRoZSBgY2FsbCgpYCBtZXRob2Qgb2YgdGhlIGNlbGwgY2FuIGFsc28gdGFrZSB0aGUgYXJndW1lbnQgYGNvbnN0YW50c2AsXG4gICAqICAgICBzZWUgc2VjdGlvbiBcIk5vdGUgb24gcGFzc2luZyBleHRlcm5hbCBjb25zdGFudHNcIiBiZWxvdy5cbiAgICogICAgIFBvcnRpbmcgTm9kZTogUHlLZXJhcyBvdmVycmlkZXMgdGhlIGBjYWxsKClgIHNpZ25hdHVyZSBvZiBSTk4gY2VsbHMsXG4gICAqICAgICAgIHdoaWNoIGFyZSBMYXllciBzdWJ0eXBlcywgdG8gYWNjZXB0IHR3byBhcmd1bWVudHMuIHRmanMtbGF5ZXJzIGRvZXNcbiAgICogICAgICAgbm90IGRvIHN1Y2ggb3ZlcnJpZGluZy4gSW5zdGVhZCB3ZSBwcmVzZXZlIHRoZSBgY2FsbCgpYCBzaWduYXR1cmUsXG4gICAqICAgICAgIHdoaWNoIGR1ZSB0byBpdHMgYFRlbnNvcnxUZW5zb3JbXWAgYXJndW1lbnQgYW5kIHJldHVybiB2YWx1ZSwgaXNcbiAgICogICAgICAgZmxleGlibGUgZW5vdWdoIHRvIGhhbmRsZSB0aGUgaW5wdXRzIGFuZCBzdGF0ZXMuXG4gICAqICAgLSBhIGBzdGF0ZVNpemVgIGF0dHJpYnV0ZS4gVGhpcyBjYW4gYmUgYSBzaW5nbGUgaW50ZWdlciAoc2luZ2xlIHN0YXRlKVxuICAgKiAgICAgaW4gd2hpY2ggY2FzZSBpdCBpcyB0aGUgc2l6ZSBvZiB0aGUgcmVjdXJyZW50IHN0YXRlICh3aGljaCBzaG91bGQgYmVcbiAgICogICAgIHRoZSBzYW1lIGFzIHRoZSBzaXplIG9mIHRoZSBjZWxsIG91dHB1dCkuIFRoaXMgY2FuIGFsc28gYmUgYW4gQXJyYXkgb2ZcbiAgICogICAgIGludGVnZXJzIChvbmUgc2l6ZSBwZXIgc3RhdGUpLiBJbiB0aGlzIGNhc2UsIHRoZSBmaXJzdCBlbnRyeVxuICAgKiAgICAgKGBzdGF0ZVNpemVbMF1gKSBzaG91bGQgYmUgdGhlIHNhbWUgYXMgdGhlIHNpemUgb2YgdGhlIGNlbGwgb3V0cHV0LlxuICAgKiBJdCBpcyBhbHNvIHBvc3NpYmxlIGZvciBgY2VsbGAgdG8gYmUgYSBsaXN0IG9mIFJOTiBjZWxsIGluc3RhbmNlcywgaW4gd2hpY2hcbiAgICogY2FzZSB0aGUgY2VsbHMgZ2V0IHN0YWNrZWQgb24gYWZ0ZXIgdGhlIG90aGVyIGluIHRoZSBSTk4sIGltcGxlbWVudGluZyBhblxuICAgKiBlZmZpY2llbnQgc3RhY2tlZCBSTk4uXG4gICAqL1xuICBjZWxsPzogUk5OQ2VsbHxSTk5DZWxsW107XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBsYXN0IG91dHB1dCBpbiB0aGUgb3V0cHV0IHNlcXVlbmNlLCBvciB0aGUgZnVsbFxuICAgKiBzZXF1ZW5jZS5cbiAgICovXG4gIHJldHVyblNlcXVlbmNlcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gcmV0dXJuIHRoZSBsYXN0IHN0YXRlIGluIGFkZGl0aW9uIHRvIHRoZSBvdXRwdXQuXG4gICAqL1xuICByZXR1cm5TdGF0ZT86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgcHJvY2VzcyB0aGUgaW5wdXQgc2VxdWVuY2UgYmFja3dhcmRzIGFuZCByZXR1cm4gdGhlIHJldmVyc2VkXG4gICAqIHNlcXVlbmNlIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAgICovXG4gIGdvQmFja3dhcmRzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbGFzdCBzdGF0ZSBmb3IgZWFjaCBzYW1wbGUgYXQgaW5kZXggaSBpbiBhIGJhdGNoIHdpbGwgYmVcbiAgICogdXNlZCBhcyBpbml0aWFsIHN0YXRlIG9mIHRoZSBzYW1wbGUgb2YgaW5kZXggaSBpbiB0aGUgZm9sbG93aW5nIGJhdGNoXG4gICAqIChkZWZhdWx0OiBgZmFsc2VgKS5cbiAgICpcbiAgICogWW91IGNhbiBzZXQgUk5OIGxheWVycyB0byBiZSBcInN0YXRlZnVsXCIsIHdoaWNoIG1lYW5zIHRoYXQgdGhlIHN0YXRlc1xuICAgKiBjb21wdXRlZCBmb3IgdGhlIHNhbXBsZXMgaW4gb25lIGJhdGNoIHdpbGwgYmUgcmV1c2VkIGFzIGluaXRpYWwgc3RhdGVzXG4gICAqIGZvciB0aGUgc2FtcGxlcyBpbiB0aGUgbmV4dCBiYXRjaC4gVGhpcyBhc3N1bWVzIGEgb25lLXRvLW9uZSBtYXBwaW5nXG4gICAqIGJldHdlZW4gc2FtcGxlcyBpbiBkaWZmZXJlbnQgc3VjY2Vzc2l2ZSBiYXRjaGVzLlxuICAgKlxuICAgKiBUbyBlbmFibGUgXCJzdGF0ZWZ1bG5lc3NcIjpcbiAgICogICAtIHNwZWNpZnkgYHN0YXRlZnVsOiB0cnVlYCBpbiB0aGUgbGF5ZXIgY29uc3RydWN0b3IuXG4gICAqICAgLSBzcGVjaWZ5IGEgZml4ZWQgYmF0Y2ggc2l6ZSBmb3IgeW91ciBtb2RlbCwgYnkgcGFzc2luZ1xuICAgKiAgICAgLSBpZiBzZXF1ZW50aWFsIG1vZGVsOlxuICAgKiAgICAgICBgYmF0Y2hJbnB1dFNoYXBlOiBbLi4uXWAgdG8gdGhlIGZpcnN0IGxheWVyIGluIHlvdXIgbW9kZWwuXG4gICAqICAgICAtIGVsc2UgZm9yIGZ1bmN0aW9uYWwgbW9kZWwgd2l0aCAxIG9yIG1vcmUgSW5wdXQgbGF5ZXJzOlxuICAgKiAgICAgICBgYmF0Y2hTaGFwZTogWy4uLl1gIHRvIGFsbCB0aGUgZmlyc3QgbGF5ZXJzIGluIHlvdXIgbW9kZWwuXG4gICAqICAgICBUaGlzIGlzIHRoZSBleHBlY3RlZCBzaGFwZSBvZiB5b3VyIGlucHV0c1xuICAgKiAgICAgKmluY2x1ZGluZyB0aGUgYmF0Y2ggc2l6ZSouXG4gICAqICAgICBJdCBzaG91bGQgYmUgYSB0dXBsZSBvZiBpbnRlZ2VycywgZS5nLiwgYFszMiwgMTAsIDEwMF1gLlxuICAgKiAgIC0gc3BlY2lmeSBgc2h1ZmZsZTogZmFsc2VgIHdoZW4gY2FsbGluZyBgTGF5ZXJzTW9kZWwuZml0KClgLlxuICAgKlxuICAgKiBUbyByZXNldCB0aGUgc3RhdGUgb2YgeW91ciBtb2RlbCwgY2FsbCBgcmVzZXRTdGF0ZXMoKWAgb24gZWl0aGVyIHRoZVxuICAgKiBzcGVjaWZpYyBsYXllciBvciBvbiB0aGUgZW50aXJlIG1vZGVsLlxuICAgKi9cbiAgc3RhdGVmdWw/OiBib29sZWFuO1xuICAvLyBUT0RPKGNhaXMpOiBFeHBsb3JlIHdoZXRoZXIgd2UgY2FuIHdhcm4gdXNlcnMgd2hlbiB0aGV5IGZhaWwgdG8gc2V0XG4gIC8vICAgYHNodWZmbGU6IGZhbHNlYCB3aGVuIHRyYWluaW5nIGEgbW9kZWwgY29uc2lzdGluZyBvZiBzdGF0ZWZ1bCBSTk5zXG4gIC8vICAgYW5kIGFueSBzdGF0ZWZ1bCBMYXllcnMgaW4gZ2VuZXJhbC5cblxuICAvKipcbiAgICogSWYgYHRydWVgLCB0aGUgbmV0d29yayB3aWxsIGJlIHVucm9sbGVkLCBlbHNlIGEgc3ltYm9saWMgbG9vcCB3aWxsIGJlXG4gICAqIHVzZWQuIFVucm9sbGluZyBjYW4gc3BlZWQtdXAgYSBSTk4sIGFsdGhvdWdoIGl0IHRlbmRzIHRvIGJlIG1vcmUgbWVtb3J5LVxuICAgKiBpbnRlbnNpdmUuIFVucm9sbGluZyBpcyBvbmx5IHN1aXRhYmxlIGZvciBzaG9ydCBzZXF1ZW5jZXMgKGRlZmF1bHQ6XG4gICAqIGBmYWxzZWApLlxuICAgKiBQb3J0aW5nIE5vdGU6IHRmanMtbGF5ZXJzIGhhcyBhbiBpbXBlcmF0aXZlIGJhY2tlbmQuIFJOTnMgYXJlIGV4ZWN1dGVkIHdpdGhcbiAgICogICBub3JtYWwgVHlwZVNjcmlwdCBjb250cm9sIGZsb3cuIEhlbmNlIHRoaXMgcHJvcGVydHkgaXMgaW5hcHBsaWNhYmxlIGFuZFxuICAgKiAgIGlnbm9yZWQgaW4gdGZqcy1sYXllcnMuXG4gICAqL1xuICB1bnJvbGw/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBEaW1lbnNpb25hbGl0eSBvZiB0aGUgaW5wdXQgKGludGVnZXIpLlxuICAgKiAgIFRoaXMgb3B0aW9uIChvciBhbHRlcm5hdGl2ZWx5LCB0aGUgb3B0aW9uIGBpbnB1dFNoYXBlYCkgaXMgcmVxdWlyZWQgd2hlblxuICAgKiAgIHRoaXMgbGF5ZXIgaXMgdXNlZCBhcyB0aGUgZmlyc3QgbGF5ZXIgaW4gYSBtb2RlbC5cbiAgICovXG4gIGlucHV0RGltPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBMZW5ndGggb2YgdGhlIGlucHV0IHNlcXVlbmNlcywgdG8gYmUgc3BlY2lmaWVkIHdoZW4gaXQgaXMgY29uc3RhbnQuXG4gICAqIFRoaXMgYXJndW1lbnQgaXMgcmVxdWlyZWQgaWYgeW91IGFyZSBnb2luZyB0byBjb25uZWN0IGBGbGF0dGVuYCB0aGVuXG4gICAqIGBEZW5zZWAgbGF5ZXJzIHVwc3RyZWFtICh3aXRob3V0IGl0LCB0aGUgc2hhcGUgb2YgdGhlIGRlbnNlIG91dHB1dHMgY2Fubm90XG4gICAqIGJlIGNvbXB1dGVkKS4gTm90ZSB0aGF0IGlmIHRoZSByZWN1cnJlbnQgbGF5ZXIgaXMgbm90IHRoZSBmaXJzdCBsYXllciBpblxuICAgKiB5b3VyIG1vZGVsLCB5b3Ugd291bGQgbmVlZCB0byBzcGVjaWZ5IHRoZSBpbnB1dCBsZW5ndGggYXQgdGhlIGxldmVsIG9mIHRoZVxuICAgKiBmaXJzdCBsYXllciAoZS5nLiwgdmlhIHRoZSBgaW5wdXRTaGFwZWAgb3B0aW9uKS5cbiAgICovXG4gIGlucHV0TGVuZ3RoPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgUk5OIGV4dGVuZHMgTGF5ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdSTk4nO1xuICBwdWJsaWMgcmVhZG9ubHkgY2VsbDogUk5OQ2VsbDtcbiAgcHVibGljIHJlYWRvbmx5IHJldHVyblNlcXVlbmNlczogYm9vbGVhbjtcbiAgcHVibGljIHJlYWRvbmx5IHJldHVyblN0YXRlOiBib29sZWFuO1xuICBwdWJsaWMgcmVhZG9ubHkgZ29CYWNrd2FyZHM6IGJvb2xlYW47XG4gIHB1YmxpYyByZWFkb25seSB1bnJvbGw6IGJvb2xlYW47XG5cbiAgcHVibGljIHN0YXRlU3BlYzogSW5wdXRTcGVjW107XG4gIHByb3RlY3RlZCBzdGF0ZXNfOiBUZW5zb3JbXTtcblxuICAvLyBOT1RFKGNhaXMpOiBGb3Igc3RhdGVmdWwgUk5OcywgdGhlIG9sZCBzdGF0ZXMgY2Fubm90IGJlIGRpc3Bvc2VkIHJpZ2h0XG4gIC8vIGF3YXkgd2hlbiBuZXcgc3RhdGVzIGFyZSBzZXQsIGJlY2F1c2UgdGhlIG9sZCBzdGF0ZXMgbWF5IG5lZWQgdG8gYmUgdXNlZFxuICAvLyBsYXRlciBmb3IgYmFja3Byb3BhZ2F0aW9uIHRocm91Z2ggdGltZSAoQlBUVCkgYW5kIG90aGVyIHB1cnBvc2VzLiBTbyB3ZVxuICAvLyBrZWVwIHRoZW0gaGVyZSBmb3IgZmluYWwgZGlzcG9zYWwgd2hlbiB0aGUgc3RhdGUgaXMgcmVzZXQgY29tcGxldGVseVxuICAvLyAoaS5lLiwgdGhyb3VnaCBuby1hcmcgY2FsbCB0byBgcmVzZXRTdGF0ZXMoKWApLlxuICBwcm90ZWN0ZWQga2VwdFN0YXRlczogVGVuc29yW11bXTtcblxuICBwcml2YXRlIG51bUNvbnN0YW50czogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFJOTkxheWVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIGxldCBjZWxsOiBSTk5DZWxsO1xuICAgIGlmIChhcmdzLmNlbGwgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ2NlbGwgcHJvcGVydHkgaXMgbWlzc2luZyBmb3IgdGhlIGNvbnN0cnVjdG9yIG9mIFJOTi4nKTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJncy5jZWxsKSkge1xuICAgICAgY2VsbCA9IG5ldyBTdGFja2VkUk5OQ2VsbHMoe2NlbGxzOiBhcmdzLmNlbGx9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbCA9IGFyZ3MuY2VsbDtcbiAgICB9XG4gICAgaWYgKGNlbGwuc3RhdGVTaXplID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdUaGUgUk5OIGNlbGwgc2hvdWxkIGhhdmUgYW4gYXR0cmlidXRlIGBzdGF0ZVNpemVgICh0dXBsZSBvZiAnICtcbiAgICAgICAgICAnaW50ZWdlcnMsIG9uZSBpbnRlZ2VyIHBlciBSTk4gc3RhdGUpLicpO1xuICAgIH1cbiAgICB0aGlzLmNlbGwgPSBjZWxsO1xuICAgIHRoaXMucmV0dXJuU2VxdWVuY2VzID1cbiAgICAgICAgYXJncy5yZXR1cm5TZXF1ZW5jZXMgPT0gbnVsbCA/IGZhbHNlIDogYXJncy5yZXR1cm5TZXF1ZW5jZXM7XG4gICAgdGhpcy5yZXR1cm5TdGF0ZSA9IGFyZ3MucmV0dXJuU3RhdGUgPT0gbnVsbCA/IGZhbHNlIDogYXJncy5yZXR1cm5TdGF0ZTtcbiAgICB0aGlzLmdvQmFja3dhcmRzID0gYXJncy5nb0JhY2t3YXJkcyA9PSBudWxsID8gZmFsc2UgOiBhcmdzLmdvQmFja3dhcmRzO1xuICAgIHRoaXMuX3N0YXRlZnVsID0gYXJncy5zdGF0ZWZ1bCA9PSBudWxsID8gZmFsc2UgOiBhcmdzLnN0YXRlZnVsO1xuICAgIHRoaXMudW5yb2xsID0gYXJncy51bnJvbGwgPT0gbnVsbCA/IGZhbHNlIDogYXJncy51bnJvbGw7XG5cbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgdGhpcy5pbnB1dFNwZWMgPSBbbmV3IElucHV0U3BlYyh7bmRpbTogM30pXTtcbiAgICB0aGlzLnN0YXRlU3BlYyA9IG51bGw7XG4gICAgdGhpcy5zdGF0ZXNfID0gbnVsbDtcbiAgICAvLyBUT0RPKGNhaXMpOiBBZGQgY29uc3RhbnRzU3BlYyBhbmQgbnVtQ29uc3RhbnRzLlxuICAgIHRoaXMubnVtQ29uc3RhbnRzID0gbnVsbDtcbiAgICAvLyBUT0RPKGNhaXMpOiBMb29rIGludG8gdGhlIHVzZSBvZiBpbml0aWFsX3N0YXRlIGluIHRoZSBrd2FyZ3Mgb2YgdGhlXG4gICAgLy8gICBjb25zdHJ1Y3Rvci5cblxuICAgIHRoaXMua2VwdFN0YXRlcyA9IFtdO1xuICB9XG5cbiAgLy8gUG9ydGluZyBOb3RlOiBUaGlzIGlzIHRoZSBlcXVpdmFsZW50IG9mIGBSTk4uc3RhdGVzYCBwcm9wZXJ0eSBnZXR0ZXIgaW5cbiAgLy8gICBQeUtlcmFzLlxuICBnZXRTdGF0ZXMoKTogVGVuc29yW10ge1xuICAgIGlmICh0aGlzLnN0YXRlc18gPT0gbnVsbCkge1xuICAgICAgY29uc3QgbnVtU3RhdGVzID1cbiAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpID8gdGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGggOiAxO1xuICAgICAgcmV0dXJuIG1hdGhfdXRpbHMucmFuZ2UoMCwgbnVtU3RhdGVzKS5tYXAoeCA9PiBudWxsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdGVzXztcbiAgICB9XG4gIH1cblxuICAvLyBQb3J0aW5nIE5vdGU6IFRoaXMgaXMgdGhlIGVxdWl2YWxlbnQgb2YgdGhlIGBSTk4uc3RhdGVzYCBwcm9wZXJ0eSBzZXR0ZXIgaW5cbiAgLy8gICBQeUtlcmFzLlxuICBzZXRTdGF0ZXMoc3RhdGVzOiBUZW5zb3JbXSk6IHZvaWQge1xuICAgIHRoaXMuc3RhdGVzXyA9IHN0YXRlcztcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaWYgKGlzQXJyYXlPZlNoYXBlcyhpbnB1dFNoYXBlKSkge1xuICAgICAgaW5wdXRTaGFwZSA9IChpbnB1dFNoYXBlIGFzIFNoYXBlW10pWzBdO1xuICAgIH1cbiAgICBpbnB1dFNoYXBlID0gaW5wdXRTaGFwZSBhcyBTaGFwZTtcblxuICAgIC8vIFRPRE8oY2Fpcyk6IFJlbW92ZSB0aGUgY2FzdGluZyBvbmNlIHN0YWNrZWQgUk5OIGNlbGxzIGJlY29tZSBzdXBwb3J0ZWQuXG4gICAgbGV0IHN0YXRlU2l6ZSA9IHRoaXMuY2VsbC5zdGF0ZVNpemU7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHN0YXRlU2l6ZSkpIHtcbiAgICAgIHN0YXRlU2l6ZSA9IFtzdGF0ZVNpemVdO1xuICAgIH1cbiAgICBjb25zdCBvdXRwdXREaW0gPSBzdGF0ZVNpemVbMF07XG4gICAgbGV0IG91dHB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdO1xuICAgIGlmICh0aGlzLnJldHVyblNlcXVlbmNlcykge1xuICAgICAgb3V0cHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsxXSwgb3V0cHV0RGltXTtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXSwgb3V0cHV0RGltXTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5yZXR1cm5TdGF0ZSkge1xuICAgICAgY29uc3Qgc3RhdGVTaGFwZTogU2hhcGVbXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBkaW0gb2Ygc3RhdGVTaXplKSB7XG4gICAgICAgIHN0YXRlU2hhcGUucHVzaChbaW5wdXRTaGFwZVswXSwgZGltXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW291dHB1dFNoYXBlXS5jb25jYXQoc3RhdGVTaGFwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgICB9XG4gIH1cblxuICBjb21wdXRlTWFzayhpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwgbWFzaz86IFRlbnNvcnxUZW5zb3JbXSk6IFRlbnNvclxuICAgICAgfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGZjLnRpZHkoKCkgPT4ge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkobWFzaykpIHtcbiAgICAgICAgbWFzayA9IG1hc2tbMF07XG4gICAgICB9XG4gICAgICBjb25zdCBvdXRwdXRNYXNrID0gdGhpcy5yZXR1cm5TZXF1ZW5jZXMgPyBtYXNrIDogbnVsbDtcblxuICAgICAgaWYgKHRoaXMucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgY29uc3Qgc3RhdGVNYXNrID0gdGhpcy5zdGF0ZXMubWFwKHMgPT4gbnVsbCk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0TWFza10uY29uY2F0KHN0YXRlTWFzayk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gb3V0cHV0TWFzaztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIGN1cnJlbnQgc3RhdGUgdGVuc29ycyBvZiB0aGUgUk5OLlxuICAgKlxuICAgKiBJZiB0aGUgc3RhdGUgaGFzbid0IGJlZW4gc2V0LCByZXR1cm4gYW4gYXJyYXkgb2YgYG51bGxgcyBvZiB0aGUgY29ycmVjdFxuICAgKiBsZW5ndGguXG4gICAqL1xuICBnZXQgc3RhdGVzKCk6IFRlbnNvcltdIHtcbiAgICBpZiAodGhpcy5zdGF0ZXNfID09IG51bGwpIHtcbiAgICAgIGNvbnN0IG51bVN0YXRlcyA9XG4gICAgICAgICAgQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKSA/IHRoaXMuY2VsbC5zdGF0ZVNpemUubGVuZ3RoIDogMTtcbiAgICAgIGNvbnN0IG91dHB1dDogVGVuc29yW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3RhdGVzOyArK2kpIHtcbiAgICAgICAgb3V0cHV0LnB1c2gobnVsbCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5zdGF0ZXNfO1xuICAgIH1cbiAgfVxuXG4gIHNldCBzdGF0ZXMoczogVGVuc29yW10pIHtcbiAgICB0aGlzLnN0YXRlc18gPSBzO1xuICB9XG5cbiAgcHVibGljIGJ1aWxkKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiB2b2lkIHtcbiAgICAvLyBOb3RlIGlucHV0U2hhcGUgd2lsbCBiZSBhbiBBcnJheSBvZiBTaGFwZXMgb2YgaW5pdGlhbCBzdGF0ZXMgYW5kXG4gICAgLy8gY29uc3RhbnRzIGlmIHRoZXNlIGFyZSBwYXNzZWQgaW4gYXBwbHkoKS5cbiAgICBjb25zdCBjb25zdGFudFNoYXBlOiBTaGFwZVtdID0gbnVsbDtcbiAgICBpZiAodGhpcy5udW1Db25zdGFudHMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ0NvbnN0YW50cyBzdXBwb3J0IGlzIG5vdCBpbXBsZW1lbnRlZCBpbiBSTk4geWV0LicpO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5T2ZTaGFwZXMoaW5wdXRTaGFwZSkpIHtcbiAgICAgIGlucHV0U2hhcGUgPSAoaW5wdXRTaGFwZSBhcyBTaGFwZVtdKVswXTtcbiAgICB9XG4gICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGUgYXMgU2hhcGU7XG5cbiAgICBjb25zdCBiYXRjaFNpemU6IG51bWJlciA9IHRoaXMuc3RhdGVmdWwgPyBpbnB1dFNoYXBlWzBdIDogbnVsbDtcbiAgICBjb25zdCBpbnB1dERpbSA9IGlucHV0U2hhcGUuc2xpY2UoMik7XG4gICAgdGhpcy5pbnB1dFNwZWNbMF0gPSBuZXcgSW5wdXRTcGVjKHtzaGFwZTogW2JhdGNoU2l6ZSwgbnVsbCwgLi4uaW5wdXREaW1dfSk7XG5cbiAgICAvLyBBbGxvdyBjZWxsIChpZiBSTk5DZWxsIExheWVyKSB0byBidWlsZCBiZWZvcmUgd2Ugc2V0IG9yIHZhbGlkYXRlXG4gICAgLy8gc3RhdGVTcGVjLlxuICAgIGNvbnN0IHN0ZXBJbnB1dFNoYXBlID0gW2lucHV0U2hhcGVbMF1dLmNvbmNhdChpbnB1dFNoYXBlLnNsaWNlKDIpKTtcbiAgICBpZiAoY29uc3RhbnRTaGFwZSAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAnQ29uc3RhbnRzIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkIGluIFJOTiB5ZXQuJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY2VsbC5idWlsZChzdGVwSW5wdXRTaGFwZSk7XG4gICAgfVxuXG4gICAgLy8gU2V0IG9yIHZhbGlkYXRlIHN0YXRlU3BlYy5cbiAgICBsZXQgc3RhdGVTaXplOiBudW1iZXJbXTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh0aGlzLmNlbGwuc3RhdGVTaXplKSkge1xuICAgICAgc3RhdGVTaXplID0gdGhpcy5jZWxsLnN0YXRlU2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGVTaXplID0gW3RoaXMuY2VsbC5zdGF0ZVNpemVdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnN0YXRlU3BlYyAhPSBudWxsKSB7XG4gICAgICBpZiAoIXV0aWwuYXJyYXlzRXF1YWwoXG4gICAgICAgICAgICAgIHRoaXMuc3RhdGVTcGVjLm1hcChzcGVjID0+IHNwZWMuc2hhcGVbc3BlYy5zaGFwZS5sZW5ndGggLSAxXSksXG4gICAgICAgICAgICAgIHN0YXRlU2l6ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgQW4gaW5pdGlhbFN0YXRlIHdhcyBwYXNzZWQgdGhhdCBpcyBub3QgY29tcGF0aWJsZSB3aXRoIGAgK1xuICAgICAgICAgICAgYGNlbGwuc3RhdGVTaXplLiBSZWNlaXZlZCBzdGF0ZVNwZWM9JHt0aGlzLnN0YXRlU3BlY307IGAgK1xuICAgICAgICAgICAgYEhvd2V2ZXIgY2VsbC5zdGF0ZVNpemUgaXMgJHt0aGlzLmNlbGwuc3RhdGVTaXplfWApO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXRlU3BlYyA9XG4gICAgICAgICAgc3RhdGVTaXplLm1hcChkaW0gPT4gbmV3IElucHV0U3BlYyh7c2hhcGU6IFtudWxsLCBkaW1dfSkpO1xuICAgIH1cbiAgICBpZiAodGhpcy5zdGF0ZWZ1bCkge1xuICAgICAgdGhpcy5yZXNldFN0YXRlcygpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNldCB0aGUgc3RhdGUgdGVuc29ycyBvZiB0aGUgUk5OLlxuICAgKlxuICAgKiBJZiB0aGUgYHN0YXRlc2AgYXJndW1lbnQgaXMgYHVuZGVmaW5lZGAgb3IgYG51bGxgLCB3aWxsIHNldCB0aGVcbiAgICogc3RhdGUgdGVuc29yKHMpIG9mIHRoZSBSTk4gdG8gYWxsLXplcm8gdGVuc29ycyBvZiB0aGUgYXBwcm9wcmlhdGVcbiAgICogc2hhcGUocykuXG4gICAqXG4gICAqIElmIGBzdGF0ZXNgIGlzIHByb3ZpZGVkLCB3aWxsIHNldCB0aGUgc3RhdGUgdGVuc29ycyBvZiB0aGUgUk5OIHRvIGl0c1xuICAgKiB2YWx1ZS5cbiAgICpcbiAgICogQHBhcmFtIHN0YXRlcyBPcHRpb25hbCBleHRlcm5hbGx5LXByb3ZpZGVkIGluaXRpYWwgc3RhdGVzLlxuICAgKiBAcGFyYW0gdHJhaW5pbmcgV2hldGhlciB0aGlzIGNhbGwgaXMgZG9uZSBkdXJpbmcgdHJhaW5pbmcuIEZvciBzdGF0ZWZ1bFxuICAgKiAgIFJOTnMsIHRoaXMgYWZmZWN0cyB3aGV0aGVyIHRoZSBvbGQgc3RhdGVzIGFyZSBrZXB0IG9yIGRpc2NhcmRlZC4gSW5cbiAgICogICBwYXJ0aWN1bGFyLCBpZiBgdHJhaW5pbmdgIGlzIGB0cnVlYCwgdGhlIG9sZCBzdGF0ZXMgd2lsbCBiZSBrZXB0IHNvXG4gICAqICAgdGhhdCBzdWJzZXF1ZW50IGJhY2twcm9wZ2F0YWlvbiB0aHJvdWdoIHRpbWUgKEJQVFQpIG1heSB3b3JrIHByb3Blcmx5LlxuICAgKiAgIEVsc2UsIHRoZSBvbGQgc3RhdGVzIHdpbGwgYmUgZGlzY2FyZGVkLlxuICAgKi9cbiAgcmVzZXRTdGF0ZXMoc3RhdGVzPzogVGVuc29yfFRlbnNvcltdLCB0cmFpbmluZyA9IGZhbHNlKTogdm9pZCB7XG4gICAgdGlkeSgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGVmdWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFxuICAgICAgICAgICAgJ0Nhbm5vdCBjYWxsIHJlc2V0U3RhdGVzKCkgb24gYW4gUk5OIExheWVyIHRoYXQgaXMgbm90IHN0YXRlZnVsLicpO1xuICAgICAgfVxuICAgICAgY29uc3QgYmF0Y2hTaXplID0gdGhpcy5pbnB1dFNwZWNbMF0uc2hhcGVbMF07XG4gICAgICBpZiAoYmF0Y2hTaXplID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAnSWYgYW4gUk5OIGlzIHN0YXRlZnVsLCBpdCBuZWVkcyB0byBrbm93IGl0cyBiYXRjaCBzaXplLiBTcGVjaWZ5ICcgK1xuICAgICAgICAgICAgJ3RoZSBiYXRjaCBzaXplIG9mIHlvdXIgaW5wdXQgdGVuc29yczogXFxuJyArXG4gICAgICAgICAgICAnLSBJZiB1c2luZyBhIFNlcXVlbnRpYWwgbW9kZWwsIHNwZWNpZnkgdGhlIGJhdGNoIHNpemUgYnkgJyArXG4gICAgICAgICAgICAncGFzc2luZyBhIGBiYXRjaElucHV0U2hhcGVgIG9wdGlvbiB0byB5b3VyIGZpcnN0IGxheWVyLlxcbicgK1xuICAgICAgICAgICAgJy0gSWYgdXNpbmcgdGhlIGZ1bmN0aW9uYWwgQVBJLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5ICcgK1xuICAgICAgICAgICAgJ3Bhc3NpbmcgYSBgYmF0Y2hTaGFwZWAgb3B0aW9uIHRvIHlvdXIgSW5wdXQgbGF5ZXIuJyk7XG4gICAgICB9XG4gICAgICAvLyBJbml0aWFsaXplIHN0YXRlIGlmIG51bGwuXG4gICAgICBpZiAodGhpcy5zdGF0ZXNfID09IG51bGwpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlc18gPVxuICAgICAgICAgICAgICB0aGlzLmNlbGwuc3RhdGVTaXplLm1hcChkaW0gPT4gdGZjLnplcm9zKFtiYXRjaFNpemUsIGRpbV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlc18gPSBbdGZjLnplcm9zKFtiYXRjaFNpemUsIHRoaXMuY2VsbC5zdGF0ZVNpemVdKV07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoc3RhdGVzID09IG51bGwpIHtcbiAgICAgICAgLy8gRGlzcG9zZSBvbGQgc3RhdGUgdGVuc29ycy5cbiAgICAgICAgdGZjLmRpc3Bvc2UodGhpcy5zdGF0ZXNfKTtcbiAgICAgICAgLy8gRm9yIHN0YXRlZnVsIFJOTnMsIGZ1bGx5IGRpc3Bvc2Uga2VwdCBvbGQgc3RhdGVzLlxuICAgICAgICBpZiAodGhpcy5rZXB0U3RhdGVzICE9IG51bGwpIHtcbiAgICAgICAgICB0ZmMuZGlzcG9zZSh0aGlzLmtlcHRTdGF0ZXMpO1xuICAgICAgICAgIHRoaXMua2VwdFN0YXRlcyA9IFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSkpIHtcbiAgICAgICAgICB0aGlzLnN0YXRlc18gPVxuICAgICAgICAgICAgICB0aGlzLmNlbGwuc3RhdGVTaXplLm1hcChkaW0gPT4gdGZjLnplcm9zKFtiYXRjaFNpemUsIGRpbV0pKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlc19bMF0gPSB0ZmMuemVyb3MoW2JhdGNoU2l6ZSwgdGhpcy5jZWxsLnN0YXRlU2l6ZV0pO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkoc3RhdGVzKSkge1xuICAgICAgICAgIHN0YXRlcyA9IFtzdGF0ZXNdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZXMubGVuZ3RoICE9PSB0aGlzLnN0YXRlc18ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgIGBMYXllciAke3RoaXMubmFtZX0gZXhwZWN0cyAke3RoaXMuc3RhdGVzXy5sZW5ndGh9IHN0YXRlKHMpLCBgICtcbiAgICAgICAgICAgICAgYGJ1dCBpdCByZWNlaXZlZCAke3N0YXRlcy5sZW5ndGh9IHN0YXRlIHZhbHVlKHMpLiBJbnB1dCBgICtcbiAgICAgICAgICAgICAgYHJlY2VpdmVkOiAke3N0YXRlc31gKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICh0cmFpbmluZyA9PT0gdHJ1ZSkge1xuICAgICAgICAgIC8vIFN0b3JlIG9sZCBzdGF0ZSB0ZW5zb3JzIGZvciBjb21wbGV0ZSBkaXNwb3NhbCBsYXRlciwgaS5lLiwgZHVyaW5nXG4gICAgICAgICAgLy8gdGhlIG5leHQgbm8tYXJnIGNhbGwgdG8gdGhpcyBtZXRob2QuIFdlIGRvIG5vdCBkaXNwb3NlIHRoZSBvbGRcbiAgICAgICAgICAvLyBzdGF0ZXMgaW1tZWRpYXRlbHkgYmVjYXVzZSB0aGF0IEJQVFQgKGFtb25nIG90aGVyIHRoaW5ncykgcmVxdWlyZVxuICAgICAgICAgIC8vIHRoZW0uXG4gICAgICAgICAgdGhpcy5rZXB0U3RhdGVzLnB1c2godGhpcy5zdGF0ZXNfLnNsaWNlKCkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRmYy5kaXNwb3NlKHRoaXMuc3RhdGVzXyk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGxldCBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5zdGF0ZXNfLmxlbmd0aDsgKytpbmRleCkge1xuICAgICAgICAgIGNvbnN0IHZhbHVlID0gc3RhdGVzW2luZGV4XTtcbiAgICAgICAgICBjb25zdCBkaW0gPSBBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpID9cbiAgICAgICAgICAgICAgdGhpcy5jZWxsLnN0YXRlU2l6ZVtpbmRleF0gOlxuICAgICAgICAgICAgICB0aGlzLmNlbGwuc3RhdGVTaXplO1xuICAgICAgICAgIGNvbnN0IGV4cGVjdGVkU2hhcGUgPSBbYmF0Y2hTaXplLCBkaW1dO1xuICAgICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbCh2YWx1ZS5zaGFwZSwgZXhwZWN0ZWRTaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICAgIGBTdGF0ZSAke2luZGV4fSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX06IGAgK1xuICAgICAgICAgICAgICAgIGBleHBlY3RlZCBzaGFwZT0ke2V4cGVjdGVkU2hhcGV9LCByZWNlaXZlZCBzaGFwZT0ke1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zaGFwZX1gKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zdGF0ZXNfW2luZGV4XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aGlzLnN0YXRlc18gPSB0aGlzLnN0YXRlc18ubWFwKHN0YXRlID0+IHRmYy5rZWVwKHN0YXRlLmNsb25lKCkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGFwcGx5KFxuICAgICAgaW5wdXRzOiBUZW5zb3J8VGVuc29yW118U3ltYm9saWNUZW5zb3J8U3ltYm9saWNUZW5zb3JbXSxcbiAgICAgIGt3YXJncz86IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcnxTeW1ib2xpY1RlbnNvcltdIHtcbiAgICAvLyBUT0RPKGNhaXMpOiBGaWd1cmUgb3V0IHdoZXRoZXIgaW5pdGlhbFN0YXRlIGlzIGluIGt3YXJncyBvciBpbnB1dHMuXG4gICAgbGV0IGluaXRpYWxTdGF0ZTogVGVuc29yW118U3ltYm9saWNUZW5zb3JbXSA9XG4gICAgICAgIGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snaW5pdGlhbFN0YXRlJ107XG4gICAgbGV0IGNvbnN0YW50czogVGVuc29yW118U3ltYm9saWNUZW5zb3JbXSA9XG4gICAgICAgIGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snY29uc3RhbnRzJ107XG4gICAgaWYgKGt3YXJncyA9PSBudWxsKSB7XG4gICAgICBrd2FyZ3MgPSB7fTtcbiAgICB9XG5cbiAgICBjb25zdCBzdGFuZGFyZGl6ZWQgPVxuICAgICAgICBzdGFuZGFyZGl6ZUFyZ3MoaW5wdXRzLCBpbml0aWFsU3RhdGUsIGNvbnN0YW50cywgdGhpcy5udW1Db25zdGFudHMpO1xuICAgIGlucHV0cyA9IHN0YW5kYXJkaXplZC5pbnB1dHM7XG4gICAgaW5pdGlhbFN0YXRlID0gc3RhbmRhcmRpemVkLmluaXRpYWxTdGF0ZTtcbiAgICBjb25zdGFudHMgPSBzdGFuZGFyZGl6ZWQuY29uc3RhbnRzO1xuXG4gICAgLy8gSWYgYW55IG9mIGBpbml0aWFsX3N0YXRlYCBvciBgY29uc3RhbnRzYCBhcmUgc3BlY2lmaWVkIGFuZCBhcmVcbiAgICAvLyBgdGYuU3ltYm9saWNUZW5zb3JgcywgdGhlbiBhZGQgdGhlbSB0byB0aGUgaW5wdXRzIGFuZCB0ZW1wb3JhcmlseSBtb2RpZnlcbiAgICAvLyB0aGUgaW5wdXRfc3BlYyB0byBpbmNsdWRlIHRoZW0uXG5cbiAgICBsZXQgYWRkaXRpb25hbElucHV0czogQXJyYXk8VGVuc29yfFN5bWJvbGljVGVuc29yPiA9IFtdO1xuICAgIGxldCBhZGRpdGlvbmFsU3BlY3M6IElucHV0U3BlY1tdID0gW107XG4gICAgaWYgKGluaXRpYWxTdGF0ZSAhPSBudWxsKSB7XG4gICAgICBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddID0gaW5pdGlhbFN0YXRlO1xuICAgICAgYWRkaXRpb25hbElucHV0cyA9IGFkZGl0aW9uYWxJbnB1dHMuY29uY2F0KGluaXRpYWxTdGF0ZSk7XG4gICAgICB0aGlzLnN0YXRlU3BlYyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBzdGF0ZSBvZiBpbml0aWFsU3RhdGUpIHtcbiAgICAgICAgdGhpcy5zdGF0ZVNwZWMucHVzaChuZXcgSW5wdXRTcGVjKHtzaGFwZTogc3RhdGUuc2hhcGV9KSk7XG4gICAgICB9XG4gICAgICAvLyBUT0RPKGNhaXMpOiBVc2UgdGhlIGZvbGxvd2luZyBpbnN0ZWFkLlxuICAgICAgLy8gdGhpcy5zdGF0ZVNwZWMgPSBpbml0aWFsU3RhdGUubWFwKHN0YXRlID0+IG5ldyBJbnB1dFNwZWMoe3NoYXBlOlxuICAgICAgLy8gc3RhdGUuc2hhcGV9KSk7XG4gICAgICBhZGRpdGlvbmFsU3BlY3MgPSBhZGRpdGlvbmFsU3BlY3MuY29uY2F0KHRoaXMuc3RhdGVTcGVjKTtcbiAgICB9XG4gICAgaWYgKGNvbnN0YW50cyAhPSBudWxsKSB7XG4gICAgICBrd2FyZ3NbJ2NvbnN0YW50cyddID0gY29uc3RhbnRzO1xuICAgICAgYWRkaXRpb25hbElucHV0cyA9IGFkZGl0aW9uYWxJbnB1dHMuY29uY2F0KGNvbnN0YW50cyk7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgdGhpcy5jb25zdGFudHNTcGVjLlxuICAgICAgdGhpcy5udW1Db25zdGFudHMgPSBjb25zdGFudHMubGVuZ3RoO1xuICAgIH1cblxuICAgIGNvbnN0IGlzVGVuc29yID0gYWRkaXRpb25hbElucHV0c1swXSBpbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yO1xuICAgIGlmIChpc1RlbnNvcikge1xuICAgICAgLy8gQ29tcHV0ZSBmdWxsIGlucHV0IHNwZWMsIGluY2x1ZGluZyBzdGF0ZSBhbmQgY29uc3RhbnRzLlxuICAgICAgY29uc3QgZnVsbElucHV0ID1cbiAgICAgICAgICBbaW5wdXRzXS5jb25jYXQoYWRkaXRpb25hbElucHV0cykgYXMgVGVuc29yW10gfCBTeW1ib2xpY1RlbnNvcltdO1xuICAgICAgY29uc3QgZnVsbElucHV0U3BlYyA9IHRoaXMuaW5wdXRTcGVjLmNvbmNhdChhZGRpdGlvbmFsU3BlY3MpO1xuICAgICAgLy8gUGVyZm9ybSB0aGUgY2FsbCB3aXRoIHRlbXBvcmFyaWx5IHJlcGxhY2VkIGlucHV0U3BlYy5cbiAgICAgIGNvbnN0IG9yaWdpbmFsSW5wdXRTcGVjID0gdGhpcy5pbnB1dFNwZWM7XG4gICAgICB0aGlzLmlucHV0U3BlYyA9IGZ1bGxJbnB1dFNwZWM7XG4gICAgICBjb25zdCBvdXRwdXQgPSBzdXBlci5hcHBseShmdWxsSW5wdXQsIGt3YXJncyk7XG4gICAgICB0aGlzLmlucHV0U3BlYyA9IG9yaWdpbmFsSW5wdXRTcGVjO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIHN1cGVyLmFwcGx5KGlucHV0cywga3dhcmdzKTtcbiAgICB9XG4gIH1cblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICAvLyBJbnB1dCBzaGFwZTogYFtzYW1wbGVzLCB0aW1lIChwYWRkZWQgd2l0aCB6ZXJvcyksIGlucHV0X2RpbV1gLlxuICAgIC8vIE5vdGUgdGhhdCB0aGUgLmJ1aWxkKCkgbWV0aG9kIG9mIHN1YmNsYXNzZXMgKiptdXN0KiogZGVmaW5lXG4gICAgLy8gdGhpcy5pbnB1dFNwZWMgYW5kIHRoaXMuc3RhdGVTcGVjIG93aXRoIGNvbXBsZXRlIGlucHV0IHNoYXBlcy5cbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBtYXNrID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydtYXNrJ10gYXMgVGVuc29yO1xuICAgICAgY29uc3QgdHJhaW5pbmcgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ3RyYWluaW5nJ107XG4gICAgICBsZXQgaW5pdGlhbFN0YXRlOiBUZW5zb3JbXSA9XG4gICAgICAgICAga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydpbml0aWFsU3RhdGUnXTtcblxuICAgICAgaW5wdXRzID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgaWYgKGluaXRpYWxTdGF0ZSA9PSBudWxsKSB7XG4gICAgICAgIGlmICh0aGlzLnN0YXRlZnVsKSB7XG4gICAgICAgICAgaW5pdGlhbFN0YXRlID0gdGhpcy5zdGF0ZXNfO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGluaXRpYWxTdGF0ZSA9IHRoaXMuZ2V0SW5pdGlhbFN0YXRlKGlucHV0cyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgY29uc3QgbnVtU3RhdGVzID1cbiAgICAgICAgICBBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpID8gdGhpcy5jZWxsLnN0YXRlU2l6ZS5sZW5ndGggOiAxO1xuICAgICAgaWYgKGluaXRpYWxTdGF0ZS5sZW5ndGggIT09IG51bVN0YXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBSTk4gTGF5ZXIgaGFzICR7bnVtU3RhdGVzfSBzdGF0ZShzKSBidXQgd2FzIHBhc3NlZCBgICtcbiAgICAgICAgICAgIGAke2luaXRpYWxTdGF0ZS5sZW5ndGh9IGluaXRpYWwgc3RhdGUocykuYCk7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy51bnJvbGwpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgJ0lnbm9yaW5nIHVucm9sbCA9IHRydWUgZm9yIFJOTiBsYXllciwgZHVlIHRvIGltcGVyYXRpdmUgYmFja2VuZC4nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2VsbENhbGxLd2FyZ3M6IEt3YXJncyA9IHt0cmFpbmluZ307XG5cbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBzdXBwb3J0IGZvciBjb25zdGFudHMuXG4gICAgICBjb25zdCBzdGVwID0gKGlucHV0czogVGVuc29yLCBzdGF0ZXM6IFRlbnNvcltdKSA9PiB7XG4gICAgICAgIC8vIGBpbnB1dHNgIGFuZCBgc3RhdGVzYCBhcmUgY29uY2F0ZW5hdGVkIHRvIGZvcm0gYSBzaW5nbGUgYEFycmF5YCBvZlxuICAgICAgICAvLyBgdGYuVGVuc29yYHMgYXMgdGhlIGlucHV0IHRvIGBjZWxsLmNhbGwoKWAuXG4gICAgICAgIGNvbnN0IG91dHB1dHMgPVxuICAgICAgICAgICAgdGhpcy5jZWxsLmNhbGwoW2lucHV0c10uY29uY2F0KHN0YXRlcyksIGNlbGxDYWxsS3dhcmdzKSBhcyBUZW5zb3JbXTtcbiAgICAgICAgLy8gTWFyc2hhbGwgdGhlIHJldHVybiB2YWx1ZSBpbnRvIG91dHB1dCBhbmQgbmV3IHN0YXRlcy5cbiAgICAgICAgcmV0dXJuIFtvdXRwdXRzWzBdLCBvdXRwdXRzLnNsaWNlKDEpXSBhcyBbVGVuc29yLCBUZW5zb3JbXV07XG4gICAgICB9O1xuXG4gICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgc3VwcG9ydCBmb3IgY29uc3RhbnRzLlxuXG4gICAgICBjb25zdCBybm5PdXRwdXRzID1cbiAgICAgICAgICBybm4oc3RlcCwgaW5wdXRzLCBpbml0aWFsU3RhdGUsIHRoaXMuZ29CYWNrd2FyZHMsIG1hc2ssIG51bGwsXG4gICAgICAgICAgICAgIHRoaXMudW5yb2xsLCB0aGlzLnJldHVyblNlcXVlbmNlcyk7XG4gICAgICBjb25zdCBsYXN0T3V0cHV0ID0gcm5uT3V0cHV0c1swXTtcbiAgICAgIGNvbnN0IG91dHB1dHMgPSBybm5PdXRwdXRzWzFdO1xuICAgICAgY29uc3Qgc3RhdGVzID0gcm5uT3V0cHV0c1syXTtcblxuICAgICAgaWYgKHRoaXMuc3RhdGVmdWwpIHtcbiAgICAgICAgdGhpcy5yZXNldFN0YXRlcyhzdGF0ZXMsIHRyYWluaW5nKTtcbiAgICAgIH1cblxuICAgICAgY29uc3Qgb3V0cHV0ID0gdGhpcy5yZXR1cm5TZXF1ZW5jZXMgPyBvdXRwdXRzIDogbGFzdE91dHB1dDtcblxuICAgICAgLy8gVE9ETyhjYWlzKTogUG9ycGVydHkgc2V0IGxlYXJuaW5nIHBoYXNlIGZsYWcuXG5cbiAgICAgIGlmICh0aGlzLnJldHVyblN0YXRlKSB7XG4gICAgICAgIHJldHVybiBbb3V0cHV0XS5jb25jYXQoc3RhdGVzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBnZXRJbml0aWFsU3RhdGUoaW5wdXRzOiBUZW5zb3IpOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgLy8gQnVpbGQgYW4gYWxsLXplcm8gdGVuc29yIG9mIHNoYXBlIFtzYW1wbGVzLCBvdXRwdXREaW1dLlxuICAgICAgLy8gW1NhbXBsZXMsIHRpbWVTdGVwcywgaW5wdXREaW1dLlxuICAgICAgbGV0IGluaXRpYWxTdGF0ZSA9IHRmYy56ZXJvcyhpbnB1dHMuc2hhcGUpO1xuICAgICAgLy8gW1NhbXBsZXNdLlxuICAgICAgaW5pdGlhbFN0YXRlID0gdGZjLnN1bShpbml0aWFsU3RhdGUsIFsxLCAyXSk7XG4gICAgICBpbml0aWFsU3RhdGUgPSBLLmV4cGFuZERpbXMoaW5pdGlhbFN0YXRlKTsgIC8vIFtTYW1wbGVzLCAxXS5cblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodGhpcy5jZWxsLnN0YXRlU2l6ZSkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5zdGF0ZVNpemUubWFwKFxuICAgICAgICAgICAgZGltID0+IGRpbSA+IDEgPyBLLnRpbGUoaW5pdGlhbFN0YXRlLCBbMSwgZGltXSkgOiBpbml0aWFsU3RhdGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2VsbC5zdGF0ZVNpemUgPiAxID9cbiAgICAgICAgICAgIFtLLnRpbGUoaW5pdGlhbFN0YXRlLCBbMSwgdGhpcy5jZWxsLnN0YXRlU2l6ZV0pXSA6XG4gICAgICAgICAgICBbaW5pdGlhbFN0YXRlXTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGdldCB0cmFpbmFibGVXZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgaWYgKCF0aGlzLnRyYWluYWJsZSkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgICAvLyBQb3J0aW5nIE5vdGU6IEluIFR5cGVTY3JpcHQsIGB0aGlzYCBpcyBhbHdheXMgYW4gaW5zdGFuY2Ugb2YgYExheWVyYC5cbiAgICByZXR1cm4gdGhpcy5jZWxsLnRyYWluYWJsZVdlaWdodHM7XG4gIH1cblxuICBnZXQgbm9uVHJhaW5hYmxlV2VpZ2h0cygpOiBMYXllclZhcmlhYmxlW10ge1xuICAgIC8vIFBvcnRpbmcgTm90ZTogSW4gVHlwZVNjcmlwdCwgYHRoaXNgIGlzIGFsd2F5cyBhbiBpbnN0YW5jZSBvZiBgTGF5ZXJgLlxuICAgIGlmICghdGhpcy50cmFpbmFibGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmNlbGwud2VpZ2h0cztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY2VsbC5ub25UcmFpbmFibGVXZWlnaHRzO1xuICB9XG5cbiAgc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHN1cGVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodmFsdWUpO1xuICAgIGlmICh0aGlzLmNlbGwgIT0gbnVsbCkge1xuICAgICAgdGhpcy5jZWxsLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcblxuICAgIGNvbnN0IGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge1xuICAgICAgcmV0dXJuU2VxdWVuY2VzOiB0aGlzLnJldHVyblNlcXVlbmNlcyxcbiAgICAgIHJldHVyblN0YXRlOiB0aGlzLnJldHVyblN0YXRlLFxuICAgICAgZ29CYWNrd2FyZHM6IHRoaXMuZ29CYWNrd2FyZHMsXG4gICAgICBzdGF0ZWZ1bDogdGhpcy5zdGF0ZWZ1bCxcbiAgICAgIHVucm9sbDogdGhpcy51bnJvbGwsXG4gICAgfTtcblxuICAgIGlmICh0aGlzLm51bUNvbnN0YW50cyAhPSBudWxsKSB7XG4gICAgICBjb25maWdbJ251bUNvbnN0YW50cyddID0gdGhpcy5udW1Db25zdGFudHM7XG4gICAgfVxuXG4gICAgY29uc3QgY2VsbENvbmZpZyA9IHRoaXMuY2VsbC5nZXRDb25maWcoKTtcblxuICAgIGlmICh0aGlzLmdldENsYXNzTmFtZSgpID09PSBSTk4uY2xhc3NOYW1lKSB7XG4gICAgICBjb25maWdbJ2NlbGwnXSA9IHtcbiAgICAgICAgJ2NsYXNzTmFtZSc6IHRoaXMuY2VsbC5nZXRDbGFzc05hbWUoKSxcbiAgICAgICAgJ2NvbmZpZyc6IGNlbGxDb25maWcsXG4gICAgICB9IGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFZhbHVlO1xuICAgIH1cblxuICAgIC8vIHRoaXMgb3JkZXIgaXMgbmVjZXNzYXJ5LCB0byBwcmV2ZW50IGNlbGwgbmFtZSBmcm9tIHJlcGxhY2luZyBsYXllciBuYW1lXG4gICAgcmV0dXJuIHsuLi5jZWxsQ29uZmlnLCAuLi5iYXNlQ29uZmlnLCAuLi5jb25maWd9O1xuICB9XG5cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlQ29uc3RydWN0b3I8VD4sXG4gICAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCxcbiAgICAgIGN1c3RvbU9iamVjdHMgPSB7fSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QpOiBUIHtcbiAgICBjb25zdCBjZWxsQ29uZmlnID0gY29uZmlnWydjZWxsJ10gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0O1xuICAgIGNvbnN0IGNlbGwgPSBkZXNlcmlhbGl6ZShjZWxsQ29uZmlnLCBjdXN0b21PYmplY3RzKSBhcyBSTk5DZWxsO1xuICAgIHJldHVybiBuZXcgY2xzKE9iamVjdC5hc3NpZ24oY29uZmlnLCB7Y2VsbH0pKTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJOTik7XG5cbi8vIFBvcnRpbmcgTm90ZTogVGhpcyBpcyBhIGNvbW1vbiBwYXJlbnQgY2xhc3MgZm9yIFJOTiBjZWxscy4gVGhlcmUgaXMgbm9cbi8vIGVxdWl2YWxlbnQgb2YgdGhpcyBpbiBQeUtlcmFzLiBIYXZpbmcgYSBjb21tb24gcGFyZW50IGNsYXNzIGZvcmdvZXMgdGhlXG4vLyAgbmVlZCBmb3IgYGhhc19hdHRyKGNlbGwsIC4uLilgIGNoZWNrcyBvciBpdHMgVHlwZVNjcmlwdCBlcXVpdmFsZW50LlxuLyoqXG4gKiBBbiBSTk5DZWxsIGxheWVyLlxuICpcbiAqIEBkb2Mge2hlYWRpbmc6ICdMYXllcnMnLCBzdWJoZWFkaW5nOiAnQ2xhc3Nlcyd9XG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBSTk5DZWxsIGV4dGVuZHMgTGF5ZXIge1xuICAvKipcbiAgICogU2l6ZShzKSBvZiB0aGUgc3RhdGVzLlxuICAgKiBGb3IgUk5OIGNlbGxzIHdpdGggb25seSBhIHNpbmdsZSBzdGF0ZSwgdGhpcyBpcyBhIHNpbmdsZSBpbnRlZ2VyLlxuICAgKi9cbiAgLy8gU2VlXG4gIC8vIGh0dHBzOi8vd3d3LnR5cGVzY3JpcHRsYW5nLm9yZy9kb2NzL2hhbmRib29rL3JlbGVhc2Utbm90ZXMvdHlwZXNjcmlwdC00LTAuaHRtbCNwcm9wZXJ0aWVzLW92ZXJyaWRpbmctYWNjZXNzb3JzLWFuZC12aWNlLXZlcnNhLWlzLWFuLWVycm9yXG4gIHB1YmxpYyBhYnN0cmFjdCBzdGF0ZVNpemU6IG51bWJlcnxudW1iZXJbXTtcbiAgcHVibGljIGRyb3BvdXRNYXNrOiBUZW5zb3J8VGVuc29yW107XG4gIHB1YmxpYyByZWN1cnJlbnREcm9wb3V0TWFzazogVGVuc29yfFRlbnNvcltdO1xufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgU2ltcGxlUk5OQ2VsbExheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiB1bml0czogUG9zaXRpdmUgaW50ZWdlciwgZGltZW5zaW9uYWxpdHkgb2YgdGhlIG91dHB1dCBzcGFjZS5cbiAgICovXG4gIHVuaXRzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEFjdGl2YXRpb24gZnVuY3Rpb24gdG8gdXNlLlxuICAgKiBEZWZhdWx0OiBoeXBlcmJvbGljIHRhbmdlbnQgKCd0YW5oJykuXG4gICAqIElmIHlvdSBwYXNzIGBudWxsYCwgICdsaW5lYXInIGFjdGl2YXRpb24gd2lsbCBiZSBhcHBsaWVkLlxuICAgKi9cbiAgYWN0aXZhdGlvbj86IEFjdGl2YXRpb25JZGVudGlmaWVyO1xuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBsYXllciB1c2VzIGEgYmlhcyB2ZWN0b3IuXG4gICAqL1xuICB1c2VCaWFzPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgZm9yIHRoZSBga2VybmVsYCB3ZWlnaHRzIG1hdHJpeCwgdXNlZCBmb3IgdGhlIGxpbmVhclxuICAgKiB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgaW5wdXRzLlxuICAgKi9cbiAga2VybmVsSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXJ8SW5pdGlhbGl6ZXI7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIGZvciB0aGUgYHJlY3VycmVudEtlcm5lbGAgd2VpZ2h0cyBtYXRyaXgsIHVzZWQgZm9yXG4gICAqIGxpbmVhciB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgcmVjdXJyZW50IHN0YXRlLlxuICAgKi9cbiAgcmVjdXJyZW50SW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXJ8SW5pdGlhbGl6ZXI7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIGZvciB0aGUgYmlhcyB2ZWN0b3IuXG4gICAqL1xuICBiaWFzSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXJ8SW5pdGlhbGl6ZXI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXJpemVyIGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGBrZXJuZWxgIHdlaWdodHMgbWF0cml4LlxuICAgKi9cbiAga2VybmVsUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXJ8UmVndWxhcml6ZXI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXJpemVyIGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGByZWN1cnJlbnRfa2VybmVsYCB3ZWlnaHRzIG1hdHJpeC5cbiAgICovXG4gIHJlY3VycmVudFJlZ3VsYXJpemVyPzogUmVndWxhcml6ZXJJZGVudGlmaWVyfFJlZ3VsYXJpemVyO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBiaWFzIHZlY3Rvci5cbiAgICovXG4gIGJpYXNSZWd1bGFyaXplcj86IFJlZ3VsYXJpemVySWRlbnRpZmllcnxSZWd1bGFyaXplcjtcblxuICAvKipcbiAgICogQ29uc3RyYWludCBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBga2VybmVsYCB3ZWlnaHRzIG1hdHJpeC5cbiAgICovXG4gIGtlcm5lbENvbnN0cmFpbnQ/OiBDb25zdHJhaW50SWRlbnRpZmllcnxDb25zdHJhaW50O1xuXG4gIC8qKlxuICAgKiBDb25zdHJhaW50IGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGByZWN1cnJlbnRLZXJuZWxgIHdlaWdodHMgbWF0cml4LlxuICAgKi9cbiAgcmVjdXJyZW50Q29uc3RyYWludD86IENvbnN0cmFpbnRJZGVudGlmaWVyfENvbnN0cmFpbnQ7XG5cbiAgLyoqXG4gICAqIENvbnN0cmFpbnRmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBiaWFzIHZlY3Rvci5cbiAgICovXG4gIGJpYXNDb25zdHJhaW50PzogQ29uc3RyYWludElkZW50aWZpZXJ8Q29uc3RyYWludDtcblxuICAvKipcbiAgICogRmxvYXQgbnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gRnJhY3Rpb24gb2YgdGhlIHVuaXRzIHRvIGRyb3AgZm9yIHRoZSBsaW5lYXJcbiAgICogdHJhbnNmb3JtYXRpb24gb2YgdGhlIGlucHV0cy5cbiAgICovXG4gIGRyb3BvdXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIEZsb2F0IG51bWJlciBiZXR3ZWVuIDAgYW5kIDEuIEZyYWN0aW9uIG9mIHRoZSB1bml0cyB0byBkcm9wIGZvciB0aGUgbGluZWFyXG4gICAqIHRyYW5zZm9ybWF0aW9uIG9mIHRoZSByZWN1cnJlbnQgc3RhdGUuXG4gICAqL1xuICByZWN1cnJlbnREcm9wb3V0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGlzIGlzIGFkZGVkIGZvciB0ZXN0IERJIHB1cnBvc2UuXG4gICAqL1xuICBkcm9wb3V0RnVuYz86IEZ1bmN0aW9uO1xufVxuXG5leHBvcnQgY2xhc3MgU2ltcGxlUk5OQ2VsbCBleHRlbmRzIFJOTkNlbGwge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdTaW1wbGVSTk5DZWxsJztcbiAgcmVhZG9ubHkgdW5pdHM6IG51bWJlcjtcbiAgcmVhZG9ubHkgYWN0aXZhdGlvbjogQWN0aXZhdGlvbjtcbiAgcmVhZG9ubHkgdXNlQmlhczogYm9vbGVhbjtcblxuICByZWFkb25seSBrZXJuZWxJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG4gIHJlYWRvbmx5IHJlY3VycmVudEluaXRpYWxpemVyOiBJbml0aWFsaXplcjtcbiAgcmVhZG9ubHkgYmlhc0luaXRpYWxpemVyOiBJbml0aWFsaXplcjtcblxuICByZWFkb25seSBrZXJuZWxDb25zdHJhaW50OiBDb25zdHJhaW50O1xuICByZWFkb25seSByZWN1cnJlbnRDb25zdHJhaW50OiBDb25zdHJhaW50O1xuICByZWFkb25seSBiaWFzQ29uc3RyYWludDogQ29uc3RyYWludDtcblxuICByZWFkb25seSBrZXJuZWxSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG4gIHJlYWRvbmx5IHJlY3VycmVudFJlZ3VsYXJpemVyOiBSZWd1bGFyaXplcjtcbiAgcmVhZG9ubHkgYmlhc1JlZ3VsYXJpemVyOiBSZWd1bGFyaXplcjtcblxuICByZWFkb25seSBkcm9wb3V0OiBudW1iZXI7XG4gIHJlYWRvbmx5IHJlY3VycmVudERyb3BvdXQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgZHJvcG91dEZ1bmM6IEZ1bmN0aW9uO1xuXG4gIHJlYWRvbmx5IHN0YXRlU2l6ZTogbnVtYmVyO1xuXG4gIGtlcm5lbDogTGF5ZXJWYXJpYWJsZTtcbiAgcmVjdXJyZW50S2VybmVsOiBMYXllclZhcmlhYmxlO1xuICBiaWFzOiBMYXllclZhcmlhYmxlO1xuXG4gIHJlYWRvbmx5IERFRkFVTFRfQUNUSVZBVElPTiA9ICd0YW5oJztcbiAgcmVhZG9ubHkgREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIgPSAnZ2xvcm90Tm9ybWFsJztcbiAgcmVhZG9ubHkgREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIgPSAnb3J0aG9nb25hbCc7XG4gIHJlYWRvbmx5IERFRkFVTFRfQklBU19JTklUSUFMSVpFUjogSW5pdGlhbGl6ZXJJZGVudGlmaWVyID0gJ3plcm9zJztcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBTaW1wbGVSTk5DZWxsTGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgdGhpcy51bml0cyA9IGFyZ3MudW5pdHM7XG4gICAgYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKHRoaXMudW5pdHMsIGB1bml0c2ApO1xuICAgIHRoaXMuYWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb24oXG4gICAgICAgIGFyZ3MuYWN0aXZhdGlvbiA9PSBudWxsID8gdGhpcy5ERUZBVUxUX0FDVElWQVRJT04gOiBhcmdzLmFjdGl2YXRpb24pO1xuICAgIHRoaXMudXNlQmlhcyA9IGFyZ3MudXNlQmlhcyA9PSBudWxsID8gdHJ1ZSA6IGFyZ3MudXNlQmlhcztcblxuICAgIHRoaXMua2VybmVsSW5pdGlhbGl6ZXIgPSBnZXRJbml0aWFsaXplcihcbiAgICAgICAgYXJncy5rZXJuZWxJbml0aWFsaXplciB8fCB0aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICB0aGlzLnJlY3VycmVudEluaXRpYWxpemVyID0gZ2V0SW5pdGlhbGl6ZXIoXG4gICAgICAgIGFyZ3MucmVjdXJyZW50SW5pdGlhbGl6ZXIgfHwgdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9JTklUSUFMSVpFUik7XG5cbiAgICB0aGlzLmJpYXNJbml0aWFsaXplciA9XG4gICAgICAgIGdldEluaXRpYWxpemVyKGFyZ3MuYmlhc0luaXRpYWxpemVyIHx8IHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKTtcblxuICAgIHRoaXMua2VybmVsUmVndWxhcml6ZXIgPSBnZXRSZWd1bGFyaXplcihhcmdzLmtlcm5lbFJlZ3VsYXJpemVyKTtcbiAgICB0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyID0gZ2V0UmVndWxhcml6ZXIoYXJncy5yZWN1cnJlbnRSZWd1bGFyaXplcik7XG4gICAgdGhpcy5iaWFzUmVndWxhcml6ZXIgPSBnZXRSZWd1bGFyaXplcihhcmdzLmJpYXNSZWd1bGFyaXplcik7XG5cbiAgICB0aGlzLmtlcm5lbENvbnN0cmFpbnQgPSBnZXRDb25zdHJhaW50KGFyZ3Mua2VybmVsQ29uc3RyYWludCk7XG4gICAgdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50ID0gZ2V0Q29uc3RyYWludChhcmdzLnJlY3VycmVudENvbnN0cmFpbnQpO1xuICAgIHRoaXMuYmlhc0NvbnN0cmFpbnQgPSBnZXRDb25zdHJhaW50KGFyZ3MuYmlhc0NvbnN0cmFpbnQpO1xuXG4gICAgdGhpcy5kcm9wb3V0ID0gbWF0aF91dGlscy5taW4oXG4gICAgICAgIFsxLCBtYXRoX3V0aWxzLm1heChbMCwgYXJncy5kcm9wb3V0ID09IG51bGwgPyAwIDogYXJncy5kcm9wb3V0XSldKTtcbiAgICB0aGlzLnJlY3VycmVudERyb3BvdXQgPSBtYXRoX3V0aWxzLm1pbihbXG4gICAgICAxLFxuICAgICAgbWF0aF91dGlscy5tYXgoXG4gICAgICAgICAgWzAsIGFyZ3MucmVjdXJyZW50RHJvcG91dCA9PSBudWxsID8gMCA6IGFyZ3MucmVjdXJyZW50RHJvcG91dF0pXG4gICAgXSk7XG4gICAgdGhpcy5kcm9wb3V0RnVuYyA9IGFyZ3MuZHJvcG91dEZ1bmM7XG4gICAgdGhpcy5zdGF0ZVNpemUgPSB0aGlzLnVuaXRzO1xuICAgIHRoaXMuZHJvcG91dE1hc2sgPSBudWxsO1xuICAgIHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2sgPSBudWxsO1xuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgLy8gVE9ETyhjYWlzKTogVXNlIHJlZ3VsYXJpemVyLlxuICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICdrZXJuZWwnLCBbaW5wdXRTaGFwZVtpbnB1dFNoYXBlLmxlbmd0aCAtIDFdLCB0aGlzLnVuaXRzXSwgbnVsbCxcbiAgICAgICAgdGhpcy5rZXJuZWxJbml0aWFsaXplciwgdGhpcy5rZXJuZWxSZWd1bGFyaXplciwgdHJ1ZSxcbiAgICAgICAgdGhpcy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICB0aGlzLnJlY3VycmVudEtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAncmVjdXJyZW50X2tlcm5lbCcsIFt0aGlzLnVuaXRzLCB0aGlzLnVuaXRzXSwgbnVsbCxcbiAgICAgICAgdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciwgdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciwgdHJ1ZSxcbiAgICAgICAgdGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KTtcbiAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICB0aGlzLmJpYXMgPSB0aGlzLmFkZFdlaWdodChcbiAgICAgICAgICAnYmlhcycsIFt0aGlzLnVuaXRzXSwgbnVsbCwgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsXG4gICAgICAgICAgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpYXMgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIFBvcnRpbmcgTm90ZTogUHlLZXJhcycgZXF1aXZhbGVudCBvZiB0aGlzIG1ldGhvZCB0YWtlcyB0d28gdGVuc29yIGlucHV0czpcbiAgLy8gICBgaW5wdXRzYCBhbmQgYHN0YXRlc2AuIEhlcmUsIHRoZSB0d28gdGVuc29ycyBhcmUgY29tYmluZWQgaW50byBhblxuICAvLyAgIGBUZW5zb3JbXWAgQXJyYXkgYXMgdGhlIGZpcnN0IGlucHV0IGFyZ3VtZW50LlxuICAvLyAgIFNpbWlsYXJseSwgUHlLZXJhcycgZXF1aXZhbGVudCBvZiB0aGlzIG1ldGhvZCByZXR1cm5zIHR3byB2YWx1ZXM6XG4gIC8vICAgIGBvdXRwdXRgIGFuZCBgW291dHB1dF1gLiBIZXJlIHRoZSB0d28gYXJlIGNvbWJpbmVkIGludG8gb25lIGxlbmd0aC0yXG4gIC8vICAgIGBUZW5zb3JbXWAsIGNvbnNpc3Rpbmcgb2YgYG91dHB1dGAgcmVwZWF0ZWQuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpbnB1dHMgPSBpbnB1dHMgYXMgVGVuc29yW107XG4gICAgICBpZiAoaW5wdXRzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgIGBTaW1wbGVSTk5DZWxsIGV4cGVjdHMgMiBpbnB1dCBUZW5zb3JzLCBnb3QgJHtpbnB1dHMubGVuZ3RofS5gKTtcbiAgICAgIH1cbiAgICAgIGxldCBwcmV2T3V0cHV0ID0gaW5wdXRzWzFdO1xuICAgICAgaW5wdXRzID0gaW5wdXRzWzBdO1xuICAgICAgY29uc3QgdHJhaW5pbmcgPSBrd2FyZ3NbJ3RyYWluaW5nJ10gPT0gbnVsbCA/IGZhbHNlIDoga3dhcmdzWyd0cmFpbmluZyddO1xuXG4gICAgICBpZiAoMCA8IHRoaXMuZHJvcG91dCAmJiB0aGlzLmRyb3BvdXQgPCAxICYmIHRoaXMuZHJvcG91dE1hc2sgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRyb3BvdXRNYXNrID0gZ2VuZXJhdGVEcm9wb3V0TWFzayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXM6ICgpID0+IHRmYy5vbmVzTGlrZShpbnB1dHMgYXMgVGVuc29yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0ZTogdGhpcy5kcm9wb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcG91dEZ1bmM6IHRoaXMuZHJvcG91dEZ1bmMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB9KSBhcyBUZW5zb3I7XG4gICAgICB9XG4gICAgICBpZiAoMCA8IHRoaXMucmVjdXJyZW50RHJvcG91dCAmJiB0aGlzLnJlY3VycmVudERyb3BvdXQgPCAxICYmXG4gICAgICAgICAgdGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzayA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2sgPSBnZW5lcmF0ZURyb3BvdXRNYXNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lczogKCkgPT4gdGZjLm9uZXNMaWtlKHByZXZPdXRwdXQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRlOiB0aGlzLnJlY3VycmVudERyb3BvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWluaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wb3V0RnVuYzogdGhpcy5kcm9wb3V0RnVuYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIGFzIFRlbnNvcjtcbiAgICAgIH1cbiAgICAgIGxldCBoOiBUZW5zb3I7XG4gICAgICBjb25zdCBkcE1hc2s6IFRlbnNvciA9IHRoaXMuZHJvcG91dE1hc2sgYXMgVGVuc29yO1xuICAgICAgY29uc3QgcmVjRHBNYXNrOiBUZW5zb3IgPSB0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrIGFzIFRlbnNvcjtcbiAgICAgIGlmIChkcE1hc2sgIT0gbnVsbCkge1xuICAgICAgICBoID0gSy5kb3QodGZjLm11bChpbnB1dHMsIGRwTWFzayksIHRoaXMua2VybmVsLnJlYWQoKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBoID0gSy5kb3QoaW5wdXRzLCB0aGlzLmtlcm5lbC5yZWFkKCkpO1xuICAgICAgfVxuICAgICAgaWYgKHRoaXMuYmlhcyAhPSBudWxsKSB7XG4gICAgICAgIGggPSBLLmJpYXNBZGQoaCwgdGhpcy5iaWFzLnJlYWQoKSk7XG4gICAgICB9XG4gICAgICBpZiAocmVjRHBNYXNrICE9IG51bGwpIHtcbiAgICAgICAgcHJldk91dHB1dCA9IHRmYy5tdWwocHJldk91dHB1dCwgcmVjRHBNYXNrKTtcbiAgICAgIH1cbiAgICAgIGxldCBvdXRwdXQgPSB0ZmMuYWRkKGgsIEsuZG90KHByZXZPdXRwdXQsIHRoaXMucmVjdXJyZW50S2VybmVsLnJlYWQoKSkpO1xuICAgICAgaWYgKHRoaXMuYWN0aXZhdGlvbiAhPSBudWxsKSB7XG4gICAgICAgIG91dHB1dCA9IHRoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXQpO1xuICAgICAgfVxuXG4gICAgICAvLyBUT0RPKGNhaXMpOiBQcm9wZXJseSBzZXQgbGVhcm5pbmcgcGhhc2Ugb24gb3V0cHV0IHRlbnNvcj9cbiAgICAgIHJldHVybiBbb3V0cHV0LCBvdXRwdXRdO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuXG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7XG4gICAgICB1bml0czogdGhpcy51bml0cyxcbiAgICAgIGFjdGl2YXRpb246IHNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxcbiAgICAgIHVzZUJpYXM6IHRoaXMudXNlQmlhcyxcbiAgICAgIGtlcm5lbEluaXRpYWxpemVyOiBzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxcbiAgICAgIHJlY3VycmVudEluaXRpYWxpemVyOiBzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxcbiAgICAgIGJpYXNJbml0aWFsaXplcjogc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLFxuICAgICAga2VybmVsUmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLFxuICAgICAgcmVjdXJyZW50UmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLFxuICAgICAgYmlhc1JlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksXG4gICAgICBhY3Rpdml0eVJlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLFxuICAgICAga2VybmVsQ29uc3RyYWludDogc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLFxuICAgICAgcmVjdXJyZW50Q29uc3RyYWludDogc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLFxuICAgICAgYmlhc0NvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksXG4gICAgICBkcm9wb3V0OiB0aGlzLmRyb3BvdXQsXG4gICAgICByZWN1cnJlbnREcm9wb3V0OiB0aGlzLnJlY3VycmVudERyb3BvdXQsXG4gICAgfTtcblxuICAgIHJldHVybiB7Li4uYmFzZUNvbmZpZywgLi4uY29uZmlnfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFNpbXBsZVJOTkNlbGwpO1xuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgU2ltcGxlUk5OTGF5ZXJBcmdzIGV4dGVuZHMgQmFzZVJOTkxheWVyQXJncyB7XG4gIC8qKlxuICAgKiBQb3NpdGl2ZSBpbnRlZ2VyLCBkaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNwYWNlLlxuICAgKi9cbiAgdW5pdHM6IG51bWJlcjtcblxuICAvKipcbiAgICogQWN0aXZhdGlvbiBmdW5jdGlvbiB0byB1c2UuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvICBoeXBlcmJvbGljIHRhbmdlbnQgKGB0YW5oYClcbiAgICpcbiAgICogSWYgeW91IHBhc3MgYG51bGxgLCBubyBhY3RpdmF0aW9uIHdpbGwgYmUgYXBwbGllZC5cbiAgICovXG4gIGFjdGl2YXRpb24/OiBBY3RpdmF0aW9uSWRlbnRpZmllcjtcblxuICAvKipcbiAgICogV2hldGhlciB0aGUgbGF5ZXIgdXNlcyBhIGJpYXMgdmVjdG9yLlxuICAgKi9cbiAgdXNlQmlhcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIGZvciB0aGUgYGtlcm5lbGAgd2VpZ2h0cyBtYXRyaXgsIHVzZWQgZm9yIHRoZSBsaW5lYXJcbiAgICogdHJhbnNmb3JtYXRpb24gb2YgdGhlIGlucHV0cy5cbiAgICovXG4gIGtlcm5lbEluaXRpYWxpemVyPzogSW5pdGlhbGl6ZXJJZGVudGlmaWVyfEluaXRpYWxpemVyO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBmb3IgdGhlIGByZWN1cnJlbnRLZXJuZWxgIHdlaWdodHMgbWF0cml4LCB1c2VkIGZvclxuICAgKiBsaW5lYXIgdHJhbnNmb3JtYXRpb24gb2YgdGhlIHJlY3VycmVudCBzdGF0ZS5cbiAgICovXG4gIHJlY3VycmVudEluaXRpYWxpemVyPzogSW5pdGlhbGl6ZXJJZGVudGlmaWVyfEluaXRpYWxpemVyO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBmb3IgdGhlIGJpYXMgdmVjdG9yLlxuICAgKi9cbiAgYmlhc0luaXRpYWxpemVyPzogSW5pdGlhbGl6ZXJJZGVudGlmaWVyfEluaXRpYWxpemVyO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBrZXJuZWwgd2VpZ2h0cyBtYXRyaXguXG4gICAqL1xuICBrZXJuZWxSZWd1bGFyaXplcj86IFJlZ3VsYXJpemVySWRlbnRpZmllcnxSZWd1bGFyaXplcjtcblxuICAvKipcbiAgICogUmVndWxhcml6ZXIgZnVuY3Rpb24gYXBwbGllZCB0byB0aGUgcmVjdXJyZW50S2VybmVsIHdlaWdodHMgbWF0cml4LlxuICAgKi9cbiAgcmVjdXJyZW50UmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXJ8UmVndWxhcml6ZXI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXJpemVyIGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGJpYXMgdmVjdG9yLlxuICAgKi9cbiAgYmlhc1JlZ3VsYXJpemVyPzogUmVndWxhcml6ZXJJZGVudGlmaWVyfFJlZ3VsYXJpemVyO1xuXG4gIC8qKlxuICAgKiBDb25zdHJhaW50IGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGtlcm5lbCB3ZWlnaHRzIG1hdHJpeC5cbiAgICovXG4gIGtlcm5lbENvbnN0cmFpbnQ/OiBDb25zdHJhaW50SWRlbnRpZmllcnxDb25zdHJhaW50O1xuXG4gIC8qKlxuICAgKiBDb25zdHJhaW50IGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIHJlY3VycmVudEtlcm5lbCB3ZWlnaHRzIG1hdHJpeC5cbiAgICovXG4gIHJlY3VycmVudENvbnN0cmFpbnQ/OiBDb25zdHJhaW50SWRlbnRpZmllcnxDb25zdHJhaW50O1xuXG4gIC8qKlxuICAgKiBDb25zdHJhaW50IGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGJpYXMgdmVjdG9yLlxuICAgKi9cbiAgYmlhc0NvbnN0cmFpbnQ/OiBDb25zdHJhaW50SWRlbnRpZmllcnxDb25zdHJhaW50O1xuXG4gIC8qKlxuICAgKiBOdW1iZXIgYmV0d2VlbiAwIGFuZCAxLiBGcmFjdGlvbiBvZiB0aGUgdW5pdHMgdG8gZHJvcCBmb3IgdGhlIGxpbmVhclxuICAgKiB0cmFuc2Zvcm1hdGlvbiBvZiB0aGUgaW5wdXRzLlxuICAgKi9cbiAgZHJvcG91dD86IG51bWJlcjtcblxuICAvKipcbiAgICogTnVtYmVyIGJldHdlZW4gMCBhbmQgMS4gRnJhY3Rpb24gb2YgdGhlIHVuaXRzIHRvIGRyb3AgZm9yIHRoZSBsaW5lYXJcbiAgICogdHJhbnNmb3JtYXRpb24gb2YgdGhlIHJlY3VycmVudCBzdGF0ZS5cbiAgICovXG4gIHJlY3VycmVudERyb3BvdXQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoaXMgaXMgYWRkZWQgZm9yIHRlc3QgREkgcHVycG9zZS5cbiAgICovXG4gIGRyb3BvdXRGdW5jPzogRnVuY3Rpb247XG59XG5cbi8qKlxuICogUk5OTGF5ZXJDb25maWcgaXMgaWRlbnRpY2FsIHRvIEJhc2VSTk5MYXllckNvbmZpZywgZXhjZXB0IGl0IG1ha2VzIHRoZVxuICogYGNlbGxgIHByb3BlcnR5IHJlcXVpcmVkLiBUaGlzIGludGVyZmFjZSBpcyB0byBiZSB1c2VkIHdpdGggY29uc3RydWN0b3JzXG4gKiBvZiBjb25jcmV0ZSBSTk4gbGF5ZXIgc3VidHlwZXMuXG4gKi9cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBSTk5MYXllckFyZ3MgZXh0ZW5kcyBCYXNlUk5OTGF5ZXJBcmdzIHtcbiAgY2VsbDogUk5OQ2VsbHxSTk5DZWxsW107XG59XG5cbmV4cG9ydCBjbGFzcyBTaW1wbGVSTk4gZXh0ZW5kcyBSTk4ge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdTaW1wbGVSTk4nO1xuICBjb25zdHJ1Y3RvcihhcmdzOiBTaW1wbGVSTk5MYXllckFyZ3MpIHtcbiAgICBhcmdzLmNlbGwgPSBuZXcgU2ltcGxlUk5OQ2VsbChhcmdzKTtcbiAgICBzdXBlcihhcmdzIGFzIFJOTkxheWVyQXJncyk7XG4gICAgLy8gVE9ETyhjYWlzKTogQWRkIGFjdGl2aXR5UmVndWxhcml6ZXIuXG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2VsbC5kcm9wb3V0TWFzayAhPSBudWxsKSB7XG4gICAgICAgIHRmYy5kaXNwb3NlKHRoaXMuY2VsbC5kcm9wb3V0TWFzayk7XG4gICAgICAgIHRoaXMuY2VsbC5kcm9wb3V0TWFzayA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrICE9IG51bGwpIHtcbiAgICAgICAgdGZjLmRpc3Bvc2UodGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrKTtcbiAgICAgICAgdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1hc2sgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ21hc2snXTtcbiAgICAgIGNvbnN0IHRyYWluaW5nID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWyd0cmFpbmluZyddO1xuICAgICAgY29uc3QgaW5pdGlhbFN0YXRlOiBUZW5zb3JbXSA9XG4gICAgICAgICAga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydpbml0aWFsU3RhdGUnXTtcbiAgICAgIHJldHVybiBzdXBlci5jYWxsKGlucHV0cywge21hc2ssIHRyYWluaW5nLCBpbml0aWFsU3RhdGV9KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgZnJvbUNvbmZpZzxUIGV4dGVuZHMgc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGU+KFxuICAgICAgY2xzOiBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZUNvbnN0cnVjdG9yPFQ+LFxuICAgICAgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QpOiBUIHtcbiAgICByZXR1cm4gbmV3IGNscyhjb25maWcpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU2ltcGxlUk5OKTtcblxuLy8gUG9ydGluZyBOb3RlOiBTaW5jZSB0aGlzIGlzIGEgc3VwZXJzZXQgb2YgU2ltcGxlUk5OTGF5ZXJDb25maWcsIHdlIGV4dGVuZFxuLy8gICB0aGF0IGludGVyZmFjZSBpbnN0ZWFkIG9mIHJlcGVhdGluZyB0aGUgZmllbGRzLlxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIEdSVUNlbGxMYXllckFyZ3MgZXh0ZW5kcyBTaW1wbGVSTk5DZWxsTGF5ZXJBcmdzIHtcbiAgLyoqXG4gICAqIEFjdGl2YXRpb24gZnVuY3Rpb24gdG8gdXNlIGZvciB0aGUgcmVjdXJyZW50IHN0ZXAuXG4gICAqXG4gICAqIERlZmF1bHRzIHRvIGhhcmQgc2lnbW9pZCAoYGhhcmRTaWdtb2lkYCkuXG4gICAqXG4gICAqIElmIGBudWxsYCwgbm8gYWN0aXZhdGlvbiBpcyBhcHBsaWVkLlxuICAgKi9cbiAgcmVjdXJyZW50QWN0aXZhdGlvbj86IEFjdGl2YXRpb25JZGVudGlmaWVyO1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBtb2RlLCBlaXRoZXIgMSBvciAyLlxuICAgKlxuICAgKiBNb2RlIDEgd2lsbCBzdHJ1Y3R1cmUgaXRzIG9wZXJhdGlvbnMgYXMgYSBsYXJnZXIgbnVtYmVyIG9mXG4gICAqICAgc21hbGxlciBkb3QgcHJvZHVjdHMgYW5kIGFkZGl0aW9ucy5cbiAgICpcbiAgICogTW9kZSAyIHdpbGwgYmF0Y2ggdGhlbSBpbnRvIGZld2VyLCBsYXJnZXIgb3BlcmF0aW9ucy4gVGhlc2UgbW9kZXMgd2lsbFxuICAgKiBoYXZlIGRpZmZlcmVudCBwZXJmb3JtYW5jZSBwcm9maWxlcyBvbiBkaWZmZXJlbnQgaGFyZHdhcmUgYW5kXG4gICAqIGZvciBkaWZmZXJlbnQgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBOb3RlOiBGb3Igc3VwZXJpb3IgcGVyZm9ybWFuY2UsIFRlbnNvckZsb3cuanMgYWx3YXlzIHVzZXMgaW1wbGVtZW50YXRpb25cbiAgICogMiwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIHZhbHVlIG9mIHRoaXMgY29uZmlndXJhdGlvbiBmaWVsZC5cbiAgICovXG4gIGltcGxlbWVudGF0aW9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBHUlUgY29udmVudGlvbiAod2hldGhlciB0byBhcHBseSByZXNldCBnYXRlIGFmdGVyIG9yIGJlZm9yZSBtYXRyaXhcbiAgICogbXVsdGlwbGljYXRpb24pLiBmYWxzZSA9IFwiYmVmb3JlXCIsIHRydWUgPSBcImFmdGVyXCIgKG9ubHkgZmFsc2UgaXNcbiAgICogc3VwcG9ydGVkKS5cbiAgICovXG4gIHJlc2V0QWZ0ZXI/OiBib29sZWFuO1xufVxuXG5leHBvcnQgY2xhc3MgR1JVQ2VsbCBleHRlbmRzIFJOTkNlbGwge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdHUlVDZWxsJztcbiAgcmVhZG9ubHkgdW5pdHM6IG51bWJlcjtcbiAgcmVhZG9ubHkgYWN0aXZhdGlvbjogQWN0aXZhdGlvbjtcbiAgcmVhZG9ubHkgcmVjdXJyZW50QWN0aXZhdGlvbjogQWN0aXZhdGlvbjtcbiAgcmVhZG9ubHkgdXNlQmlhczogYm9vbGVhbjtcblxuICByZWFkb25seSBrZXJuZWxJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG4gIHJlYWRvbmx5IHJlY3VycmVudEluaXRpYWxpemVyOiBJbml0aWFsaXplcjtcbiAgcmVhZG9ubHkgYmlhc0luaXRpYWxpemVyOiBJbml0aWFsaXplcjtcblxuICByZWFkb25seSBrZXJuZWxSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG4gIHJlYWRvbmx5IHJlY3VycmVudFJlZ3VsYXJpemVyOiBSZWd1bGFyaXplcjtcbiAgcmVhZG9ubHkgYmlhc1JlZ3VsYXJpemVyOiBSZWd1bGFyaXplcjtcblxuICByZWFkb25seSBrZXJuZWxDb25zdHJhaW50OiBDb25zdHJhaW50O1xuICByZWFkb25seSByZWN1cnJlbnRDb25zdHJhaW50OiBDb25zdHJhaW50O1xuICByZWFkb25seSBiaWFzQ29uc3RyYWludDogQ29uc3RyYWludDtcblxuICByZWFkb25seSBkcm9wb3V0OiBudW1iZXI7XG4gIHJlYWRvbmx5IHJlY3VycmVudERyb3BvdXQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgZHJvcG91dEZ1bmM6IEZ1bmN0aW9uO1xuXG4gIHJlYWRvbmx5IHN0YXRlU2l6ZTogbnVtYmVyO1xuICByZWFkb25seSBpbXBsZW1lbnRhdGlvbjogbnVtYmVyO1xuXG4gIHJlYWRvbmx5IERFRkFVTFRfQUNUSVZBVElPTiA9ICd0YW5oJztcbiAgcmVhZG9ubHkgREVGQVVMVF9SRUNVUlJFTlRfQUNUSVZBVElPTjogQWN0aXZhdGlvbklkZW50aWZpZXIgPSAnaGFyZFNpZ21vaWQnO1xuXG4gIHJlYWRvbmx5IERFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSID0gJ2dsb3JvdE5vcm1hbCc7XG4gIHJlYWRvbmx5IERFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSID0gJ29ydGhvZ29uYWwnO1xuICByZWFkb25seSBERUZBVUxUX0JJQVNfSU5JVElBTElaRVI6IEluaXRpYWxpemVySWRlbnRpZmllciA9ICd6ZXJvcyc7XG5cbiAga2VybmVsOiBMYXllclZhcmlhYmxlO1xuICByZWN1cnJlbnRLZXJuZWw6IExheWVyVmFyaWFibGU7XG4gIGJpYXM6IExheWVyVmFyaWFibGU7XG5cbiAgY29uc3RydWN0b3IoYXJnczogR1JVQ2VsbExheWVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIGlmIChhcmdzLnJlc2V0QWZ0ZXIpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBHUlVDZWxsIGRvZXMgbm90IHN1cHBvcnQgcmVzZXRfYWZ0ZXIgcGFyYW1ldGVyIHNldCB0byB0cnVlLmApO1xuICAgIH1cbiAgICB0aGlzLnVuaXRzID0gYXJncy51bml0cztcbiAgICBhc3NlcnRQb3NpdGl2ZUludGVnZXIodGhpcy51bml0cywgJ3VuaXRzJyk7XG4gICAgdGhpcy5hY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvbihcbiAgICAgICAgYXJncy5hY3RpdmF0aW9uID09PSB1bmRlZmluZWQgPyB0aGlzLkRFRkFVTFRfQUNUSVZBVElPTiA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5hY3RpdmF0aW9uKTtcbiAgICB0aGlzLnJlY3VycmVudEFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uKFxuICAgICAgICBhcmdzLnJlY3VycmVudEFjdGl2YXRpb24gPT09IHVuZGVmaW5lZCA/XG4gICAgICAgICAgICB0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0FDVElWQVRJT04gOlxuICAgICAgICAgICAgYXJncy5yZWN1cnJlbnRBY3RpdmF0aW9uKTtcbiAgICB0aGlzLnVzZUJpYXMgPSBhcmdzLnVzZUJpYXMgPT0gbnVsbCA/IHRydWUgOiBhcmdzLnVzZUJpYXM7XG5cbiAgICB0aGlzLmtlcm5lbEluaXRpYWxpemVyID0gZ2V0SW5pdGlhbGl6ZXIoXG4gICAgICAgIGFyZ3Mua2VybmVsSW5pdGlhbGl6ZXIgfHwgdGhpcy5ERUZBVUxUX0tFUk5FTF9JTklUSUFMSVpFUik7XG4gICAgdGhpcy5yZWN1cnJlbnRJbml0aWFsaXplciA9IGdldEluaXRpYWxpemVyKFxuICAgICAgICBhcmdzLnJlY3VycmVudEluaXRpYWxpemVyIHx8IHRoaXMuREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIpO1xuXG4gICAgdGhpcy5iaWFzSW5pdGlhbGl6ZXIgPVxuICAgICAgICBnZXRJbml0aWFsaXplcihhcmdzLmJpYXNJbml0aWFsaXplciB8fCB0aGlzLkRFRkFVTFRfQklBU19JTklUSUFMSVpFUik7XG5cbiAgICB0aGlzLmtlcm5lbFJlZ3VsYXJpemVyID0gZ2V0UmVndWxhcml6ZXIoYXJncy5rZXJuZWxSZWd1bGFyaXplcik7XG4gICAgdGhpcy5yZWN1cnJlbnRSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3MucmVjdXJyZW50UmVndWxhcml6ZXIpO1xuICAgIHRoaXMuYmlhc1JlZ3VsYXJpemVyID0gZ2V0UmVndWxhcml6ZXIoYXJncy5iaWFzUmVndWxhcml6ZXIpO1xuXG4gICAgdGhpcy5rZXJuZWxDb25zdHJhaW50ID0gZ2V0Q29uc3RyYWludChhcmdzLmtlcm5lbENvbnN0cmFpbnQpO1xuICAgIHRoaXMucmVjdXJyZW50Q29uc3RyYWludCA9IGdldENvbnN0cmFpbnQoYXJncy5yZWN1cnJlbnRDb25zdHJhaW50KTtcbiAgICB0aGlzLmJpYXNDb25zdHJhaW50ID0gZ2V0Q29uc3RyYWludChhcmdzLmJpYXNDb25zdHJhaW50KTtcblxuICAgIHRoaXMuZHJvcG91dCA9IG1hdGhfdXRpbHMubWluKFxuICAgICAgICBbMSwgbWF0aF91dGlscy5tYXgoWzAsIGFyZ3MuZHJvcG91dCA9PSBudWxsID8gMCA6IGFyZ3MuZHJvcG91dF0pXSk7XG4gICAgdGhpcy5yZWN1cnJlbnREcm9wb3V0ID0gbWF0aF91dGlscy5taW4oW1xuICAgICAgMSxcbiAgICAgIG1hdGhfdXRpbHMubWF4KFxuICAgICAgICAgIFswLCBhcmdzLnJlY3VycmVudERyb3BvdXQgPT0gbnVsbCA/IDAgOiBhcmdzLnJlY3VycmVudERyb3BvdXRdKVxuICAgIF0pO1xuICAgIHRoaXMuZHJvcG91dEZ1bmMgPSBhcmdzLmRyb3BvdXRGdW5jO1xuICAgIHRoaXMuaW1wbGVtZW50YXRpb24gPSBhcmdzLmltcGxlbWVudGF0aW9uO1xuICAgIHRoaXMuc3RhdGVTaXplID0gdGhpcy51bml0cztcbiAgICB0aGlzLmRyb3BvdXRNYXNrID0gbnVsbDtcbiAgICB0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrID0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBidWlsZChpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogdm9pZCB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBjb25zdCBpbnB1dERpbSA9IGlucHV0U2hhcGVbaW5wdXRTaGFwZS5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAna2VybmVsJywgW2lucHV0RGltLCB0aGlzLnVuaXRzICogM10sIG51bGwsIHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsXG4gICAgICAgIHRoaXMua2VybmVsUmVndWxhcml6ZXIsIHRydWUsIHRoaXMua2VybmVsQ29uc3RyYWludCk7XG4gICAgdGhpcy5yZWN1cnJlbnRLZXJuZWwgPSB0aGlzLmFkZFdlaWdodChcbiAgICAgICAgJ3JlY3VycmVudF9rZXJuZWwnLCBbdGhpcy51bml0cywgdGhpcy51bml0cyAqIDNdLCBudWxsLFxuICAgICAgICB0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLCB0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCB0cnVlLFxuICAgICAgICB0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpO1xuICAgIGlmICh0aGlzLnVzZUJpYXMpIHtcbiAgICAgIHRoaXMuYmlhcyA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAgICdiaWFzJywgW3RoaXMudW5pdHMgKiAzXSwgbnVsbCwgdGhpcy5iaWFzSW5pdGlhbGl6ZXIsXG4gICAgICAgICAgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpYXMgPSBudWxsO1xuICAgIH1cbiAgICAvLyBQb3J0aW5nIE5vdGVzOiBVbmxpa2UgdGhlIFB5S2VyYXMgaW1wbGVtZW50YXRpb24sIHdlIHBlcmZvcm0gc2xpY2luZ1xuICAgIC8vICAgb2YgdGhlIHdlaWdodHMgYW5kIGJpYXMgaW4gdGhlIGNhbGwoKSBtZXRob2QsIGF0IGV4ZWN1dGlvbiB0aW1lLlxuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlucHV0cyA9IGlucHV0cyBhcyBUZW5zb3JbXTtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYEdSVUNlbGwgZXhwZWN0cyAyIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCBgICtcbiAgICAgICAgICAgIGAke2lucHV0cy5sZW5ndGh9LmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFpbmluZyA9IGt3YXJnc1sndHJhaW5pbmcnXSA9PSBudWxsID8gZmFsc2UgOiBrd2FyZ3NbJ3RyYWluaW5nJ107XG4gICAgICBsZXQgaFRNaW51czEgPSBpbnB1dHNbMV07ICAvLyBQcmV2aW91cyBtZW1vcnkgc3RhdGUuXG4gICAgICBpbnB1dHMgPSBpbnB1dHNbMF07XG5cbiAgICAgIC8vIE5vdGU6IEZvciBzdXBlcmlvciBwZXJmb3JtYW5jZSwgVGVuc29yRmxvdy5qcyBhbHdheXMgdXNlc1xuICAgICAgLy8gaW1wbGVtZW50YXRpb24gMiwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIHZhbHVlIG9mXG4gICAgICAvLyBjb25maWcuaW1wbGVtZW50YXRpb24uXG4gICAgICBpZiAoMCA8IHRoaXMuZHJvcG91dCAmJiB0aGlzLmRyb3BvdXQgPCAxICYmIHRoaXMuZHJvcG91dE1hc2sgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRyb3BvdXRNYXNrID0gZ2VuZXJhdGVEcm9wb3V0TWFzayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXM6ICgpID0+IHRmYy5vbmVzTGlrZShpbnB1dHMgYXMgVGVuc29yKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0ZTogdGhpcy5kcm9wb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BvdXRGdW5jOiB0aGlzLmRyb3BvdXRGdW5jLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgYXMgVGVuc29yW107XG4gICAgICB9XG4gICAgICBpZiAoMCA8IHRoaXMucmVjdXJyZW50RHJvcG91dCAmJiB0aGlzLnJlY3VycmVudERyb3BvdXQgPCAxICYmXG4gICAgICAgICAgdGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzayA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2sgPSBnZW5lcmF0ZURyb3BvdXRNYXNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lczogKCkgPT4gdGZjLm9uZXNMaWtlKGhUTWludXMxKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0ZTogdGhpcy5yZWN1cnJlbnREcm9wb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IDMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BvdXRGdW5jOiB0aGlzLmRyb3BvdXRGdW5jLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgYXMgVGVuc29yW107XG4gICAgICB9XG4gICAgICBjb25zdCBkcE1hc2sgPSB0aGlzLmRyb3BvdXRNYXNrIGFzIFtUZW5zb3IsIFRlbnNvciwgVGVuc29yXTtcbiAgICAgIGNvbnN0IHJlY0RwTWFzayA9IHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2sgYXMgW1RlbnNvciwgVGVuc29yLCBUZW5zb3JdO1xuICAgICAgbGV0IHo6IFRlbnNvcjtcbiAgICAgIGxldCByOiBUZW5zb3I7XG4gICAgICBsZXQgaGg6IFRlbnNvcjtcblxuICAgICAgaWYgKDAgPCB0aGlzLmRyb3BvdXQgJiYgdGhpcy5kcm9wb3V0IDwgMSkge1xuICAgICAgICBpbnB1dHMgPSB0ZmMubXVsKGlucHV0cywgZHBNYXNrWzBdKTtcbiAgICAgIH1cbiAgICAgIGxldCBtYXRyaXhYID0gSy5kb3QoaW5wdXRzLCB0aGlzLmtlcm5lbC5yZWFkKCkpO1xuICAgICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgICBtYXRyaXhYID0gSy5iaWFzQWRkKG1hdHJpeFgsIHRoaXMuYmlhcy5yZWFkKCkpO1xuICAgICAgfVxuICAgICAgaWYgKDAgPCB0aGlzLnJlY3VycmVudERyb3BvdXQgJiYgdGhpcy5yZWN1cnJlbnREcm9wb3V0IDwgMSkge1xuICAgICAgICBoVE1pbnVzMSA9IHRmYy5tdWwoaFRNaW51czEsIHJlY0RwTWFza1swXSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY3VycmVudEtlcm5lbFZhbHVlID0gdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpO1xuICAgICAgY29uc3QgW3JrMSwgcmsyXSA9IHRmYy5zcGxpdChcbiAgICAgICAgICByZWN1cnJlbnRLZXJuZWxWYWx1ZSwgWzIgKiB0aGlzLnVuaXRzLCB0aGlzLnVuaXRzXSxcbiAgICAgICAgICByZWN1cnJlbnRLZXJuZWxWYWx1ZS5yYW5rIC0gMSk7XG4gICAgICBjb25zdCBtYXRyaXhJbm5lciA9IEsuZG90KGhUTWludXMxLCByazEpO1xuXG4gICAgICBjb25zdCBbeFosIHhSLCB4SF0gPSB0ZmMuc3BsaXQobWF0cml4WCwgMywgbWF0cml4WC5yYW5rIC0gMSk7XG4gICAgICBjb25zdCBbcmVjdXJyZW50WiwgcmVjdXJyZW50Ul0gPVxuICAgICAgICAgIHRmYy5zcGxpdChtYXRyaXhJbm5lciwgMiwgbWF0cml4SW5uZXIucmFuayAtIDEpO1xuICAgICAgeiA9IHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh0ZmMuYWRkKHhaLCByZWN1cnJlbnRaKSk7XG4gICAgICByID0gdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeFIsIHJlY3VycmVudFIpKTtcblxuICAgICAgY29uc3QgcmVjdXJyZW50SCA9IEsuZG90KHRmYy5tdWwociwgaFRNaW51czEpLCByazIpO1xuICAgICAgaGggPSB0aGlzLmFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4SCwgcmVjdXJyZW50SCkpO1xuXG4gICAgICBjb25zdCBoID1cbiAgICAgICAgICB0ZmMuYWRkKHRmYy5tdWwoeiwgaFRNaW51czEpLCB0ZmMubXVsKHRmYy5hZGQoMSwgdGZjLm5lZyh6KSksIGhoKSk7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgdXNlX2xlYXJuaW5nX3BoYXNlIGZsYWcgcHJvcGVybHkuXG4gICAgICByZXR1cm4gW2gsIGhdO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuXG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7XG4gICAgICB1bml0czogdGhpcy51bml0cyxcbiAgICAgIGFjdGl2YXRpb246IHNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5hY3RpdmF0aW9uKSxcbiAgICAgIHJlY3VycmVudEFjdGl2YXRpb246IHNlcmlhbGl6ZUFjdGl2YXRpb24odGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uKSxcbiAgICAgIHVzZUJpYXM6IHRoaXMudXNlQmlhcyxcbiAgICAgIGtlcm5lbEluaXRpYWxpemVyOiBzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmtlcm5lbEluaXRpYWxpemVyKSxcbiAgICAgIHJlY3VycmVudEluaXRpYWxpemVyOiBzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLnJlY3VycmVudEluaXRpYWxpemVyKSxcbiAgICAgIGJpYXNJbml0aWFsaXplcjogc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iaWFzSW5pdGlhbGl6ZXIpLFxuICAgICAga2VybmVsUmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMua2VybmVsUmVndWxhcml6ZXIpLFxuICAgICAgcmVjdXJyZW50UmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIpLFxuICAgICAgYmlhc1JlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJpYXNSZWd1bGFyaXplciksXG4gICAgICBhY3Rpdml0eVJlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLFxuICAgICAga2VybmVsQ29uc3RyYWludDogc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmtlcm5lbENvbnN0cmFpbnQpLFxuICAgICAgcmVjdXJyZW50Q29uc3RyYWludDogc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpLFxuICAgICAgYmlhc0NvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iaWFzQ29uc3RyYWludCksXG4gICAgICBkcm9wb3V0OiB0aGlzLmRyb3BvdXQsXG4gICAgICByZWN1cnJlbnREcm9wb3V0OiB0aGlzLnJlY3VycmVudERyb3BvdXQsXG4gICAgICBpbXBsZW1lbnRhdGlvbjogdGhpcy5pbXBsZW1lbnRhdGlvbixcbiAgICAgIHJlc2V0QWZ0ZXI6IGZhbHNlXG4gICAgfTtcblxuICAgIHJldHVybiB7Li4uYmFzZUNvbmZpZywgLi4uY29uZmlnfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdSVUNlbGwpO1xuXG4vLyBQb3J0aW5nIE5vdGU6IFNpbmNlIHRoaXMgaXMgYSBzdXBlcnNldCBvZiBTaW1wbGVSTk5MYXllckNvbmZpZywgd2UgaW5oZXJpdFxuLy8gICBmcm9tIHRoYXQgaW50ZXJmYWNlIGluc3RlYWQgb2YgcmVwZWF0aW5nIHRoZSBmaWVsZHMgaGVyZS5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBHUlVMYXllckFyZ3MgZXh0ZW5kcyBTaW1wbGVSTk5MYXllckFyZ3Mge1xuICAvKipcbiAgICogQWN0aXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgZm9yIHRoZSByZWN1cnJlbnQgc3RlcC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gaGFyZCBzaWdtb2lkIChgaGFyZFNpZ21vaWRgKS5cbiAgICpcbiAgICogSWYgYG51bGxgLCBubyBhY3RpdmF0aW9uIGlzIGFwcGxpZWQuXG4gICAqL1xuICByZWN1cnJlbnRBY3RpdmF0aW9uPzogQWN0aXZhdGlvbklkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG1vZGUsIGVpdGhlciAxIG9yIDIuXG4gICAqXG4gICAqIE1vZGUgMSB3aWxsIHN0cnVjdHVyZSBpdHMgb3BlcmF0aW9ucyBhcyBhIGxhcmdlciBudW1iZXIgb2ZcbiAgICogc21hbGxlciBkb3QgcHJvZHVjdHMgYW5kIGFkZGl0aW9ucy5cbiAgICpcbiAgICogTW9kZSAyIHdpbGwgYmF0Y2ggdGhlbSBpbnRvIGZld2VyLCBsYXJnZXIgb3BlcmF0aW9ucy4gVGhlc2UgbW9kZXMgd2lsbFxuICAgKiBoYXZlIGRpZmZlcmVudCBwZXJmb3JtYW5jZSBwcm9maWxlcyBvbiBkaWZmZXJlbnQgaGFyZHdhcmUgYW5kXG4gICAqIGZvciBkaWZmZXJlbnQgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBOb3RlOiBGb3Igc3VwZXJpb3IgcGVyZm9ybWFuY2UsIFRlbnNvckZsb3cuanMgYWx3YXlzIHVzZXMgaW1wbGVtZW50YXRpb25cbiAgICogMiwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIHZhbHVlIG9mIHRoaXMgY29uZmlndXJhdGlvbiBmaWVsZC5cbiAgICovXG4gIGltcGxlbWVudGF0aW9uPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgR1JVIGV4dGVuZHMgUk5OIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnR1JVJztcbiAgY29uc3RydWN0b3IoYXJnczogR1JVTGF5ZXJBcmdzKSB7XG4gICAgaWYgKGFyZ3MuaW1wbGVtZW50YXRpb24gPT09IDApIHtcbiAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAnYGltcGxlbWVudGF0aW9uPTBgIGhhcyBiZWVuIGRlcHJlY2F0ZWQsIGFuZCBub3cgZGVmYXVsdHMgdG8gJyArXG4gICAgICAgICAgJ2BpbXBsZW1lbnRhdGlvbj0xYC4gUGxlYXNlIHVwZGF0ZSB5b3VyIGxheWVyIGNhbGwuJyk7XG4gICAgfVxuICAgIGFyZ3MuY2VsbCA9IG5ldyBHUlVDZWxsKGFyZ3MpO1xuICAgIHN1cGVyKGFyZ3MgYXMgUk5OTGF5ZXJBcmdzKTtcbiAgICAvLyBUT0RPKGNhaXMpOiBBZGQgYWN0aXZpdHlSZWd1bGFyaXplci5cbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jZWxsLmRyb3BvdXRNYXNrICE9IG51bGwpIHtcbiAgICAgICAgdGZjLmRpc3Bvc2UodGhpcy5jZWxsLmRyb3BvdXRNYXNrKTtcbiAgICAgICAgdGhpcy5jZWxsLmRyb3BvdXRNYXNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2sgIT0gbnVsbCkge1xuICAgICAgICB0ZmMuZGlzcG9zZSh0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spO1xuICAgICAgICB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFzayA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snbWFzayddO1xuICAgICAgY29uc3QgdHJhaW5pbmcgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ3RyYWluaW5nJ107XG4gICAgICBjb25zdCBpbml0aWFsU3RhdGU6IFRlbnNvcltdID1cbiAgICAgICAgICBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddO1xuICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoaW5wdXRzLCB7bWFzaywgdHJhaW5pbmcsIGluaXRpYWxTdGF0ZX0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlQ29uc3RydWN0b3I8VD4sXG4gICAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCk6IFQge1xuICAgIGlmIChjb25maWdbJ2ltcGxtZW50YXRpb24nXSA9PT0gMCkge1xuICAgICAgY29uZmlnWydpbXBsZW1lbnRhdGlvbiddID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnKTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdSVSk7XG5cbi8vIFBvcnRpbmcgTm90ZTogU2luY2UgdGhpcyBpcyBhIHN1cGVyc2V0IG9mIFNpbXBsZVJOTkxheWVyQ29uZmlnLCB3ZSBleHRlbmRcbi8vICAgdGhhdCBpbnRlcmZhY2UgaW5zdGVhZCBvZiByZXBlYXRpbmcgdGhlIGZpZWxkcy5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBMU1RNQ2VsbExheWVyQXJncyBleHRlbmRzIFNpbXBsZVJOTkNlbGxMYXllckFyZ3Mge1xuICAvKipcbiAgICogQWN0aXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgZm9yIHRoZSByZWN1cnJlbnQgc3RlcC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gaGFyZCBzaWdtb2lkIChgaGFyZFNpZ21vaWRgKS5cbiAgICpcbiAgICogSWYgYG51bGxgLCBubyBhY3RpdmF0aW9uIGlzIGFwcGxpZWQuXG4gICAqL1xuICByZWN1cnJlbnRBY3RpdmF0aW9uPzogQWN0aXZhdGlvbklkZW50aWZpZXI7XG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgYWRkIDEgdG8gdGhlIGJpYXMgb2YgdGhlIGZvcmdldCBnYXRlIGF0IGluaXRpYWxpemF0aW9uLlxuICAgKiBTZXR0aW5nIGl0IHRvIGB0cnVlYCB3aWxsIGFsc28gZm9yY2UgYGJpYXNJbml0aWFsaXplciA9ICd6ZXJvcydgLlxuICAgKiBUaGlzIGlzIHJlY29tbWVuZGVkIGluXG4gICAqIFtKb3plZm93aWN6IGV0XG4gICAqIGFsLl0oaHR0cDovL3d3dy5qbWxyLm9yZy9wcm9jZWVkaW5ncy9wYXBlcnMvdjM3L2pvemVmb3dpY3oxNS5wZGYpLlxuICAgKi9cbiAgdW5pdEZvcmdldEJpYXM/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbXBsZW1lbnRhdGlvbiBtb2RlLCBlaXRoZXIgMSBvciAyLlxuICAgKlxuICAgKiBNb2RlIDEgd2lsbCBzdHJ1Y3R1cmUgaXRzIG9wZXJhdGlvbnMgYXMgYSBsYXJnZXIgbnVtYmVyIG9mXG4gICAqICAgc21hbGxlciBkb3QgcHJvZHVjdHMgYW5kIGFkZGl0aW9ucy5cbiAgICpcbiAgICogTW9kZSAyIHdpbGwgYmF0Y2ggdGhlbSBpbnRvIGZld2VyLCBsYXJnZXIgb3BlcmF0aW9ucy4gVGhlc2UgbW9kZXMgd2lsbFxuICAgKiBoYXZlIGRpZmZlcmVudCBwZXJmb3JtYW5jZSBwcm9maWxlcyBvbiBkaWZmZXJlbnQgaGFyZHdhcmUgYW5kXG4gICAqIGZvciBkaWZmZXJlbnQgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBOb3RlOiBGb3Igc3VwZXJpb3IgcGVyZm9ybWFuY2UsIFRlbnNvckZsb3cuanMgYWx3YXlzIHVzZXMgaW1wbGVtZW50YXRpb25cbiAgICogMiwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIHZhbHVlIG9mIHRoaXMgY29uZmlndXJhdGlvbiBmaWVsZC5cbiAgICovXG4gIGltcGxlbWVudGF0aW9uPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgTFNUTUNlbGwgZXh0ZW5kcyBSTk5DZWxsIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTFNUTUNlbGwnO1xuICByZWFkb25seSB1bml0czogbnVtYmVyO1xuICByZWFkb25seSBhY3RpdmF0aW9uOiBBY3RpdmF0aW9uO1xuICByZWFkb25seSByZWN1cnJlbnRBY3RpdmF0aW9uOiBBY3RpdmF0aW9uO1xuICByZWFkb25seSB1c2VCaWFzOiBib29sZWFuO1xuXG4gIHJlYWRvbmx5IGtlcm5lbEluaXRpYWxpemVyOiBJbml0aWFsaXplcjtcbiAgcmVhZG9ubHkgcmVjdXJyZW50SW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyO1xuICByZWFkb25seSBiaWFzSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyO1xuICByZWFkb25seSB1bml0Rm9yZ2V0QmlhczogYm9vbGVhbjtcblxuICByZWFkb25seSBrZXJuZWxDb25zdHJhaW50OiBDb25zdHJhaW50O1xuICByZWFkb25seSByZWN1cnJlbnRDb25zdHJhaW50OiBDb25zdHJhaW50O1xuICByZWFkb25seSBiaWFzQ29uc3RyYWludDogQ29uc3RyYWludDtcblxuICByZWFkb25seSBrZXJuZWxSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG4gIHJlYWRvbmx5IHJlY3VycmVudFJlZ3VsYXJpemVyOiBSZWd1bGFyaXplcjtcbiAgcmVhZG9ubHkgYmlhc1JlZ3VsYXJpemVyOiBSZWd1bGFyaXplcjtcblxuICByZWFkb25seSBkcm9wb3V0OiBudW1iZXI7XG4gIHJlYWRvbmx5IHJlY3VycmVudERyb3BvdXQ6IG51bWJlcjtcbiAgcmVhZG9ubHkgZHJvcG91dEZ1bmM6IEZ1bmN0aW9uO1xuXG4gIHJlYWRvbmx5IHN0YXRlU2l6ZTogbnVtYmVyW107XG4gIHJlYWRvbmx5IGltcGxlbWVudGF0aW9uOiBudW1iZXI7XG5cbiAgcmVhZG9ubHkgREVGQVVMVF9BQ1RJVkFUSU9OID0gJ3RhbmgnO1xuICByZWFkb25seSBERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OID0gJ2hhcmRTaWdtb2lkJztcbiAgcmVhZG9ubHkgREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIgPSAnZ2xvcm90Tm9ybWFsJztcbiAgcmVhZG9ubHkgREVGQVVMVF9SRUNVUlJFTlRfSU5JVElBTElaRVIgPSAnb3J0aG9nb25hbCc7XG5cbiAgcmVhZG9ubHkgREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSID0gJ3plcm9zJztcblxuICBrZXJuZWw6IExheWVyVmFyaWFibGU7XG4gIHJlY3VycmVudEtlcm5lbDogTGF5ZXJWYXJpYWJsZTtcbiAgYmlhczogTGF5ZXJWYXJpYWJsZTtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBMU1RNQ2VsbExheWVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuXG4gICAgdGhpcy51bml0cyA9IGFyZ3MudW5pdHM7XG4gICAgYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKHRoaXMudW5pdHMsICd1bml0cycpO1xuICAgIHRoaXMuYWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb24oXG4gICAgICAgIGFyZ3MuYWN0aXZhdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5ERUZBVUxUX0FDVElWQVRJT04gOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3MuYWN0aXZhdGlvbik7XG4gICAgdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uID0gZ2V0QWN0aXZhdGlvbihcbiAgICAgICAgYXJncy5yZWN1cnJlbnRBY3RpdmF0aW9uID09PSB1bmRlZmluZWQgP1xuICAgICAgICAgICAgdGhpcy5ERUZBVUxUX1JFQ1VSUkVOVF9BQ1RJVkFUSU9OIDpcbiAgICAgICAgICAgIGFyZ3MucmVjdXJyZW50QWN0aXZhdGlvbik7XG4gICAgdGhpcy51c2VCaWFzID0gYXJncy51c2VCaWFzID09IG51bGwgPyB0cnVlIDogYXJncy51c2VCaWFzO1xuXG4gICAgdGhpcy5rZXJuZWxJbml0aWFsaXplciA9IGdldEluaXRpYWxpemVyKFxuICAgICAgICBhcmdzLmtlcm5lbEluaXRpYWxpemVyIHx8IHRoaXMuREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVIpO1xuICAgIHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIgPSBnZXRJbml0aWFsaXplcihcbiAgICAgICAgYXJncy5yZWN1cnJlbnRJbml0aWFsaXplciB8fCB0aGlzLkRFRkFVTFRfUkVDVVJSRU5UX0lOSVRJQUxJWkVSKTtcblxuICAgIHRoaXMuYmlhc0luaXRpYWxpemVyID1cbiAgICAgICAgZ2V0SW5pdGlhbGl6ZXIoYXJncy5iaWFzSW5pdGlhbGl6ZXIgfHwgdGhpcy5ERUZBVUxUX0JJQVNfSU5JVElBTElaRVIpO1xuICAgIHRoaXMudW5pdEZvcmdldEJpYXMgPSBhcmdzLnVuaXRGb3JnZXRCaWFzO1xuXG4gICAgdGhpcy5rZXJuZWxSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3Mua2VybmVsUmVndWxhcml6ZXIpO1xuICAgIHRoaXMucmVjdXJyZW50UmVndWxhcml6ZXIgPSBnZXRSZWd1bGFyaXplcihhcmdzLnJlY3VycmVudFJlZ3VsYXJpemVyKTtcbiAgICB0aGlzLmJpYXNSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3MuYmlhc1JlZ3VsYXJpemVyKTtcblxuICAgIHRoaXMua2VybmVsQ29uc3RyYWludCA9IGdldENvbnN0cmFpbnQoYXJncy5rZXJuZWxDb25zdHJhaW50KTtcbiAgICB0aGlzLnJlY3VycmVudENvbnN0cmFpbnQgPSBnZXRDb25zdHJhaW50KGFyZ3MucmVjdXJyZW50Q29uc3RyYWludCk7XG4gICAgdGhpcy5iaWFzQ29uc3RyYWludCA9IGdldENvbnN0cmFpbnQoYXJncy5iaWFzQ29uc3RyYWludCk7XG5cbiAgICB0aGlzLmRyb3BvdXQgPSBtYXRoX3V0aWxzLm1pbihcbiAgICAgICAgWzEsIG1hdGhfdXRpbHMubWF4KFswLCBhcmdzLmRyb3BvdXQgPT0gbnVsbCA/IDAgOiBhcmdzLmRyb3BvdXRdKV0pO1xuICAgIHRoaXMucmVjdXJyZW50RHJvcG91dCA9IG1hdGhfdXRpbHMubWluKFtcbiAgICAgIDEsXG4gICAgICBtYXRoX3V0aWxzLm1heChcbiAgICAgICAgICBbMCwgYXJncy5yZWN1cnJlbnREcm9wb3V0ID09IG51bGwgPyAwIDogYXJncy5yZWN1cnJlbnREcm9wb3V0XSlcbiAgICBdKTtcbiAgICB0aGlzLmRyb3BvdXRGdW5jID0gYXJncy5kcm9wb3V0RnVuYztcbiAgICB0aGlzLmltcGxlbWVudGF0aW9uID0gYXJncy5pbXBsZW1lbnRhdGlvbjtcbiAgICB0aGlzLnN0YXRlU2l6ZSA9IFt0aGlzLnVuaXRzLCB0aGlzLnVuaXRzXTtcbiAgICB0aGlzLmRyb3BvdXRNYXNrID0gbnVsbDtcbiAgICB0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrID0gbnVsbDtcbiAgfVxuXG4gIHB1YmxpYyBidWlsZChpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogdm9pZCB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBjb25zdCBpbnB1dERpbSA9IGlucHV0U2hhcGVbaW5wdXRTaGFwZS5sZW5ndGggLSAxXTtcbiAgICB0aGlzLmtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAna2VybmVsJywgW2lucHV0RGltLCB0aGlzLnVuaXRzICogNF0sIG51bGwsIHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsXG4gICAgICAgIHRoaXMua2VybmVsUmVndWxhcml6ZXIsIHRydWUsIHRoaXMua2VybmVsQ29uc3RyYWludCk7XG4gICAgdGhpcy5yZWN1cnJlbnRLZXJuZWwgPSB0aGlzLmFkZFdlaWdodChcbiAgICAgICAgJ3JlY3VycmVudF9rZXJuZWwnLCBbdGhpcy51bml0cywgdGhpcy51bml0cyAqIDRdLCBudWxsLFxuICAgICAgICB0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLCB0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCB0cnVlLFxuICAgICAgICB0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpO1xuICAgIGxldCBiaWFzSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyO1xuICAgIGlmICh0aGlzLnVzZUJpYXMpIHtcbiAgICAgIGlmICh0aGlzLnVuaXRGb3JnZXRCaWFzKSB7XG4gICAgICAgIGNvbnN0IGNhcHR1cmVkQmlhc0luaXQgPSB0aGlzLmJpYXNJbml0aWFsaXplcjtcbiAgICAgICAgY29uc3QgY2FwdHVyZWRVbml0cyA9IHRoaXMudW5pdHM7XG4gICAgICAgIGJpYXNJbml0aWFsaXplciA9IG5ldyAoY2xhc3MgQ3VzdG9tSW5pdCBleHRlbmRzIEluaXRpYWxpemVyIHtcbiAgICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgICBzdGF0aWMgY2xhc3NOYW1lID0gJ0N1c3RvbUluaXQnO1xuXG4gICAgICAgICAgYXBwbHkoc2hhcGU6IFNoYXBlLCBkdHlwZT86IERhdGFUeXBlKTogVGVuc29yIHtcbiAgICAgICAgICAgIC8vIFRPRE8oY2Fpcyk6IE1vcmUgaW5mb3JtYXRpdmUgdmFyaWFibGUgbmFtZXM/XG4gICAgICAgICAgICBjb25zdCBiSSA9IGNhcHR1cmVkQmlhc0luaXQuYXBwbHkoW2NhcHR1cmVkVW5pdHNdKTtcbiAgICAgICAgICAgIGNvbnN0IGJGID0gKG5ldyBPbmVzKCkpLmFwcGx5KFtjYXB0dXJlZFVuaXRzXSk7XG4gICAgICAgICAgICBjb25zdCBiQ0FuZEggPSBjYXB0dXJlZEJpYXNJbml0LmFwcGx5KFtjYXB0dXJlZFVuaXRzICogMl0pO1xuICAgICAgICAgICAgcmV0dXJuIEsuY29uY2F0QWxvbmdGaXJzdEF4aXMoXG4gICAgICAgICAgICAgICAgSy5jb25jYXRBbG9uZ0ZpcnN0QXhpcyhiSSwgYkYpLCBiQ0FuZEgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSkoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJpYXNJbml0aWFsaXplciA9IHRoaXMuYmlhc0luaXRpYWxpemVyO1xuICAgICAgfVxuICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICAgJ2JpYXMnLCBbdGhpcy51bml0cyAqIDRdLCBudWxsLCBiaWFzSW5pdGlhbGl6ZXIsIHRoaXMuYmlhc1JlZ3VsYXJpemVyLFxuICAgICAgICAgIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJpYXMgPSBudWxsO1xuICAgIH1cbiAgICAvLyBQb3J0aW5nIE5vdGVzOiBVbmxpa2UgdGhlIFB5S2VyYXMgaW1wbGVtZW50YXRpb24sIHdlIHBlcmZvcm0gc2xpY2luZ1xuICAgIC8vICAgb2YgdGhlIHdlaWdodHMgYW5kIGJpYXMgaW4gdGhlIGNhbGwoKSBtZXRob2QsIGF0IGV4ZWN1dGlvbiB0aW1lLlxuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IHRyYWluaW5nID0ga3dhcmdzWyd0cmFpbmluZyddID09IG51bGwgPyBmYWxzZSA6IGt3YXJnc1sndHJhaW5pbmcnXTtcbiAgICAgIGlucHV0cyA9IGlucHV0cyBhcyBUZW5zb3JbXTtcbiAgICAgIGlmIChpbnB1dHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYExTVE1DZWxsIGV4cGVjdHMgMyBpbnB1dCBUZW5zb3JzIChpbnB1dHMsIGgsIGMpLCBnb3QgYCArXG4gICAgICAgICAgICBgJHtpbnB1dHMubGVuZ3RofS5gKTtcbiAgICAgIH1cbiAgICAgIGxldCBoVE1pbnVzMSA9IGlucHV0c1sxXTsgICAgLy8gUHJldmlvdXMgbWVtb3J5IHN0YXRlLlxuICAgICAgY29uc3QgY1RNaW51czEgPSBpbnB1dHNbMl07ICAvLyBQcmV2aW91cyBjYXJyeSBzdGF0ZS5cbiAgICAgIGlucHV0cyA9IGlucHV0c1swXTtcbiAgICAgIGlmICgwIDwgdGhpcy5kcm9wb3V0ICYmIHRoaXMuZHJvcG91dCA8IDEgJiYgdGhpcy5kcm9wb3V0TWFzayA9PSBudWxsKSB7XG4gICAgICAgIHRoaXMuZHJvcG91dE1hc2sgPSBnZW5lcmF0ZURyb3BvdXRNYXNrKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25lczogKCkgPT4gdGZjLm9uZXNMaWtlKGlucHV0cyBhcyBUZW5zb3IpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRlOiB0aGlzLmRyb3BvdXQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYWluaW5nLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudDogNCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcG91dEZ1bmM6IHRoaXMuZHJvcG91dEZ1bmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIGFzIFRlbnNvcltdO1xuICAgICAgfVxuICAgICAgaWYgKDAgPCB0aGlzLnJlY3VycmVudERyb3BvdXQgJiYgdGhpcy5yZWN1cnJlbnREcm9wb3V0IDwgMSAmJlxuICAgICAgICAgIHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2sgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrID0gZ2VuZXJhdGVEcm9wb3V0TWFzayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXM6ICgpID0+IHRmYy5vbmVzTGlrZShoVE1pbnVzMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGU6IHRoaXMucmVjdXJyZW50RHJvcG91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaW5pbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiA0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkcm9wb3V0RnVuYzogdGhpcy5kcm9wb3V0RnVuY1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkgYXMgVGVuc29yW107XG4gICAgICB9XG4gICAgICBjb25zdCBkcE1hc2sgPSB0aGlzLmRyb3BvdXRNYXNrIGFzIFtUZW5zb3IsIFRlbnNvciwgVGVuc29yLCBUZW5zb3JdO1xuICAgICAgY29uc3QgcmVjRHBNYXNrID1cbiAgICAgICAgICB0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrIGFzIFtUZW5zb3IsIFRlbnNvciwgVGVuc29yLCBUZW5zb3JdO1xuXG4gICAgICAvLyBOb3RlOiBGb3Igc3VwZXJpb3IgcGVyZm9ybWFuY2UsIFRlbnNvckZsb3cuanMgYWx3YXlzIHVzZXNcbiAgICAgIC8vIGltcGxlbWVudGF0aW9uIDIgcmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIHZhbHVlIG9mXG4gICAgICAvLyBjb25maWcuaW1wbGVtZW50YXRpb24uXG4gICAgICBsZXQgaTogVGVuc29yO1xuICAgICAgbGV0IGY6IFRlbnNvcjtcbiAgICAgIGxldCBjOiBUZW5zb3I7XG4gICAgICBsZXQgbzogVGVuc29yO1xuICAgICAgaWYgKDAgPCB0aGlzLmRyb3BvdXQgJiYgdGhpcy5kcm9wb3V0IDwgMSkge1xuICAgICAgICBpbnB1dHMgPSB0ZmMubXVsKGlucHV0cywgZHBNYXNrWzBdKTtcbiAgICAgIH1cbiAgICAgIGxldCB6ID0gSy5kb3QoaW5wdXRzLCB0aGlzLmtlcm5lbC5yZWFkKCkpO1xuICAgICAgaWYgKDAgPCB0aGlzLnJlY3VycmVudERyb3BvdXQgJiYgdGhpcy5yZWN1cnJlbnREcm9wb3V0IDwgMSkge1xuICAgICAgICBoVE1pbnVzMSA9IHRmYy5tdWwoaFRNaW51czEsIHJlY0RwTWFza1swXSk7XG4gICAgICB9XG4gICAgICB6ID0gdGZjLmFkZCh6LCBLLmRvdChoVE1pbnVzMSwgdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpKSk7XG4gICAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICAgIHogPSBLLmJpYXNBZGQoeiwgdGhpcy5iaWFzLnJlYWQoKSk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IFt6MCwgejEsIHoyLCB6M10gPSB0ZmMuc3BsaXQoeiwgNCwgei5yYW5rIC0gMSk7XG5cbiAgICAgIGkgPSB0aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkoejApO1xuICAgICAgZiA9IHRoaXMucmVjdXJyZW50QWN0aXZhdGlvbi5hcHBseSh6MSk7XG4gICAgICBjID0gdGZjLmFkZCh0ZmMubXVsKGYsIGNUTWludXMxKSwgdGZjLm11bChpLCB0aGlzLmFjdGl2YXRpb24uYXBwbHkoejIpKSk7XG4gICAgICBvID0gdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHozKTtcblxuICAgICAgY29uc3QgaCA9IHRmYy5tdWwobywgdGhpcy5hY3RpdmF0aW9uLmFwcGx5KGMpKTtcbiAgICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCB1c2VfbGVhcm5pbmdfcGhhc2UgZmxhZyBwcm9wZXJseS5cbiAgICAgIHJldHVybiBbaCwgaCwgY107XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG5cbiAgICBjb25zdCBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHtcbiAgICAgIHVuaXRzOiB0aGlzLnVuaXRzLFxuICAgICAgYWN0aXZhdGlvbjogc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgcmVjdXJyZW50QWN0aXZhdGlvbjogc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLnJlY3VycmVudEFjdGl2YXRpb24pLFxuICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IHNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgcmVjdXJyZW50SW5pdGlhbGl6ZXI6IHNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMucmVjdXJyZW50SW5pdGlhbGl6ZXIpLFxuICAgICAgYmlhc0luaXRpYWxpemVyOiBzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICB1bml0Rm9yZ2V0QmlhczogdGhpcy51bml0Rm9yZ2V0QmlhcyxcbiAgICAgIGtlcm5lbFJlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmtlcm5lbFJlZ3VsYXJpemVyKSxcbiAgICAgIHJlY3VycmVudFJlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyKSxcbiAgICAgIGJpYXNSZWd1bGFyaXplcjogc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5iaWFzUmVndWxhcml6ZXIpLFxuICAgICAgYWN0aXZpdHlSZWd1bGFyaXplcjogc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyKSxcbiAgICAgIGtlcm5lbENvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5rZXJuZWxDb25zdHJhaW50KSxcbiAgICAgIHJlY3VycmVudENvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5yZWN1cnJlbnRDb25zdHJhaW50KSxcbiAgICAgIGJpYXNDb25zdHJhaW50OiBzZXJpYWxpemVDb25zdHJhaW50KHRoaXMuYmlhc0NvbnN0cmFpbnQpLFxuICAgICAgZHJvcG91dDogdGhpcy5kcm9wb3V0LFxuICAgICAgcmVjdXJyZW50RHJvcG91dDogdGhpcy5yZWN1cnJlbnREcm9wb3V0LFxuICAgICAgaW1wbGVtZW50YXRpb246IHRoaXMuaW1wbGVtZW50YXRpb24sXG4gICAgfTtcblxuICAgIHJldHVybiB7Li4uYmFzZUNvbmZpZywgLi4uY29uZmlnfTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExTVE1DZWxsKTtcblxuLy8gUG9ydGluZyBOb3RlOiBTaW5jZSB0aGlzIGlzIGEgc3VwZXJzZXQgb2YgU2ltcGxlUk5OTGF5ZXJDb25maWcsIHdlIGluaGVyaXRcbi8vICAgZnJvbSB0aGF0IGludGVyZmFjZSBpbnN0ZWFkIG9mIHJlcGVhdGluZyB0aGUgZmllbGRzIGhlcmUuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgTFNUTUxheWVyQXJncyBleHRlbmRzIFNpbXBsZVJOTkxheWVyQXJncyB7XG4gIC8qKlxuICAgKiBBY3RpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZSBmb3IgdGhlIHJlY3VycmVudCBzdGVwLlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byBoYXJkIHNpZ21vaWQgKGBoYXJkU2lnbW9pZGApLlxuICAgKlxuICAgKiBJZiBgbnVsbGAsIG5vIGFjdGl2YXRpb24gaXMgYXBwbGllZC5cbiAgICovXG4gIHJlY3VycmVudEFjdGl2YXRpb24/OiBBY3RpdmF0aW9uSWRlbnRpZmllcjtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBhZGQgMSB0byB0aGUgYmlhcyBvZiB0aGUgZm9yZ2V0IGdhdGUgYXQgaW5pdGlhbGl6YXRpb24uXG4gICAqIFNldHRpbmcgaXQgdG8gYHRydWVgIHdpbGwgYWxzbyBmb3JjZSBgYmlhc0luaXRpYWxpemVyID0gJ3plcm9zJ2AuXG4gICAqIFRoaXMgaXMgcmVjb21tZW5kZWQgaW5cbiAgICogW0pvemVmb3dpY3ogZXRcbiAgICogYWwuXShodHRwOi8vd3d3LmptbHIub3JnL3Byb2NlZWRpbmdzL3BhcGVycy92Mzcvam96ZWZvd2ljejE1LnBkZikuXG4gICAqL1xuICB1bml0Rm9yZ2V0Qmlhcz86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIEltcGxlbWVudGF0aW9uIG1vZGUsIGVpdGhlciAxIG9yIDIuXG4gICAqICAgTW9kZSAxIHdpbGwgc3RydWN0dXJlIGl0cyBvcGVyYXRpb25zIGFzIGEgbGFyZ2VyIG51bWJlciBvZlxuICAgKiAgIHNtYWxsZXIgZG90IHByb2R1Y3RzIGFuZCBhZGRpdGlvbnMsIHdoZXJlYXMgbW9kZSAyIHdpbGxcbiAgICogICBiYXRjaCB0aGVtIGludG8gZmV3ZXIsIGxhcmdlciBvcGVyYXRpb25zLiBUaGVzZSBtb2RlcyB3aWxsXG4gICAqICAgaGF2ZSBkaWZmZXJlbnQgcGVyZm9ybWFuY2UgcHJvZmlsZXMgb24gZGlmZmVyZW50IGhhcmR3YXJlIGFuZFxuICAgKiAgIGZvciBkaWZmZXJlbnQgYXBwbGljYXRpb25zLlxuICAgKlxuICAgKiBOb3RlOiBGb3Igc3VwZXJpb3IgcGVyZm9ybWFuY2UsIFRlbnNvckZsb3cuanMgYWx3YXlzIHVzZXMgaW1wbGVtZW50YXRpb25cbiAgICogMiwgcmVnYXJkbGVzcyBvZiB0aGUgYWN0dWFsIHZhbHVlIG9mIHRoaXMgY29uZmlnIGZpZWxkLlxuICAgKi9cbiAgaW1wbGVtZW50YXRpb24/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBMU1RNIGV4dGVuZHMgUk5OIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTFNUTSc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IExTVE1MYXllckFyZ3MpIHtcbiAgICBpZiAoYXJncy5pbXBsZW1lbnRhdGlvbiA9PT0gMCkge1xuICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdgaW1wbGVtZW50YXRpb249MGAgaGFzIGJlZW4gZGVwcmVjYXRlZCwgYW5kIG5vdyBkZWZhdWx0cyB0byAnICtcbiAgICAgICAgICAnYGltcGxlbWVudGF0aW9uPTFgLiBQbGVhc2UgdXBkYXRlIHlvdXIgbGF5ZXIgY2FsbC4nKTtcbiAgICB9XG4gICAgYXJncy5jZWxsID0gbmV3IExTVE1DZWxsKGFyZ3MpO1xuICAgIHN1cGVyKGFyZ3MgYXMgUk5OTGF5ZXJBcmdzKTtcbiAgICAvLyBUT0RPKGNhaXMpOiBBZGQgYWN0aXZpdHlSZWd1bGFyaXplci5cbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpZiAodGhpcy5jZWxsLmRyb3BvdXRNYXNrICE9IG51bGwpIHtcbiAgICAgICAgdGZjLmRpc3Bvc2UodGhpcy5jZWxsLmRyb3BvdXRNYXNrKTtcbiAgICAgICAgdGhpcy5jZWxsLmRyb3BvdXRNYXNrID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2sgIT0gbnVsbCkge1xuICAgICAgICB0ZmMuZGlzcG9zZSh0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2spO1xuICAgICAgICB0aGlzLmNlbGwucmVjdXJyZW50RHJvcG91dE1hc2sgPSBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3QgbWFzayA9IGt3YXJncyA9PSBudWxsID8gbnVsbCA6IGt3YXJnc1snbWFzayddO1xuICAgICAgY29uc3QgdHJhaW5pbmcgPSBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ3RyYWluaW5nJ107XG4gICAgICBjb25zdCBpbml0aWFsU3RhdGU6IFRlbnNvcltdID1cbiAgICAgICAgICBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddO1xuICAgICAgcmV0dXJuIHN1cGVyLmNhbGwoaW5wdXRzLCB7bWFzaywgdHJhaW5pbmcsIGluaXRpYWxTdGF0ZX0pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBmcm9tQ29uZmlnPFQgZXh0ZW5kcyBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlQ29uc3RydWN0b3I8VD4sXG4gICAgICBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCk6IFQge1xuICAgIGlmIChjb25maWdbJ2ltcGxtZW50YXRpb24nXSA9PT0gMCkge1xuICAgICAgY29uZmlnWydpbXBsZW1lbnRhdGlvbiddID0gMTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnKTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExTVE0pO1xuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgU3RhY2tlZFJOTkNlbGxzQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBBIGBBcnJheWAgb2YgYFJOTkNlbGxgIGluc3RhbmNlcy5cbiAgICovXG4gIGNlbGxzOiBSTk5DZWxsW107XG59XG5cbmV4cG9ydCBjbGFzcyBTdGFja2VkUk5OQ2VsbHMgZXh0ZW5kcyBSTk5DZWxsIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnU3RhY2tlZFJOTkNlbGxzJztcbiAgcHJvdGVjdGVkIGNlbGxzOiBSTk5DZWxsW107XG5cbiAgY29uc3RydWN0b3IoYXJnczogU3RhY2tlZFJOTkNlbGxzQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMuY2VsbHMgPSBhcmdzLmNlbGxzO1xuICB9XG5cbiAgZ2V0IHN0YXRlU2l6ZSgpOiBudW1iZXJbXSB7XG4gICAgLy8gU3RhdGVzIGFyZSBhIGZsYXQgbGlzdCBpbiByZXZlcnNlIG9yZGVyIG9mIHRoZSBjZWxsIHN0YWNrLlxuICAgIC8vIFRoaXMgYWxsb3dzIHBlcnNlcnZpbmcgdGhlIHJlcXVpcmVtZW50IGBzdGFjay5zdGF0ZXNpemVbMF0gPT09XG4gICAgLy8gb3V0cHV0RGltYC4gRS5nLiwgc3RhdGVzIG9mIGEgMi1sYXllciBMU1RNIHdvdWxkIGJlIGBbaDIsIGMyLCBoMSwgYzFdYCxcbiAgICAvLyBhc3N1bWluZyBvbmUgTFNUTSBoYXMgc3RhdGVzIGBbaCwgY11gLlxuICAgIGNvbnN0IHN0YXRlU2l6ZTogbnVtYmVyW10gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscy5zbGljZSgpLnJldmVyc2UoKSkge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgIHN0YXRlU2l6ZS5wdXNoKC4uLmNlbGwuc3RhdGVTaXplKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlU2l6ZS5wdXNoKGNlbGwuc3RhdGVTaXplKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHN0YXRlU2l6ZTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBpbnB1dHMgPSBpbnB1dHMgYXMgVGVuc29yW107XG4gICAgICBsZXQgc3RhdGVzID0gaW5wdXRzLnNsaWNlKDEpO1xuXG4gICAgICAvLyBSZWNvdmVyIHBlci1jZWxsIHN0YXRlcy5cbiAgICAgIGNvbnN0IG5lc3RlZFN0YXRlczogVGVuc29yW11bXSA9IFtdO1xuICAgICAgZm9yIChjb25zdCBjZWxsIG9mIHRoaXMuY2VsbHMuc2xpY2UoKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgbmVzdGVkU3RhdGVzLnB1c2goc3RhdGVzLnNwbGljZSgwLCBjZWxsLnN0YXRlU2l6ZS5sZW5ndGgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZXN0ZWRTdGF0ZXMucHVzaChzdGF0ZXMuc3BsaWNlKDAsIDEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbmVzdGVkU3RhdGVzLnJldmVyc2UoKTtcblxuICAgICAgLy8gQ2FsbCB0aGUgY2VsbHMgaW4gb3JkZXIgYW5kIHN0b3JlIHRoZSByZXR1cm5lZCBzdGF0ZXMuXG4gICAgICBjb25zdCBuZXdOZXN0ZWRTdGF0ZXM6IFRlbnNvcltdW10gPSBbXTtcbiAgICAgIGxldCBjYWxsSW5wdXRzOiBUZW5zb3JbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5jZWxscy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBjZWxsID0gdGhpcy5jZWxsc1tpXTtcbiAgICAgICAgc3RhdGVzID0gbmVzdGVkU3RhdGVzW2ldO1xuICAgICAgICAvLyBUT0RPKGNhaXMpOiBUYWtlIGNhcmUgb2YgY29uc3RhbnRzLlxuICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgIGNhbGxJbnB1dHMgPSBbaW5wdXRzWzBdXS5jb25jYXQoc3RhdGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjYWxsSW5wdXRzID0gW2NhbGxJbnB1dHNbMF1dLmNvbmNhdChzdGF0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIGNhbGxJbnB1dHMgPSBjZWxsLmNhbGwoY2FsbElucHV0cywga3dhcmdzKSBhcyBUZW5zb3JbXTtcbiAgICAgICAgbmV3TmVzdGVkU3RhdGVzLnB1c2goY2FsbElucHV0cy5zbGljZSgxKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIEZvcm1hdCB0aGUgbmV3IHN0YXRlcyBhcyBhIGZsYXQgbGlzdCBpbiByZXZlcnNlIGNlbGwgb3JkZXIuXG4gICAgICBzdGF0ZXMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY2VsbFN0YXRlcyBvZiBuZXdOZXN0ZWRTdGF0ZXMuc2xpY2UoKS5yZXZlcnNlKCkpIHtcbiAgICAgICAgc3RhdGVzLnB1c2goLi4uY2VsbFN0YXRlcyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gW2NhbGxJbnB1dHNbMF1dLmNvbmNhdChzdGF0ZXMpO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIGJ1aWxkKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiB2b2lkIHtcbiAgICBpZiAoaXNBcnJheU9mU2hhcGVzKGlucHV0U2hhcGUpKSB7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBUYWtlIGNhcmUgb2YgaW5wdXQgY29uc3RhbnRzLlxuICAgICAgLy8gY29uc3QgY29uc3RhbnRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoMSk7XG4gICAgICBpbnB1dFNoYXBlID0gKGlucHV0U2hhcGUgYXMgU2hhcGVbXSlbMF07XG4gICAgfVxuICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlIGFzIFNoYXBlO1xuICAgIGxldCBvdXRwdXREaW06IG51bWJlcjtcbiAgICB0aGlzLmNlbGxzLmZvckVhY2goKGNlbGwsIGkpID0+IHtcbiAgICAgIG5hbWVTY29wZShgUk5OQ2VsbF8ke2l9YCwgKCkgPT4ge1xuICAgICAgICAvLyBUT0RPKGNhaXMpOiBUYWtlIGNhcmUgb2YgaW5wdXQgY29uc3RhbnRzLlxuXG4gICAgICAgIGNlbGwuYnVpbGQoaW5wdXRTaGFwZSk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNlbGwuc3RhdGVTaXplKSkge1xuICAgICAgICAgIG91dHB1dERpbSA9IGNlbGwuc3RhdGVTaXplWzBdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dERpbSA9IGNlbGwuc3RhdGVTaXplO1xuICAgICAgICB9XG4gICAgICAgIGlucHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXSwgb3V0cHV0RGltXSBhcyBTaGFwZTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuXG4gICAgY29uc3QgZ2V0Q2VsbENvbmZpZyA9IChjZWxsOiBSTk5DZWxsKSA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAnY2xhc3NOYW1lJzogY2VsbC5nZXRDbGFzc05hbWUoKSxcbiAgICAgICAgJ2NvbmZpZyc6IGNlbGwuZ2V0Q29uZmlnKCksXG4gICAgICB9O1xuICAgIH07XG5cbiAgICBjb25zdCBjZWxsQ29uZmlncyA9IHRoaXMuY2VsbHMubWFwKGdldENlbGxDb25maWcpO1xuXG4gICAgY29uc3QgY29uZmlnID0geydjZWxscyc6IGNlbGxDb25maWdzfTtcblxuICAgIHJldHVybiB7Li4uYmFzZUNvbmZpZywgLi4uY29uZmlnfTtcbiAgfVxuXG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgZnJvbUNvbmZpZzxUIGV4dGVuZHMgc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGU+KFxuICAgICAgY2xzOiBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZUNvbnN0cnVjdG9yPFQ+LFxuICAgICAgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QsXG4gICAgICBjdXN0b21PYmplY3RzID0ge30gYXMgc2VyaWFsaXphdGlvbi5Db25maWdEaWN0KTogVCB7XG4gICAgY29uc3QgY2VsbHM6IFJOTkNlbGxbXSA9IFtdO1xuICAgIGZvciAoY29uc3QgY2VsbENvbmZpZyBvZiAoY29uZmlnWydjZWxscyddIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdFtdKSkge1xuICAgICAgY2VsbHMucHVzaChkZXNlcmlhbGl6ZShjZWxsQ29uZmlnLCBjdXN0b21PYmplY3RzKSBhcyBSTk5DZWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBjbHMoe2NlbGxzfSk7XG4gIH1cblxuICBnZXQgdHJhaW5hYmxlV2VpZ2h0cygpOiBMYXllclZhcmlhYmxlW10ge1xuICAgIGlmICghdGhpcy50cmFpbmFibGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgY29uc3Qgd2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdID0gW107XG4gICAgZm9yIChjb25zdCBjZWxsIG9mIHRoaXMuY2VsbHMpIHtcbiAgICAgIHdlaWdodHMucHVzaCguLi5jZWxsLnRyYWluYWJsZVdlaWdodHMpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbiAgfVxuXG4gIGdldCBub25UcmFpbmFibGVXZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgY29uc3Qgd2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdID0gW107XG4gICAgZm9yIChjb25zdCBjZWxsIG9mIHRoaXMuY2VsbHMpIHtcbiAgICAgIHdlaWdodHMucHVzaCguLi5jZWxsLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMudHJhaW5hYmxlKSB7XG4gICAgICBjb25zdCB0cmFpbmFibGVXZWlnaHRzOiBMYXllclZhcmlhYmxlW10gPSBbXTtcbiAgICAgIGZvciAoY29uc3QgY2VsbCBvZiB0aGlzLmNlbGxzKSB7XG4gICAgICAgIHRyYWluYWJsZVdlaWdodHMucHVzaCguLi5jZWxsLnRyYWluYWJsZVdlaWdodHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRyYWluYWJsZVdlaWdodHMuY29uY2F0KHdlaWdodHMpO1xuICAgIH1cbiAgICByZXR1cm4gd2VpZ2h0cztcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZSB0aGUgd2VpZ2h0cyBvZiBhIHRoZSBtb2RlbC5cbiAgICpcbiAgICogQHJldHVybnMgQSBmbGF0IGBBcnJheWAgb2YgYHRmLlRlbnNvcmBzLlxuICAgKi9cbiAgZ2V0V2VpZ2h0cygpOiBUZW5zb3JbXSB7XG4gICAgY29uc3Qgd2VpZ2h0czogTGF5ZXJWYXJpYWJsZVtdID0gW107XG4gICAgZm9yIChjb25zdCBjZWxsIG9mIHRoaXMuY2VsbHMpIHtcbiAgICAgIHdlaWdodHMucHVzaCguLi5jZWxsLndlaWdodHMpO1xuICAgIH1cbiAgICByZXR1cm4gYmF0Y2hHZXRWYWx1ZSh3ZWlnaHRzKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgdGhlIHdlaWdodHMgb2YgdGhlIG1vZGVsLlxuICAgKlxuICAgKiBAcGFyYW0gd2VpZ2h0cyBBbiBgQXJyYXlgIG9mIGB0Zi5UZW5zb3JgcyB3aXRoIHNoYXBlcyBhbmQgdHlwZXMgbWF0Y2hpbmdcbiAgICogICAgIHRoZSBvdXRwdXQgb2YgYGdldFdlaWdodHMoKWAuXG4gICAqL1xuICBzZXRXZWlnaHRzKHdlaWdodHM6IFRlbnNvcltdKTogdm9pZCB7XG4gICAgY29uc3QgdHVwbGVzOiBBcnJheTxbTGF5ZXJWYXJpYWJsZSwgVGVuc29yXT4gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNlbGwgb2YgdGhpcy5jZWxscykge1xuICAgICAgY29uc3QgbnVtUGFyYW1zID0gY2VsbC53ZWlnaHRzLmxlbmd0aDtcbiAgICAgIGNvbnN0IGlucHV0V2VpZ2h0cyA9IHdlaWdodHMuc3BsaWNlKG51bVBhcmFtcyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNlbGwud2VpZ2h0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB0dXBsZXMucHVzaChbY2VsbC53ZWlnaHRzW2ldLCBpbnB1dFdlaWdodHNbaV1dKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYmF0Y2hTZXRWYWx1ZSh0dXBsZXMpO1xuICB9XG5cbiAgLy8gVE9ETyhjYWlzKTogTWF5YmUgaW1wbGVtbnQgYGxvc3Nlc2AgYW5kIGBnZXRMb3NzZXNGb3JgLlxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFN0YWNrZWRSTk5DZWxscyk7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZURyb3BvdXRNYXNrKGFyZ3M6IHtcbiAgb25lczogKCkgPT4gdGZjLlRlbnNvcixcbiAgcmF0ZTogbnVtYmVyLFxuICB0cmFpbmluZz86IGJvb2xlYW4sXG4gIGNvdW50PzogbnVtYmVyLFxuICBkcm9wb3V0RnVuYz86IEZ1bmN0aW9uLFxufSk6IHRmYy5UZW5zb3J8dGZjLlRlbnNvcltdIHtcbiAgY29uc3Qge29uZXMsIHJhdGUsIHRyYWluaW5nID0gZmFsc2UsIGNvdW50ID0gMSwgZHJvcG91dEZ1bmN9ID0gYXJncztcblxuICBjb25zdCBkcm9wcGVkSW5wdXRzID0gKCkgPT5cbiAgICAgIGRyb3BvdXRGdW5jICE9IG51bGwgPyBkcm9wb3V0RnVuYyhvbmVzKCksIHJhdGUpIDogSy5kcm9wb3V0KG9uZXMoKSwgcmF0ZSk7XG5cbiAgY29uc3QgY3JlYXRlTWFzayA9ICgpID0+IEsuaW5UcmFpblBoYXNlKGRyb3BwZWRJbnB1dHMsIG9uZXMsIHRyYWluaW5nKTtcblxuICAvLyBqdXN0IGluIGNhc2UgY291bnQgaXMgcHJvdmlkZWQgd2l0aCBudWxsIG9yIHVuZGVmaW5lZFxuICBpZiAoIWNvdW50IHx8IGNvdW50IDw9IDEpIHtcbiAgICByZXR1cm4gdGZjLmtlZXAoY3JlYXRlTWFzaygpLmNsb25lKCkpO1xuICB9XG5cbiAgY29uc3QgbWFza3MgPSBBcnJheShjb3VudCkuZmlsbCh1bmRlZmluZWQpLm1hcChjcmVhdGVNYXNrKTtcblxuICByZXR1cm4gbWFza3MubWFwKG0gPT4gdGZjLmtlZXAobS5jbG9uZSgpKSk7XG59XG4iXX0=","/**\n * @license\n * Copyright 2020 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { util } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { AttributeError, NotImplementedError, ValueError } from '../errors';\nimport { Initializer } from '../initializers';\nimport { convOutputLength, normalizeArray } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape } from '../utils/types_utils';\nimport { generateDropoutMask, LSTMCell, RNN, RNNCell } from './recurrent';\nclass ConvRNN2DCell extends RNNCell {\n}\n/**\n * Base class for convolutional-recurrent layers.\n */\nclass ConvRNN2D extends RNN {\n    constructor(args) {\n        if (args.unroll) {\n            throw new NotImplementedError('Unrolling is not possible with convolutional RNNs.');\n        }\n        if (Array.isArray(args.cell)) {\n            throw new NotImplementedError('It is not possible at the moment to stack convolutional cells.');\n        }\n        super(args);\n        this.inputSpec = [new InputSpec({ ndim: 5 })];\n    }\n    call(inputs, kwargs) {\n        return tfc.tidy(() => {\n            if (this.cell.dropoutMask != null) {\n                tfc.dispose(this.cell.dropoutMask);\n                this.cell.dropoutMask = null;\n            }\n            if (this.cell.recurrentDropoutMask != null) {\n                tfc.dispose(this.cell.recurrentDropoutMask);\n                this.cell.recurrentDropoutMask = null;\n            }\n            if (kwargs && kwargs['constants']) {\n                throw new ValueError('ConvRNN2D cell does not support constants');\n            }\n            const mask = kwargs == null ? null : kwargs['mask'];\n            const training = kwargs == null ? null : kwargs['training'];\n            const initialState = kwargs == null ? null : kwargs['initialState'];\n            return super.call(inputs, { mask, training, initialState });\n        });\n    }\n    computeOutputShape(inputShape) {\n        let outShape = this.computeSingleOutputShape(inputShape);\n        if (!this.returnSequences) {\n            outShape = [outShape[0], ...outShape.slice(2)];\n        }\n        if (this.returnState) {\n            outShape =\n                [outShape, ...Array(2).fill([inputShape[0], ...outShape.slice(-3)])];\n        }\n        return outShape;\n    }\n    getInitialState(inputs) {\n        return tfc.tidy(() => {\n            const { stateSize } = this.cell;\n            const inputShape = inputs.shape;\n            const outputShape = this.computeSingleOutputShape(inputShape);\n            const stateShape = [outputShape[0], ...outputShape.slice(2)];\n            const initialState = tfc.zeros(stateShape);\n            if (Array.isArray(stateSize)) {\n                return Array(stateSize.length).fill(initialState);\n            }\n            return [initialState];\n        });\n    }\n    resetStates(states, training = false) {\n        tfc.tidy(() => {\n            if (!this.stateful) {\n                throw new AttributeError('Cannot call resetStates() on an RNN Layer that is not stateful.');\n            }\n            const inputShape = this.inputSpec[0].shape;\n            const outputShape = this.computeSingleOutputShape(inputShape);\n            const stateShape = [outputShape[0], ...outputShape.slice(2)];\n            const batchSize = inputShape[0];\n            if (batchSize == null) {\n                throw new ValueError('If an RNN is stateful, it needs to know its batch size. Specify ' +\n                    'the batch size of your input tensors: \\n' +\n                    '- If using a Sequential model, specify the batch size by ' +\n                    'passing a `batchInputShape` option to your first layer.\\n' +\n                    '- If using the functional API, specify the batch size by ' +\n                    'passing a `batchShape` option to your Input layer.');\n            }\n            // Initialize state if null.\n            if (this.getStates() == null) {\n                if (Array.isArray(this.cell.stateSize)) {\n                    this.states_ = this.cell.stateSize.map(() => tfc.zeros(stateShape));\n                }\n                else {\n                    this.states_ = [tfc.zeros(stateShape)];\n                }\n            }\n            else if (states == null) {\n                // Dispose old state tensors.\n                tfc.dispose(this.states_);\n                // For stateful RNNs, fully dispose kept old states.\n                if (this.keptStates != null) {\n                    tfc.dispose(this.keptStates);\n                    this.keptStates = [];\n                }\n                if (Array.isArray(this.cell.stateSize)) {\n                    this.states_ = this.cell.stateSize.map(() => tfc.zeros(stateShape));\n                }\n                else {\n                    this.states_[0] = tfc.zeros(stateShape);\n                }\n            }\n            else {\n                if (!Array.isArray(states)) {\n                    states = [states];\n                }\n                if (states.length !== this.states_.length) {\n                    throw new ValueError(`Layer ${this.name} expects ${this.states_.length} state(s), ` +\n                        `but it received ${states.length} state value(s). Input ` +\n                        `received: ${states}`);\n                }\n                if (training) {\n                    // Store old state tensors for complete disposal later, i.e., during\n                    // the next no-arg call to this method. We do not dispose the old\n                    // states immediately because that BPTT (among other things) require\n                    // them.\n                    this.keptStates.push(this.states_.slice());\n                }\n                else {\n                    tfc.dispose(this.states_);\n                }\n                for (let index = 0; index < this.states_.length; ++index) {\n                    const value = states[index];\n                    const expectedShape = stateShape;\n                    if (!util.arraysEqual(value.shape, expectedShape)) {\n                        throw new ValueError(`State ${index} is incompatible with layer ${this.name}: ` +\n                            `expected shape=${expectedShape}, received shape=${value.shape}`);\n                    }\n                    this.states_[index] = value;\n                }\n            }\n            this.states_ = this.states_.map(state => tfc.keep(state.clone()));\n        });\n    }\n    computeSingleOutputShape(inputShape) {\n        const { dataFormat, filters, kernelSize, padding, strides, dilationRate } = this.cell;\n        const isChannelsFirst = dataFormat === 'channelsFirst';\n        const h = inputShape[isChannelsFirst ? 3 : 2];\n        const w = inputShape[isChannelsFirst ? 4 : 3];\n        const hOut = convOutputLength(h, kernelSize[0], padding, strides[0], dilationRate[0]);\n        const wOut = convOutputLength(w, kernelSize[1], padding, strides[1], dilationRate[1]);\n        const outShape = [\n            ...inputShape.slice(0, 2),\n            ...(isChannelsFirst ? [filters, hOut, wOut] : [hOut, wOut, filters])\n        ];\n        return outShape;\n    }\n}\n/** @nocollapse */\nConvRNN2D.className = 'ConvRNN2D';\nexport class ConvLSTM2DCell extends LSTMCell {\n    constructor(args) {\n        const { filters, kernelSize, strides, padding, dataFormat, dilationRate, } = args;\n        super(Object.assign({}, args, { units: filters }));\n        this.filters = filters;\n        assertPositiveInteger(this.filters, 'filters');\n        this.kernelSize = normalizeArray(kernelSize, 2, 'kernelSize');\n        this.kernelSize.forEach(size => assertPositiveInteger(size, 'kernelSize'));\n        this.strides = normalizeArray(strides || 1, 2, 'strides');\n        this.strides.forEach(stride => assertPositiveInteger(stride, 'strides'));\n        this.padding = padding || 'valid';\n        checkPaddingMode(this.padding);\n        this.dataFormat = dataFormat || 'channelsLast';\n        checkDataFormat(this.dataFormat);\n        this.dilationRate = normalizeArray(dilationRate || 1, 2, 'dilationRate');\n        this.dilationRate.forEach(rate => assertPositiveInteger(rate, 'dilationRate'));\n    }\n    build(inputShape) {\n        var _a;\n        inputShape = getExactlyOneShape(inputShape);\n        const channelAxis = this.dataFormat === 'channelsFirst' ? 1 : inputShape.length - 1;\n        if (inputShape[channelAxis] == null) {\n            throw new ValueError(`The channel dimension of the input should be defined. ` +\n                `Found ${inputShape[channelAxis]}`);\n        }\n        const inputDim = inputShape[channelAxis];\n        const numOfKernels = 4;\n        const kernelShape = this.kernelSize.concat([inputDim, this.filters * numOfKernels]);\n        this.kernel = this.addWeight('kernel', kernelShape, null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n        const recurrentKernelShape = this.kernelSize.concat([this.filters, this.filters * numOfKernels]);\n        this.recurrentKernel = this.addWeight('recurrent_kernel', recurrentKernelShape, null, this.recurrentInitializer, this.recurrentRegularizer, true, this.recurrentConstraint);\n        if (this.useBias) {\n            let biasInitializer;\n            if (this.unitForgetBias) {\n                const init = this.biasInitializer;\n                const filters = this.filters;\n                biasInitializer = new (_a = class CustomInit extends Initializer {\n                        apply(shape, dtype) {\n                            const biasI = init.apply([filters]);\n                            const biasF = tfc.ones([filters]);\n                            const biasCAndO = init.apply([filters * 2]);\n                            return K.concatenate([biasI, biasF, biasCAndO]);\n                        }\n                    },\n                    /** @nocollapse */\n                    _a.className = 'CustomInit',\n                    _a)();\n            }\n            else {\n                biasInitializer = this.biasInitializer;\n            }\n            this.bias = this.addWeight('bias', [this.filters * numOfKernels], null, biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n        }\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tfc.tidy(() => {\n            if (inputs.length !== 3) {\n                throw new ValueError(`ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got ` +\n                    `${inputs.length}.`);\n            }\n            const training = kwargs['training'] || false;\n            const x = inputs[0]; // Current input\n            const hTMinus1 = inputs[1]; // Previous memory state.\n            const cTMinus1 = inputs[2]; // Previous carry state.\n            const numOfKernels = 4;\n            if (0 < this.dropout && this.dropout < 1 && this.dropoutMask == null) {\n                this.dropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(x),\n                    rate: this.dropout,\n                    training,\n                    count: numOfKernels,\n                    dropoutFunc: this.dropoutFunc\n                });\n            }\n            const dropoutMask = this.dropoutMask;\n            const applyDropout = (x, mask, index) => {\n                if (!mask || !mask[index]) {\n                    return x;\n                }\n                return tfc.mul(mask[index], x);\n            };\n            let xI = applyDropout(x, dropoutMask, 0);\n            let xF = applyDropout(x, dropoutMask, 1);\n            let xC = applyDropout(x, dropoutMask, 2);\n            let xO = applyDropout(x, dropoutMask, 3);\n            if (0 < this.recurrentDropout && this.recurrentDropout < 1 &&\n                this.recurrentDropoutMask == null) {\n                this.recurrentDropoutMask = generateDropoutMask({\n                    ones: () => tfc.onesLike(hTMinus1),\n                    rate: this.recurrentDropout,\n                    training,\n                    count: numOfKernels,\n                    dropoutFunc: this.dropoutFunc\n                });\n            }\n            const recDropoutMask = this.recurrentDropoutMask;\n            let hI = applyDropout(hTMinus1, recDropoutMask, 0);\n            let hF = applyDropout(hTMinus1, recDropoutMask, 1);\n            let hC = applyDropout(hTMinus1, recDropoutMask, 2);\n            let hO = applyDropout(hTMinus1, recDropoutMask, 3);\n            const kernelChannelAxis = 3;\n            const [kernelI, kernelF, kernelC, kernelO] = tfc.split(this.kernel.read(), numOfKernels, kernelChannelAxis);\n            const [biasI, biasF, biasC, biasO] = this.useBias ?\n                tfc.split(this.bias.read(), numOfKernels) :\n                [null, null, null, null];\n            xI = this.inputConv(xI, kernelI, biasI, this.padding);\n            xF = this.inputConv(xF, kernelF, biasF, this.padding);\n            xC = this.inputConv(xC, kernelC, biasC, this.padding);\n            xO = this.inputConv(xO, kernelO, biasO, this.padding);\n            const [recKernelI, recKernelF, recKernelC, recKernelO] = tfc.split(this.recurrentKernel.read(), numOfKernels, kernelChannelAxis);\n            hI = this.recurrentConv(hI, recKernelI);\n            hF = this.recurrentConv(hF, recKernelF);\n            hC = this.recurrentConv(hC, recKernelC);\n            hO = this.recurrentConv(hO, recKernelO);\n            const i = this.recurrentActivation.apply(tfc.add(xI, hI));\n            const f = this.recurrentActivation.apply(tfc.add(xF, hF));\n            const c = tfc.add(tfc.mul(f, cTMinus1), tfc.mul(i, this.activation.apply(tfc.add(xC, hC))));\n            const h = tfc.mul(this.recurrentActivation.apply(tfc.add(xO, hO)), this.activation.apply(c));\n            return [h, h, c];\n        });\n    }\n    getConfig() {\n        const _a = super.getConfig(), { 'units': _ } = _a, baseConfig = __rest(_a, ['units']);\n        const config = {\n            filters: this.filters,\n            kernelSize: this.kernelSize,\n            padding: this.padding,\n            dataFormat: this.dataFormat,\n            dilationRate: this.dilationRate,\n            strides: this.strides,\n        };\n        return Object.assign({}, baseConfig, config);\n    }\n    inputConv(x, w, b, padding) {\n        const out = tfc.conv2d(x, w, this.strides, (padding || 'valid'), this.dataFormat === 'channelsFirst' ? 'NCHW' : 'NHWC', this.dilationRate);\n        if (b) {\n            return K.biasAdd(out, b, this.dataFormat);\n        }\n        return out;\n    }\n    recurrentConv(x, w) {\n        const strides = 1;\n        return tfc.conv2d(x, w, strides, 'same', this.dataFormat === 'channelsFirst' ? 'NCHW' : 'NHWC');\n    }\n}\n/** @nocollapse */\nConvLSTM2DCell.className = 'ConvLSTM2DCell';\ntfc.serialization.registerClass(ConvLSTM2DCell);\nexport class ConvLSTM2D extends ConvRNN2D {\n    constructor(args) {\n        const cell = new ConvLSTM2DCell(args);\n        super(Object.assign({}, args, { cell }));\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        return new cls(config);\n    }\n}\n/** @nocollapse */\nConvLSTM2D.className = 'ConvLSTM2D';\ntfc.serialization.registerClass(ConvLSTM2D);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udm9sdXRpb25hbF9yZWN1cnJlbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvbGF5ZXJzL2NvbnZvbHV0aW9uYWxfcmVjdXJyZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHOzs7Ozs7Ozs7Ozs7QUFFSCxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBUyxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUduRCxPQUFPLEtBQUssQ0FBQyxNQUFNLHlCQUF5QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxlQUFlLEVBQUUsZ0JBQWdCLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFFNUQsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQzdDLE9BQU8sRUFBQyxjQUFjLEVBQUUsbUJBQW1CLEVBQUUsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQzFFLE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxpQkFBaUIsQ0FBQztBQUk1QyxPQUFPLEVBQUMsZ0JBQWdCLEVBQUUsY0FBYyxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDckUsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDN0QsT0FBTyxFQUFDLGtCQUFrQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFFeEQsT0FBTyxFQUFtQixtQkFBbUIsRUFBRSxRQUFRLEVBQW9DLEdBQUcsRUFBRSxPQUFPLEVBQXVDLE1BQU0sYUFBYSxDQUFDO0FBc0RsSyxNQUFlLGFBQWMsU0FBUSxPQUFPO0NBeUIzQztBQUtEOztHQUVHO0FBQ0gsTUFBTSxTQUFVLFNBQVEsR0FBRztJQU16QixZQUFZLElBQXdCO1FBQ2xDLElBQUksSUFBSSxDQUFDLE1BQU0sRUFBRTtZQUNmLE1BQU0sSUFBSSxtQkFBbUIsQ0FDekIsb0RBQW9ELENBQUMsQ0FB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QUksR0FBRyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQ3pCLENBQUM7O0FBZEQsa0JBQWtCO0FBQ1gsb0JBQVMsR0FBRyxZQUFZLENBQUM7QUFnQmxDLEdBQUcsQ0FBQyxhQUFhLENBQUMsYUFBYSxDQUFDLFVBQVUsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMjAgR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge1RlbnNvciwgdXRpbH0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtBY3RpdmF0aW9ufSBmcm9tICcuLi9hY3RpdmF0aW9ucyc7XG5pbXBvcnQgKiBhcyBLIGZyb20gJy4uL2JhY2tlbmQvdGZqc19iYWNrZW5kJztcbmltcG9ydCB7Y2hlY2tEYXRhRm9ybWF0LCBjaGVja1BhZGRpbmdNb2RlfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHtDb25zdHJhaW50fSBmcm9tICcuLi9jb25zdHJhaW50cyc7XG5pbXBvcnQge0lucHV0U3BlY30gZnJvbSAnLi4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7QXR0cmlidXRlRXJyb3IsIE5vdEltcGxlbWVudGVkRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge0luaXRpYWxpemVyfSBmcm9tICcuLi9pbml0aWFsaXplcnMnO1xuaW1wb3J0IHtEYXRhRm9ybWF0LCBEYXRhVHlwZSwgUGFkZGluZ01vZGUsIFNoYXBlfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvY29tbW9uJztcbmltcG9ydCB7UmVndWxhcml6ZXJ9IGZyb20gJy4uL3JlZ3VsYXJpemVycyc7XG5pbXBvcnQge0t3YXJnc30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtjb252T3V0cHV0TGVuZ3RoLCBub3JtYWxpemVBcnJheX0gZnJvbSAnLi4vdXRpbHMvY29udl91dGlscyc7XG5pbXBvcnQge2Fzc2VydFBvc2l0aXZlSW50ZWdlcn0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQge2dldEV4YWN0bHlPbmVTaGFwZX0gZnJvbSAnLi4vdXRpbHMvdHlwZXNfdXRpbHMnO1xuXG5pbXBvcnQge0Jhc2VSTk5MYXllckFyZ3MsIGdlbmVyYXRlRHJvcG91dE1hc2ssIExTVE1DZWxsLCBMU1RNQ2VsbExheWVyQXJncywgTFNUTUxheWVyQXJncywgUk5OLCBSTk5DZWxsLCBSTk5MYXllckFyZ3MsIFNpbXBsZVJOTkNlbGxMYXllckFyZ3N9IGZyb20gJy4vcmVjdXJyZW50JztcblxuZGVjbGFyZSBpbnRlcmZhY2UgQ29udlJOTjJEQ2VsbEFyZ3MgZXh0ZW5kc1xuICAgIE9taXQ8U2ltcGxlUk5OQ2VsbExheWVyQXJncywgJ3VuaXRzJz4ge1xuICAvKipcbiAgICogVGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBvdXRwdXQgc3BhY2UgKGkuZS4gdGhlIG51bWJlciBvZiBmaWx0ZXJzIGluIHRoZVxuICAgKiBjb252b2x1dGlvbikuXG4gICAqL1xuICBmaWx0ZXJzOiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFRoZSBkaW1lbnNpb25zIG9mIHRoZSBjb252b2x1dGlvbiB3aW5kb3cuIElmIGtlcm5lbFNpemUgaXMgYSBudW1iZXIsIHRoZVxuICAgKiBjb252b2x1dGlvbmFsIHdpbmRvdyB3aWxsIGJlIHNxdWFyZS5cbiAgICovXG4gIGtlcm5lbFNpemU6IG51bWJlcnxudW1iZXJbXTtcblxuICAvKipcbiAgICogVGhlIHN0cmlkZXMgb2YgdGhlIGNvbnZvbHV0aW9uIGluIGVhY2ggZGltZW5zaW9uLiBJZiBzdHJpZGVzIGlzIGEgbnVtYmVyLFxuICAgKiBzdHJpZGVzIGluIGJvdGggZGltZW5zaW9ucyBhcmUgZXF1YWwuXG4gICAqXG4gICAqIFNwZWNpZnlpbmcgYW55IHN0cmlkZSB2YWx1ZSAhPSAxIGlzIGluY29tcGF0aWJsZSB3aXRoIHNwZWNpZnlpbmcgYW55XG4gICAqIGBkaWxhdGlvblJhdGVgIHZhbHVlICE9IDEuXG4gICAqL1xuICBzdHJpZGVzPzogbnVtYmVyfG51bWJlcltdO1xuXG4gIC8qKlxuICAgKiBQYWRkaW5nIG1vZGUuXG4gICAqL1xuICBwYWRkaW5nPzogUGFkZGluZ01vZGU7XG5cbiAgLyoqXG4gICAqIEZvcm1hdCBvZiB0aGUgZGF0YSwgd2hpY2ggZGV0ZXJtaW5lcyB0aGUgb3JkZXJpbmcgb2YgdGhlIGRpbWVuc2lvbnMgaW5cbiAgICogdGhlIGlucHV0cy5cbiAgICpcbiAgICogYGNoYW5uZWxzX2xhc3RgIGNvcnJlc3BvbmRzIHRvIGlucHV0cyB3aXRoIHNoYXBlXG4gICAqICAgYChiYXRjaCwgLi4uLCBjaGFubmVscylgXG4gICAqXG4gICAqICBgY2hhbm5lbHNfZmlyc3RgIGNvcnJlc3BvbmRzIHRvIGlucHV0cyB3aXRoIHNoYXBlIGAoYmF0Y2gsIGNoYW5uZWxzLFxuICAgKiAuLi4pYC5cbiAgICpcbiAgICogRGVmYXVsdHMgdG8gYGNoYW5uZWxzX2xhc3RgLlxuICAgKi9cbiAgZGF0YUZvcm1hdD86IERhdGFGb3JtYXQ7XG5cbiAgLyoqXG4gICAqIFRoZSBkaWxhdGlvbiByYXRlIHRvIHVzZSBmb3IgdGhlIGRpbGF0ZWQgY29udm9sdXRpb24gaW4gZWFjaCBkaW1lbnNpb24uXG4gICAqIFNob3VsZCBiZSBhbiBpbnRlZ2VyIG9yIGFycmF5IG9mIHR3byBvciB0aHJlZSBpbnRlZ2Vycy5cbiAgICpcbiAgICogQ3VycmVudGx5LCBzcGVjaWZ5aW5nIGFueSBgZGlsYXRpb25SYXRlYCB2YWx1ZSAhPSAxIGlzIGluY29tcGF0aWJsZSB3aXRoXG4gICAqIHNwZWNpZnlpbmcgYW55IGBzdHJpZGVzYCB2YWx1ZSAhPSAxLlxuICAgKi9cbiAgZGlsYXRpb25SYXRlPzogbnVtYmVyfFtudW1iZXJdfFtudW1iZXIsIG51bWJlcl07XG59XG5cbmFic3RyYWN0IGNsYXNzIENvbnZSTk4yRENlbGwgZXh0ZW5kcyBSTk5DZWxsIHtcbiAgcmVhZG9ubHkgZmlsdGVyczogbnVtYmVyO1xuICByZWFkb25seSBrZXJuZWxTaXplOiBudW1iZXJbXTtcbiAgcmVhZG9ubHkgc3RyaWRlczogbnVtYmVyW107XG4gIHJlYWRvbmx5IHBhZGRpbmc6IFBhZGRpbmdNb2RlO1xuICByZWFkb25seSBkYXRhRm9ybWF0OiBEYXRhRm9ybWF0O1xuICByZWFkb25seSBkaWxhdGlvblJhdGU6IG51bWJlcltdO1xuXG4gIHJlYWRvbmx5IGFjdGl2YXRpb246IEFjdGl2YXRpb247XG4gIHJlYWRvbmx5IHVzZUJpYXM6IGJvb2xlYW47XG5cbiAgcmVhZG9ubHkga2VybmVsSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyO1xuICByZWFkb25seSByZWN1cnJlbnRJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG4gIHJlYWRvbmx5IGJpYXNJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG5cbiAgcmVhZG9ubHkga2VybmVsQ29uc3RyYWludDogQ29uc3RyYWludDtcbiAgcmVhZG9ubHkgcmVjdXJyZW50Q29uc3RyYWludDogQ29uc3RyYWludDtcbiAgcmVhZG9ubHkgYmlhc0NvbnN0cmFpbnQ6IENvbnN0cmFpbnQ7XG5cbiAgcmVhZG9ubHkga2VybmVsUmVndWxhcml6ZXI6IFJlZ3VsYXJpemVyO1xuICByZWFkb25seSByZWN1cnJlbnRSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG4gIHJlYWRvbmx5IGJpYXNSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG5cbiAgcmVhZG9ubHkgZHJvcG91dDogbnVtYmVyO1xuICByZWFkb25seSByZWN1cnJlbnREcm9wb3V0OiBudW1iZXI7XG59XG5cbmRlY2xhcmUgaW50ZXJmYWNlIENvbnZSTk4yRExheWVyQXJncyBleHRlbmRzIEJhc2VSTk5MYXllckFyZ3MsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb252Uk5OMkRDZWxsQXJncyB7fVxuXG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIGNvbnZvbHV0aW9uYWwtcmVjdXJyZW50IGxheWVycy5cbiAqL1xuY2xhc3MgQ29udlJOTjJEIGV4dGVuZHMgUk5OIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQ29udlJOTjJEJztcblxuICByZWFkb25seSBjZWxsOiBDb252Uk5OMkRDZWxsO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IENvbnZSTk4yRExheWVyQXJncykge1xuICAgIGlmIChhcmdzLnVucm9sbCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ1Vucm9sbGluZyBpcyBub3QgcG9zc2libGUgd2l0aCBjb252b2x1dGlvbmFsIFJOTnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoYXJncy5jZWxsKSkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ0l0IGlzIG5vdCBwb3NzaWJsZSBhdCB0aGUgbW9tZW50IHRvIHN0YWNrIGNvbnZvbHV0aW9uYWwgY2VsbHMuJyk7XG4gICAgfVxuXG4gICAgc3VwZXIoYXJncyBhcyBSTk5MYXllckFyZ3MpO1xuXG4gICAgdGhpcy5pbnB1dFNwZWMgPSBbbmV3IElucHV0U3BlYyh7bmRpbTogNX0pXTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGZjLnRpZHkoKCkgPT4ge1xuICAgICAgaWYgKHRoaXMuY2VsbC5kcm9wb3V0TWFzayAhPSBudWxsKSB7XG4gICAgICAgIHRmYy5kaXNwb3NlKHRoaXMuY2VsbC5kcm9wb3V0TWFzayk7XG5cbiAgICAgICAgdGhpcy5jZWxsLmRyb3BvdXRNYXNrID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayAhPSBudWxsKSB7XG4gICAgICAgIHRmYy5kaXNwb3NlKHRoaXMuY2VsbC5yZWN1cnJlbnREcm9wb3V0TWFzayk7XG5cbiAgICAgICAgdGhpcy5jZWxsLnJlY3VycmVudERyb3BvdXRNYXNrID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKGt3YXJncyAmJiBrd2FyZ3NbJ2NvbnN0YW50cyddKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdDb252Uk5OMkQgY2VsbCBkb2VzIG5vdCBzdXBwb3J0IGNvbnN0YW50cycpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtYXNrID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWydtYXNrJ107XG5cbiAgICAgIGNvbnN0IHRyYWluaW5nID0ga3dhcmdzID09IG51bGwgPyBudWxsIDoga3dhcmdzWyd0cmFpbmluZyddO1xuXG4gICAgICBjb25zdCBpbml0aWFsU3RhdGU6IFRlbnNvcltdID1cbiAgICAgICAgICBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddO1xuXG4gICAgICByZXR1cm4gc3VwZXIuY2FsbChpbnB1dHMsIHttYXNrLCB0cmFpbmluZywgaW5pdGlhbFN0YXRlfSk7XG4gICAgfSk7XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGUpOiBTaGFwZXxTaGFwZVtdIHtcbiAgICBsZXQgb3V0U2hhcGU6IFNoYXBlID0gdGhpcy5jb21wdXRlU2luZ2xlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZSk7XG5cbiAgICBpZiAoIXRoaXMucmV0dXJuU2VxdWVuY2VzKSB7XG4gICAgICBvdXRTaGFwZSA9IFtvdXRTaGFwZVswXSwgLi4ub3V0U2hhcGUuc2xpY2UoMildO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJldHVyblN0YXRlKSB7XG4gICAgICBvdXRTaGFwZSA9XG4gICAgICAgICAgW291dFNoYXBlLCAuLi5BcnJheSgyKS5maWxsKFtpbnB1dFNoYXBlWzBdLCAuLi5vdXRTaGFwZS5zbGljZSgtMyldKV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG91dFNoYXBlO1xuICB9XG5cbiAgZ2V0SW5pdGlhbFN0YXRlKGlucHV0czogdGZjLlRlbnNvcik6IHRmYy5UZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRmYy50aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IHtzdGF0ZVNpemV9ID0gdGhpcy5jZWxsO1xuXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gaW5wdXRzLnNoYXBlO1xuXG4gICAgICBjb25zdCBvdXRwdXRTaGFwZSA9IHRoaXMuY29tcHV0ZVNpbmdsZU91dHB1dFNoYXBlKGlucHV0U2hhcGUpO1xuXG4gICAgICBjb25zdCBzdGF0ZVNoYXBlID0gW291dHB1dFNoYXBlWzBdLCAuLi5vdXRwdXRTaGFwZS5zbGljZSgyKV07XG5cbiAgICAgIGNvbnN0IGluaXRpYWxTdGF0ZSA9IHRmYy56ZXJvcyhzdGF0ZVNoYXBlKTtcblxuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc3RhdGVTaXplKSkge1xuICAgICAgICByZXR1cm4gQXJyYXkoc3RhdGVTaXplLmxlbmd0aCkuZmlsbChpbml0aWFsU3RhdGUpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW2luaXRpYWxTdGF0ZV07XG4gICAgfSk7XG4gIH1cblxuICByZXNldFN0YXRlcyhzdGF0ZXM/OiBUZW5zb3J8VGVuc29yW10sIHRyYWluaW5nID0gZmFsc2UpOiB2b2lkIHtcbiAgICB0ZmMudGlkeSgoKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuc3RhdGVmdWwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEF0dHJpYnV0ZUVycm9yKFxuICAgICAgICAgICAgJ0Nhbm5vdCBjYWxsIHJlc2V0U3RhdGVzKCkgb24gYW4gUk5OIExheWVyIHRoYXQgaXMgbm90IHN0YXRlZnVsLicpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBpbnB1dFNoYXBlID0gdGhpcy5pbnB1dFNwZWNbMF0uc2hhcGU7XG5cbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gdGhpcy5jb21wdXRlU2luZ2xlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZSk7XG5cbiAgICAgIGNvbnN0IHN0YXRlU2hhcGUgPSBbb3V0cHV0U2hhcGVbMF0sIC4uLm91dHB1dFNoYXBlLnNsaWNlKDIpXTtcblxuICAgICAgY29uc3QgYmF0Y2hTaXplID0gaW5wdXRTaGFwZVswXTtcblxuICAgICAgaWYgKGJhdGNoU2l6ZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgJ0lmIGFuIFJOTiBpcyBzdGF0ZWZ1bCwgaXQgbmVlZHMgdG8ga25vdyBpdHMgYmF0Y2ggc2l6ZS4gU3BlY2lmeSAnICtcbiAgICAgICAgICAgICd0aGUgYmF0Y2ggc2l6ZSBvZiB5b3VyIGlucHV0IHRlbnNvcnM6IFxcbicgK1xuICAgICAgICAgICAgJy0gSWYgdXNpbmcgYSBTZXF1ZW50aWFsIG1vZGVsLCBzcGVjaWZ5IHRoZSBiYXRjaCBzaXplIGJ5ICcgK1xuICAgICAgICAgICAgJ3Bhc3NpbmcgYSBgYmF0Y2hJbnB1dFNoYXBlYCBvcHRpb24gdG8geW91ciBmaXJzdCBsYXllci5cXG4nICtcbiAgICAgICAgICAgICctIElmIHVzaW5nIHRoZSBmdW5jdGlvbmFsIEFQSSwgc3BlY2lmeSB0aGUgYmF0Y2ggc2l6ZSBieSAnICtcbiAgICAgICAgICAgICdwYXNzaW5nIGEgYGJhdGNoU2hhcGVgIG9wdGlvbiB0byB5b3VyIElucHV0IGxheWVyLicpO1xuICAgICAgfVxuXG4gICAgICAvLyBJbml0aWFsaXplIHN0YXRlIGlmIG51bGwuXG4gICAgICBpZiAodGhpcy5nZXRTdGF0ZXMoKSA9PSBudWxsKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXNfID0gdGhpcy5jZWxsLnN0YXRlU2l6ZS5tYXAoKCkgPT4gdGZjLnplcm9zKHN0YXRlU2hhcGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlc18gPSBbdGZjLnplcm9zKHN0YXRlU2hhcGUpXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGF0ZXMgPT0gbnVsbCkge1xuICAgICAgICAvLyBEaXNwb3NlIG9sZCBzdGF0ZSB0ZW5zb3JzLlxuICAgICAgICB0ZmMuZGlzcG9zZSh0aGlzLnN0YXRlc18pO1xuXG4gICAgICAgIC8vIEZvciBzdGF0ZWZ1bCBSTk5zLCBmdWxseSBkaXNwb3NlIGtlcHQgb2xkIHN0YXRlcy5cbiAgICAgICAgaWYgKHRoaXMua2VwdFN0YXRlcyAhPSBudWxsKSB7XG4gICAgICAgICAgdGZjLmRpc3Bvc2UodGhpcy5rZXB0U3RhdGVzKTtcbiAgICAgICAgICB0aGlzLmtlcHRTdGF0ZXMgPSBbXTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRoaXMuY2VsbC5zdGF0ZVNpemUpKSB7XG4gICAgICAgICAgdGhpcy5zdGF0ZXNfID0gdGhpcy5jZWxsLnN0YXRlU2l6ZS5tYXAoKCkgPT4gdGZjLnplcm9zKHN0YXRlU2hhcGUpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnN0YXRlc19bMF0gPSB0ZmMuemVyb3Moc3RhdGVTaGFwZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShzdGF0ZXMpKSB7XG4gICAgICAgICAgc3RhdGVzID0gW3N0YXRlc107XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhdGVzLmxlbmd0aCAhPT0gdGhpcy5zdGF0ZXNfLmxlbmd0aCkge1xuICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgTGF5ZXIgJHt0aGlzLm5hbWV9IGV4cGVjdHMgJHt0aGlzLnN0YXRlc18ubGVuZ3RofSBzdGF0ZShzKSwgYCArXG4gICAgICAgICAgICAgIGBidXQgaXQgcmVjZWl2ZWQgJHtzdGF0ZXMubGVuZ3RofSBzdGF0ZSB2YWx1ZShzKS4gSW5wdXQgYCArXG4gICAgICAgICAgICAgIGByZWNlaXZlZDogJHtzdGF0ZXN9YCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHJhaW5pbmcpIHtcbiAgICAgICAgICAvLyBTdG9yZSBvbGQgc3RhdGUgdGVuc29ycyBmb3IgY29tcGxldGUgZGlzcG9zYWwgbGF0ZXIsIGkuZS4sIGR1cmluZ1xuICAgICAgICAgIC8vIHRoZSBuZXh0IG5vLWFyZyBjYWxsIHRvIHRoaXMgbWV0aG9kLiBXZSBkbyBub3QgZGlzcG9zZSB0aGUgb2xkXG4gICAgICAgICAgLy8gc3RhdGVzIGltbWVkaWF0ZWx5IGJlY2F1c2UgdGhhdCBCUFRUIChhbW9uZyBvdGhlciB0aGluZ3MpIHJlcXVpcmVcbiAgICAgICAgICAvLyB0aGVtLlxuICAgICAgICAgIHRoaXMua2VwdFN0YXRlcy5wdXNoKHRoaXMuc3RhdGVzXy5zbGljZSgpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZmMuZGlzcG9zZSh0aGlzLnN0YXRlc18pO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHRoaXMuc3RhdGVzXy5sZW5ndGg7ICsraW5kZXgpIHtcbiAgICAgICAgICBjb25zdCB2YWx1ZSA9IHN0YXRlc1tpbmRleF07XG5cbiAgICAgICAgICBjb25zdCBleHBlY3RlZFNoYXBlID0gc3RhdGVTaGFwZTtcblxuICAgICAgICAgIGlmICghdXRpbC5hcnJheXNFcXVhbCh2YWx1ZS5zaGFwZSwgZXhwZWN0ZWRTaGFwZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICAgIGBTdGF0ZSAke2luZGV4fSBpcyBpbmNvbXBhdGlibGUgd2l0aCBsYXllciAke3RoaXMubmFtZX06IGAgK1xuICAgICAgICAgICAgICAgIGBleHBlY3RlZCBzaGFwZT0ke2V4cGVjdGVkU2hhcGV9LCByZWNlaXZlZCBzaGFwZT0ke1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZS5zaGFwZX1gKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB0aGlzLnN0YXRlc19baW5kZXhdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGF0ZXNfID0gdGhpcy5zdGF0ZXNfLm1hcChzdGF0ZSA9PiB0ZmMua2VlcChzdGF0ZS5jbG9uZSgpKSk7XG4gICAgfSk7XG4gIH1cblxuICBwcm90ZWN0ZWQgY29tcHV0ZVNpbmdsZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlKTogU2hhcGUge1xuICAgIGNvbnN0IHtkYXRhRm9ybWF0LCBmaWx0ZXJzLCBrZXJuZWxTaXplLCBwYWRkaW5nLCBzdHJpZGVzLCBkaWxhdGlvblJhdGV9ID1cbiAgICAgICAgdGhpcy5jZWxsO1xuXG4gICAgY29uc3QgaXNDaGFubmVsc0ZpcnN0ID0gZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnO1xuXG4gICAgY29uc3QgaCA9IGlucHV0U2hhcGVbaXNDaGFubmVsc0ZpcnN0ID8gMyA6IDJdO1xuICAgIGNvbnN0IHcgPSBpbnB1dFNoYXBlW2lzQ2hhbm5lbHNGaXJzdCA/IDQgOiAzXTtcblxuICAgIGNvbnN0IGhPdXQgPSBjb252T3V0cHV0TGVuZ3RoKFxuICAgICAgICBoLCBrZXJuZWxTaXplWzBdLCBwYWRkaW5nLCBzdHJpZGVzWzBdLCBkaWxhdGlvblJhdGVbMF0pO1xuICAgIGNvbnN0IHdPdXQgPSBjb252T3V0cHV0TGVuZ3RoKFxuICAgICAgICB3LCBrZXJuZWxTaXplWzFdLCBwYWRkaW5nLCBzdHJpZGVzWzFdLCBkaWxhdGlvblJhdGVbMV0pO1xuXG4gICAgY29uc3Qgb3V0U2hhcGU6IFNoYXBlID0gW1xuICAgICAgLi4uaW5wdXRTaGFwZS5zbGljZSgwLCAyKSxcbiAgICAgIC4uLihpc0NoYW5uZWxzRmlyc3QgPyBbZmlsdGVycywgaE91dCwgd091dF0gOiBbaE91dCwgd091dCwgZmlsdGVyc10pXG4gICAgXTtcblxuICAgIHJldHVybiBvdXRTaGFwZTtcbiAgfVxufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgQ29udkxTVE0yRENlbGxBcmdzIGV4dGVuZHNcbiAgICBPbWl0PExTVE1DZWxsTGF5ZXJBcmdzLCAndW5pdHMnPiwgQ29udlJOTjJEQ2VsbEFyZ3Mge31cblxuZXhwb3J0IGNsYXNzIENvbnZMU1RNMkRDZWxsIGV4dGVuZHMgTFNUTUNlbGwgaW1wbGVtZW50cyBDb252Uk5OMkRDZWxsIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQ29udkxTVE0yRENlbGwnO1xuXG4gIHJlYWRvbmx5IGZpbHRlcnM6IG51bWJlcjtcbiAgcmVhZG9ubHkga2VybmVsU2l6ZTogbnVtYmVyW107XG4gIHJlYWRvbmx5IHN0cmlkZXM6IG51bWJlcltdO1xuICByZWFkb25seSBwYWRkaW5nOiBQYWRkaW5nTW9kZTtcbiAgcmVhZG9ubHkgZGF0YUZvcm1hdDogRGF0YUZvcm1hdDtcbiAgcmVhZG9ubHkgZGlsYXRpb25SYXRlOiBudW1iZXJbXTtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBDb252TFNUTTJEQ2VsbEFyZ3MpIHtcbiAgICBjb25zdCB7XG4gICAgICBmaWx0ZXJzLFxuICAgICAga2VybmVsU2l6ZSxcbiAgICAgIHN0cmlkZXMsXG4gICAgICBwYWRkaW5nLFxuICAgICAgZGF0YUZvcm1hdCxcbiAgICAgIGRpbGF0aW9uUmF0ZSxcbiAgICB9ID0gYXJncztcblxuICAgIHN1cGVyKHsuLi5hcmdzLCB1bml0czogZmlsdGVyc30pO1xuXG4gICAgdGhpcy5maWx0ZXJzID0gZmlsdGVycztcbiAgICBhc3NlcnRQb3NpdGl2ZUludGVnZXIodGhpcy5maWx0ZXJzLCAnZmlsdGVycycpO1xuXG4gICAgdGhpcy5rZXJuZWxTaXplID0gbm9ybWFsaXplQXJyYXkoa2VybmVsU2l6ZSwgMiwgJ2tlcm5lbFNpemUnKTtcbiAgICB0aGlzLmtlcm5lbFNpemUuZm9yRWFjaChzaXplID0+IGFzc2VydFBvc2l0aXZlSW50ZWdlcihzaXplLCAna2VybmVsU2l6ZScpKTtcblxuICAgIHRoaXMuc3RyaWRlcyA9IG5vcm1hbGl6ZUFycmF5KHN0cmlkZXMgfHwgMSwgMiwgJ3N0cmlkZXMnKTtcbiAgICB0aGlzLnN0cmlkZXMuZm9yRWFjaChzdHJpZGUgPT4gYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKHN0cmlkZSwgJ3N0cmlkZXMnKSk7XG5cbiAgICB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nIHx8ICd2YWxpZCc7XG4gICAgY2hlY2tQYWRkaW5nTW9kZSh0aGlzLnBhZGRpbmcpO1xuXG4gICAgdGhpcy5kYXRhRm9ybWF0ID0gZGF0YUZvcm1hdCB8fCAnY2hhbm5lbHNMYXN0JztcbiAgICBjaGVja0RhdGFGb3JtYXQodGhpcy5kYXRhRm9ybWF0KTtcblxuICAgIHRoaXMuZGlsYXRpb25SYXRlID0gbm9ybWFsaXplQXJyYXkoZGlsYXRpb25SYXRlIHx8IDEsIDIsICdkaWxhdGlvblJhdGUnKTtcbiAgICB0aGlzLmRpbGF0aW9uUmF0ZS5mb3JFYWNoKFxuICAgICAgICByYXRlID0+IGFzc2VydFBvc2l0aXZlSW50ZWdlcihyYXRlLCAnZGlsYXRpb25SYXRlJykpO1xuICB9XG5cbiAgcHVibGljIGJ1aWxkKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiB2b2lkIHtcbiAgICBpbnB1dFNoYXBlID0gZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuXG4gICAgY29uc3QgY2hhbm5lbEF4aXMgPVxuICAgICAgICB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IDEgOiBpbnB1dFNoYXBlLmxlbmd0aCAtIDE7XG5cbiAgICBpZiAoaW5wdXRTaGFwZVtjaGFubmVsQXhpc10gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYFRoZSBjaGFubmVsIGRpbWVuc2lvbiBvZiB0aGUgaW5wdXQgc2hvdWxkIGJlIGRlZmluZWQuIGAgK1xuICAgICAgICAgIGBGb3VuZCAke2lucHV0U2hhcGVbY2hhbm5lbEF4aXNdfWApO1xuICAgIH1cblxuICAgIGNvbnN0IGlucHV0RGltID0gaW5wdXRTaGFwZVtjaGFubmVsQXhpc107XG5cbiAgICBjb25zdCBudW1PZktlcm5lbHMgPSA0O1xuXG4gICAgY29uc3Qga2VybmVsU2hhcGUgPVxuICAgICAgICB0aGlzLmtlcm5lbFNpemUuY29uY2F0KFtpbnB1dERpbSwgdGhpcy5maWx0ZXJzICogbnVtT2ZLZXJuZWxzXSk7XG5cbiAgICB0aGlzLmtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAna2VybmVsJywga2VybmVsU2hhcGUsIG51bGwsIHRoaXMua2VybmVsSW5pdGlhbGl6ZXIsXG4gICAgICAgIHRoaXMua2VybmVsUmVndWxhcml6ZXIsIHRydWUsIHRoaXMua2VybmVsQ29uc3RyYWludCk7XG5cbiAgICBjb25zdCByZWN1cnJlbnRLZXJuZWxTaGFwZSA9XG4gICAgICAgIHRoaXMua2VybmVsU2l6ZS5jb25jYXQoW3RoaXMuZmlsdGVycywgdGhpcy5maWx0ZXJzICogbnVtT2ZLZXJuZWxzXSk7XG5cbiAgICB0aGlzLnJlY3VycmVudEtlcm5lbCA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAncmVjdXJyZW50X2tlcm5lbCcsIHJlY3VycmVudEtlcm5lbFNoYXBlLCBudWxsLFxuICAgICAgICB0aGlzLnJlY3VycmVudEluaXRpYWxpemVyLCB0aGlzLnJlY3VycmVudFJlZ3VsYXJpemVyLCB0cnVlLFxuICAgICAgICB0aGlzLnJlY3VycmVudENvbnN0cmFpbnQpO1xuXG4gICAgaWYgKHRoaXMudXNlQmlhcykge1xuICAgICAgbGV0IGJpYXNJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG5cbiAgICAgIGlmICh0aGlzLnVuaXRGb3JnZXRCaWFzKSB7XG4gICAgICAgIGNvbnN0IGluaXQgPSB0aGlzLmJpYXNJbml0aWFsaXplcjtcblxuICAgICAgICBjb25zdCBmaWx0ZXJzID0gdGhpcy5maWx0ZXJzO1xuXG4gICAgICAgIGJpYXNJbml0aWFsaXplciA9IG5ldyAoY2xhc3MgQ3VzdG9tSW5pdCBleHRlbmRzIEluaXRpYWxpemVyIHtcbiAgICAgICAgICAvKiogQG5vY29sbGFwc2UgKi9cbiAgICAgICAgICBzdGF0aWMgY2xhc3NOYW1lID0gJ0N1c3RvbUluaXQnO1xuXG4gICAgICAgICAgYXBwbHkoc2hhcGU6IFNoYXBlLCBkdHlwZT86IERhdGFUeXBlKTogdGZjLlRlbnNvciB7XG4gICAgICAgICAgICBjb25zdCBiaWFzSSA9IGluaXQuYXBwbHkoW2ZpbHRlcnNdKTtcbiAgICAgICAgICAgIGNvbnN0IGJpYXNGID0gdGZjLm9uZXMoW2ZpbHRlcnNdKTtcbiAgICAgICAgICAgIGNvbnN0IGJpYXNDQW5kTyA9IGluaXQuYXBwbHkoW2ZpbHRlcnMgKiAyXSk7XG4gICAgICAgICAgICByZXR1cm4gSy5jb25jYXRlbmF0ZShbYmlhc0ksIGJpYXNGLCBiaWFzQ0FuZE9dKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiaWFzSW5pdGlhbGl6ZXIgPSB0aGlzLmJpYXNJbml0aWFsaXplcjtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iaWFzID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICAgJ2JpYXMnLCBbdGhpcy5maWx0ZXJzICogbnVtT2ZLZXJuZWxzXSwgbnVsbCwgYmlhc0luaXRpYWxpemVyLFxuICAgICAgICAgIHRoaXMuYmlhc1JlZ3VsYXJpemVyLCB0cnVlLCB0aGlzLmJpYXNDb25zdHJhaW50KTtcbiAgICB9XG5cbiAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiB0ZmMuVGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogdGZjLlRlbnNvcltdIHtcbiAgICByZXR1cm4gdGZjLnRpZHkoKCkgPT4ge1xuICAgICAgaWYgKGlucHV0cy5sZW5ndGggIT09IDMpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgQ29udkxTVE0yRENlbGwgZXhwZWN0cyAzIGlucHV0IFRlbnNvcnMgKGlucHV0cywgaCwgYyksIGdvdCBgICtcbiAgICAgICAgICAgIGAke2lucHV0cy5sZW5ndGh9LmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB0cmFpbmluZyA9IGt3YXJnc1sndHJhaW5pbmcnXSB8fCBmYWxzZTtcblxuICAgICAgY29uc3QgeCA9IGlucHV0c1swXTsgICAgICAgICAvLyBDdXJyZW50IGlucHV0XG4gICAgICBjb25zdCBoVE1pbnVzMSA9IGlucHV0c1sxXTsgIC8vIFByZXZpb3VzIG1lbW9yeSBzdGF0ZS5cbiAgICAgIGNvbnN0IGNUTWludXMxID0gaW5wdXRzWzJdOyAgLy8gUHJldmlvdXMgY2Fycnkgc3RhdGUuXG5cbiAgICAgIGNvbnN0IG51bU9mS2VybmVscyA9IDQ7XG5cbiAgICAgIHR5cGUgRHJvcG91dE1hc2tzID0gW3RmYy5UZW5zb3IsIHRmYy5UZW5zb3IsIHRmYy5UZW5zb3IsIHRmYy5UZW5zb3JdO1xuXG4gICAgICBpZiAoMCA8IHRoaXMuZHJvcG91dCAmJiB0aGlzLmRyb3BvdXQgPCAxICYmIHRoaXMuZHJvcG91dE1hc2sgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLmRyb3BvdXRNYXNrID0gZ2VuZXJhdGVEcm9wb3V0TWFzayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXM6ICgpID0+IHRmYy5vbmVzTGlrZSh4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0ZTogdGhpcy5kcm9wb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFpbmluZyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnQ6IG51bU9mS2VybmVscyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJvcG91dEZ1bmM6IHRoaXMuZHJvcG91dEZ1bmNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pIGFzIHRmYy5UZW5zb3JbXTtcbiAgICAgIH1cblxuICAgICAgY29uc3QgZHJvcG91dE1hc2sgPSB0aGlzLmRyb3BvdXRNYXNrIGFzIERyb3BvdXRNYXNrcztcblxuICAgICAgY29uc3QgYXBwbHlEcm9wb3V0ID1cbiAgICAgICAgICAoeDogdGZjLlRlbnNvciwgbWFzazogdGZjLlRlbnNvcltdLCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBpZiAoIW1hc2sgfHwgIW1hc2tbaW5kZXhdKSB7XG4gICAgICAgICAgICAgIHJldHVybiB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGZjLm11bChtYXNrW2luZGV4XSwgeCk7XG4gICAgICAgICAgfTtcblxuICAgICAgbGV0IHhJID0gYXBwbHlEcm9wb3V0KHgsIGRyb3BvdXRNYXNrLCAwKTtcbiAgICAgIGxldCB4RiA9IGFwcGx5RHJvcG91dCh4LCBkcm9wb3V0TWFzaywgMSk7XG4gICAgICBsZXQgeEMgPSBhcHBseURyb3BvdXQoeCwgZHJvcG91dE1hc2ssIDIpO1xuICAgICAgbGV0IHhPID0gYXBwbHlEcm9wb3V0KHgsIGRyb3BvdXRNYXNrLCAzKTtcblxuICAgICAgaWYgKDAgPCB0aGlzLnJlY3VycmVudERyb3BvdXQgJiYgdGhpcy5yZWN1cnJlbnREcm9wb3V0IDwgMSAmJlxuICAgICAgICAgIHRoaXMucmVjdXJyZW50RHJvcG91dE1hc2sgPT0gbnVsbCkge1xuICAgICAgICB0aGlzLnJlY3VycmVudERyb3BvdXRNYXNrID0gZ2VuZXJhdGVEcm9wb3V0TWFzayh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uZXM6ICgpID0+IHRmYy5vbmVzTGlrZShoVE1pbnVzMSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJhdGU6IHRoaXMucmVjdXJyZW50RHJvcG91dCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJhaW5pbmcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50OiBudW1PZktlcm5lbHMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyb3BvdXRGdW5jOiB0aGlzLmRyb3BvdXRGdW5jXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSBhcyB0ZmMuVGVuc29yW107XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHJlY0Ryb3BvdXRNYXNrID0gdGhpcy5yZWN1cnJlbnREcm9wb3V0TWFzayBhcyBEcm9wb3V0TWFza3M7XG5cbiAgICAgIGxldCBoSSA9IGFwcGx5RHJvcG91dChoVE1pbnVzMSwgcmVjRHJvcG91dE1hc2ssIDApO1xuICAgICAgbGV0IGhGID0gYXBwbHlEcm9wb3V0KGhUTWludXMxLCByZWNEcm9wb3V0TWFzaywgMSk7XG4gICAgICBsZXQgaEMgPSBhcHBseURyb3BvdXQoaFRNaW51czEsIHJlY0Ryb3BvdXRNYXNrLCAyKTtcbiAgICAgIGxldCBoTyA9IGFwcGx5RHJvcG91dChoVE1pbnVzMSwgcmVjRHJvcG91dE1hc2ssIDMpO1xuXG4gICAgICBjb25zdCBrZXJuZWxDaGFubmVsQXhpcyA9IDM7XG5cbiAgICAgIGNvbnN0IFtrZXJuZWxJLCBrZXJuZWxGLCBrZXJuZWxDLCBrZXJuZWxPXTogdGZjLlRlbnNvcltdID1cbiAgICAgICAgICB0ZmMuc3BsaXQodGhpcy5rZXJuZWwucmVhZCgpLCBudW1PZktlcm5lbHMsIGtlcm5lbENoYW5uZWxBeGlzKTtcblxuICAgICAgY29uc3QgW2JpYXNJLCBiaWFzRiwgYmlhc0MsIGJpYXNPXTogdGZjLlRlbnNvcltdID0gdGhpcy51c2VCaWFzID9cbiAgICAgICAgICB0ZmMuc3BsaXQodGhpcy5iaWFzLnJlYWQoKSwgbnVtT2ZLZXJuZWxzKSA6XG4gICAgICAgICAgW251bGwsIG51bGwsIG51bGwsIG51bGxdO1xuXG4gICAgICB4SSA9IHRoaXMuaW5wdXRDb252KHhJLCBrZXJuZWxJLCBiaWFzSSwgdGhpcy5wYWRkaW5nKTtcbiAgICAgIHhGID0gdGhpcy5pbnB1dENvbnYoeEYsIGtlcm5lbEYsIGJpYXNGLCB0aGlzLnBhZGRpbmcpO1xuICAgICAgeEMgPSB0aGlzLmlucHV0Q29udih4Qywga2VybmVsQywgYmlhc0MsIHRoaXMucGFkZGluZyk7XG4gICAgICB4TyA9IHRoaXMuaW5wdXRDb252KHhPLCBrZXJuZWxPLCBiaWFzTywgdGhpcy5wYWRkaW5nKTtcblxuICAgICAgY29uc3QgW3JlY0tlcm5lbEksIHJlY0tlcm5lbEYsIHJlY0tlcm5lbEMsIHJlY0tlcm5lbE9dOiB0ZmMuVGVuc29yW10gPVxuICAgICAgICAgIHRmYy5zcGxpdChcbiAgICAgICAgICAgICAgdGhpcy5yZWN1cnJlbnRLZXJuZWwucmVhZCgpLCBudW1PZktlcm5lbHMsIGtlcm5lbENoYW5uZWxBeGlzKTtcblxuICAgICAgaEkgPSB0aGlzLnJlY3VycmVudENvbnYoaEksIHJlY0tlcm5lbEkpO1xuICAgICAgaEYgPSB0aGlzLnJlY3VycmVudENvbnYoaEYsIHJlY0tlcm5lbEYpO1xuICAgICAgaEMgPSB0aGlzLnJlY3VycmVudENvbnYoaEMsIHJlY0tlcm5lbEMpO1xuICAgICAgaE8gPSB0aGlzLnJlY3VycmVudENvbnYoaE8sIHJlY0tlcm5lbE8pO1xuXG4gICAgICBjb25zdCBpID0gdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeEksIGhJKSk7XG4gICAgICBjb25zdCBmID0gdGhpcy5yZWN1cnJlbnRBY3RpdmF0aW9uLmFwcGx5KHRmYy5hZGQoeEYsIGhGKSk7XG4gICAgICBjb25zdCBjID0gdGZjLmFkZChcbiAgICAgICAgICB0ZmMubXVsKGYsIGNUTWludXMxKSxcbiAgICAgICAgICB0ZmMubXVsKGksIHRoaXMuYWN0aXZhdGlvbi5hcHBseSh0ZmMuYWRkKHhDLCBoQykpKSk7XG4gICAgICBjb25zdCBoID0gdGZjLm11bChcbiAgICAgICAgICB0aGlzLnJlY3VycmVudEFjdGl2YXRpb24uYXBwbHkodGZjLmFkZCh4TywgaE8pKSxcbiAgICAgICAgICB0aGlzLmFjdGl2YXRpb24uYXBwbHkoYykpO1xuXG4gICAgICByZXR1cm4gW2gsIGgsIGNdO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHRmYy5zZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IHsndW5pdHMnOiBfLCAuLi5iYXNlQ29uZmlnfSA9IHN1cGVyLmdldENvbmZpZygpO1xuXG4gICAgY29uc3QgY29uZmlnOiB0ZmMuc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge1xuICAgICAgZmlsdGVyczogdGhpcy5maWx0ZXJzLFxuICAgICAga2VybmVsU2l6ZTogdGhpcy5rZXJuZWxTaXplLFxuICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxuICAgICAgZGF0YUZvcm1hdDogdGhpcy5kYXRhRm9ybWF0LFxuICAgICAgZGlsYXRpb25SYXRlOiB0aGlzLmRpbGF0aW9uUmF0ZSxcbiAgICAgIHN0cmlkZXM6IHRoaXMuc3RyaWRlcyxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHsuLi5iYXNlQ29uZmlnLCAuLi5jb25maWd9O1xuICB9XG5cbiAgaW5wdXRDb252KHg6IFRlbnNvciwgdzogVGVuc29yLCBiPzogVGVuc29yLCBwYWRkaW5nPzogUGFkZGluZ01vZGUpIHtcbiAgICBjb25zdCBvdXQgPSB0ZmMuY29udjJkKFxuICAgICAgICB4IGFzIHRmYy5UZW5zb3IzRCwgdyBhcyB0ZmMuVGVuc29yNEQsIHRoaXMuc3RyaWRlcyBhcyBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgICAocGFkZGluZyB8fCAndmFsaWQnKSBhcyAnc2FtZScgfCAndmFsaWQnLFxuICAgICAgICB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/ICdOQ0hXJyA6ICdOSFdDJyxcbiAgICAgICAgdGhpcy5kaWxhdGlvblJhdGUgYXMgW251bWJlciwgbnVtYmVyXSk7XG5cbiAgICBpZiAoYikge1xuICAgICAgcmV0dXJuIEsuYmlhc0FkZChvdXQsIGIsIHRoaXMuZGF0YUZvcm1hdCkgYXMgdGZjLlRlbnNvcjNEO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQ7XG4gIH1cblxuICByZWN1cnJlbnRDb252KHg6IFRlbnNvciwgdzogVGVuc29yKSB7XG4gICAgY29uc3Qgc3RyaWRlcyA9IDE7XG5cbiAgICByZXR1cm4gdGZjLmNvbnYyZChcbiAgICAgICAgeCBhcyB0ZmMuVGVuc29yM0QsIHcgYXMgdGZjLlRlbnNvcjRELCBzdHJpZGVzLCAnc2FtZScsXG4gICAgICAgIHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gJ05DSFcnIDogJ05IV0MnKTtcbiAgfVxufVxuXG50ZmMuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnZMU1RNMkRDZWxsKTtcblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIENvbnZMU1RNMkRBcmdzIGV4dGVuZHNcbiAgICBPbWl0PExTVE1MYXllckFyZ3MsICd1bml0cyd8J2NlbGwnPiwgQ29udlJOTjJETGF5ZXJBcmdzIHt9XG5cbmV4cG9ydCBjbGFzcyBDb252TFNUTTJEIGV4dGVuZHMgQ29udlJOTjJEIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQ29udkxTVE0yRCc7XG5cbiAgY29uc3RydWN0b3IoYXJnczogQ29udkxTVE0yREFyZ3MpIHtcbiAgICBjb25zdCBjZWxsID0gbmV3IENvbnZMU1RNMkRDZWxsKGFyZ3MpO1xuXG4gICAgc3VwZXIoey4uLmFyZ3MsIGNlbGx9IGFzIENvbnZSTk4yRExheWVyQXJncyk7XG4gIH1cblxuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGZyb21Db25maWc8VCBleHRlbmRzIHRmYy5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZT4oXG4gICAgICBjbHM6IHRmYy5zZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZUNvbnN0cnVjdG9yPFQ+LFxuICAgICAgY29uZmlnOiB0ZmMuc2VyaWFsaXphdGlvbi5Db25maWdEaWN0KTogVCB7XG4gICAgcmV0dXJuIG5ldyBjbHMoY29uZmlnKTtcbiAgfVxufVxuXG50ZmMuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbnZMU1RNMkQpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Basic Layers.\n */\nimport { any, cast, mul, notEqual, reshape, serialization, tidy, transpose, util } from '@tensorflow/tfjs-core';\nimport { getActivation, serializeActivation } from '../activations';\nimport * as K from '../backend/tfjs_backend';\nimport { getConstraint, serializeConstraint } from '../constraints';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { ValueError } from '../errors';\nimport { getInitializer, serializeInitializer } from '../initializers';\nimport { getRegularizer, serializeRegularizer } from '../regularizers';\nimport { assertPositiveInteger, mapActivationToFusedKernel } from '../utils/generic_utils';\nimport { arrayProd, range } from '../utils/math_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nexport class Dropout extends Layer {\n    constructor(args) {\n        super(args);\n        this.rate = Math.max(Math.min(args.rate, 1), 0);\n        // So that the scalar doesn't get tidied up between executions.\n        this.noiseShape = args.noiseShape;\n        this.seed = args.seed;\n        this.supportsMasking = true;\n    }\n    getNoiseShape(input) {\n        if (this.noiseShape == null) {\n            return this.noiseShape;\n        }\n        const inputShape = input.shape;\n        const noiseShape = [];\n        for (let i = 0; i < this.noiseShape.length; ++i) {\n            noiseShape.push(this.noiseShape[i] == null ? inputShape[i] : this.noiseShape[i]);\n        }\n        return noiseShape;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            const input = getExactlyOneTensor(inputs);\n            if (0 < this.rate && this.rate < 1) {\n                const training = kwargs['training'] == null ? false : kwargs['training'];\n                const noiseShape = this.getNoiseShape(input);\n                const output = K.inTrainPhase(() => K.dropout(input, this.rate, noiseShape, this.seed), () => input, training);\n                return output;\n            }\n            return inputs;\n        });\n    }\n    getConfig() {\n        const config = {\n            rate: this.rate,\n            noiseShape: this.noiseShape,\n            seed: this.seed,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n    dispose() {\n        return super.dispose();\n    }\n}\n/** @nocollapse */\nDropout.className = 'Dropout';\nserialization.registerClass(Dropout);\nexport class SpatialDropout1D extends Dropout {\n    constructor(args) {\n        super(args);\n        this.inputSpec = [{ ndim: 3 }];\n    }\n    getNoiseShape(input) {\n        const inputShape = input.shape;\n        return [inputShape[0], 1, inputShape[2]];\n    }\n}\n/** @nocollapse */\nSpatialDropout1D.className = 'SpatialDropout1D';\nserialization.registerClass(SpatialDropout1D);\nexport class Dense extends Layer {\n    constructor(args) {\n        super(args);\n        // Default activation: Linear (none).\n        this.activation = null;\n        this.useBias = true;\n        this.kernel = null;\n        this.bias = null;\n        this.DEFAULT_KERNEL_INITIALIZER = 'glorotNormal';\n        this.DEFAULT_BIAS_INITIALIZER = 'zeros';\n        if (args.batchInputShape == null && args.inputShape == null &&\n            args.inputDim != null) {\n            // This logic is copied from Layer's constructor, since we can't\n            // do exactly what the Python constructor does for Dense().\n            let batchSize = null;\n            if (args.batchSize != null) {\n                batchSize = args.batchSize;\n            }\n            this.batchInputShape = [batchSize, args.inputDim];\n        }\n        this.units = args.units;\n        assertPositiveInteger(this.units, 'units');\n        this.activation = getActivation(args.activation);\n        if (args.useBias != null) {\n            this.useBias = args.useBias;\n        }\n        this.kernelInitializer = getInitializer(args.kernelInitializer || this.DEFAULT_KERNEL_INITIALIZER);\n        this.biasInitializer =\n            getInitializer(args.biasInitializer || this.DEFAULT_BIAS_INITIALIZER);\n        this.kernelConstraint = getConstraint(args.kernelConstraint);\n        this.biasConstraint = getConstraint(args.biasConstraint);\n        this.kernelRegularizer = getRegularizer(args.kernelRegularizer);\n        this.biasRegularizer = getRegularizer(args.biasRegularizer);\n        this.activityRegularizer = getRegularizer(args.activityRegularizer);\n        this.supportsMasking = true;\n        this.inputSpec = [{ minNDim: 2 }];\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const inputLastDim = inputShape[inputShape.length - 1];\n        if (this.kernel == null) {\n            this.kernel = this.addWeight('kernel', [inputLastDim, this.units], null, this.kernelInitializer, this.kernelRegularizer, true, this.kernelConstraint);\n            if (this.useBias) {\n                this.bias = this.addWeight('bias', [this.units], null, this.biasInitializer, this.biasRegularizer, true, this.biasConstraint);\n            }\n        }\n        this.inputSpec = [{ minNDim: 2, axes: { [-1]: inputLastDim } }];\n        this.built = true;\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const outputShape = inputShape.slice();\n        outputShape[outputShape.length - 1] = this.units;\n        return outputShape;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            // Dense layer accepts only a single input.\n            const input = getExactlyOneTensor(inputs);\n            const fusedActivationName = mapActivationToFusedKernel(this.activation.getClassName());\n            let output;\n            if (fusedActivationName != null) {\n                output = K.dot(input, this.kernel.read(), fusedActivationName, this.bias ? this.bias.read() : null);\n            }\n            else {\n                output = K.dot(input, this.kernel.read());\n                if (this.bias != null) {\n                    output = K.biasAdd(output, this.bias.read());\n                }\n                if (this.activation != null) {\n                    output = this.activation.apply(output);\n                }\n            }\n            return output;\n        });\n    }\n    getConfig() {\n        const config = {\n            units: this.units,\n            activation: serializeActivation(this.activation),\n            useBias: this.useBias,\n            kernelInitializer: serializeInitializer(this.kernelInitializer),\n            biasInitializer: serializeInitializer(this.biasInitializer),\n            kernelRegularizer: serializeRegularizer(this.kernelRegularizer),\n            biasRegularizer: serializeRegularizer(this.biasRegularizer),\n            activityRegularizer: serializeRegularizer(this.activityRegularizer),\n            kernelConstraint: serializeConstraint(this.kernelConstraint),\n            biasConstraint: serializeConstraint(this.biasConstraint)\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nDense.className = 'Dense';\nserialization.registerClass(Dense);\nexport class Flatten extends Layer {\n    constructor(args) {\n        args = args || {};\n        super(args);\n        this.inputSpec = [{ minNDim: 3 }];\n        this.dataFormat = args.dataFormat;\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        for (const dim of inputShape.slice(1)) {\n            if (dim == null) {\n                throw new ValueError(`The shape of the input to \"Flatten\" is not fully defined ` +\n                    `(got ${inputShape.slice(1)}). Make sure to pass a complete ` +\n                    `\"input_shape\" or \"batch_input_shape\" argument to the first ` +\n                    `layer in your model.`);\n            }\n        }\n        return [inputShape[0], arrayProd(inputShape, 1)];\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            let input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsFirst' && input.rank > 1) {\n                const permutation = [0];\n                for (let i = 2; i < input.rank; ++i) {\n                    permutation.push(i);\n                }\n                permutation.push(1);\n                input = transpose(input, permutation);\n            }\n            return K.batchFlatten(input);\n        });\n    }\n    getConfig() {\n        const config = {};\n        if (this.dataFormat != null) {\n            config['dataFormat'] = this.dataFormat;\n        }\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nFlatten.className = 'Flatten';\nserialization.registerClass(Flatten);\nexport class Activation extends Layer {\n    constructor(args) {\n        super(args);\n        this.supportsMasking = true;\n        this.activation = getActivation(args.activation);\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            const input = getExactlyOneTensor(inputs);\n            return this.activation.apply(input);\n        });\n    }\n    getConfig() {\n        const config = { activation: serializeActivation(this.activation) };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nActivation.className = 'Activation';\nserialization.registerClass(Activation);\nexport class RepeatVector extends Layer {\n    constructor(args) {\n        super(args);\n        this.n = args.n;\n        this.inputSpec = [{ ndim: 2 }];\n    }\n    computeOutputShape(inputShape) {\n        return [inputShape[0], this.n, inputShape[1]];\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = getExactlyOneTensor(inputs);\n            return K.repeat(inputs, this.n);\n        });\n    }\n    getConfig() {\n        const config = {\n            n: this.n,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nRepeatVector.className = 'RepeatVector';\nserialization.registerClass(RepeatVector);\nexport class Reshape extends Layer {\n    constructor(args) {\n        super(args);\n        this.targetShape = args.targetShape;\n        // Make sure that all unknown dimensions are represented as `null`.\n        for (let i = 0; i < this.targetShape.length; ++i) {\n            if (this.isUnknown(this.targetShape[i])) {\n                this.targetShape[i] = null;\n            }\n        }\n    }\n    isUnknown(dim) {\n        return dim < 0 || dim == null;\n    }\n    /**\n     * Finds and replaces a missing dimension in output shape.\n     *\n     * This is a near direct port of the internal Numpy function\n     * `_fix_unknown_dimension` in `numpy/core/src/multiarray/shape.c`.\n     *\n     * @param inputShape: Original shape of array begin reshape.\n     * @param outputShape: Target shape of the array, with at most a single\n     * `null` or negative number, which indicates an underdetermined dimension\n     * that should be derived from `inputShape` and the known dimensions of\n     *   `outputShape`.\n     * @returns: The output shape with `null` replaced with its computed value.\n     * @throws: ValueError: If `inputShape` and `outputShape` do not match.\n     */\n    fixUnknownDimension(inputShape, outputShape) {\n        const errorMsg = 'Total size of new array must be unchanged.';\n        const finalShape = outputShape.slice();\n        let known = 1;\n        let unknown = null;\n        for (let i = 0; i < finalShape.length; ++i) {\n            const dim = finalShape[i];\n            if (this.isUnknown(dim)) {\n                if (unknown === null) {\n                    unknown = i;\n                }\n                else {\n                    throw new ValueError('Can only specifiy one unknown dimension.');\n                }\n            }\n            else {\n                known *= dim;\n            }\n        }\n        const originalSize = arrayProd(inputShape);\n        if (unknown !== null) {\n            if (known === 0 || originalSize % known !== 0) {\n                throw new ValueError(errorMsg);\n            }\n            finalShape[unknown] = originalSize / known;\n        }\n        else if (originalSize !== known) {\n            throw new ValueError(errorMsg);\n        }\n        return finalShape;\n    }\n    computeOutputShape(inputShape) {\n        let anyUnknownDims = false;\n        for (let i = 0; i < inputShape.length; ++i) {\n            if (this.isUnknown(inputShape[i])) {\n                anyUnknownDims = true;\n                break;\n            }\n        }\n        if (anyUnknownDims) {\n            return inputShape.slice(0, 1).concat(this.targetShape);\n        }\n        else {\n            return inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            const input = getExactlyOneTensor(inputs);\n            const inputShape = input.shape;\n            const outputShape = inputShape.slice(0, 1).concat(this.fixUnknownDimension(inputShape.slice(1), this.targetShape));\n            return reshape(input, outputShape);\n        });\n    }\n    getConfig() {\n        const config = {\n            targetShape: this.targetShape,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nReshape.className = 'Reshape';\nserialization.registerClass(Reshape);\nexport class Permute extends Layer {\n    constructor(args) {\n        super(args);\n        if (args.dims == null) {\n            throw new Error('Required configuration field `dims` is missing during Permute ' +\n                'constructor call.');\n        }\n        if (!Array.isArray(args.dims)) {\n            throw new Error('Permute constructor requires `dims` to be an Array, but received ' +\n                `${args.dims} instead.`);\n        }\n        // Check the validity of the permutation indices.\n        const expectedSortedIndices = range(1, args.dims.length + 1);\n        if (!util.arraysEqual(args.dims.slice().sort(), expectedSortedIndices)) {\n            throw new Error('Invalid permutation `dims`: ' + JSON.stringify(args.dims) +\n                ' `dims` must contain consecutive integers starting from 1.');\n        }\n        this.dims = args.dims;\n        this.dimsIncludingBatch = [0].concat(this.dims);\n        this.inputSpec = [new InputSpec({ ndim: this.dims.length + 1 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const outputShape = inputShape.slice();\n        this.dims.forEach((dim, i) => {\n            outputShape[i + 1] = inputShape[dim];\n        });\n        return outputShape;\n    }\n    call(inputs, kwargs) {\n        return transpose(getExactlyOneTensor(inputs), this.dimsIncludingBatch);\n    }\n    getConfig() {\n        const config = {\n            dims: this.dims,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nPermute.className = 'Permute';\nserialization.registerClass(Permute);\nexport class Masking extends Layer {\n    constructor(args) {\n        super(args == null ? {} : args);\n        this.supportsMasking = true;\n        if (args != null) {\n            this.maskValue = args.maskValue == null ? 0 : args.maskValue;\n        }\n        else {\n            this.maskValue = 0;\n        }\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const config = { maskValue: this.maskValue };\n        Object.assign(config, baseConfig);\n        return config;\n    }\n    computeMask(inputs, mask) {\n        const input = getExactlyOneTensor(inputs);\n        const axis = -1;\n        return any(notEqual(input, this.maskValue), axis);\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            const input = getExactlyOneTensor(inputs);\n            const axis = -1;\n            const keepDims = true;\n            const booleanMask = any(notEqual(input, this.maskValue), axis, keepDims);\n            const output = mul(input, cast(booleanMask, input.dtype));\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nMasking.className = 'Masking';\nserialization.registerClass(Masking);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29yZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvY29yZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxFQUFDLEdBQUcsRUFBRSxJQUFJLEVBQUUsR0FBRyxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsYUFBYSxFQUFVLElBQUksRUFBRSxTQUFTLEVBQUUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFdEgsT0FBTyxFQUE2QixhQUFhLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUM5RixPQUFPLEtBQUssQ0FBQyxNQUFNLHlCQUF5QixDQUFDO0FBQzdDLE9BQU8sRUFBbUMsYUFBYSxFQUFFLG1CQUFtQixFQUFDLE1BQU0sZ0JBQWdCLENBQUM7QUFDcEcsT0FBTyxFQUFnQixTQUFTLEVBQUUsS0FBSyxFQUFZLE1BQU0sb0JBQW9CLENBQUM7QUFDOUUsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNyQyxPQUFPLEVBQUMsY0FBYyxFQUFzQyxvQkFBb0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBSXpHLE9BQU8sRUFBQyxjQUFjLEVBQXNDLG9CQUFvQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFekcsT0FBTyxFQUFDLHFCQUFxQixFQUFFLDBCQUEwQixFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDekYsT0FBTyxFQUFDLFNBQVMsRUFBRSxLQUFLLEVBQUMsTUFBTSxxQkFBcUIsQ0FBQztBQUNyRCxPQUFPLEVBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQXFCN0UsTUFBTSxPQUFPLE9BQVEsU0FBUSxLQUFLO0lBT2hDLFlBQVksSUFBc0I7UUFDaEMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFD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MUMsTUFBTSxJQUFJLEdBQUcsQ0FBQyxDQUFDLENBQUM7WUFDaEIsTUFBTSxRQUFRLEdBQUcsSUFBSSxDQUFDO1lBQ3RCLE1BQU0sV0FBVyxHQUFHLEdBQUcsQ0FBQyxRQUFRLENBQUMsS0FBSyxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsRUFBRSxJQUFJLEVBQUUsUUFBUSxDQUFDLENBQUM7WUFDekUsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLEtBQUssQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDO1lBQzFELE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7QUF6Q0Qsa0JBQWtCO0FBQ1gsaUJBQVMsR0FBRyxTQUFTLENBQUM7QUEwQy9CLGFBQWEsQ0FBQyxhQUFhLENBQUMsT0FBTyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIFRlbnNvckZsb3cuanMgTGF5ZXJzOiBCYXNpYyBMYXllcnMuXG4gKi9cblxuaW1wb3J0IHthbnksIGNhc3QsIG11bCwgbm90RXF1YWwsIHJlc2hhcGUsIHNlcmlhbGl6YXRpb24sIFRlbnNvciwgdGlkeSwgdHJhbnNwb3NlLCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuXG5pbXBvcnQge0FjdGl2YXRpb24gYXMgQWN0aXZhdGlvbkZuLCBnZXRBY3RpdmF0aW9uLCBzZXJpYWxpemVBY3RpdmF0aW9ufSBmcm9tICcuLi9hY3RpdmF0aW9ucyc7XG5pbXBvcnQgKiBhcyBLIGZyb20gJy4uL2JhY2tlbmQvdGZqc19iYWNrZW5kJztcbmltcG9ydCB7Q29uc3RyYWludCwgQ29uc3RyYWludElkZW50aWZpZXIsIGdldENvbnN0cmFpbnQsIHNlcmlhbGl6ZUNvbnN0cmFpbnR9IGZyb20gJy4uL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7RGlzcG9zZVJlc3VsdCwgSW5wdXRTcGVjLCBMYXllciwgTGF5ZXJBcmdzfSBmcm9tICcuLi9lbmdpbmUvdG9wb2xvZ3knO1xuaW1wb3J0IHtWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtnZXRJbml0aWFsaXplciwgSW5pdGlhbGl6ZXIsIEluaXRpYWxpemVySWRlbnRpZmllciwgc2VyaWFsaXplSW5pdGlhbGl6ZXJ9IGZyb20gJy4uL2luaXRpYWxpemVycyc7XG5pbXBvcnQge0FjdGl2YXRpb25JZGVudGlmaWVyfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvYWN0aXZhdGlvbl9jb25maWcnO1xuaW1wb3J0IHtEYXRhRm9ybWF0LCBTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge0xheWVyQ29uZmlnfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvdG9wb2xvZ3lfY29uZmlnJztcbmltcG9ydCB7Z2V0UmVndWxhcml6ZXIsIFJlZ3VsYXJpemVyLCBSZWd1bGFyaXplcklkZW50aWZpZXIsIHNlcmlhbGl6ZVJlZ3VsYXJpemVyfSBmcm9tICcuLi9yZWd1bGFyaXplcnMnO1xuaW1wb3J0IHtLd2FyZ3N9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7YXNzZXJ0UG9zaXRpdmVJbnRlZ2VyLCBtYXBBY3RpdmF0aW9uVG9GdXNlZEtlcm5lbH0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQge2FycmF5UHJvZCwgcmFuZ2V9IGZyb20gJy4uL3V0aWxzL21hdGhfdXRpbHMnO1xuaW1wb3J0IHtnZXRFeGFjdGx5T25lU2hhcGUsIGdldEV4YWN0bHlPbmVUZW5zb3J9IGZyb20gJy4uL3V0aWxzL3R5cGVzX3V0aWxzJztcbmltcG9ydCB7TGF5ZXJWYXJpYWJsZX0gZnJvbSAnLi4vdmFyaWFibGVzJztcblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIERyb3BvdXRMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKiogRmxvYXQgYmV0d2VlbiAwIGFuZCAxLiBGcmFjdGlvbiBvZiB0aGUgaW5wdXQgdW5pdHMgdG8gZHJvcC4gKi9cbiAgcmF0ZTogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJbnRlZ2VyIGFycmF5IHJlcHJlc2VudGluZyB0aGUgc2hhcGUgb2YgdGhlIGJpbmFyeSBkcm9wb3V0IG1hc2sgdGhhdCB3aWxsXG4gICAqIGJlIG11bHRpcGxpZWQgd2l0aCB0aGUgaW5wdXQuXG4gICAqXG4gICAqIEZvciBpbnN0YW5jZSwgaWYgeW91ciBpbnB1dHMgaGF2ZSBzaGFwZSBgKGJhdGNoU2l6ZSwgdGltZXN0ZXBzLCBmZWF0dXJlcylgXG4gICAqIGFuZCB5b3Ugd2FudCB0aGUgZHJvcG91dCBtYXNrIHRvIGJlIHRoZSBzYW1lIGZvciBhbGwgdGltZXN0ZXBzLCB5b3UgY2FuIHVzZVxuICAgKiBgbm9pc2Vfc2hhcGU9KGJhdGNoX3NpemUsIDEsIGZlYXR1cmVzKWAuXG4gICAqL1xuICBub2lzZVNoYXBlPzogbnVtYmVyW107XG5cbiAgLyoqIEFuIGludGVnZXIgdG8gdXNlIGFzIHJhbmRvbSBzZWVkLiAqL1xuICBzZWVkPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgRHJvcG91dCBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnRHJvcG91dCc7XG4gIHByaXZhdGUgcmVhZG9ubHkgcmF0ZTogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IG5vaXNlU2hhcGU6IG51bWJlcltdO1xuICBwcml2YXRlIHJlYWRvbmx5IHNlZWQ6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBEcm9wb3V0TGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgdGhpcy5yYXRlID0gTWF0aC5tYXgoTWF0aC5taW4oYXJncy5yYXRlLCAxKSwgMCk7XG4gICAgLy8gU28gdGhhdCB0aGUgc2NhbGFyIGRvZXNuJ3QgZ2V0IHRpZGllZCB1cCBiZXR3ZWVuIGV4ZWN1dGlvbnMuXG4gICAgdGhpcy5ub2lzZVNoYXBlID0gYXJncy5ub2lzZVNoYXBlO1xuICAgIHRoaXMuc2VlZCA9IGFyZ3Muc2VlZDtcbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Tm9pc2VTaGFwZShpbnB1dDogVGVuc29yKTogU2hhcGUge1xuICAgIGlmICh0aGlzLm5vaXNlU2hhcGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHRoaXMubm9pc2VTaGFwZTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICAgIGNvbnN0IG5vaXNlU2hhcGU6IFNoYXBlID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm5vaXNlU2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIG5vaXNlU2hhcGUucHVzaChcbiAgICAgICAgICB0aGlzLm5vaXNlU2hhcGVbaV0gPT0gbnVsbCA/IGlucHV0U2hhcGVbaV0gOiB0aGlzLm5vaXNlU2hhcGVbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gbm9pc2VTaGFwZTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICB0aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgaWYgKDAgPCB0aGlzLnJhdGUgJiYgdGhpcy5yYXRlIDwgMSkge1xuICAgICAgICBjb25zdCB0cmFpbmluZyA9XG4gICAgICAgICAgICBrd2FyZ3NbJ3RyYWluaW5nJ10gPT0gbnVsbCA/IGZhbHNlIDoga3dhcmdzWyd0cmFpbmluZyddO1xuICAgICAgICBjb25zdCBub2lzZVNoYXBlID0gdGhpcy5nZXROb2lzZVNoYXBlKGlucHV0KTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gSy5pblRyYWluUGhhc2UoXG4gICAgICAgICAgICAoKSA9PiBLLmRyb3BvdXQoaW5wdXQsIHRoaXMucmF0ZSwgbm9pc2VTaGFwZSwgdGhpcy5zZWVkKSxcbiAgICAgICAgICAgICgpID0+IGlucHV0LCB0cmFpbmluZyk7XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaW5wdXRzO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgcmF0ZTogdGhpcy5yYXRlLFxuICAgICAgbm9pc2VTaGFwZTogdGhpcy5ub2lzZVNoYXBlLFxuICAgICAgc2VlZDogdGhpcy5zZWVkLFxuICAgIH07XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG5cbiAgZGlzcG9zZSgpOiBEaXNwb3NlUmVzdWx0IHtcbiAgICByZXR1cm4gc3VwZXIuZGlzcG9zZSgpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRHJvcG91dCk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBEZW5zZUxheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKiBQb3NpdGl2ZSBpbnRlZ2VyLCBkaW1lbnNpb25hbGl0eSBvZiB0aGUgb3V0cHV0IHNwYWNlLiAqL1xuICB1bml0czogbnVtYmVyO1xuICAvKipcbiAgICogQWN0aXZhdGlvbiBmdW5jdGlvbiB0byB1c2UuXG4gICAqXG4gICAqIElmIHVuc3BlY2lmaWVkLCBubyBhY3RpdmF0aW9uIGlzIGFwcGxpZWQuXG4gICAqL1xuICBhY3RpdmF0aW9uPzogQWN0aXZhdGlvbklkZW50aWZpZXI7XG4gIC8qKiBXaGV0aGVyIHRvIGFwcGx5IGEgYmlhcy4gKi9cbiAgdXNlQmlhcz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBmb3IgdGhlIGRlbnNlIGtlcm5lbCB3ZWlnaHRzIG1hdHJpeC5cbiAgICovXG4gIGtlcm5lbEluaXRpYWxpemVyPzogSW5pdGlhbGl6ZXJJZGVudGlmaWVyfEluaXRpYWxpemVyO1xuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgZm9yIHRoZSBiaWFzIHZlY3Rvci5cbiAgICovXG4gIGJpYXNJbml0aWFsaXplcj86IEluaXRpYWxpemVySWRlbnRpZmllcnxJbml0aWFsaXplcjtcbiAgLyoqXG4gICAqIElmIHNwZWNpZmllZCwgZGVmaW5lcyBpbnB1dFNoYXBlIGFzIGBbaW5wdXREaW1dYC5cbiAgICovXG4gIGlucHV0RGltPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBDb25zdHJhaW50IGZvciB0aGUga2VybmVsIHdlaWdodHMuXG4gICAqL1xuICBrZXJuZWxDb25zdHJhaW50PzogQ29uc3RyYWludElkZW50aWZpZXJ8Q29uc3RyYWludDtcblxuICAvKipcbiAgICogQ29uc3RyYWludCBmb3IgdGhlIGJpYXMgdmVjdG9yLlxuICAgKi9cbiAgYmlhc0NvbnN0cmFpbnQ/OiBDb25zdHJhaW50SWRlbnRpZmllcnxDb25zdHJhaW50O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBkZW5zZSBrZXJuZWwgd2VpZ2h0cyBtYXRyaXguXG4gICAqL1xuICBrZXJuZWxSZWd1bGFyaXplcj86IFJlZ3VsYXJpemVySWRlbnRpZmllcnxSZWd1bGFyaXplcjtcblxuICAvKipcbiAgICogUmVndWxhcml6ZXIgZnVuY3Rpb24gYXBwbGllZCB0byB0aGUgYmlhcyB2ZWN0b3IuXG4gICAqL1xuICBiaWFzUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXJ8UmVndWxhcml6ZXI7XG5cbiAgLyoqXG4gICAqIFJlZ3VsYXJpemVyIGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGFjdGl2YXRpb24uXG4gICAqL1xuICBhY3Rpdml0eVJlZ3VsYXJpemVyPzogUmVndWxhcml6ZXJJZGVudGlmaWVyfFJlZ3VsYXJpemVyO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNwYXRpYWxEcm9wb3V0MURMYXllckNvbmZpZyBleHRlbmRzIExheWVyQ29uZmlnIHtcbiAgLyoqIEZsb2F0IGJldHdlZW4gMCBhbmQgMS4gRnJhY3Rpb24gb2YgdGhlIGlucHV0IHVuaXRzIHRvIGRyb3AuICovXG4gIHJhdGU6IG51bWJlcjtcblxuICAvKiogQW4gaW50ZWdlciB0byB1c2UgYXMgcmFuZG9tIHNlZWQuICovXG4gIHNlZWQ/OiBudW1iZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBTcGF0aWFsRHJvcG91dDFEIGV4dGVuZHMgRHJvcG91dCB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ1NwYXRpYWxEcm9wb3V0MUQnO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFNwYXRpYWxEcm9wb3V0MURMYXllckNvbmZpZykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMuaW5wdXRTcGVjID0gW3tuZGltOiAzfV07XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0Tm9pc2VTaGFwZShpbnB1dDogVGVuc29yKTogU2hhcGUge1xuICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5zaGFwZTtcbiAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIDEsIGlucHV0U2hhcGVbMl1dO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoU3BhdGlhbERyb3BvdXQxRCk7XG5cbmV4cG9ydCBjbGFzcyBEZW5zZSBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnRGVuc2UnO1xuICBwcml2YXRlIHVuaXRzOiBudW1iZXI7XG4gIC8vIERlZmF1bHQgYWN0aXZhdGlvbjogTGluZWFyIChub25lKS5cbiAgcHJpdmF0ZSBhY3RpdmF0aW9uOiBBY3RpdmF0aW9uRm4gPSBudWxsO1xuICBwcml2YXRlIHVzZUJpYXMgPSB0cnVlO1xuICBwcml2YXRlIGtlcm5lbEluaXRpYWxpemVyOiBJbml0aWFsaXplcjtcbiAgcHJpdmF0ZSBiaWFzSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyO1xuICBwcml2YXRlIGtlcm5lbDogTGF5ZXJWYXJpYWJsZSA9IG51bGw7XG4gIHByaXZhdGUgYmlhczogTGF5ZXJWYXJpYWJsZSA9IG51bGw7XG5cbiAgcmVhZG9ubHkgREVGQVVMVF9LRVJORUxfSU5JVElBTElaRVI6IEluaXRpYWxpemVySWRlbnRpZmllciA9ICdnbG9yb3ROb3JtYWwnO1xuICByZWFkb25seSBERUZBVUxUX0JJQVNfSU5JVElBTElaRVI6IEluaXRpYWxpemVySWRlbnRpZmllciA9ICd6ZXJvcyc7XG4gIHByaXZhdGUgcmVhZG9ubHkga2VybmVsQ29uc3RyYWludD86IENvbnN0cmFpbnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgYmlhc0NvbnN0cmFpbnQ/OiBDb25zdHJhaW50O1xuICBwcml2YXRlIHJlYWRvbmx5IGtlcm5lbFJlZ3VsYXJpemVyPzogUmVndWxhcml6ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgYmlhc1JlZ3VsYXJpemVyPzogUmVndWxhcml6ZXI7XG5cbiAgY29uc3RydWN0b3IoYXJnczogRGVuc2VMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICBpZiAoYXJncy5iYXRjaElucHV0U2hhcGUgPT0gbnVsbCAmJiBhcmdzLmlucHV0U2hhcGUgPT0gbnVsbCAmJlxuICAgICAgICBhcmdzLmlucHV0RGltICE9IG51bGwpIHtcbiAgICAgIC8vIFRoaXMgbG9naWMgaXMgY29waWVkIGZyb20gTGF5ZXIncyBjb25zdHJ1Y3Rvciwgc2luY2Ugd2UgY2FuJ3RcbiAgICAgIC8vIGRvIGV4YWN0bHkgd2hhdCB0aGUgUHl0aG9uIGNvbnN0cnVjdG9yIGRvZXMgZm9yIERlbnNlKCkuXG4gICAgICBsZXQgYmF0Y2hTaXplOiBudW1iZXIgPSBudWxsO1xuICAgICAgaWYgKGFyZ3MuYmF0Y2hTaXplICE9IG51bGwpIHtcbiAgICAgICAgYmF0Y2hTaXplID0gYXJncy5iYXRjaFNpemU7XG4gICAgICB9XG4gICAgICB0aGlzLmJhdGNoSW5wdXRTaGFwZSA9IFtiYXRjaFNpemUsIGFyZ3MuaW5wdXREaW1dO1xuICAgIH1cblxuICAgIHRoaXMudW5pdHMgPSBhcmdzLnVuaXRzO1xuICAgIGFzc2VydFBvc2l0aXZlSW50ZWdlcih0aGlzLnVuaXRzLCAndW5pdHMnKTtcbiAgICB0aGlzLmFjdGl2YXRpb24gPSBnZXRBY3RpdmF0aW9uKGFyZ3MuYWN0aXZhdGlvbik7XG4gICAgaWYgKGFyZ3MudXNlQmlhcyAhPSBudWxsKSB7XG4gICAgICB0aGlzLnVzZUJpYXMgPSBhcmdzLnVzZUJpYXM7XG4gICAgfVxuICAgIHRoaXMua2VybmVsSW5pdGlhbGl6ZXIgPSBnZXRJbml0aWFsaXplcihcbiAgICAgICAgYXJncy5rZXJuZWxJbml0aWFsaXplciB8fCB0aGlzLkRFRkFVTFRfS0VSTkVMX0lOSVRJQUxJWkVSKTtcbiAgICB0aGlzLmJpYXNJbml0aWFsaXplciA9XG4gICAgICAgIGdldEluaXRpYWxpemVyKGFyZ3MuYmlhc0luaXRpYWxpemVyIHx8IHRoaXMuREVGQVVMVF9CSUFTX0lOSVRJQUxJWkVSKTtcbiAgICB0aGlzLmtlcm5lbENvbnN0cmFpbnQgPSBnZXRDb25zdHJhaW50KGFyZ3Mua2VybmVsQ29uc3RyYWludCk7XG4gICAgdGhpcy5iaWFzQ29uc3RyYWludCA9IGdldENvbnN0cmFpbnQoYXJncy5iaWFzQ29uc3RyYWludCk7XG4gICAgdGhpcy5rZXJuZWxSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3Mua2VybmVsUmVndWxhcml6ZXIpO1xuICAgIHRoaXMuYmlhc1JlZ3VsYXJpemVyID0gZ2V0UmVndWxhcml6ZXIoYXJncy5iaWFzUmVndWxhcml6ZXIpO1xuICAgIHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3MuYWN0aXZpdHlSZWd1bGFyaXplcik7XG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuXG4gICAgdGhpcy5pbnB1dFNwZWMgPSBbe21pbk5EaW06IDJ9XTtcbiAgfVxuXG4gIHB1YmxpYyBidWlsZChpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogdm9pZCB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBjb25zdCBpbnB1dExhc3REaW0gPSBpbnB1dFNoYXBlW2lucHV0U2hhcGUubGVuZ3RoIC0gMV07XG4gICAgaWYgKHRoaXMua2VybmVsID09IG51bGwpIHtcbiAgICAgIHRoaXMua2VybmVsID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICAgJ2tlcm5lbCcsIFtpbnB1dExhc3REaW0sIHRoaXMudW5pdHNdLCBudWxsLCB0aGlzLmtlcm5lbEluaXRpYWxpemVyLFxuICAgICAgICAgIHRoaXMua2VybmVsUmVndWxhcml6ZXIsIHRydWUsIHRoaXMua2VybmVsQ29uc3RyYWludCk7XG4gICAgICBpZiAodGhpcy51c2VCaWFzKSB7XG4gICAgICAgIHRoaXMuYmlhcyA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAgICAgJ2JpYXMnLCBbdGhpcy51bml0c10sIG51bGwsIHRoaXMuYmlhc0luaXRpYWxpemVyLFxuICAgICAgICAgICAgdGhpcy5iaWFzUmVndWxhcml6ZXIsIHRydWUsIHRoaXMuYmlhc0NvbnN0cmFpbnQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuaW5wdXRTcGVjID0gW3ttaW5ORGltOiAyLCBheGVzOiB7Wy0xXTogaW5wdXRMYXN0RGltfX1dO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiBTaGFwZXxTaGFwZVtdIHtcbiAgICBpbnB1dFNoYXBlID0gZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgpO1xuICAgIG91dHB1dFNoYXBlW291dHB1dFNoYXBlLmxlbmd0aCAtIDFdID0gdGhpcy51bml0cztcbiAgICByZXR1cm4gb3V0cHV0U2hhcGU7XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgdGhpcy5pbnZva2VDYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgICAvLyBEZW5zZSBsYXllciBhY2NlcHRzIG9ubHkgYSBzaW5nbGUgaW5wdXQuXG4gICAgICBjb25zdCBpbnB1dCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgIGNvbnN0IGZ1c2VkQWN0aXZhdGlvbk5hbWUgPVxuICAgICAgICAgIG1hcEFjdGl2YXRpb25Ub0Z1c2VkS2VybmVsKHRoaXMuYWN0aXZhdGlvbi5nZXRDbGFzc05hbWUoKSk7XG4gICAgICBsZXQgb3V0cHV0OiBUZW5zb3I7XG5cbiAgICAgIGlmIChmdXNlZEFjdGl2YXRpb25OYW1lICE9IG51bGwpIHtcbiAgICAgICAgb3V0cHV0ID0gSy5kb3QoXG4gICAgICAgICAgICBpbnB1dCwgdGhpcy5rZXJuZWwucmVhZCgpLCBmdXNlZEFjdGl2YXRpb25OYW1lLFxuICAgICAgICAgICAgdGhpcy5iaWFzID8gdGhpcy5iaWFzLnJlYWQoKSA6IG51bGwpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0cHV0ID0gSy5kb3QoaW5wdXQsIHRoaXMua2VybmVsLnJlYWQoKSk7XG4gICAgICAgIGlmICh0aGlzLmJpYXMgIT0gbnVsbCkge1xuICAgICAgICAgIG91dHB1dCA9IEsuYmlhc0FkZChvdXRwdXQsIHRoaXMuYmlhcy5yZWFkKCkpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmFjdGl2YXRpb24gIT0gbnVsbCkge1xuICAgICAgICAgIG91dHB1dCA9IHRoaXMuYWN0aXZhdGlvbi5hcHBseShvdXRwdXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHtcbiAgICAgIHVuaXRzOiB0aGlzLnVuaXRzLFxuICAgICAgYWN0aXZhdGlvbjogc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pLFxuICAgICAgdXNlQmlhczogdGhpcy51c2VCaWFzLFxuICAgICAga2VybmVsSW5pdGlhbGl6ZXI6IHNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMua2VybmVsSW5pdGlhbGl6ZXIpLFxuICAgICAgYmlhc0luaXRpYWxpemVyOiBzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLmJpYXNJbml0aWFsaXplciksXG4gICAgICBrZXJuZWxSZWd1bGFyaXplcjogc2VyaWFsaXplUmVndWxhcml6ZXIodGhpcy5rZXJuZWxSZWd1bGFyaXplciksXG4gICAgICBiaWFzUmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmlhc1JlZ3VsYXJpemVyKSxcbiAgICAgIGFjdGl2aXR5UmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYWN0aXZpdHlSZWd1bGFyaXplciksXG4gICAgICBrZXJuZWxDb25zdHJhaW50OiBzZXJpYWxpemVDb25zdHJhaW50KHRoaXMua2VybmVsQ29uc3RyYWludCksXG4gICAgICBiaWFzQ29uc3RyYWludDogc2VyaWFsaXplQ29uc3RyYWludCh0aGlzLmJpYXNDb25zdHJhaW50KVxuICAgIH07XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoRGVuc2UpO1xuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgRmxhdHRlbkxheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKiBJbWFnZSBkYXRhIGZvcm1hdDogY2hhbm5lTGFzdCAoZGVmYXVsdCkgb3IgY2hhbm5lbEZpcnN0LiAqL1xuICBkYXRhRm9ybWF0PzogRGF0YUZvcm1hdDtcbn1cblxuZXhwb3J0IGNsYXNzIEZsYXR0ZW4gZXh0ZW5kcyBMYXllciB7XG4gIHByaXZhdGUgZGF0YUZvcm1hdDogRGF0YUZvcm1hdDtcblxuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdGbGF0dGVuJztcbiAgY29uc3RydWN0b3IoYXJncz86IEZsYXR0ZW5MYXllckFyZ3MpIHtcbiAgICBhcmdzID0gYXJncyB8fCB7fTtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLmlucHV0U3BlYyA9IFt7bWluTkRpbTogM31dO1xuICAgIHRoaXMuZGF0YUZvcm1hdCA9IGFyZ3MuZGF0YUZvcm1hdDtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBmb3IgKGNvbnN0IGRpbSBvZiBpbnB1dFNoYXBlLnNsaWNlKDEpKSB7XG4gICAgICBpZiAoZGltID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgVGhlIHNoYXBlIG9mIHRoZSBpbnB1dCB0byBcIkZsYXR0ZW5cIiBpcyBub3QgZnVsbHkgZGVmaW5lZCBgICtcbiAgICAgICAgICAgIGAoZ290ICR7aW5wdXRTaGFwZS5zbGljZSgxKX0pLiBNYWtlIHN1cmUgdG8gcGFzcyBhIGNvbXBsZXRlIGAgK1xuICAgICAgICAgICAgYFwiaW5wdXRfc2hhcGVcIiBvciBcImJhdGNoX2lucHV0X3NoYXBlXCIgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGAgK1xuICAgICAgICAgICAgYGxheWVyIGluIHlvdXIgbW9kZWwuYCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgYXJyYXlQcm9kKGlucHV0U2hhcGUsIDEpXTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICB0aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcblxuICAgICAgbGV0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnICYmIGlucHV0LnJhbmsgPiAxKSB7XG4gICAgICAgIGNvbnN0IHBlcm11dGF0aW9uOiBudW1iZXJbXSA9IFswXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDI7IGkgPCBpbnB1dC5yYW5rOyArK2kpIHtcbiAgICAgICAgICBwZXJtdXRhdGlvbi5wdXNoKGkpO1xuICAgICAgICB9XG4gICAgICAgIHBlcm11dGF0aW9uLnB1c2goMSk7XG4gICAgICAgIGlucHV0ID0gdHJhbnNwb3NlKGlucHV0LCBwZXJtdXRhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBLLmJhdGNoRmxhdHRlbihpbnB1dCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHt9O1xuICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgIT0gbnVsbCkge1xuICAgICAgY29uZmlnWydkYXRhRm9ybWF0J10gPSB0aGlzLmRhdGFGb3JtYXQ7XG4gICAgfVxuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEZsYXR0ZW4pO1xuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgQWN0aXZhdGlvbkxheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBOYW1lIG9mIHRoZSBhY3RpdmF0aW9uIGZ1bmN0aW9uIHRvIHVzZS5cbiAgICovXG4gIGFjdGl2YXRpb246IEFjdGl2YXRpb25JZGVudGlmaWVyO1xufVxuXG5leHBvcnQgY2xhc3MgQWN0aXZhdGlvbiBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQWN0aXZhdGlvbic7XG4gIGFjdGl2YXRpb246IEFjdGl2YXRpb25GbjtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBBY3RpdmF0aW9uTGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgIHRoaXMuYWN0aXZhdGlvbiA9IGdldEFjdGl2YXRpb24oYXJncy5hY3RpdmF0aW9uKTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICB0aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgcmV0dXJuIHRoaXMuYWN0aXZhdGlvbi5hcHBseShpbnB1dCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSB7YWN0aXZhdGlvbjogc2VyaWFsaXplQWN0aXZhdGlvbih0aGlzLmFjdGl2YXRpb24pfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBY3RpdmF0aW9uKTtcblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFJlc2hhcGVMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKiogVGhlIHRhcmdldCBzaGFwZS4gRG9lcyBub3QgaW5jbHVkZSB0aGUgYmF0Y2ggYXhpcy4gKi9cbiAgdGFyZ2V0U2hhcGU6IFNoYXBlO1xufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgUmVwZWF0VmVjdG9yTGF5ZXJBcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcbiAgLyoqXG4gICAqIFRoZSBpbnRlZ2VyIG51bWJlciBvZiB0aW1lcyB0byByZXBlYXQgdGhlIGlucHV0LlxuICAgKi9cbiAgbjogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgUmVwZWF0VmVjdG9yIGV4dGVuZHMgTGF5ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdSZXBlYXRWZWN0b3InO1xuICByZWFkb25seSBuOiBudW1iZXI7XG5cbiAgY29uc3RydWN0b3IoYXJnczogUmVwZWF0VmVjdG9yTGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgdGhpcy5uID0gYXJncy5uO1xuICAgIHRoaXMuaW5wdXRTcGVjID0gW3tuZGltOiAyfV07XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGUpOiBTaGFwZSB7XG4gICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCB0aGlzLm4sIGlucHV0U2hhcGVbMV1dO1xuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGlucHV0cyA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgIHJldHVybiBLLnJlcGVhdChpbnB1dHMsIHRoaXMubik7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBuOiB0aGlzLm4sXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhSZXBlYXRWZWN0b3IpO1xuXG5leHBvcnQgY2xhc3MgUmVzaGFwZSBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnUmVzaGFwZSc7XG4gIHByaXZhdGUgdGFyZ2V0U2hhcGU6IFNoYXBlO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFJlc2hhcGVMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLnRhcmdldFNoYXBlID0gYXJncy50YXJnZXRTaGFwZTtcblxuICAgIC8vIE1ha2Ugc3VyZSB0aGF0IGFsbCB1bmtub3duIGRpbWVuc2lvbnMgYXJlIHJlcHJlc2VudGVkIGFzIGBudWxsYC5cbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMudGFyZ2V0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmlzVW5rbm93bih0aGlzLnRhcmdldFNoYXBlW2ldKSkge1xuICAgICAgICB0aGlzLnRhcmdldFNoYXBlW2ldID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGlzVW5rbm93bihkaW06IG51bWJlcik6IGJvb2xlYW4ge1xuICAgIHJldHVybiBkaW0gPCAwIHx8IGRpbSA9PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpbmRzIGFuZCByZXBsYWNlcyBhIG1pc3NpbmcgZGltZW5zaW9uIGluIG91dHB1dCBzaGFwZS5cbiAgICpcbiAgICogVGhpcyBpcyBhIG5lYXIgZGlyZWN0IHBvcnQgb2YgdGhlIGludGVybmFsIE51bXB5IGZ1bmN0aW9uXG4gICAqIGBfZml4X3Vua25vd25fZGltZW5zaW9uYCBpbiBgbnVtcHkvY29yZS9zcmMvbXVsdGlhcnJheS9zaGFwZS5jYC5cbiAgICpcbiAgICogQHBhcmFtIGlucHV0U2hhcGU6IE9yaWdpbmFsIHNoYXBlIG9mIGFycmF5IGJlZ2luIHJlc2hhcGUuXG4gICAqIEBwYXJhbSBvdXRwdXRTaGFwZTogVGFyZ2V0IHNoYXBlIG9mIHRoZSBhcnJheSwgd2l0aCBhdCBtb3N0IGEgc2luZ2xlXG4gICAqIGBudWxsYCBvciBuZWdhdGl2ZSBudW1iZXIsIHdoaWNoIGluZGljYXRlcyBhbiB1bmRlcmRldGVybWluZWQgZGltZW5zaW9uXG4gICAqIHRoYXQgc2hvdWxkIGJlIGRlcml2ZWQgZnJvbSBgaW5wdXRTaGFwZWAgYW5kIHRoZSBrbm93biBkaW1lbnNpb25zIG9mXG4gICAqICAgYG91dHB1dFNoYXBlYC5cbiAgICogQHJldHVybnM6IFRoZSBvdXRwdXQgc2hhcGUgd2l0aCBgbnVsbGAgcmVwbGFjZWQgd2l0aCBpdHMgY29tcHV0ZWQgdmFsdWUuXG4gICAqIEB0aHJvd3M6IFZhbHVlRXJyb3I6IElmIGBpbnB1dFNoYXBlYCBhbmQgYG91dHB1dFNoYXBlYCBkbyBub3QgbWF0Y2guXG4gICAqL1xuICBwcml2YXRlIGZpeFVua25vd25EaW1lbnNpb24oaW5wdXRTaGFwZTogU2hhcGUsIG91dHB1dFNoYXBlOiBTaGFwZSk6IFNoYXBlIHtcbiAgICBjb25zdCBlcnJvck1zZyA9ICdUb3RhbCBzaXplIG9mIG5ldyBhcnJheSBtdXN0IGJlIHVuY2hhbmdlZC4nO1xuICAgIGNvbnN0IGZpbmFsU2hhcGUgPSBvdXRwdXRTaGFwZS5zbGljZSgpO1xuICAgIGxldCBrbm93biA9IDE7XG4gICAgbGV0IHVua25vd24gPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZmluYWxTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZGltID0gZmluYWxTaGFwZVtpXTtcbiAgICAgIGlmICh0aGlzLmlzVW5rbm93bihkaW0pKSB7XG4gICAgICAgIGlmICh1bmtub3duID09PSBudWxsKSB7XG4gICAgICAgICAgdW5rbm93biA9IGk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ0NhbiBvbmx5IHNwZWNpZml5IG9uZSB1bmtub3duIGRpbWVuc2lvbi4nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAga25vd24gKj0gZGltO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IG9yaWdpbmFsU2l6ZSA9IGFycmF5UHJvZChpbnB1dFNoYXBlKTtcbiAgICBpZiAodW5rbm93biAhPT0gbnVsbCkge1xuICAgICAgaWYgKGtub3duID09PSAwIHx8IG9yaWdpbmFsU2l6ZSAlIGtub3duICE9PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGVycm9yTXNnKTtcbiAgICAgIH1cbiAgICAgIGZpbmFsU2hhcGVbdW5rbm93bl0gPSBvcmlnaW5hbFNpemUgLyBrbm93bjtcbiAgICB9IGVsc2UgaWYgKG9yaWdpbmFsU2l6ZSAhPT0ga25vd24pIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKGVycm9yTXNnKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmluYWxTaGFwZTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZSk6IFNoYXBlIHtcbiAgICBsZXQgYW55VW5rbm93bkRpbXMgPSBmYWxzZTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmlzVW5rbm93bihpbnB1dFNoYXBlW2ldKSkge1xuICAgICAgICBhbnlVbmtub3duRGltcyA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChhbnlVbmtub3duRGltcykge1xuICAgICAgcmV0dXJuIGlucHV0U2hhcGUuc2xpY2UoMCwgMSkuY29uY2F0KHRoaXMudGFyZ2V0U2hhcGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gaW5wdXRTaGFwZS5zbGljZSgwLCAxKS5jb25jYXQoXG4gICAgICAgICAgdGhpcy5maXhVbmtub3duRGltZW5zaW9uKGlucHV0U2hhcGUuc2xpY2UoMSksIHRoaXMudGFyZ2V0U2hhcGUpKTtcbiAgICB9XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgdGhpcy5pbnZva2VDYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgICBjb25zdCBpbnB1dCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5zaGFwZTtcbiAgICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZS5zbGljZSgwLCAxKS5jb25jYXQoXG4gICAgICAgICAgdGhpcy5maXhVbmtub3duRGltZW5zaW9uKGlucHV0U2hhcGUuc2xpY2UoMSksIHRoaXMudGFyZ2V0U2hhcGUpKTtcbiAgICAgIHJldHVybiByZXNoYXBlKGlucHV0LCBvdXRwdXRTaGFwZSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICB0YXJnZXRTaGFwZTogdGhpcy50YXJnZXRTaGFwZSxcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFJlc2hhcGUpO1xuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgUGVybXV0ZUxheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBBcnJheSBvZiBpbnRlZ2Vycy4gUGVybXV0YXRpb24gcGF0dGVybi4gRG9lcyBub3QgaW5jbHVkZSB0aGVcbiAgICogc2FtcGxlIChiYXRjaCkgZGltZW5zaW9uLiBJbmRleCBzdGFydHMgYXQgMS5cbiAgICogRm9yIGluc3RhbmNlLCBgWzIsIDFdYCBwZXJtdXRlcyB0aGUgZmlyc3QgYW5kIHNlY29uZCBkaW1lbnNpb25zXG4gICAqIG9mIHRoZSBpbnB1dC5cbiAgICovXG4gIGRpbXM6IG51bWJlcltdO1xufVxuXG5leHBvcnQgY2xhc3MgUGVybXV0ZSBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnUGVybXV0ZSc7XG4gIHJlYWRvbmx5IGRpbXM6IG51bWJlcltdO1xuICBwcml2YXRlIHJlYWRvbmx5IGRpbXNJbmNsdWRpbmdCYXRjaDogbnVtYmVyW107XG5cbiAgY29uc3RydWN0b3IoYXJnczogUGVybXV0ZUxheWVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICAgIGlmIChhcmdzLmRpbXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdSZXF1aXJlZCBjb25maWd1cmF0aW9uIGZpZWxkIGBkaW1zYCBpcyBtaXNzaW5nIGR1cmluZyBQZXJtdXRlICcgK1xuICAgICAgICAgICdjb25zdHJ1Y3RvciBjYWxsLicpO1xuICAgIH1cbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJncy5kaW1zKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICdQZXJtdXRlIGNvbnN0cnVjdG9yIHJlcXVpcmVzIGBkaW1zYCB0byBiZSBhbiBBcnJheSwgYnV0IHJlY2VpdmVkICcgK1xuICAgICAgICAgIGAke2FyZ3MuZGltc30gaW5zdGVhZC5gKTtcbiAgICB9XG5cbiAgICAvLyBDaGVjayB0aGUgdmFsaWRpdHkgb2YgdGhlIHBlcm11dGF0aW9uIGluZGljZXMuXG4gICAgY29uc3QgZXhwZWN0ZWRTb3J0ZWRJbmRpY2VzID0gcmFuZ2UoMSwgYXJncy5kaW1zLmxlbmd0aCArIDEpO1xuICAgIGlmICghdXRpbC5hcnJheXNFcXVhbChhcmdzLmRpbXMuc2xpY2UoKS5zb3J0KCksIGV4cGVjdGVkU29ydGVkSW5kaWNlcykpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAnSW52YWxpZCBwZXJtdXRhdGlvbiBgZGltc2A6ICcgKyBKU09OLnN0cmluZ2lmeShhcmdzLmRpbXMpICtcbiAgICAgICAgICAnIGBkaW1zYCBtdXN0IGNvbnRhaW4gY29uc2VjdXRpdmUgaW50ZWdlcnMgc3RhcnRpbmcgZnJvbSAxLicpO1xuICAgIH1cblxuICAgIHRoaXMuZGltcyA9IGFyZ3MuZGltcztcbiAgICB0aGlzLmRpbXNJbmNsdWRpbmdCYXRjaCA9IFswXS5jb25jYXQodGhpcy5kaW1zKTtcbiAgICB0aGlzLmlucHV0U3BlYyA9IFtuZXcgSW5wdXRTcGVjKHtuZGltOiB0aGlzLmRpbXMubGVuZ3RoICsgMX0pXTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBjb25zdCBvdXRwdXRTaGFwZSA9IGlucHV0U2hhcGUuc2xpY2UoKTtcbiAgICB0aGlzLmRpbXMuZm9yRWFjaCgoZGltOiBudW1iZXIsIGk6IG51bWJlcikgPT4ge1xuICAgICAgb3V0cHV0U2hhcGVbaSArIDFdID0gKGlucHV0U2hhcGUgYXMgU2hhcGUpW2RpbV07XG4gICAgfSk7XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0cmFuc3Bvc2UoZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpLCB0aGlzLmRpbXNJbmNsdWRpbmdCYXRjaCk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBkaW1zOiB0aGlzLmRpbXMsXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhQZXJtdXRlKTtcblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIE1hc2tpbmdBcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcbiAgLyoqXG4gICAqIE1hc2tpbmcgVmFsdWUuIERlZmF1bHRzIHRvIGAwLjBgLlxuICAgKi9cbiAgbWFza1ZhbHVlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgY2xhc3MgTWFza2luZyBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTWFza2luZyc7XG4gIG1hc2tWYWx1ZTogbnVtYmVyO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBNYXNraW5nQXJncykge1xuICAgIHN1cGVyKGFyZ3MgPT0gbnVsbCA/IHt9IDogYXJncyk7XG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgIGlmIChhcmdzICE9IG51bGwpIHtcbiAgICAgIHRoaXMubWFza1ZhbHVlID0gYXJncy5tYXNrVmFsdWUgPT0gbnVsbCA/IDAgOiBhcmdzLm1hc2tWYWx1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5tYXNrVmFsdWUgPSAwO1xuICAgIH1cbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgcmV0dXJuIGlucHV0U2hhcGU7XG4gIH1cblxuICBnZXRDb25maWcoKSB7XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuICAgIGNvbnN0IGNvbmZpZyA9IHttYXNrVmFsdWU6IHRoaXMubWFza1ZhbHVlfTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIGNvbXB1dGVNYXNrKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBtYXNrPzogVGVuc29yfFRlbnNvcltdKTogVGVuc29yIHtcbiAgICBjb25zdCBpbnB1dCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICBjb25zdCBheGlzID0gLTE7XG4gICAgcmV0dXJuIGFueShub3RFcXVhbChpbnB1dCwgdGhpcy5tYXNrVmFsdWUpLCBheGlzKTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICB0aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgY29uc3QgYXhpcyA9IC0xO1xuICAgICAgY29uc3Qga2VlcERpbXMgPSB0cnVlO1xuICAgICAgY29uc3QgYm9vbGVhbk1hc2sgPSBhbnkobm90RXF1YWwoaW5wdXQsIHRoaXMubWFza1ZhbHVlKSwgYXhpcywga2VlcERpbXMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gbXVsKGlucHV0LCBjYXN0KGJvb2xlYW5NYXNrLCBpbnB1dC5kdHlwZSkpO1xuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1hc2tpbmcpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Embedding Layer.\n *\n * Original source: keras/constraints.py\n */\nimport { notEqual, reshape, serialization, tidy, zerosLike } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { getConstraint, serializeConstraint } from '../constraints';\nimport { Layer } from '../engine/topology';\nimport { ValueError } from '../errors';\nimport { getInitializer, serializeInitializer } from '../initializers';\nimport { getRegularizer, serializeRegularizer } from '../regularizers';\nimport * as generic_utils from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nexport class Embedding extends Layer {\n    constructor(args) {\n        super(args);\n        this.embeddings = null;\n        this.DEFAULT_EMBEDDINGS_INITIALIZER = 'randomUniform';\n        if (args.batchInputShape == null && args.inputShape == null) {\n            // Porting Note: This logic is copied from Layer's constructor, since we\n            // can't do exactly what the Python constructor does for Embedding().\n            // Specifically, the super constructor can not be called after the\n            // mutation of the `config` argument.\n            let batchSize = null;\n            if (args.batchSize != null) {\n                batchSize = args.batchSize;\n            }\n            if (args.inputLength == null) {\n                // Fix super-constructor to what it would have done if\n                // 'config.inputShape' were (None, )\n                this.batchInputShape = [batchSize, null];\n            }\n            else {\n                // Fix super-constructor to what it would have done if\n                // 'config.inputShape' were (config.inputLength, )\n                this.batchInputShape =\n                    [batchSize].concat(generic_utils.toList(args.inputLength));\n            }\n        }\n        this.inputDim = args.inputDim;\n        generic_utils.assertPositiveInteger(this.inputDim, 'inputDim');\n        this.outputDim = args.outputDim;\n        generic_utils.assertPositiveInteger(this.outputDim, 'outputDim');\n        this.embeddingsInitializer = getInitializer(args.embeddingsInitializer || this.DEFAULT_EMBEDDINGS_INITIALIZER);\n        this.embeddingsRegularizer = getRegularizer(args.embeddingsRegularizer);\n        this.activityRegularizer = getRegularizer(args.activityRegularizer);\n        this.embeddingsConstraint = getConstraint(args.embeddingsConstraint);\n        this.maskZero = args.maskZero;\n        this.supportsMasking = args.maskZero;\n        this.inputLength = args.inputLength;\n    }\n    build(inputShape) {\n        this.embeddings = this.addWeight('embeddings', [this.inputDim, this.outputDim], this.dtype, this.embeddingsInitializer, this.embeddingsRegularizer, true, this.embeddingsConstraint);\n        this.built = true;\n    }\n    // Override warnOnIncompatibleInputShape because an embedding layer allows\n    // the input to have varying ranks.\n    warnOnIncompatibleInputShape(inputShape) { }\n    computeMask(inputs, mask) {\n        return tidy(() => {\n            if (!this.maskZero) {\n                return null;\n            }\n            else {\n                inputs = getExactlyOneTensor(inputs);\n                return notEqual(inputs, zerosLike(inputs));\n            }\n        });\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        if (this.inputLength == null) {\n            return [...inputShape, this.outputDim];\n        }\n        // inputLength can be an array if input is 3D or higher.\n        const inLens = generic_utils.toList(this.inputLength);\n        if (inLens.length !== inputShape.length - 1) {\n            throw new ValueError(`\"inputLength\" is ${this.inputLength}, but received ` +\n                `input shape has shape ${inputShape}`);\n        }\n        else {\n            let i = 0;\n            for (let k = 0; k < inLens.length; ++k) {\n                const s1 = inLens[k];\n                const s2 = inputShape[k + 1];\n                if ((s1 != null) && (s2 != null) && (s1 !== s2)) {\n                    throw new ValueError(`\"inputLength\" is ${this.inputLength}, but received ` +\n                        `input shape has shape ${inputShape}`);\n                }\n                else if (s1 == null) {\n                    inLens[i] = s2;\n                }\n                i++;\n            }\n        }\n        return [inputShape[0], ...inLens, this.outputDim];\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            // Embedding layer accepts only a single input.\n            let input = getExactlyOneTensor(inputs);\n            if (input.dtype !== 'int32') {\n                input = K.cast(input, 'int32');\n            }\n            const output = K.gather(this.embeddings.read(), reshape(input, [input.size]));\n            return reshape(output, getExactlyOneShape(this.computeOutputShape(input.shape)));\n        });\n    }\n    getConfig() {\n        const config = {\n            inputDim: this.inputDim,\n            outputDim: this.outputDim,\n            embeddingsInitializer: serializeInitializer(this.embeddingsInitializer),\n            embeddingsRegularizer: serializeRegularizer(this.embeddingsRegularizer),\n            activityRegularizer: serializeRegularizer(this.activityRegularizer),\n            embeddingsConstraint: serializeConstraint(this.embeddingsConstraint),\n            maskZero: this.maskZero,\n            inputLength: this.inputLength\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nEmbedding.className = 'Embedding';\nserialization.registerClass(Embedding);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZW1iZWRkaW5ncy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvZW1iZWRkaW5ncy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOzs7O0dBSUc7QUFDSCxPQUFPLEVBQUMsUUFBUSxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQVUsSUFBSSxFQUFFLFNBQVMsRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBRWhHLE9BQU8sS0FBSyxDQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDN0MsT0FBTyxFQUFtQyxhQUFhLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRyxPQUFPLEVBQUMsS0FBSyxFQUFZLE1BQU0sb0JBQW9CLENBQUM7QUFDcEQsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUNyQyxPQUFPLEVBQUMsY0FBYyxFQUFzQyxvQkFBb0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRXpHLE9BQU8sRUFBQyxjQUFjLEVBQXNDLG9CQUFvQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFekcsT0FBTyxLQUFLLGFBQWEsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxPQUFPLEVBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQWlEN0UsTUFBTSxPQUFPLFNBQVUsU0FBUSxLQUFLO0lBZ0JsQyxZQUFZLElBQXdCO1FBQ2xDLEtBQUssQ0FBQyxJQUFJLENBQUMsQ0FBQztRQVJOLGVBQVUsR0FBa0IsSUFBSSxDQUFDO1FBRWhDLG1DQUE4QixHQUNuQyxlQUFlLENBQUM7UUFNbEIsSUFBSSxJQUFJLENBQUMsZUFBZSxJQUFJLElBQUksSUFBSSxJQUFJLENBQUMsVUFBVSxJQUFJLElBQUksRUFBRTtZQUMzRCx3RUFBd0U7WUFDeEUscUVBQXFFO1lBQ3JFLGtFQUFrRTtZQUNsRSxxQ0FBcUM7WUFDckMsSUFBSSxTQUFTLEdBQVcsSUFBSSxDQUFDO1lBQzdCLElBQUksSUFBSSxDQUFDLFNBQVMsSUFBSSxJQUFJLEVBQUU7Z0JBQzFCLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO2FBQzVCO1lBQ0QsSUFBSSxJQUFJLENBQUMsV0FBVyxJQUFJLElBQUksRUFBRTtnQkFDNUIsc0RBQXNEO2dCQUN0RCxvQ0FBb0M7Z0JBQ3BDLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxTQUFTLEVBQUUsSUFBSSxDQUFDLENBQUM7YUFDMUM7aUJBQU07Z0JBQ0wsc0RBQXNEO2dCQUN0RCxrREFBa0Q7Z0JBQ2xELElBQUksQ0FBQyxlQUFlO29CQUNoQixDQUFDLFNBQVMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxhQUFhLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQyxDQUFDO2FBQ2hFO1NBQ0Y7UUFDRCxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDOUIsYUFBYSxDQUFDLHFCQUFxQixDQUFDLElBQUksQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDL0QsSUFBSSxDQUFDLFNBQVMsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDO1FBQ2hDLGFBQWEsQ0FBQyxxQkFBcUIsQ0FBQyxJQUFJLENBQUMsU0FBUyxFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBQ2pFLElBQUksQ0FBQyxxQkFBcUIsR0FBRyxjQUFjLENBQ3ZDLElBQUksQ0FBQyxxQkFBcUIsSUFBSSxJQUFJLENBQUMsOEJBQThCLENBQUMsQ0FBQztRQUN2RSxJQUFJLENBQUMscUJBQXFCLEdBQUcsY0FBYyxDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxDQUFDO1FBQ3hFLElBQUksQ0FBQyxtQkFBbUIsR0FBRyxjQUFjLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDLENBQUM7UUFDcEUsSUFBSSxDQUFDLG9CQUFvQixHQUFHLGFBQWEsQ0FBQyxJQUFJLENBQUMsb0JBQW9CLENBQUMsQ0FBQztRQUNyRSxJQUFJLENBQUMsUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLENBQUM7UUFDOUIsSUFBSSxDQUFDLGVBQWUsR0FBRyxJQUFJLENBQUMsUUFBUSxDQUFDO1FBQ3JDLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztJQUN0QyxDQUFDO0lBRU0sS0FBSyxDQUFDLFVBQXlCO1FBQ3BDLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxDQUFDLFNBQVMsQ0FDNUIsWUFBWSxFQUFFLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLEVBQUUsSUFBSSxDQUFDLEtBQUssRUFDekQsSUFBSSxDQUFDLHFCQUFxQixFQUFFLElBQUksQ0FBQyxxQkFBcUIsRUFBRSxJQUFJLEVBQzVELElBQUksQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO1FBQy9CLElBQUksQ0FBQyxLQUFLLEdBQUcsSUFBSSxDQUFDO0lBQ3BCLENBQUM7SUFFRCwwRUFBMEU7SUFDMUUsbUNBQW1DO0lBQ3pCLDRCQUE0QixDQUFDLFVBQWlCLElBQUcsQ0FBQztJQUU1RCxXQUFXLENBQUMsTUFBdUIsRUFBRSxJQUFzQjtRQUN6RCxPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRTtnQkFDbEIsT0FBTyxJQUFJLENBQUM7YUFDYjtpQkFBTTtnQkFDTCxNQUFNLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7Z0JBQ3JDLE9BQU8sUUFBUSxDQUFDLE1BQU0sRUFBRSxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQzthQUM1QztRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQztJQUVELGtCQUFrQixDQUFDLFVBQXlCO1FBQzFDLFVBQVUsR0FBRyxrQkFBa0IsQ0FBQyxVQUFVLENBQUMsQ0FBQztRQUM1QyxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksSUFBSSxFQUFFO1lBQzVCLE9BQU8sQ0FBQyxHQUFHLFVBQVUsRUFBRSxJQUFJLENBQUMsU0FBUyxDQUFDLENBQUM7U0FDeEM7UUFDRCx3REFBd0Q7UUFDeEQsTUFBTSxNQUFNLEdBQWEsYUFBYSxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7UUFDaEUsSUFBSSxNQUFNLENBQUMsTUFBTSxLQUFLLFVBQVUsQ0FBQyxNQUFNLEdBQUcsQ0FBQyxFQUFFO1lBQzNDLE1BQU0sSUFBSSxVQUFVLENBQ2hCLG9CQUFvQixJQUFJLENBQUMsV0FBVyxpQkFBaUI7Z0JBQ3JELHlCQUF5QixVQUFVLEVBQUUsQ0FBQyxDQUFDO1NBQzVDO2FBQU07WUFDTCxJQUFJLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDVixLQUFLLElBQUksQ0FBQyxHQUFHLENBQUMsRUFBRSxDQUFDLEdBQUcsTUFBTSxDQUFDLE1BQU0sRUFBRSxFQUFFLENBQUMsRUFBRTtnQkFDdEMsTUFBTSxFQUFFLEdBQUcsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDO2dCQUNyQixNQUFNLEVBQUUsR0FBRyxVQUFVLENBQUMsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUFDO2dCQUM3QixJQUFJLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxJQUFJLElBQUksQ0FBQyxJQUFJLENBQUMsRUFBRSxLQUFLLEVBQUUsQ0FBQyxFQUFFO29CQUMvQyxNQUFNLElBQUksVUFBVSxDQUNoQixvQkFBb0IsSUFBSSxDQUFDLFdBQVcsaUJBQWlCO3dCQUNyRCx5QkFBeUIsVUFBVSxFQUFFLENBQUMsQ0FBQztpQkFDNUM7cUJBQU0sSUFBSSxFQUFFLElBQUksSUFBSSxFQUFFO29CQUNyQixNQUFNLENBQUMsQ0FBQyxDQUFDLEdBQUcsRUFBRSxDQUFDO2lCQUNoQjtnQkFDRCxDQUFDLEVBQUUsQ0FBQzthQUNMO1NBQ0Y7UUFDRCxPQUFPLENBQUMsVUFBVSxDQUFDLENBQUMsQ0FBQyxFQUFFLEdBQUcsTUFBTSxFQUFFLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQztJQUNwRCxDQUFDO0lBRUQsSUFBSSxDQUFDLE1BQXVCLEVBQUUsTUFBYztRQUMxQyxPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDZixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztZQUNwQywrQ0FBK0M7WUFDL0MsSUFBSSxLQUFLLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDeEMsSUFBSSxLQUFLLENBQUMsS0FBSyxLQUFLLE9BQU8sRUFBRTtnQkFDM0IsS0FBSyxHQUFHLENBQUMsQ0FBQyxJQUFJLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO2FBQ2hDO1lBQ0QsTUFBTSxNQUFNLEdBQ1IsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksRUFBRSxFQUFFLE9BQU8sQ0FBQyxLQUFLLEVBQUUsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ25FLE9BQU8sT0FBTyxDQUNWLE1BQU0sRUFBRSxrQkFBa0IsQ0FBQyxJQUFJLENBQUMsa0JBQWtCLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUN4RSxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUM7SUFFRCxTQUFTO1FBQ1AsTUFBTSxNQUFNLEdBQUc7WUFDYixRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsU0FBUyxFQUFFLElBQUksQ0FBQyxTQUFTO1lBQ3pCLHFCQUFxQixFQUFFLG9CQUFvQixDQUFDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQztZQUN2RSxxQkFBcUIsRUFBRSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMscUJBQXFCLENBQUM7WUFDdkUsbUJBQW1CLEVBQUUsb0JBQW9CLENBQUMsSUFBSSxDQUFDLG1CQUFtQixDQUFDO1lBQ25FLG9CQUFvQixFQUFFLG1CQUFtQixDQUFDLElBQUksQ0FBQyxvQkFBb0IsQ0FBQztZQUNwRSxRQUFRLEVBQUUsSUFBSSxDQUFDLFFBQVE7WUFDdkIsV0FBVyxFQUFFLElBQUksQ0FBQyxXQUFXO1NBQzlCLENBQUM7UUFDRixNQUFNLFVBQVUsR0FBRyxLQUFLLENBQUMsU0FBUyxFQUFFLENBQUM7UUFDckMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEVBQUUsVUFBVSxDQUFDLENBQUM7UUFDbEMsT0FBTyxNQUFNLENBQUM7SUFDaEIsQ0FBQzs7QUFwSUQsa0JBQWtCO0FBQ1gsbUJBQVMsR0FBRyxXQUFXLENBQUM7QUFxSWpDLGFBQWEsQ0FBQyxhQUFhLENBQUMsU0FBUyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOCBHb29nbGUgTExDXG4gKlxuICogVXNlIG9mIHRoaXMgc291cmNlIGNvZGUgaXMgZ292ZXJuZWQgYnkgYW4gTUlULXN0eWxlXG4gKiBsaWNlbnNlIHRoYXQgY2FuIGJlIGZvdW5kIGluIHRoZSBMSUNFTlNFIGZpbGUgb3IgYXRcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxuICogPT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT1cbiAqL1xuXG4vKipcbiAqIFRlbnNvckZsb3cuanMgTGF5ZXJzOiBFbWJlZGRpbmcgTGF5ZXIuXG4gKlxuICogT3JpZ2luYWwgc291cmNlOiBrZXJhcy9jb25zdHJhaW50cy5weVxuICovXG5pbXBvcnQge25vdEVxdWFsLCByZXNoYXBlLCBzZXJpYWxpemF0aW9uLCBUZW5zb3IsIHRpZHksIHplcm9zTGlrZX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0ICogYXMgSyBmcm9tICcuLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge0NvbnN0cmFpbnQsIENvbnN0cmFpbnRJZGVudGlmaWVyLCBnZXRDb25zdHJhaW50LCBzZXJpYWxpemVDb25zdHJhaW50fSBmcm9tICcuLi9jb25zdHJhaW50cyc7XG5pbXBvcnQge0xheWVyLCBMYXllckFyZ3N9IGZyb20gJy4uL2VuZ2luZS90b3BvbG9neSc7XG5pbXBvcnQge1ZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge2dldEluaXRpYWxpemVyLCBJbml0aWFsaXplciwgSW5pdGlhbGl6ZXJJZGVudGlmaWVyLCBzZXJpYWxpemVJbml0aWFsaXplcn0gZnJvbSAnLi4vaW5pdGlhbGl6ZXJzJztcbmltcG9ydCB7U2hhcGV9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuaW1wb3J0IHtnZXRSZWd1bGFyaXplciwgUmVndWxhcml6ZXIsIFJlZ3VsYXJpemVySWRlbnRpZmllciwgc2VyaWFsaXplUmVndWxhcml6ZXJ9IGZyb20gJy4uL3JlZ3VsYXJpemVycyc7XG5pbXBvcnQge0t3YXJnc30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0ICogYXMgZ2VuZXJpY191dGlscyBmcm9tICcuLi91dGlscy9nZW5lcmljX3V0aWxzJztcbmltcG9ydCB7Z2V0RXhhY3RseU9uZVNoYXBlLCBnZXRFeGFjdGx5T25lVGVuc29yfSBmcm9tICcuLi91dGlscy90eXBlc191dGlscyc7XG5pbXBvcnQge0xheWVyVmFyaWFibGV9IGZyb20gJy4uL3ZhcmlhYmxlcyc7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBFbWJlZGRpbmdMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogSW50ZWdlciA+IDAuIFNpemUgb2YgdGhlIHZvY2FidWxhcnksIGkuZS4gbWF4aW11bSBpbnRlZ2VyIGluZGV4ICsgMS5cbiAgICovXG4gIGlucHV0RGltOiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbnRlZ2VyID49IDAuIERpbWVuc2lvbiBvZiB0aGUgZGVuc2UgZW1iZWRkaW5nLlxuICAgKi9cbiAgb3V0cHV0RGltOiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBmb3IgdGhlIGBlbWJlZGRpbmdzYCBtYXRyaXguXG4gICAqL1xuICBlbWJlZGRpbmdzSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXJ8SW5pdGlhbGl6ZXI7XG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmdW5jdGlvbiBhcHBsaWVkIHRvIHRoZSBgZW1iZWRkaW5nc2AgbWF0cml4LlxuICAgKi9cbiAgZW1iZWRkaW5nc1JlZ3VsYXJpemVyPzogUmVndWxhcml6ZXJJZGVudGlmaWVyfFJlZ3VsYXJpemVyO1xuICAvKipcbiAgICogUmVndWxhcml6ZXIgZnVuY3Rpb24gYXBwbGllZCB0byB0aGUgYWN0aXZhdGlvbi5cbiAgICovXG4gIGFjdGl2aXR5UmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXJ8UmVndWxhcml6ZXI7XG4gIC8qKlxuICAgKiBDb25zdHJhaW50IGZ1bmN0aW9uIGFwcGxpZWQgdG8gdGhlIGBlbWJlZGRpbmdzYCBtYXRyaXguXG4gICAqL1xuICBlbWJlZGRpbmdzQ29uc3RyYWludD86IENvbnN0cmFpbnRJZGVudGlmaWVyfENvbnN0cmFpbnQ7XG4gIC8qKlxuICAgKiBXaGV0aGVyIHRoZSBpbnB1dCB2YWx1ZSAwIGlzIGEgc3BlY2lhbCBcInBhZGRpbmdcIiB2YWx1ZSB0aGF0IHNob3VsZCBiZVxuICAgKiBtYXNrZWQgb3V0LiBUaGlzIGlzIHVzZWZ1bCB3aGVuIHVzaW5nIHJlY3VycmVudCBsYXllcnMgd2hpY2ggbWF5IHRha2VcbiAgICogdmFyaWFibGUgbGVuZ3RoIGlucHV0LlxuICAgKlxuICAgKiBJZiB0aGlzIGlzIGBUcnVlYCB0aGVuIGFsbCBzdWJzZXF1ZW50IGxheWVycyBpbiB0aGUgbW9kZWwgbmVlZCB0byBzdXBwb3J0XG4gICAqIG1hc2tpbmcgb3IgYW4gZXhjZXB0aW9uIHdpbGwgYmUgcmFpc2VkLiBJZiBtYXNrWmVybyBpcyBzZXQgdG8gYFRydWVgLCBhcyBhXG4gICAqIGNvbnNlcXVlbmNlLCBpbmRleCAwIGNhbm5vdCBiZSB1c2VkIGluIHRoZSB2b2NhYnVsYXJ5IChpbnB1dERpbSBzaG91bGRcbiAgICogZXF1YWwgc2l6ZSBvZiB2b2NhYnVsYXJ5ICsgMSkuXG4gICAqL1xuICBtYXNrWmVybz86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBMZW5ndGggb2YgaW5wdXQgc2VxdWVuY2VzLCB3aGVuIGl0IGlzIGNvbnN0YW50LlxuICAgKlxuICAgKiBUaGlzIGFyZ3VtZW50IGlzIHJlcXVpcmVkIGlmIHlvdSBhcmUgZ29pbmcgdG8gY29ubmVjdCBgZmxhdHRlbmAgdGhlblxuICAgKiBgZGVuc2VgIGxheWVycyB1cHN0cmVhbSAod2l0aG91dCBpdCwgdGhlIHNoYXBlIG9mIHRoZSBkZW5zZSBvdXRwdXRzIGNhbm5vdFxuICAgKiBiZSBjb21wdXRlZCkuXG4gICAqL1xuICBpbnB1dExlbmd0aD86IG51bWJlcnxudW1iZXJbXTtcbn1cblxuZXhwb3J0IGNsYXNzIEVtYmVkZGluZyBleHRlbmRzIExheWVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnRW1iZWRkaW5nJztcbiAgcHJpdmF0ZSBpbnB1dERpbTogbnVtYmVyO1xuICBwcml2YXRlIG91dHB1dERpbTogbnVtYmVyO1xuICBwcml2YXRlIGVtYmVkZGluZ3NJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG4gIHByaXZhdGUgbWFza1plcm86IGJvb2xlYW47XG4gIHByaXZhdGUgaW5wdXRMZW5ndGg6IG51bWJlcnxudW1iZXJbXTtcblxuICBwcml2YXRlIGVtYmVkZGluZ3M6IExheWVyVmFyaWFibGUgPSBudWxsO1xuXG4gIHJlYWRvbmx5IERFRkFVTFRfRU1CRURESU5HU19JTklUSUFMSVpFUjogSW5pdGlhbGl6ZXJJZGVudGlmaWVyID1cbiAgICAgICdyYW5kb21Vbmlmb3JtJztcbiAgcHJpdmF0ZSByZWFkb25seSBlbWJlZGRpbmdzUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcjtcbiAgcHJpdmF0ZSByZWFkb25seSBlbWJlZGRpbmdzQ29uc3RyYWludD86IENvbnN0cmFpbnQ7XG5cbiAgY29uc3RydWN0b3IoYXJnczogRW1iZWRkaW5nTGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gICAgaWYgKGFyZ3MuYmF0Y2hJbnB1dFNoYXBlID09IG51bGwgJiYgYXJncy5pbnB1dFNoYXBlID09IG51bGwpIHtcbiAgICAgIC8vIFBvcnRpbmcgTm90ZTogVGhpcyBsb2dpYyBpcyBjb3BpZWQgZnJvbSBMYXllcidzIGNvbnN0cnVjdG9yLCBzaW5jZSB3ZVxuICAgICAgLy8gY2FuJ3QgZG8gZXhhY3RseSB3aGF0IHRoZSBQeXRob24gY29uc3RydWN0b3IgZG9lcyBmb3IgRW1iZWRkaW5nKCkuXG4gICAgICAvLyBTcGVjaWZpY2FsbHksIHRoZSBzdXBlciBjb25zdHJ1Y3RvciBjYW4gbm90IGJlIGNhbGxlZCBhZnRlciB0aGVcbiAgICAgIC8vIG11dGF0aW9uIG9mIHRoZSBgY29uZmlnYCBhcmd1bWVudC5cbiAgICAgIGxldCBiYXRjaFNpemU6IG51bWJlciA9IG51bGw7XG4gICAgICBpZiAoYXJncy5iYXRjaFNpemUgIT0gbnVsbCkge1xuICAgICAgICBiYXRjaFNpemUgPSBhcmdzLmJhdGNoU2l6ZTtcbiAgICAgIH1cbiAgICAgIGlmIChhcmdzLmlucHV0TGVuZ3RoID09IG51bGwpIHtcbiAgICAgICAgLy8gRml4IHN1cGVyLWNvbnN0cnVjdG9yIHRvIHdoYXQgaXQgd291bGQgaGF2ZSBkb25lIGlmXG4gICAgICAgIC8vICdjb25maWcuaW5wdXRTaGFwZScgd2VyZSAoTm9uZSwgKVxuICAgICAgICB0aGlzLmJhdGNoSW5wdXRTaGFwZSA9IFtiYXRjaFNpemUsIG51bGxdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRml4IHN1cGVyLWNvbnN0cnVjdG9yIHRvIHdoYXQgaXQgd291bGQgaGF2ZSBkb25lIGlmXG4gICAgICAgIC8vICdjb25maWcuaW5wdXRTaGFwZScgd2VyZSAoY29uZmlnLmlucHV0TGVuZ3RoLCApXG4gICAgICAgIHRoaXMuYmF0Y2hJbnB1dFNoYXBlID1cbiAgICAgICAgICAgIFtiYXRjaFNpemVdLmNvbmNhdChnZW5lcmljX3V0aWxzLnRvTGlzdChhcmdzLmlucHV0TGVuZ3RoKSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuaW5wdXREaW0gPSBhcmdzLmlucHV0RGltO1xuICAgIGdlbmVyaWNfdXRpbHMuYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKHRoaXMuaW5wdXREaW0sICdpbnB1dERpbScpO1xuICAgIHRoaXMub3V0cHV0RGltID0gYXJncy5vdXRwdXREaW07XG4gICAgZ2VuZXJpY191dGlscy5hc3NlcnRQb3NpdGl2ZUludGVnZXIodGhpcy5vdXRwdXREaW0sICdvdXRwdXREaW0nKTtcbiAgICB0aGlzLmVtYmVkZGluZ3NJbml0aWFsaXplciA9IGdldEluaXRpYWxpemVyKFxuICAgICAgICBhcmdzLmVtYmVkZGluZ3NJbml0aWFsaXplciB8fCB0aGlzLkRFRkFVTFRfRU1CRURESU5HU19JTklUSUFMSVpFUik7XG4gICAgdGhpcy5lbWJlZGRpbmdzUmVndWxhcml6ZXIgPSBnZXRSZWd1bGFyaXplcihhcmdzLmVtYmVkZGluZ3NSZWd1bGFyaXplcik7XG4gICAgdGhpcy5hY3Rpdml0eVJlZ3VsYXJpemVyID0gZ2V0UmVndWxhcml6ZXIoYXJncy5hY3Rpdml0eVJlZ3VsYXJpemVyKTtcbiAgICB0aGlzLmVtYmVkZGluZ3NDb25zdHJhaW50ID0gZ2V0Q29uc3RyYWludChhcmdzLmVtYmVkZGluZ3NDb25zdHJhaW50KTtcbiAgICB0aGlzLm1hc2taZXJvID0gYXJncy5tYXNrWmVybztcbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IGFyZ3MubWFza1plcm87XG4gICAgdGhpcy5pbnB1dExlbmd0aCA9IGFyZ3MuaW5wdXRMZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIHRoaXMuZW1iZWRkaW5ncyA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAnZW1iZWRkaW5ncycsIFt0aGlzLmlucHV0RGltLCB0aGlzLm91dHB1dERpbV0sIHRoaXMuZHR5cGUsXG4gICAgICAgIHRoaXMuZW1iZWRkaW5nc0luaXRpYWxpemVyLCB0aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplciwgdHJ1ZSxcbiAgICAgICAgdGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCk7XG4gICAgdGhpcy5idWlsdCA9IHRydWU7XG4gIH1cblxuICAvLyBPdmVycmlkZSB3YXJuT25JbmNvbXBhdGlibGVJbnB1dFNoYXBlIGJlY2F1c2UgYW4gZW1iZWRkaW5nIGxheWVyIGFsbG93c1xuICAvLyB0aGUgaW5wdXQgdG8gaGF2ZSB2YXJ5aW5nIHJhbmtzLlxuICBwcm90ZWN0ZWQgd2Fybk9uSW5jb21wYXRpYmxlSW5wdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZSkge31cblxuICBjb21wdXRlTWFzayhpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwgbWFzaz86IFRlbnNvcnxUZW5zb3JbXSk6IFRlbnNvciB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgaWYgKCF0aGlzLm1hc2taZXJvKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5wdXRzID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgICByZXR1cm4gbm90RXF1YWwoaW5wdXRzLCB6ZXJvc0xpa2UoaW5wdXRzKSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgaWYgKHRoaXMuaW5wdXRMZW5ndGggPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIFsuLi5pbnB1dFNoYXBlLCB0aGlzLm91dHB1dERpbV07XG4gICAgfVxuICAgIC8vIGlucHV0TGVuZ3RoIGNhbiBiZSBhbiBhcnJheSBpZiBpbnB1dCBpcyAzRCBvciBoaWdoZXIuXG4gICAgY29uc3QgaW5MZW5zOiBudW1iZXJbXSA9IGdlbmVyaWNfdXRpbHMudG9MaXN0KHRoaXMuaW5wdXRMZW5ndGgpO1xuICAgIGlmIChpbkxlbnMubGVuZ3RoICE9PSBpbnB1dFNoYXBlLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBcImlucHV0TGVuZ3RoXCIgaXMgJHt0aGlzLmlucHV0TGVuZ3RofSwgYnV0IHJlY2VpdmVkIGAgK1xuICAgICAgICAgIGBpbnB1dCBzaGFwZSBoYXMgc2hhcGUgJHtpbnB1dFNoYXBlfWApO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaSA9IDA7XG4gICAgICBmb3IgKGxldCBrID0gMDsgayA8IGluTGVucy5sZW5ndGg7ICsraykge1xuICAgICAgICBjb25zdCBzMSA9IGluTGVuc1trXTtcbiAgICAgICAgY29uc3QgczIgPSBpbnB1dFNoYXBlW2sgKyAxXTtcbiAgICAgICAgaWYgKChzMSAhPSBudWxsKSAmJiAoczIgIT0gbnVsbCkgJiYgKHMxICE9PSBzMikpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICAgYFwiaW5wdXRMZW5ndGhcIiBpcyAke3RoaXMuaW5wdXRMZW5ndGh9LCBidXQgcmVjZWl2ZWQgYCArXG4gICAgICAgICAgICAgIGBpbnB1dCBzaGFwZSBoYXMgc2hhcGUgJHtpbnB1dFNoYXBlfWApO1xuICAgICAgICB9IGVsc2UgaWYgKHMxID09IG51bGwpIHtcbiAgICAgICAgICBpbkxlbnNbaV0gPSBzMjtcbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgLi4uaW5MZW5zLCB0aGlzLm91dHB1dERpbV07XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgdGhpcy5pbnZva2VDYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgICAvLyBFbWJlZGRpbmcgbGF5ZXIgYWNjZXB0cyBvbmx5IGEgc2luZ2xlIGlucHV0LlxuICAgICAgbGV0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgaWYgKGlucHV0LmR0eXBlICE9PSAnaW50MzInKSB7XG4gICAgICAgIGlucHV0ID0gSy5jYXN0KGlucHV0LCAnaW50MzInKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG91dHB1dCA9XG4gICAgICAgICAgSy5nYXRoZXIodGhpcy5lbWJlZGRpbmdzLnJlYWQoKSwgcmVzaGFwZShpbnB1dCwgW2lucHV0LnNpemVdKSk7XG4gICAgICByZXR1cm4gcmVzaGFwZShcbiAgICAgICAgICBvdXRwdXQsIGdldEV4YWN0bHlPbmVTaGFwZSh0aGlzLmNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dC5zaGFwZSkpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIGlucHV0RGltOiB0aGlzLmlucHV0RGltLFxuICAgICAgb3V0cHV0RGltOiB0aGlzLm91dHB1dERpbSxcbiAgICAgIGVtYmVkZGluZ3NJbml0aWFsaXplcjogc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5lbWJlZGRpbmdzSW5pdGlhbGl6ZXIpLFxuICAgICAgZW1iZWRkaW5nc1JlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmVtYmVkZGluZ3NSZWd1bGFyaXplciksXG4gICAgICBhY3Rpdml0eVJlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmFjdGl2aXR5UmVndWxhcml6ZXIpLFxuICAgICAgZW1iZWRkaW5nc0NvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5lbWJlZGRpbmdzQ29uc3RyYWludCksXG4gICAgICBtYXNrWmVybzogdGhpcy5tYXNrWmVybyxcbiAgICAgIGlucHV0TGVuZ3RoOiB0aGlzLmlucHV0TGVuZ3RoXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhFbWJlZGRpbmcpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Merge Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy, util } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { l2Normalize } from '../losses';\nimport * as generic_utils from '../utils/generic_utils';\nimport * as mathUtils from '../utils/math_utils';\nimport { getExactlyOneShape } from '../utils/types_utils';\n/**\n * Generic Merge layer for element-wise merge functions.\n *\n * Used to implement `Sum`, `Average`, `Concatenate`, etc.\n */\nexport class Merge extends Layer {\n    constructor(args) {\n        super(args || {});\n        this.supportsMasking = true;\n    }\n    /**\n     * Logic for merging multiple tensors, to be overridden by subclasses.\n     * @param inputs\n     */\n    mergeFunction(inputs) {\n        throw new NotImplementedError();\n    }\n    /**\n     * Computes the shape of the result of an elementwise operation.\n     *\n     * @param shape1: Shape of the first tensor.\n     * @param shape2: Shape of the second tensor.\n     * @returns Expected output shape when an elementwise operation is carried\n     *   out on 2 tensors with shapes `shape1` and `shape2`.\n     * @throws ValueError: If `shape1` and `shape2` are not compatible for\n     *   element-wise operations.\n     */\n    computeElementwiseOpOutputShape(shape1, shape2) {\n        if (shape1 == null || shape2 == null) {\n            return null;\n        }\n        else if (shape1.length < shape2.length) {\n            return this.computeElementwiseOpOutputShape(shape2, shape1);\n        }\n        else if (shape2.length === 0) {\n            return shape1;\n        }\n        const outputShape = shape1.slice(0, shape1.length - shape2.length);\n        for (let k = 0; k < shape2.length; ++k) {\n            const i = shape1[shape1.length - shape2.length + k];\n            const j = shape2[k];\n            if (i == null || j == null || i < 0 || j < 0) {\n                outputShape.push(null);\n            }\n            else if (i === 1) {\n                outputShape.push(j);\n            }\n            else if (j === 1) {\n                outputShape.push(i);\n            }\n            else {\n                if (i !== j) {\n                    throw new ValueError('Operands could not be broadcast together with shapes ' +\n                        JSON.stringify(shape1) + ' ' + JSON.stringify(shape2));\n                }\n                outputShape.push(i);\n            }\n        }\n        return outputShape;\n    }\n    build(inputShape) {\n        // Used purely for shape validation.\n        if (Array.isArray(inputShape) && !Array.isArray(inputShape[0])) {\n            // Make sure that inputShape is an Array of shape.\n            inputShape = [getExactlyOneShape(inputShape)];\n        }\n        inputShape = inputShape;\n        if (inputShape.length < 2) {\n            throw new ValueError('A merge layer should be called on an Array of at least 2 inputs.' +\n                ` Got ${inputShape.length} input(s).`);\n        }\n        // Make sure that there is at most one unique batch size among the input\n        // shapes.\n        let batchSizes = [];\n        for (const shape of inputShape) {\n            if (shape != null && shape[0] !== null) {\n                batchSizes.push(shape[0]);\n            }\n        }\n        batchSizes = generic_utils.unique(batchSizes);\n        if (batchSizes.length > 1) {\n            throw new ValueError(`Can not merge tensors with different batch sizes. ` +\n                `Got tensors with shapes: ${JSON.stringify(inputShape)}.`);\n        }\n        let outputShape = inputShape[0] == null ? null : inputShape[0].slice(1);\n        for (let i = 1; i < inputShape.length; ++i) {\n            const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n        }\n        // If the inputs have different ranks, we have to reshape them to make them\n        // broadcastable.\n        const allRanks = inputShape.map(shape => shape.length);\n        if (inputShape.indexOf(null) === -1 &&\n            generic_utils.unique(allRanks).length === 1) {\n            this.reshapeRequired = false;\n        }\n        else {\n            this.reshapeRequired = true;\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            inputs = inputs;\n            if (this.reshapeRequired) {\n                const reshapedInputs = [];\n                const inputDims = inputs.map(input => input.rank);\n                if (inputDims.indexOf(null) === -1) {\n                    // If ranks of all inputs are available, we simply expand each of them\n                    // at axis=1 until all of them have the same rank.\n                    const maxNDim = mathUtils.max(inputDims);\n                    for (let x of inputs) {\n                        const xNDim = x.rank;\n                        for (let k = 0; k < maxNDim - xNDim; ++k) {\n                            x = K.expandDims(x, 1);\n                        }\n                        reshapedInputs.push(x);\n                    }\n                    return this.mergeFunction(reshapedInputs);\n                }\n                else {\n                    // Transpose all inputs so that batch size is the last dimension.\n                    // [batchSize, dim1, dim2, ...] -> [dim1, dim2, ..., batchSize]\n                    let transposed = false;\n                    for (const x of inputs) {\n                        const xNDim = x.rank;\n                        if (xNDim == null) {\n                            const xShape = x.shape;\n                            const batchSize = xShape[0];\n                            const newShape = xShape.slice(1).concat([batchSize]);\n                            let xTransposed = tfc.reshape(x, [batchSize].concat(mathUtils.arrayProd(xShape.slice(1))));\n                            xTransposed = tfc.transpose(xTransposed, [1, 0]);\n                            xTransposed = tfc.reshape(xTransposed, newShape);\n                            reshapedInputs.push(xTransposed);\n                            transposed = true;\n                        }\n                        else if (xNDim > 1) {\n                            const dims = mathUtils.range(1, xNDim).concat([0]);\n                            reshapedInputs.push(tfc.transpose(x, dims));\n                            transposed = true;\n                        }\n                        else {\n                            // We don't transpose inputs if they are 1D vectors or scalars.\n                            reshapedInputs.push(x);\n                        }\n                    }\n                    let y = this.mergeFunction(reshapedInputs);\n                    const yNDim = y.rank;\n                    if (transposed) {\n                        // If inputs have been transposed, we have to transpose the output\n                        // too.\n                        if (yNDim == null) {\n                            const yShape = y.shape;\n                            const yNDim = yShape.length;\n                            const batchSize = yShape[yNDim - 1];\n                            const newShape = [batchSize].concat(yShape.slice(0, yShape.length - 1));\n                            y = tfc.reshape(tfc.transpose(tfc.reshape(y, [-1, batchSize]), [1, 0]), newShape);\n                        }\n                        else if (yNDim > 1) {\n                            const dims = [yNDim - 1].concat(mathUtils.range(0, yNDim - 1));\n                            y = tfc.transpose(y, dims);\n                        }\n                    }\n                    return y;\n                }\n            }\n            else {\n                return this.mergeFunction(inputs);\n            }\n        });\n    }\n    computeOutputShape(inputShape) {\n        inputShape = inputShape;\n        let outputShape;\n        if (inputShape[0] == null) {\n            outputShape = null;\n        }\n        else {\n            outputShape = inputShape[0].slice(1);\n        }\n        for (let i = 1; i < inputShape.length; ++i) {\n            const shape = inputShape[i] == null ? null : inputShape[i].slice(1);\n            outputShape = this.computeElementwiseOpOutputShape(outputShape, shape);\n        }\n        let batchSizes = [];\n        for (const shape of inputShape) {\n            if (shape != null && shape[0] !== null) {\n                batchSizes.push(shape[0]);\n            }\n        }\n        batchSizes = generic_utils.unique(batchSizes);\n        if (batchSizes.length === 1) {\n            outputShape = batchSizes.concat(outputShape);\n        }\n        else {\n            outputShape = [null].concat(outputShape);\n        }\n        return outputShape;\n    }\n    computeMask(inputs, mask) {\n        return tfc.tidy(() => {\n            if (mask == null) {\n                return null;\n            }\n            if (!Array.isArray(mask)) {\n                throw new ValueError('`mask` should be an Array');\n            }\n            if (!Array.isArray(inputs)) {\n                throw new ValueError('`inputs` should be an Array');\n            }\n            if (mask.length !== inputs.length) {\n                throw new ValueError(`The Array 'inputs' and 'mask' are expected to have the same ` +\n                    `length, but have different lengths ` +\n                    `(${inputs.length} vs ${mask.length})`);\n            }\n            if (mask.every(m => m == null)) {\n                return null;\n            }\n            mask = mask.map(m => m == null ? m : tfc.expandDims(m, 0));\n            let output = mask[0];\n            for (let i = 1; i < mask.length - 1; ++i) {\n                output = tfc.logicalAnd(output, mask[i]);\n            }\n            return output;\n        });\n    }\n}\nexport class Add extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0].clone();\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.add(output, inputs[i]);\n            }\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nAdd.className = 'Add';\nserialization.registerClass(Add);\n/**\n * Calculate the element-wise sum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Add` layer, by using no input argument\n *    or a single configuration argument. The resultant `Add` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const addLayer = tf.layers.add();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = addLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.add([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.add([input1, input2]).print();\n * // Gives [[11, 22], [33, 44]].\n *\n */\nexport function add(config) {\n    if (Array.isArray(config)) {\n        const layer = new Add({});\n        return layer.apply(config);\n    }\n    else {\n        return new Add(config);\n    }\n}\nexport class Multiply extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0].clone();\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.mul(output, inputs[i]);\n            }\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nMultiply.className = 'Multiply';\nserialization.registerClass(Multiply);\n/**\n * Calculate the element-wise product of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Multiply` layer, by using no input argument\n *    or a single configuration argument. The resultant `Multiply` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const multiplyLayer = tf.layers.multiply();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = multiplyLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.multiply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.multiply([input1, input2]).print();\n * // Gives [[10, 40], [90, 160]].\n *\n */\nexport function multiply(config) {\n    if (Array.isArray(config)) {\n        const layer = new Multiply({});\n        return layer.apply(config);\n    }\n    else {\n        return new Multiply(config);\n    }\n}\nexport class Average extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0].clone();\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.add(output, inputs[i]);\n            }\n            return tfc.mul(1 / inputs.length, output);\n        });\n    }\n}\n/** @nocollapse */\nAverage.className = 'Average';\nserialization.registerClass(Average);\n/**\n * Calculate the element-wise arithmetic mean of inputs, which all have the same\n * shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Average` layer, by using no input argument\n *    or a single configuration argument. The resultant `Average` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const averageLayer = tf.layers.average();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = averageLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.average([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 2, 3, 4], [2, 2]);\n * const input2 = tf.tensor2d([10, 20, 30, 40], [2, 2]);\n * tf.layers.average([input1, input2]).print();\n * // Gives [[5.5, 11], [16.5, 22]].\n *\n */\nexport function average(config) {\n    if (Array.isArray(config)) {\n        const layer = new Average({});\n        return layer.apply(config);\n    }\n    else {\n        return new Average(config);\n    }\n}\nexport class Maximum extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0];\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.maximum(output, inputs[i]);\n            }\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nMaximum.className = 'Maximum';\nserialization.registerClass(Maximum);\n/**\n * Calculate the element-wise maximum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Maximum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Maximum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const maximumLayer = tf.layers.maximum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = maximumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.maximum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.maximum([input1, input2]).print();\n * // Gives [[10, 20], [30, 40]].\n *\n */\nexport function maximum(config) {\n    if (Array.isArray(config)) {\n        const layer = new Maximum({});\n        return layer.apply(config);\n    }\n    else {\n        return new Maximum(config);\n    }\n}\nexport class Minimum extends Merge {\n    constructor(args) {\n        super(args);\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            let output = inputs[0];\n            for (let i = 1; i < inputs.length; ++i) {\n                output = tfc.minimum(output, inputs[i]);\n            }\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nMinimum.className = 'Minimum';\nserialization.registerClass(Minimum);\n/**\n * Calculate the element-wise minimum of inputs, which all have the same shape.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Minimum` layer, by using no input argument\n *    or a single configuration argument. The resultant `Minimum` layer can then\n *    be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const minimumLayer = tf.layers.minimum();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = minimumLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 2]});\n * const input2 = tf.input({shape: [2, 2]});\n * const output = tf.layers.minimum([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([1, 20, 3, 40], [2, 2]);\n * const input2 = tf.tensor2d([10, 2, 30, 4], [2, 2]);\n * tf.layers.minimum([input1, input2]).print();\n * // Gives [[1, 2], [3, 4]].\n *\n */\nexport function minimum(config) {\n    if (Array.isArray(config)) {\n        const layer = new Minimum({});\n        return layer.apply(config);\n    }\n    else {\n        return new Minimum(config);\n    }\n}\nexport class Concatenate extends Merge {\n    constructor(args) {\n        super(args);\n        this.DEFAULT_AXIS = -1;\n        if (args == null) {\n            args = {};\n        }\n        this.axis = args.axis == null ? this.DEFAULT_AXIS : args.axis;\n        this.supportsMasking = true;\n        this.reshapeRequired = false;\n    }\n    build(inputShape) {\n        // Used purely for shape validation.]\n        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0])) ||\n            inputShape.length === 1) {\n            throw new ValueError('A `Concatenate` layer should be called on a list of at least 2 ' +\n                'inputs');\n        }\n        inputShape = inputShape;\n        let allNoneShape = true;\n        for (const shape of inputShape) {\n            if (shape != null) {\n                allNoneShape = false;\n                break;\n            }\n        }\n        if (allNoneShape) {\n            return;\n        }\n        const shapeSet = [];\n        for (let i = 0; i < inputShape.length; ++i) {\n            const shapeWithoutConcatAxis = inputShape[i].slice();\n            shapeWithoutConcatAxis.splice(this.axis, 1);\n            let exists = false;\n            for (const shape of shapeSet) {\n                if (util.arraysEqual(shape, shapeWithoutConcatAxis)) {\n                    exists = true;\n                    break;\n                }\n            }\n            if (!exists) {\n                shapeSet.push(shapeWithoutConcatAxis);\n            }\n        }\n        if (shapeSet.length > 1) {\n            throw new ValueError('A `Concatenate` layer requires inputs with matching shapes ' +\n                'except for the concat axis. Got input shapes: ' +\n                JSON.stringify(inputShape));\n        }\n    }\n    mergeFunction(inputs) {\n        return tidy(() => {\n            return K.concatenate(inputs, this.axis);\n        });\n    }\n    computeOutputShape(inputShape) {\n        if (!(Array.isArray(inputShape) && Array.isArray(inputShape[0]))) {\n            throw new ValueError('A `Concatenate` layer should be called on a list of inputs.');\n        }\n        const inputShapes = inputShape;\n        const outputShape = inputShapes[0].slice();\n        const axis = this.axis < 0 ? outputShape.length + this.axis : this.axis;\n        // Porting Note: the line above is because TypeScript doesn't support\n        //   negative indices.\n        for (const shape of inputShapes.slice(1)) {\n            if (outputShape[axis] == null || shape[axis] == null) {\n                outputShape[axis] = null;\n                break;\n            }\n            outputShape[axis] += shape[axis];\n        }\n        return outputShape;\n    }\n    computeMask(inputs, mask) {\n        if (mask == null) {\n            return null;\n        }\n        if (!Array.isArray(mask)) {\n            throw new ValueError('`mask` should be an array for Concatenate');\n        }\n        if (!Array.isArray(inputs)) {\n            throw new ValueError('`inputs` should be an array for Concatenate');\n        }\n        if (mask.length !== inputs.length) {\n            throw new ValueError(`Mismatch in the length of mask (${mask.length}) ` +\n                `and the legnth of inputs (${inputs.length})`);\n        }\n        return tfc.tidy(() => {\n            let allNullMasks = true;\n            mask.forEach(m => {\n                if (m != null) {\n                    allNullMasks = false;\n                    return;\n                }\n            });\n            if (allNullMasks) {\n                return null;\n            }\n            const outputMasks = [];\n            for (let i = 0; i < inputs.length; ++i) {\n                if (mask[i] == null) {\n                    // Input is unmasked. Append all 1's to masks.\n                    outputMasks.push(tfc.cast(tfc.onesLike(inputs[i]), 'bool'));\n                }\n                else if (mask[i].rank < inputs[i].rank) {\n                    // Mask is smaller than the input, expand it.\n                    outputMasks.push(tfc.expandDims(mask[i], -1));\n                }\n                else {\n                    outputMasks.push(mask[i]);\n                }\n            }\n            const concatenatedMasks = tfc.concat(outputMasks, this.axis);\n            return tfc.all(concatenatedMasks, -1, false);\n        });\n    }\n    getConfig() {\n        const config = {\n            'axis': this.axis,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nConcatenate.className = 'Concatenate';\nserialization.registerClass(Concatenate);\n/**\n * Concatenate an `Array` of inputs.\n *\n * This function can be invoked in three ways.\n *\n * 1. Construct an instance of `Concatenate` layer, by using no input argument\n *    or a single configuration argument. The resultant `Concatenate` layer can\n *    then be used on `tf.SymbolicTensor`s or `tf.Tensor`s. For example:\n *\n * ```js\n * const concatLayer = tf.layers.concatenate();\n *\n * // The layer can be applied to inputs.\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = concatLayer.apply([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 7], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 2. Invoke directly on an `Array` of `tf.SymbolicTensor`s. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.SymbolicTensor`. For example:\n *\n * ```js\n * const input1 = tf.input({shape: [2, 3]});\n * const input2 = tf.input({shape: [2, 4]});\n * const output = tf.layers.concatenate([input1, input2]);\n * console.log(output.shape);\n * // You get [null, 2, 2], with the first dimension as the undetermined batch\n * // dimension and the last dimension as the result of concatenating the\n * // last dimensions of the two inputs.\n * ```\n *\n * 3. Invoke directly on `tf.Tensor`s, i.e., concrete values. This constructs\n *    an `Layer` object internally and calls its `apply` method on the inputs,\n *    generating a new `tf.Tensor` as the result of the computation. For\n * example:\n *\n * ```js\n * const input1 = tf.tensor2d([[1, 2], [3, 4]], [2, 2]);\n * const input2 = tf.tensor2d([[10, 20], [30, 40]], [2, 2]);\n * tf.layers.concatenate([input1, input2]).print();\n * // Gives [[1, 2, 10, 20], [3, 4, 30, 40]].\n *\n */\nexport function concatenate(config) {\n    if (Array.isArray(config)) {\n        const layer = new Concatenate({});\n        return layer.apply(config);\n    }\n    else {\n        return new Concatenate(config);\n    }\n}\n/**\n * Interpretable potentially negative axis index.\n *\n * For example, given axis = -1, and dim = 3, this function will return 2.\n *\n * @param axis The axis index, may be a positive, zero or negative integer.\n * @param dim Total number of dimensions, a positive integer.\n * @returns A non-negative axis index equivalent to the input `axis`.\n */\nfunction interpretAxis(axis, dim) {\n    while (axis < 0) {\n        axis += dim;\n    }\n    return axis;\n}\nfunction batchDot(x, y, axes) {\n    if (x.shape.length > 3 || y.shape.length > 3) {\n        throw new NotImplementedError('batchDot is not implemented for tensors of 4D or higher rank yet');\n    }\n    tfc.util.assert(x.shape.length >= 2, () => `batchDot requires the rank of x to be >= 2, ` +\n        `but got ${x.shape.length}`);\n    tfc.util.assert(x.shape.length >= 2, () => `batchDot requires the rank of y to be >= 2, ` +\n        `but got ${y.shape.length}`);\n    if (typeof axes === 'number') {\n        axes = [axes, axes];\n    }\n    if (x.dtype === 'complex64' || y.dtype === 'complex64') {\n        throw new NotImplementedError('batchDot is not implemented for complex64-type Tensors yet.');\n    }\n    const xNDim = x.shape.length;\n    const yNDim = y.shape.length;\n    if (axes == null) {\n        // Behave like batchMatmul by default.\n        axes = [xNDim - 1, yNDim - 2];\n    }\n    const axesArray = axes;\n    return tfc.tidy(() => {\n        let diff;\n        if (xNDim > yNDim) {\n            diff = xNDim - yNDim;\n            const diffShape = [];\n            for (let i = 0; i < diff; ++i) {\n                diffShape.push(1);\n            }\n            y = tfc.reshape(y, y.shape.concat(diffShape));\n        }\n        else if (yNDim > xNDim) {\n            diff = yNDim - xNDim;\n            const diffShape = [];\n            for (let i = 0; i < diff; ++i) {\n                diffShape.push(1);\n            }\n            x = tfc.reshape(x, x.shape.concat(diffShape));\n        }\n        else {\n            diff = 0;\n        }\n        let out;\n        if (x.shape.length === 2 && y.shape.length === 2) {\n            if (axesArray[0] === axesArray[1]) {\n                out = tfc.sum(tfc.mul(x, y), axesArray[0]);\n            }\n            else {\n                out = tfc.sum(tfc.mul(tfc.transpose(x, [1, 0]), y), axesArray[1]);\n            }\n        }\n        else {\n            const adjX = axesArray[0] !== x.shape.length - 1;\n            const adjY = axesArray[1] === y.shape.length - 1;\n            out = tfc.matMul(x, y, adjX, adjY);\n        }\n        if (diff > 0) {\n            let idx;\n            if (xNDim > yNDim) {\n                idx = xNDim + yNDim - 3;\n            }\n            else {\n                idx = xNDim - 1;\n            }\n            const squeezeAxes = [];\n            for (let i = idx; i < idx + diff; ++i) {\n                squeezeAxes.push(i);\n            }\n            out = tfc.squeeze(out, squeezeAxes);\n        }\n        if (out.shape.length === 1) {\n            out = tfc.expandDims(out, 1);\n        }\n        return out;\n    });\n}\nexport class Dot extends Merge {\n    constructor(args) {\n        super(args);\n        this.axes = args.axes;\n        this.normalize = args.normalize == null ? false : args.normalize;\n        this.supportsMasking = true;\n        this.reshapeRequired = false;\n    }\n    build(inputShape) {\n        tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 &&\n            Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n        const shape1 = inputShape[0];\n        const shape2 = inputShape[1];\n        if (shape1.length > 3 || shape2.length > 3) {\n            throw new NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');\n        }\n        const axes = this.interpretAxes(shape1, shape2);\n        if (shape1[axes[0]] !== shape2[axes[1]]) {\n            throw new ValueError(`Dimension incompatibility: ` +\n                `${shape1[axes[0]]} !== ${shape2[axes[1]]}`);\n        }\n    }\n    mergeFunction(inputs) {\n        if (inputs.length !== 2) {\n            throw new ValueError('A `Dot` layer must be called on exactly 2 inputs, ' +\n                `but received ${inputs.length} input(s).`);\n        }\n        let x1 = inputs[0];\n        let x2 = inputs[1];\n        let axes;\n        if (!Array.isArray(this.axes)) {\n            axes = [\n                interpretAxis(this.axes, x1.shape.length),\n                interpretAxis(this.axes, x2.shape.length)\n            ];\n        }\n        else {\n            axes = this.axes.map((axis, i) => interpretAxis(axis, inputs[i].shape.length));\n        }\n        if (this.normalize) {\n            x1 = l2Normalize(x1, axes[0]);\n            x2 = l2Normalize(x2, axes[1]);\n        }\n        return batchDot(x1, x2, axes);\n    }\n    interpretAxes(shape1, shape2) {\n        let axes;\n        if (!Array.isArray(this.axes)) {\n            // `this.axes` is a single integer.\n            axes = [\n                interpretAxis(this.axes, shape1.length),\n                interpretAxis(this.axes, shape2.length)\n            ];\n        }\n        else {\n            // `this.axes` is an Array of integers.\n            axes = this.axes;\n        }\n        return axes;\n    }\n    computeOutputShape(inputShape) {\n        tfc.util.assert(Array.isArray(inputShape) && inputShape.length === 2 &&\n            Array.isArray(inputShape[0]) && Array.isArray(inputShape[1]), () => 'A `Dot` layer should be called on a list of exactly 2 inputs.');\n        const shape1 = inputShape[0].slice();\n        const shape2 = inputShape[1].slice();\n        if (shape1.length > 3 || shape2.length > 3) {\n            throw new NotImplementedError('Dot layer does not support tensors of 4D or higher rank yet.');\n        }\n        const axes = this.interpretAxes(shape1, shape2);\n        shape1.splice(axes[0], 1);\n        shape2.splice(axes[1], 1);\n        shape2.splice(0, 1);\n        const outputShape = shape1.concat(shape2);\n        if (outputShape.length === 1) {\n            outputShape.push(1);\n        }\n        return outputShape;\n    }\n    computeMask(inputs, mask) {\n        return null;\n    }\n    getConfig() {\n        const config = {\n            'axes': this.axes,\n            'normalize': this.normalize\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nDot.className = 'Dot';\nserialization.registerClass(Dot);\n// TODO(cais): Add functional interfaces for the merge layers.\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWVyZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvbGF5ZXJzL21lcmdlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxhQUFhLEVBQVUsSUFBSSxFQUFFLElBQUksRUFBQyxNQUFNLHVCQUF1QixDQUFDO0FBQ3hFLE9BQU8sS0FBSyxDQUFDLE1BQU0seUJBQXlCLENBQUM7QUFDN0MsT0FBTyxFQUFDLEtBQUssRUFBNEIsTUFBTSxvQkFBb0IsQ0FBQztBQUNwRSxPQUFPLEVBQUMsbUJBQW1CLEVBQUUsVUFBVSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBRTFELE9BQU8sRUFBQyxXQUFXLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFFdEMsT0FBTyxLQUFLLGFBQWEsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxPQUFPLEtBQUssU0FBUyxNQUFNLHFCQUFxQixDQUFDO0FBQ2pELE9BQU8sRUFBQyxrQkFBa0IsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRXhEOzs7O0dBSUc7QUFDSCxNQUFNLE9BQWdCLEtBQU0sU0FBUSxLQUFLO0lBR3ZDLFlBQVksSUFBZ0I7UUFDMUIsS0FBSyxDQUFDLElBQUksSUFBSSxFQUFFLENBQUMsQ0FBQztRQUNsQixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztJQUM5QixDQUFDO0lBRUQ7OztPQUdHO0lBQ08sYUFBYSxDQUFDLE1BQWdCO1FBQ3RDLE1BQU0sSUFBSSxtQkFBbUIsRUFBRSxDQUFDO0lBQ2xDLENBQUM7SUFFRDs7Ozs7Ozs7O09BU0c7SUFDSywrQkFBK0IsQ0FBQyxNQUFhLEVBQUUsTUFBYTtRQUNsRSxJQUFJLE1BQU0sSUFBSSxJQUFJLElBQUksTUFBTSxJQUFJLElBQUksRUFBRTtZQUNwQyxPQUFPLElB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QUFDLENBQUM7U0FDckU7UUFFRCxNQUFNLElBQUksR0FBRyxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRSxNQUFNLENBQUMsQ0FBQztRQUNoRCxNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMxQixNQUFNLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUMxQixNQUFNLENBQUMsTUFBTSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQztRQUNwQixNQUFNLFdBQVcsR0FBRyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQzFDLElBQUksV0FBVyxDQUFDLE1BQU0sS0FBSyxDQUFDLEVBQUU7WUFDNUIsV0FBVyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNyQjtRQUNELE9BQU8sV0FBVyxDQUFDO0lBQ3JCLENBQUM7SUFFRCxXQUFXLENBQUMsTUFBdUIsRUFBRSxJQUFzQjtRQUN6RCxPQUFPLElBQUksQ0FBQztJQUNkLENBQUM7SUFFRCxTQUFTO1FBQ1AsTUFBTSxNQUFNLEdBQTZCO1lBQ3ZDLE1BQU0sRUFBRSxJQUFJLENBQUMsSUFBSTtZQUNqQixXQUFXLEVBQUUsSUFBSSxDQUFDLFNBQVM7U0FDNUIsQ0FBQztRQUNGLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNsQyxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztBQS9HRCxrQkFBa0I7QUFDWCxhQUFTLEdBQUcsS0FBSyxDQUFDO0FBZ0gzQixhQUFhLENBQUMsYUFBYSxDQUFDLEdBQUcsQ0FBQyxDQUFDO0FBRWpDLDhEQUE4RCIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogVGVuc29yRmxvdy5qcyBMYXllcnM6IE1lcmdlIExheWVycy5cbiAqL1xuXG5pbXBvcnQgKiBhcyB0ZmMgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7c2VyaWFsaXphdGlvbiwgVGVuc29yLCB0aWR5LCB1dGlsfSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0ICogYXMgSyBmcm9tICcuLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge0xheWVyLCBMYXllckFyZ3MsIFN5bWJvbGljVGVuc29yfSBmcm9tICcuLi9lbmdpbmUvdG9wb2xvZ3knO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge2wyTm9ybWFsaXplfSBmcm9tICcuLi9sb3NzZXMnO1xuaW1wb3J0IHtLd2FyZ3N9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQgKiBhcyBtYXRoVXRpbHMgZnJvbSAnLi4vdXRpbHMvbWF0aF91dGlscyc7XG5pbXBvcnQge2dldEV4YWN0bHlPbmVTaGFwZX0gZnJvbSAnLi4vdXRpbHMvdHlwZXNfdXRpbHMnO1xuXG4vKipcbiAqIEdlbmVyaWMgTWVyZ2UgbGF5ZXIgZm9yIGVsZW1lbnQtd2lzZSBtZXJnZSBmdW5jdGlvbnMuXG4gKlxuICogVXNlZCB0byBpbXBsZW1lbnQgYFN1bWAsIGBBdmVyYWdlYCwgYENvbmNhdGVuYXRlYCwgZXRjLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgTWVyZ2UgZXh0ZW5kcyBMYXllciB7XG4gIHByb3RlY3RlZCByZXNoYXBlUmVxdWlyZWQ6IGJvb2xlYW47XG5cbiAgY29uc3RydWN0b3IoYXJncz86IExheWVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MgfHwge30pO1xuICAgIHRoaXMuc3VwcG9ydHNNYXNraW5nID0gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBMb2dpYyBmb3IgbWVyZ2luZyBtdWx0aXBsZSB0ZW5zb3JzLCB0byBiZSBvdmVycmlkZGVuIGJ5IHN1YmNsYXNzZXMuXG4gICAqIEBwYXJhbSBpbnB1dHNcbiAgICovXG4gIHByb3RlY3RlZCBtZXJnZUZ1bmN0aW9uKGlucHV0czogVGVuc29yW10pOiBUZW5zb3Ige1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKCk7XG4gIH1cblxuICAvKipcbiAgICogQ29tcHV0ZXMgdGhlIHNoYXBlIG9mIHRoZSByZXN1bHQgb2YgYW4gZWxlbWVudHdpc2Ugb3BlcmF0aW9uLlxuICAgKlxuICAgKiBAcGFyYW0gc2hhcGUxOiBTaGFwZSBvZiB0aGUgZmlyc3QgdGVuc29yLlxuICAgKiBAcGFyYW0gc2hhcGUyOiBTaGFwZSBvZiB0aGUgc2Vjb25kIHRlbnNvci5cbiAgICogQHJldHVybnMgRXhwZWN0ZWQgb3V0cHV0IHNoYXBlIHdoZW4gYW4gZWxlbWVudHdpc2Ugb3BlcmF0aW9uIGlzIGNhcnJpZWRcbiAgICogICBvdXQgb24gMiB0ZW5zb3JzIHdpdGggc2hhcGVzIGBzaGFwZTFgIGFuZCBgc2hhcGUyYC5cbiAgICogQHRocm93cyBWYWx1ZUVycm9yOiBJZiBgc2hhcGUxYCBhbmQgYHNoYXBlMmAgYXJlIG5vdCBjb21wYXRpYmxlIGZvclxuICAgKiAgIGVsZW1lbnQtd2lzZSBvcGVyYXRpb25zLlxuICAgKi9cbiAgcHJpdmF0ZSBjb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKHNoYXBlMTogU2hhcGUsIHNoYXBlMjogU2hhcGUpOiBTaGFwZSB7XG4gICAgaWYgKHNoYXBlMSA9PSBudWxsIHx8IHNoYXBlMiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9IGVsc2UgaWYgKHNoYXBlMS5sZW5ndGggPCBzaGFwZTIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKHNoYXBlMiwgc2hhcGUxKTtcbiAgICB9IGVsc2UgaWYgKHNoYXBlMi5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiBzaGFwZTE7XG4gICAgfVxuICAgIGNvbnN0IG91dHB1dFNoYXBlOiBTaGFwZSA9IHNoYXBlMS5zbGljZSgwLCBzaGFwZTEubGVuZ3RoIC0gc2hhcGUyLmxlbmd0aCk7XG4gICAgZm9yIChsZXQgayA9IDA7IGsgPCBzaGFwZTIubGVuZ3RoOyArK2spIHtcbiAgICAgIGNvbnN0IGkgPSBzaGFwZTFbc2hhcGUxLmxlbmd0aCAtIHNoYXBlMi5sZW5ndGggKyBrXTtcbiAgICAgIGNvbnN0IGogPSBzaGFwZTJba107XG4gICAgICBpZiAoaSA9PSBudWxsIHx8IGogPT0gbnVsbCB8fCBpIDwgMCB8fCBqIDwgMCkge1xuICAgICAgICBvdXRwdXRTaGFwZS5wdXNoKG51bGwpO1xuICAgICAgfSBlbHNlIGlmIChpID09PSAxKSB7XG4gICAgICAgIG91dHB1dFNoYXBlLnB1c2goaik7XG4gICAgICB9IGVsc2UgaWYgKGogPT09IDEpIHtcbiAgICAgICAgb3V0cHV0U2hhcGUucHVzaChpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpICE9PSBqKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgICdPcGVyYW5kcyBjb3VsZCBub3QgYmUgYnJvYWRjYXN0IHRvZ2V0aGVyIHdpdGggc2hhcGVzICcgK1xuICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShzaGFwZTEpICsgJyAnICsgSlNPTi5zdHJpbmdpZnkoc2hhcGUyKSk7XG4gICAgICAgIH1cbiAgICAgICAgb3V0cHV0U2hhcGUucHVzaChpKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dFNoYXBlO1xuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIC8vIFVzZWQgcHVyZWx5IGZvciBzaGFwZSB2YWxpZGF0aW9uLlxuICAgIGlmIChBcnJheS5pc0FycmF5KGlucHV0U2hhcGUpICYmICFBcnJheS5pc0FycmF5KGlucHV0U2hhcGVbMF0pKSB7XG4gICAgICAvLyBNYWtlIHN1cmUgdGhhdCBpbnB1dFNoYXBlIGlzIGFuIEFycmF5IG9mIHNoYXBlLlxuICAgICAgaW5wdXRTaGFwZSA9IFtnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSldO1xuICAgIH1cbiAgICBpbnB1dFNoYXBlID0gaW5wdXRTaGFwZSBhcyBTaGFwZVtdO1xuICAgIGlmIChpbnB1dFNoYXBlLmxlbmd0aCA8IDIpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdBIG1lcmdlIGxheWVyIHNob3VsZCBiZSBjYWxsZWQgb24gYW4gQXJyYXkgb2YgYXQgbGVhc3QgMiBpbnB1dHMuJyArXG4gICAgICAgICAgYCBHb3QgJHtpbnB1dFNoYXBlLmxlbmd0aH0gaW5wdXQocykuYCk7XG4gICAgfVxuXG4gICAgLy8gTWFrZSBzdXJlIHRoYXQgdGhlcmUgaXMgYXQgbW9zdCBvbmUgdW5pcXVlIGJhdGNoIHNpemUgYW1vbmcgdGhlIGlucHV0XG4gICAgLy8gc2hhcGVzLlxuICAgIGxldCBiYXRjaFNpemVzOiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2hhcGUgb2YgaW5wdXRTaGFwZSkge1xuICAgICAgaWYgKHNoYXBlICE9IG51bGwgJiYgc2hhcGVbMF0gIT09IG51bGwpIHtcbiAgICAgICAgYmF0Y2hTaXplcy5wdXNoKHNoYXBlWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYmF0Y2hTaXplcyA9IGdlbmVyaWNfdXRpbHMudW5pcXVlKGJhdGNoU2l6ZXMpO1xuICAgIGlmIChiYXRjaFNpemVzLmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBDYW4gbm90IG1lcmdlIHRlbnNvcnMgd2l0aCBkaWZmZXJlbnQgYmF0Y2ggc2l6ZXMuIGAgK1xuICAgICAgICAgIGBHb3QgdGVuc29ycyB3aXRoIHNoYXBlczogJHtKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKX0uYCk7XG4gICAgfVxuXG4gICAgbGV0IG91dHB1dFNoYXBlOiBTaGFwZSA9XG4gICAgICAgIGlucHV0U2hhcGVbMF0gPT0gbnVsbCA/IG51bGwgOiBpbnB1dFNoYXBlWzBdLnNsaWNlKDEpO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRTaGFwZS5sZW5ndGg7ICsraSkge1xuICAgICAgY29uc3Qgc2hhcGUgPSBpbnB1dFNoYXBlW2ldID09IG51bGwgPyBudWxsIDogaW5wdXRTaGFwZVtpXS5zbGljZSgxKTtcbiAgICAgIG91dHB1dFNoYXBlID0gdGhpcy5jb21wdXRlRWxlbWVudHdpc2VPcE91dHB1dFNoYXBlKG91dHB1dFNoYXBlLCBzaGFwZSk7XG4gICAgfVxuICAgIC8vIElmIHRoZSBpbnB1dHMgaGF2ZSBkaWZmZXJlbnQgcmFua3MsIHdlIGhhdmUgdG8gcmVzaGFwZSB0aGVtIHRvIG1ha2UgdGhlbVxuICAgIC8vIGJyb2FkY2FzdGFibGUuXG4gICAgY29uc3QgYWxsUmFua3MgPSBpbnB1dFNoYXBlLm1hcChzaGFwZSA9PiBzaGFwZS5sZW5ndGgpO1xuICAgIGlmIChpbnB1dFNoYXBlLmluZGV4T2YobnVsbCkgPT09IC0xICYmXG4gICAgICAgIGdlbmVyaWNfdXRpbHMudW5pcXVlKGFsbFJhbmtzKS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRoaXMucmVzaGFwZVJlcXVpcmVkID0gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucmVzaGFwZVJlcXVpcmVkID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgaW5wdXRzID0gaW5wdXRzIGFzIFRlbnNvcltdO1xuICAgICAgaWYgKHRoaXMucmVzaGFwZVJlcXVpcmVkKSB7XG4gICAgICAgIGNvbnN0IHJlc2hhcGVkSW5wdXRzOiBUZW5zb3JbXSA9IFtdO1xuICAgICAgICBjb25zdCBpbnB1dERpbXMgPSBpbnB1dHMubWFwKGlucHV0ID0+IGlucHV0LnJhbmspO1xuICAgICAgICBpZiAoaW5wdXREaW1zLmluZGV4T2YobnVsbCkgPT09IC0xKSB7XG4gICAgICAgICAgLy8gSWYgcmFua3Mgb2YgYWxsIGlucHV0cyBhcmUgYXZhaWxhYmxlLCB3ZSBzaW1wbHkgZXhwYW5kIGVhY2ggb2YgdGhlbVxuICAgICAgICAgIC8vIGF0IGF4aXM9MSB1bnRpbCBhbGwgb2YgdGhlbSBoYXZlIHRoZSBzYW1lIHJhbmsuXG4gICAgICAgICAgY29uc3QgbWF4TkRpbSA9IG1hdGhVdGlscy5tYXgoaW5wdXREaW1zKTtcbiAgICAgICAgICBmb3IgKGxldCB4IG9mIGlucHV0cykge1xuICAgICAgICAgICAgY29uc3QgeE5EaW0gPSB4LnJhbms7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IG1heE5EaW0gLSB4TkRpbTsgKytrKSB7XG4gICAgICAgICAgICAgIHggPSBLLmV4cGFuZERpbXMoeCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXNoYXBlZElucHV0cy5wdXNoKHgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdGhpcy5tZXJnZUZ1bmN0aW9uKHJlc2hhcGVkSW5wdXRzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBUcmFuc3Bvc2UgYWxsIGlucHV0cyBzbyB0aGF0IGJhdGNoIHNpemUgaXMgdGhlIGxhc3QgZGltZW5zaW9uLlxuICAgICAgICAgIC8vIFtiYXRjaFNpemUsIGRpbTEsIGRpbTIsIC4uLl0gLT4gW2RpbTEsIGRpbTIsIC4uLiwgYmF0Y2hTaXplXVxuICAgICAgICAgIGxldCB0cmFuc3Bvc2VkID0gZmFsc2U7XG4gICAgICAgICAgZm9yIChjb25zdCB4IG9mIGlucHV0cykge1xuICAgICAgICAgICAgY29uc3QgeE5EaW0gPSB4LnJhbms7XG4gICAgICAgICAgICBpZiAoeE5EaW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB4U2hhcGUgPSB4LnNoYXBlO1xuICAgICAgICAgICAgICBjb25zdCBiYXRjaFNpemUgPSB4U2hhcGVbMF07XG4gICAgICAgICAgICAgIGNvbnN0IG5ld1NoYXBlID0geFNoYXBlLnNsaWNlKDEpLmNvbmNhdChbYmF0Y2hTaXplXSk7XG4gICAgICAgICAgICAgIGxldCB4VHJhbnNwb3NlZCA9IHRmYy5yZXNoYXBlKFxuICAgICAgICAgICAgICAgICAgeCwgW2JhdGNoU2l6ZV0uY29uY2F0KG1hdGhVdGlscy5hcnJheVByb2QoeFNoYXBlLnNsaWNlKDEpKSkpO1xuICAgICAgICAgICAgICB4VHJhbnNwb3NlZCA9IHRmYy50cmFuc3Bvc2UoeFRyYW5zcG9zZWQsIFsxLCAwXSk7XG4gICAgICAgICAgICAgIHhUcmFuc3Bvc2VkID0gdGZjLnJlc2hhcGUoeFRyYW5zcG9zZWQsIG5ld1NoYXBlKTtcbiAgICAgICAgICAgICAgcmVzaGFwZWRJbnB1dHMucHVzaCh4VHJhbnNwb3NlZCk7XG4gICAgICAgICAgICAgIHRyYW5zcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4TkRpbSA+IDEpIHtcbiAgICAgICAgICAgICAgY29uc3QgZGltcyA9IG1hdGhVdGlscy5yYW5nZSgxLCB4TkRpbSkuY29uY2F0KFswXSk7XG4gICAgICAgICAgICAgIHJlc2hhcGVkSW5wdXRzLnB1c2godGZjLnRyYW5zcG9zZSh4LCBkaW1zKSk7XG4gICAgICAgICAgICAgIHRyYW5zcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gV2UgZG9uJ3QgdHJhbnNwb3NlIGlucHV0cyBpZiB0aGV5IGFyZSAxRCB2ZWN0b3JzIG9yIHNjYWxhcnMuXG4gICAgICAgICAgICAgIHJlc2hhcGVkSW5wdXRzLnB1c2goeCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGxldCB5ID0gdGhpcy5tZXJnZUZ1bmN0aW9uKHJlc2hhcGVkSW5wdXRzKTtcbiAgICAgICAgICBjb25zdCB5TkRpbSA9IHkucmFuaztcbiAgICAgICAgICBpZiAodHJhbnNwb3NlZCkge1xuICAgICAgICAgICAgLy8gSWYgaW5wdXRzIGhhdmUgYmVlbiB0cmFuc3Bvc2VkLCB3ZSBoYXZlIHRvIHRyYW5zcG9zZSB0aGUgb3V0cHV0XG4gICAgICAgICAgICAvLyB0b28uXG4gICAgICAgICAgICBpZiAoeU5EaW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICBjb25zdCB5U2hhcGUgPSB5LnNoYXBlO1xuICAgICAgICAgICAgICBjb25zdCB5TkRpbSA9IHlTaGFwZS5sZW5ndGg7XG4gICAgICAgICAgICAgIGNvbnN0IGJhdGNoU2l6ZSA9IHlTaGFwZVt5TkRpbSAtIDFdO1xuICAgICAgICAgICAgICBjb25zdCBuZXdTaGFwZSA9XG4gICAgICAgICAgICAgICAgICBbYmF0Y2hTaXplXS5jb25jYXQoeVNoYXBlLnNsaWNlKDAsIHlTaGFwZS5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICAgIHkgPSB0ZmMucmVzaGFwZShcbiAgICAgICAgICAgICAgICAgIHRmYy50cmFuc3Bvc2UodGZjLnJlc2hhcGUoeSwgWy0xLCBiYXRjaFNpemVdKSwgWzEsIDBdKSxcbiAgICAgICAgICAgICAgICAgIG5ld1NoYXBlKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeU5EaW0gPiAxKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGRpbXMgPSBbeU5EaW0gLSAxXS5jb25jYXQobWF0aFV0aWxzLnJhbmdlKDAsIHlORGltIC0gMSkpO1xuICAgICAgICAgICAgICB5ID0gdGZjLnRyYW5zcG9zZSh5LCBkaW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0aGlzLm1lcmdlRnVuY3Rpb24oaW5wdXRzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaW5wdXRTaGFwZSA9IGlucHV0U2hhcGUgYXMgU2hhcGVbXTtcbiAgICBsZXQgb3V0cHV0U2hhcGU6IFNoYXBlO1xuICAgIGlmIChpbnB1dFNoYXBlWzBdID09IG51bGwpIHtcbiAgICAgIG91dHB1dFNoYXBlID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0cHV0U2hhcGUgPSBpbnB1dFNoYXBlWzBdLnNsaWNlKDEpO1xuICAgIH1cbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0U2hhcGUubGVuZ3RoOyArK2kpIHtcbiAgICAgIGNvbnN0IHNoYXBlID0gaW5wdXRTaGFwZVtpXSA9PSBudWxsID8gbnVsbCA6IGlucHV0U2hhcGVbaV0uc2xpY2UoMSk7XG4gICAgICBvdXRwdXRTaGFwZSA9IHRoaXMuY29tcHV0ZUVsZW1lbnR3aXNlT3BPdXRwdXRTaGFwZShvdXRwdXRTaGFwZSwgc2hhcGUpO1xuICAgIH1cblxuICAgIGxldCBiYXRjaFNpemVzOiBudW1iZXJbXSA9IFtdO1xuICAgIGZvciAoY29uc3Qgc2hhcGUgb2YgaW5wdXRTaGFwZSkge1xuICAgICAgaWYgKHNoYXBlICE9IG51bGwgJiYgc2hhcGVbMF0gIT09IG51bGwpIHtcbiAgICAgICAgYmF0Y2hTaXplcy5wdXNoKHNoYXBlWzBdKTtcbiAgICAgIH1cbiAgICB9XG4gICAgYmF0Y2hTaXplcyA9IGdlbmVyaWNfdXRpbHMudW5pcXVlKGJhdGNoU2l6ZXMpO1xuICAgIGlmIChiYXRjaFNpemVzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgb3V0cHV0U2hhcGUgPSBiYXRjaFNpemVzLmNvbmNhdChvdXRwdXRTaGFwZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFNoYXBlID0gW251bGxdLmNvbmNhdChvdXRwdXRTaGFwZSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgfVxuXG4gIGNvbXB1dGVNYXNrKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBtYXNrPzogVGVuc29yfFRlbnNvcltdKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGZjLnRpZHkoKCkgPT4ge1xuICAgICAgaWYgKG1hc2sgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShtYXNrKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignYG1hc2tgIHNob3VsZCBiZSBhbiBBcnJheScpO1xuICAgICAgfVxuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoJ2BpbnB1dHNgIHNob3VsZCBiZSBhbiBBcnJheScpO1xuICAgICAgfVxuICAgICAgaWYgKG1hc2subGVuZ3RoICE9PSBpbnB1dHMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYFRoZSBBcnJheSAnaW5wdXRzJyBhbmQgJ21hc2snIGFyZSBleHBlY3RlZCB0byBoYXZlIHRoZSBzYW1lIGAgK1xuICAgICAgICAgICAgYGxlbmd0aCwgYnV0IGhhdmUgZGlmZmVyZW50IGxlbmd0aHMgYCArXG4gICAgICAgICAgICBgKCR7aW5wdXRzLmxlbmd0aH0gdnMgJHttYXNrLmxlbmd0aH0pYCk7XG4gICAgICB9XG4gICAgICBpZiAobWFzay5ldmVyeShtID0+IG0gPT0gbnVsbCkpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG4gICAgICBtYXNrID0gbWFzay5tYXAobSA9PiBtID09IG51bGwgPyBtIDogdGZjLmV4cGFuZERpbXMobSwgMCkpO1xuICAgICAgbGV0IG91dHB1dCA9IG1hc2tbMF07XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IG1hc2subGVuZ3RoIC0gMTsgKytpKSB7XG4gICAgICAgIG91dHB1dCA9IHRmYy5sb2dpY2FsQW5kKG91dHB1dCwgbWFza1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBBZGQgZXh0ZW5kcyBNZXJnZSB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ0FkZCc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtZXJnZUZ1bmN0aW9uKGlucHV0czogVGVuc29yW10pOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGxldCBvdXRwdXQgPSBpbnB1dHNbMF0uY2xvbmUoKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG91dHB1dCA9IHRmYy5hZGQob3V0cHV0LCBpbnB1dHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEFkZCk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBlbGVtZW50LXdpc2Ugc3VtIG9mIGlucHV0cywgd2hpY2ggYWxsIGhhdmUgdGhlIHNhbWUgc2hhcGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgaW52b2tlZCBpbiB0aHJlZSB3YXlzLlxuICpcbiAqIDEuIENvbnN0cnVjdCBhbiBpbnN0YW5jZSBvZiBgQWRkYCBsYXllciwgYnkgdXNpbmcgbm8gaW5wdXQgYXJndW1lbnRcbiAqICAgIG9yIGEgc2luZ2xlIGNvbmZpZ3VyYXRpb24gYXJndW1lbnQuIFRoZSByZXN1bHRhbnQgYEFkZGAgbGF5ZXIgY2FuIHRoZW5cbiAqICAgIGJlIHVzZWQgb24gYHRmLlN5bWJvbGljVGVuc29yYHMgb3IgYHRmLlRlbnNvcmBzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYWRkTGF5ZXIgPSB0Zi5sYXllcnMuYWRkKCk7XG4gKlxuICogLy8gVGhlIGxheWVyIGNhbiBiZSBhcHBsaWVkIHRvIGlucHV0cy5cbiAqIGNvbnN0IGlucHV0MSA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBpbnB1dDIgPSB0Zi5pbnB1dCh7c2hhcGU6IFsyLCAyXX0pO1xuICogY29uc3Qgb3V0cHV0ID0gYWRkTGF5ZXIuYXBwbHkoW2lucHV0MSwgaW5wdXQyXSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQuc2hhcGUpO1xuICogLy8gWW91IGdldCBbbnVsbCwgMiwgMl0sIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBhcyB0aGUgdW5kZXRlcm1pbmVkIGJhdGNoXG4gKiAvLyBkaW1lbnNpb24uXG4gKiBgYGBcbiAqXG4gKiAyLiBJbnZva2UgZGlyZWN0bHkgb24gYW4gYEFycmF5YCBvZiBgdGYuU3ltYm9saWNUZW5zb3Jgcy4gVGhpcyBjb25zdHJ1Y3RzXG4gKiAgICBhbiBgTGF5ZXJgIG9iamVjdCBpbnRlcm5hbGx5IGFuZCBjYWxscyBpdHMgYGFwcGx5YCBtZXRob2Qgb24gdGhlIGlucHV0cyxcbiAqICAgIGdlbmVyYXRpbmcgYSBuZXcgYHRmLlN5bWJvbGljVGVuc29yYC4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0MSA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBpbnB1dDIgPSB0Zi5pbnB1dCh7c2hhcGU6IFsyLCAyXX0pO1xuICogY29uc3Qgb3V0cHV0ID0gdGYubGF5ZXJzLmFkZChbaW5wdXQxLCBpbnB1dDJdKTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dC5zaGFwZSk7XG4gKiAvLyBZb3UgZ2V0IFtudWxsLCAyLCAyXSwgd2l0aCB0aGUgZmlyc3QgZGltZW5zaW9uIGFzIHRoZSB1bmRldGVybWluZWQgYmF0Y2hcbiAqIC8vIGRpbWVuc2lvbi5cbiAqIGBgYFxuICpcbiAqIDMuIEludm9rZSBkaXJlY3RseSBvbiBgdGYuVGVuc29yYHMsIGkuZS4sIGNvbmNyZXRlIHZhbHVlcy4gVGhpcyBjb25zdHJ1Y3RzXG4gKiAgICBhbiBgTGF5ZXJgIG9iamVjdCBpbnRlcm5hbGx5IGFuZCBjYWxscyBpdHMgYGFwcGx5YCBtZXRob2Qgb24gdGhlIGlucHV0cyxcbiAqICAgIGdlbmVyYXRpbmcgYSBuZXcgYHRmLlRlbnNvcmAgYXMgdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb24uIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgaW5wdXQxID0gdGYudGVuc29yMmQoWzEsIDIsIDMsIDRdLCBbMiwgMl0pO1xuICogY29uc3QgaW5wdXQyID0gdGYudGVuc29yMmQoWzEwLCAyMCwgMzAsIDQwXSwgWzIsIDJdKTtcbiAqIHRmLmxheWVycy5hZGQoW2lucHV0MSwgaW5wdXQyXSkucHJpbnQoKTtcbiAqIC8vIEdpdmVzIFtbMTEsIDIyXSwgWzMzLCA0NF1dLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGFkZChjb25maWc/OiBTeW1ib2xpY1RlbnNvcltdfFRlbnNvcltdfExheWVyQXJncyk6IExheWVyfFxuICAgIFN5bWJvbGljVGVuc29yfFRlbnNvciB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICBjb25zdCBsYXllciA9IG5ldyBBZGQoe30pO1xuICAgIHJldHVybiBsYXllci5hcHBseShjb25maWcpIGFzIFN5bWJvbGljVGVuc29yIHwgVGVuc29yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgQWRkKGNvbmZpZyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE11bHRpcGx5IGV4dGVuZHMgTWVyZ2Uge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdNdWx0aXBseSc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtZXJnZUZ1bmN0aW9uKGlucHV0czogVGVuc29yW10pOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGxldCBvdXRwdXQgPSBpbnB1dHNbMF0uY2xvbmUoKTtcbiAgICAgIGZvciAobGV0IGkgPSAxOyBpIDwgaW5wdXRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG91dHB1dCA9IHRmYy5tdWwob3V0cHV0LCBpbnB1dHNbaV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE11bHRpcGx5KTtcblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGVsZW1lbnQtd2lzZSBwcm9kdWN0IG9mIGlucHV0cywgd2hpY2ggYWxsIGhhdmUgdGhlIHNhbWUgc2hhcGUuXG4gKlxuICogVGhpcyBmdW5jdGlvbiBjYW4gYmUgaW52b2tlZCBpbiB0aHJlZSB3YXlzLlxuICpcbiAqIDEuIENvbnN0cnVjdCBhbiBpbnN0YW5jZSBvZiBgTXVsdGlwbHlgIGxheWVyLCBieSB1c2luZyBubyBpbnB1dCBhcmd1bWVudFxuICogICAgb3IgYSBzaW5nbGUgY29uZmlndXJhdGlvbiBhcmd1bWVudC4gVGhlIHJlc3VsdGFudCBgTXVsdGlwbHlgIGxheWVyIGNhblxuICogICAgdGhlbiBiZSB1c2VkIG9uIGB0Zi5TeW1ib2xpY1RlbnNvcmBzIG9yIGB0Zi5UZW5zb3Jgcy4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IG11bHRpcGx5TGF5ZXIgPSB0Zi5sYXllcnMubXVsdGlwbHkoKTtcbiAqXG4gKiAvLyBUaGUgbGF5ZXIgY2FuIGJlIGFwcGxpZWQgdG8gaW5wdXRzLlxuICogY29uc3QgaW5wdXQxID0gdGYuaW5wdXQoe3NoYXBlOiBbMiwgMl19KTtcbiAqIGNvbnN0IGlucHV0MiA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBvdXRwdXQgPSBtdWx0aXBseUxheWVyLmFwcGx5KFtpbnB1dDEsIGlucHV0Ml0pO1xuICogY29uc29sZS5sb2cob3V0cHV0LnNoYXBlKTtcbiAqIC8vIFlvdSBnZXQgW251bGwsIDIsIDJdLCB3aXRoIHRoZSBmaXJzdCBkaW1lbnNpb24gYXMgdGhlIHVuZGV0ZXJtaW5lZCBiYXRjaFxuICogLy8gZGltZW5zaW9uLlxuICogYGBgXG4gKlxuICogMi4gSW52b2tlIGRpcmVjdGx5IG9uIGFuIGBBcnJheWAgb2YgYHRmLlN5bWJvbGljVGVuc29yYHMuIFRoaXMgY29uc3RydWN0c1xuICogICAgYW4gYExheWVyYCBvYmplY3QgaW50ZXJuYWxseSBhbmQgY2FsbHMgaXRzIGBhcHBseWAgbWV0aG9kIG9uIHRoZSBpbnB1dHMsXG4gKiAgICBnZW5lcmF0aW5nIGEgbmV3IGB0Zi5TeW1ib2xpY1RlbnNvcmAuIEZvciBleGFtcGxlOlxuICpcbiAqIGBgYGpzXG4gKiBjb25zdCBpbnB1dDEgPSB0Zi5pbnB1dCh7c2hhcGU6IFsyLCAyXX0pO1xuICogY29uc3QgaW5wdXQyID0gdGYuaW5wdXQoe3NoYXBlOiBbMiwgMl19KTtcbiAqIGNvbnN0IG91dHB1dCA9IHRmLmxheWVycy5tdWx0aXBseShbaW5wdXQxLCBpbnB1dDJdKTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dC5zaGFwZSk7XG4gKiAvLyBZb3UgZ2V0IFtudWxsLCAyLCAyXSwgd2l0aCB0aGUgZmlyc3QgZGltZW5zaW9uIGFzIHRoZSB1bmRldGVybWluZWQgYmF0Y2hcbiAqIC8vIGRpbWVuc2lvbi5cbiAqIGBgYFxuICpcbiAqIDMuIEludm9rZSBkaXJlY3RseSBvbiBgdGYuVGVuc29yYHMsIGkuZS4sIGNvbmNyZXRlIHZhbHVlcy4gVGhpcyBjb25zdHJ1Y3RzXG4gKiAgICBhbiBgTGF5ZXJgIG9iamVjdCBpbnRlcm5hbGx5IGFuZCBjYWxscyBpdHMgYGFwcGx5YCBtZXRob2Qgb24gdGhlIGlucHV0cyxcbiAqICAgIGdlbmVyYXRpbmcgYSBuZXcgYHRmLlRlbnNvcmAgYXMgdGhlIHJlc3VsdCBvZiB0aGUgY29tcHV0YXRpb24uIEZvclxuICogZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgaW5wdXQxID0gdGYudGVuc29yMmQoWzEsIDIsIDMsIDRdLCBbMiwgMl0pO1xuICogY29uc3QgaW5wdXQyID0gdGYudGVuc29yMmQoWzEwLCAyMCwgMzAsIDQwXSwgWzIsIDJdKTtcbiAqIHRmLmxheWVycy5tdWx0aXBseShbaW5wdXQxLCBpbnB1dDJdKS5wcmludCgpO1xuICogLy8gR2l2ZXMgW1sxMCwgNDBdLCBbOTAsIDE2MF1dLlxuICpcbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIG11bHRpcGx5KGNvbmZpZz86IFN5bWJvbGljVGVuc29yW118VGVuc29yW118TGF5ZXJBcmdzKTogTGF5ZXJ8XG4gICAgU3ltYm9saWNUZW5zb3J8VGVuc29yIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgIGNvbnN0IGxheWVyID0gbmV3IE11bHRpcGx5KHt9KTtcbiAgICByZXR1cm4gbGF5ZXIuYXBwbHkoY29uZmlnKSBhcyBTeW1ib2xpY1RlbnNvciB8IFRlbnNvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE11bHRpcGx5KGNvbmZpZyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEF2ZXJhZ2UgZXh0ZW5kcyBNZXJnZSB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ0F2ZXJhZ2UnO1xuICBjb25zdHJ1Y3RvcihhcmdzPzogTGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWVyZ2VGdW5jdGlvbihpbnB1dHM6IFRlbnNvcltdKTogVGVuc29yIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBsZXQgb3V0cHV0ID0gaW5wdXRzWzBdLmNsb25lKCk7XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBvdXRwdXQgPSB0ZmMuYWRkKG91dHB1dCwgaW5wdXRzW2ldKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0ZmMubXVsKDEgLyBpbnB1dHMubGVuZ3RoLCBvdXRwdXQpO1xuICAgIH0pO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQXZlcmFnZSk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBlbGVtZW50LXdpc2UgYXJpdGhtZXRpYyBtZWFuIG9mIGlucHV0cywgd2hpY2ggYWxsIGhhdmUgdGhlIHNhbWVcbiAqIHNoYXBlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGludm9rZWQgaW4gdGhyZWUgd2F5cy5cbiAqXG4gKiAxLiBDb25zdHJ1Y3QgYW4gaW5zdGFuY2Ugb2YgYEF2ZXJhZ2VgIGxheWVyLCBieSB1c2luZyBubyBpbnB1dCBhcmd1bWVudFxuICogICAgb3IgYSBzaW5nbGUgY29uZmlndXJhdGlvbiBhcmd1bWVudC4gVGhlIHJlc3VsdGFudCBgQXZlcmFnZWAgbGF5ZXIgY2FuIHRoZW5cbiAqICAgIGJlIHVzZWQgb24gYHRmLlN5bWJvbGljVGVuc29yYHMgb3IgYHRmLlRlbnNvcmBzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgYXZlcmFnZUxheWVyID0gdGYubGF5ZXJzLmF2ZXJhZ2UoKTtcbiAqXG4gKiAvLyBUaGUgbGF5ZXIgY2FuIGJlIGFwcGxpZWQgdG8gaW5wdXRzLlxuICogY29uc3QgaW5wdXQxID0gdGYuaW5wdXQoe3NoYXBlOiBbMiwgMl19KTtcbiAqIGNvbnN0IGlucHV0MiA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBvdXRwdXQgPSBhdmVyYWdlTGF5ZXIuYXBwbHkoW2lucHV0MSwgaW5wdXQyXSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQuc2hhcGUpO1xuICogLy8gWW91IGdldCBbbnVsbCwgMiwgMl0sIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBhcyB0aGUgdW5kZXRlcm1pbmVkIGJhdGNoXG4gKiAvLyBkaW1lbnNpb24uXG4gKiBgYGBcbiAqXG4gKiAyLiBJbnZva2UgZGlyZWN0bHkgb24gYW4gYEFycmF5YCBvZiBgdGYuU3ltYm9saWNUZW5zb3Jgcy4gVGhpcyBjb25zdHJ1Y3RzXG4gKiAgICBhbiBgTGF5ZXJgIG9iamVjdCBpbnRlcm5hbGx5IGFuZCBjYWxscyBpdHMgYGFwcGx5YCBtZXRob2Qgb24gdGhlIGlucHV0cyxcbiAqICAgIGdlbmVyYXRpbmcgYSBuZXcgYHRmLlN5bWJvbGljVGVuc29yYC4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0MSA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBpbnB1dDIgPSB0Zi5pbnB1dCh7c2hhcGU6IFsyLCAyXX0pO1xuICogY29uc3Qgb3V0cHV0ID0gdGYubGF5ZXJzLmF2ZXJhZ2UoW2lucHV0MSwgaW5wdXQyXSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQuc2hhcGUpO1xuICogLy8gWW91IGdldCBbbnVsbCwgMiwgMl0sIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBhcyB0aGUgdW5kZXRlcm1pbmVkIGJhdGNoXG4gKiAvLyBkaW1lbnNpb24uXG4gKiBgYGBcbiAqXG4gKiAzLiBJbnZva2UgZGlyZWN0bHkgb24gYHRmLlRlbnNvcmBzLCBpLmUuLCBjb25jcmV0ZSB2YWx1ZXMuIFRoaXMgY29uc3RydWN0c1xuICogICAgYW4gYExheWVyYCBvYmplY3QgaW50ZXJuYWxseSBhbmQgY2FsbHMgaXRzIGBhcHBseWAgbWV0aG9kIG9uIHRoZSBpbnB1dHMsXG4gKiAgICBnZW5lcmF0aW5nIGEgbmV3IGB0Zi5UZW5zb3JgIGFzIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0MSA9IHRmLnRlbnNvcjJkKFsxLCAyLCAzLCA0XSwgWzIsIDJdKTtcbiAqIGNvbnN0IGlucHV0MiA9IHRmLnRlbnNvcjJkKFsxMCwgMjAsIDMwLCA0MF0sIFsyLCAyXSk7XG4gKiB0Zi5sYXllcnMuYXZlcmFnZShbaW5wdXQxLCBpbnB1dDJdKS5wcmludCgpO1xuICogLy8gR2l2ZXMgW1s1LjUsIDExXSwgWzE2LjUsIDIyXV0uXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gYXZlcmFnZShjb25maWc/OiBTeW1ib2xpY1RlbnNvcltdfFRlbnNvcltdfExheWVyQXJncyk6IExheWVyfFxuICAgIFN5bWJvbGljVGVuc29yfFRlbnNvciB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICBjb25zdCBsYXllciA9IG5ldyBBdmVyYWdlKHt9KTtcbiAgICByZXR1cm4gbGF5ZXIuYXBwbHkoY29uZmlnKSBhcyBTeW1ib2xpY1RlbnNvciB8IFRlbnNvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IEF2ZXJhZ2UoY29uZmlnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWF4aW11bSBleHRlbmRzIE1lcmdlIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTWF4aW11bSc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtZXJnZUZ1bmN0aW9uKGlucHV0czogVGVuc29yW10pOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGxldCBvdXRwdXQgPSBpbnB1dHNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBvdXRwdXQgPSB0ZmMubWF4aW11bShvdXRwdXQsIGlucHV0c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWF4aW11bSk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBlbGVtZW50LXdpc2UgbWF4aW11bSBvZiBpbnB1dHMsIHdoaWNoIGFsbCBoYXZlIHRoZSBzYW1lIHNoYXBlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGludm9rZWQgaW4gdGhyZWUgd2F5cy5cbiAqXG4gKiAxLiBDb25zdHJ1Y3QgYW4gaW5zdGFuY2Ugb2YgYE1heGltdW1gIGxheWVyLCBieSB1c2luZyBubyBpbnB1dCBhcmd1bWVudFxuICogICAgb3IgYSBzaW5nbGUgY29uZmlndXJhdGlvbiBhcmd1bWVudC4gVGhlIHJlc3VsdGFudCBgTWF4aW11bWAgbGF5ZXIgY2FuIHRoZW5cbiAqICAgIGJlIHVzZWQgb24gYHRmLlN5bWJvbGljVGVuc29yYHMgb3IgYHRmLlRlbnNvcmBzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbWF4aW11bUxheWVyID0gdGYubGF5ZXJzLm1heGltdW0oKTtcbiAqXG4gKiAvLyBUaGUgbGF5ZXIgY2FuIGJlIGFwcGxpZWQgdG8gaW5wdXRzLlxuICogY29uc3QgaW5wdXQxID0gdGYuaW5wdXQoe3NoYXBlOiBbMiwgMl19KTtcbiAqIGNvbnN0IGlucHV0MiA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBvdXRwdXQgPSBtYXhpbXVtTGF5ZXIuYXBwbHkoW2lucHV0MSwgaW5wdXQyXSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQuc2hhcGUpO1xuICogLy8gWW91IGdldCBbbnVsbCwgMiwgMl0sIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBhcyB0aGUgdW5kZXRlcm1pbmVkIGJhdGNoXG4gKiAvLyBkaW1lbnNpb24uXG4gKiBgYGBcbiAqXG4gKiAyLiBJbnZva2UgZGlyZWN0bHkgb24gYW4gYEFycmF5YCBvZiBgdGYuU3ltYm9saWNUZW5zb3Jgcy4gVGhpcyBjb25zdHJ1Y3RzXG4gKiAgICBhbiBgTGF5ZXJgIG9iamVjdCBpbnRlcm5hbGx5IGFuZCBjYWxscyBpdHMgYGFwcGx5YCBtZXRob2Qgb24gdGhlIGlucHV0cyxcbiAqICAgIGdlbmVyYXRpbmcgYSBuZXcgYHRmLlN5bWJvbGljVGVuc29yYC4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0MSA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBpbnB1dDIgPSB0Zi5pbnB1dCh7c2hhcGU6IFsyLCAyXX0pO1xuICogY29uc3Qgb3V0cHV0ID0gdGYubGF5ZXJzLm1heGltdW0oW2lucHV0MSwgaW5wdXQyXSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQuc2hhcGUpO1xuICogLy8gWW91IGdldCBbbnVsbCwgMiwgMl0sIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBhcyB0aGUgdW5kZXRlcm1pbmVkIGJhdGNoXG4gKiAvLyBkaW1lbnNpb24uXG4gKiBgYGBcbiAqXG4gKiAzLiBJbnZva2UgZGlyZWN0bHkgb24gYHRmLlRlbnNvcmBzLCBpLmUuLCBjb25jcmV0ZSB2YWx1ZXMuIFRoaXMgY29uc3RydWN0c1xuICogICAgYW4gYExheWVyYCBvYmplY3QgaW50ZXJuYWxseSBhbmQgY2FsbHMgaXRzIGBhcHBseWAgbWV0aG9kIG9uIHRoZSBpbnB1dHMsXG4gKiAgICBnZW5lcmF0aW5nIGEgbmV3IGB0Zi5UZW5zb3JgIGFzIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0MSA9IHRmLnRlbnNvcjJkKFsxLCAyMCwgMywgNDBdLCBbMiwgMl0pO1xuICogY29uc3QgaW5wdXQyID0gdGYudGVuc29yMmQoWzEwLCAyLCAzMCwgNF0sIFsyLCAyXSk7XG4gKiB0Zi5sYXllcnMubWF4aW11bShbaW5wdXQxLCBpbnB1dDJdKS5wcmludCgpO1xuICogLy8gR2l2ZXMgW1sxMCwgMjBdLCBbMzAsIDQwXV0uXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gbWF4aW11bShjb25maWc/OiBTeW1ib2xpY1RlbnNvcltdfFRlbnNvcltdfExheWVyQXJncyk6IExheWVyfFxuICAgIFN5bWJvbGljVGVuc29yfFRlbnNvciB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICBjb25zdCBsYXllciA9IG5ldyBNYXhpbXVtKHt9KTtcbiAgICByZXR1cm4gbGF5ZXIuYXBwbHkoY29uZmlnKSBhcyBTeW1ib2xpY1RlbnNvciB8IFRlbnNvcjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbmV3IE1heGltdW0oY29uZmlnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWluaW11bSBleHRlbmRzIE1lcmdlIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTWluaW11bSc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBtZXJnZUZ1bmN0aW9uKGlucHV0czogVGVuc29yW10pOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGxldCBvdXRwdXQgPSBpbnB1dHNbMF07XG4gICAgICBmb3IgKGxldCBpID0gMTsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBvdXRwdXQgPSB0ZmMubWluaW11bShvdXRwdXQsIGlucHV0c1tpXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0pO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWluaW11bSk7XG5cbi8qKlxuICogQ2FsY3VsYXRlIHRoZSBlbGVtZW50LXdpc2UgbWluaW11bSBvZiBpbnB1dHMsIHdoaWNoIGFsbCBoYXZlIHRoZSBzYW1lIHNoYXBlLlxuICpcbiAqIFRoaXMgZnVuY3Rpb24gY2FuIGJlIGludm9rZWQgaW4gdGhyZWUgd2F5cy5cbiAqXG4gKiAxLiBDb25zdHJ1Y3QgYW4gaW5zdGFuY2Ugb2YgYE1pbmltdW1gIGxheWVyLCBieSB1c2luZyBubyBpbnB1dCBhcmd1bWVudFxuICogICAgb3IgYSBzaW5nbGUgY29uZmlndXJhdGlvbiBhcmd1bWVudC4gVGhlIHJlc3VsdGFudCBgTWluaW11bWAgbGF5ZXIgY2FuIHRoZW5cbiAqICAgIGJlIHVzZWQgb24gYHRmLlN5bWJvbGljVGVuc29yYHMgb3IgYHRmLlRlbnNvcmBzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgbWluaW11bUxheWVyID0gdGYubGF5ZXJzLm1pbmltdW0oKTtcbiAqXG4gKiAvLyBUaGUgbGF5ZXIgY2FuIGJlIGFwcGxpZWQgdG8gaW5wdXRzLlxuICogY29uc3QgaW5wdXQxID0gdGYuaW5wdXQoe3NoYXBlOiBbMiwgMl19KTtcbiAqIGNvbnN0IGlucHV0MiA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBvdXRwdXQgPSBtaW5pbXVtTGF5ZXIuYXBwbHkoW2lucHV0MSwgaW5wdXQyXSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQuc2hhcGUpO1xuICogLy8gWW91IGdldCBbbnVsbCwgMiwgMl0sIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBhcyB0aGUgdW5kZXRlcm1pbmVkIGJhdGNoXG4gKiAvLyBkaW1lbnNpb24uXG4gKiBgYGBcbiAqXG4gKiAyLiBJbnZva2UgZGlyZWN0bHkgb24gYW4gYEFycmF5YCBvZiBgdGYuU3ltYm9saWNUZW5zb3Jgcy4gVGhpcyBjb25zdHJ1Y3RzXG4gKiAgICBhbiBgTGF5ZXJgIG9iamVjdCBpbnRlcm5hbGx5IGFuZCBjYWxscyBpdHMgYGFwcGx5YCBtZXRob2Qgb24gdGhlIGlucHV0cyxcbiAqICAgIGdlbmVyYXRpbmcgYSBuZXcgYHRmLlN5bWJvbGljVGVuc29yYC4gRm9yIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0MSA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDJdfSk7XG4gKiBjb25zdCBpbnB1dDIgPSB0Zi5pbnB1dCh7c2hhcGU6IFsyLCAyXX0pO1xuICogY29uc3Qgb3V0cHV0ID0gdGYubGF5ZXJzLm1pbmltdW0oW2lucHV0MSwgaW5wdXQyXSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQuc2hhcGUpO1xuICogLy8gWW91IGdldCBbbnVsbCwgMiwgMl0sIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBhcyB0aGUgdW5kZXRlcm1pbmVkIGJhdGNoXG4gKiAvLyBkaW1lbnNpb24uXG4gKiBgYGBcbiAqXG4gKiAzLiBJbnZva2UgZGlyZWN0bHkgb24gYHRmLlRlbnNvcmBzLCBpLmUuLCBjb25jcmV0ZSB2YWx1ZXMuIFRoaXMgY29uc3RydWN0c1xuICogICAgYW4gYExheWVyYCBvYmplY3QgaW50ZXJuYWxseSBhbmQgY2FsbHMgaXRzIGBhcHBseWAgbWV0aG9kIG9uIHRoZSBpbnB1dHMsXG4gKiAgICBnZW5lcmF0aW5nIGEgbmV3IGB0Zi5UZW5zb3JgIGFzIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0MSA9IHRmLnRlbnNvcjJkKFsxLCAyMCwgMywgNDBdLCBbMiwgMl0pO1xuICogY29uc3QgaW5wdXQyID0gdGYudGVuc29yMmQoWzEwLCAyLCAzMCwgNF0sIFsyLCAyXSk7XG4gKiB0Zi5sYXllcnMubWluaW11bShbaW5wdXQxLCBpbnB1dDJdKS5wcmludCgpO1xuICogLy8gR2l2ZXMgW1sxLCAyXSwgWzMsIDRdXS5cbiAqXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBtaW5pbXVtKGNvbmZpZz86IFN5bWJvbGljVGVuc29yW118VGVuc29yW118TGF5ZXJBcmdzKTogTGF5ZXJ8XG4gICAgU3ltYm9saWNUZW5zb3J8VGVuc29yIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoY29uZmlnKSkge1xuICAgIGNvbnN0IGxheWVyID0gbmV3IE1pbmltdW0oe30pO1xuICAgIHJldHVybiBsYXllci5hcHBseShjb25maWcpIGFzIFN5bWJvbGljVGVuc29yIHwgVGVuc29yO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBuZXcgTWluaW11bShjb25maWcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBDb25jYXRlbmF0ZUxheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBBeGlzIGFsb25nIHdoaWNoIHRvIGNvbmNhdGVuYXRlLlxuICAgKi9cbiAgYXhpcz86IG51bWJlcjtcbn1cblxuZXhwb3J0IGNsYXNzIENvbmNhdGVuYXRlIGV4dGVuZHMgTWVyZ2Uge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdDb25jYXRlbmF0ZSc7XG4gIHJlYWRvbmx5IERFRkFVTFRfQVhJUyA9IC0xO1xuICBwcml2YXRlIHJlYWRvbmx5IGF4aXM6IG51bWJlcjtcblxuICBjb25zdHJ1Y3RvcihhcmdzPzogQ29uY2F0ZW5hdGVMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICBhcmdzID0ge307XG4gICAgfVxuICAgIHRoaXMuYXhpcyA9IGFyZ3MuYXhpcyA9PSBudWxsID8gdGhpcy5ERUZBVUxUX0FYSVMgOiBhcmdzLmF4aXM7XG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgIHRoaXMucmVzaGFwZVJlcXVpcmVkID0gZmFsc2U7XG4gIH1cblxuICBidWlsZChpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogdm9pZCB7XG4gICAgLy8gVXNlZCBwdXJlbHkgZm9yIHNoYXBlIHZhbGlkYXRpb24uXVxuICAgIGlmICghKEFycmF5LmlzQXJyYXkoaW5wdXRTaGFwZSkgJiYgQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlWzBdKSkgfHxcbiAgICAgICAgaW5wdXRTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgYXQgbGVhc3QgMiAnICtcbiAgICAgICAgICAnaW5wdXRzJyk7XG4gICAgfVxuICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlIGFzIFNoYXBlW107XG5cbiAgICBsZXQgYWxsTm9uZVNoYXBlID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHNoYXBlIG9mIGlucHV0U2hhcGUpIHtcbiAgICAgIGlmIChzaGFwZSAhPSBudWxsKSB7XG4gICAgICAgIGFsbE5vbmVTaGFwZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGFsbE5vbmVTaGFwZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IHNoYXBlU2V0OiBTaGFwZVtdID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dFNoYXBlLmxlbmd0aDsgKytpKSB7XG4gICAgICBjb25zdCBzaGFwZVdpdGhvdXRDb25jYXRBeGlzID0gaW5wdXRTaGFwZVtpXS5zbGljZSgpO1xuICAgICAgc2hhcGVXaXRob3V0Q29uY2F0QXhpcy5zcGxpY2UodGhpcy5heGlzLCAxKTtcbiAgICAgIGxldCBleGlzdHMgPSBmYWxzZTtcbiAgICAgIGZvciAoY29uc3Qgc2hhcGUgb2Ygc2hhcGVTZXQpIHtcbiAgICAgICAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoc2hhcGUsIHNoYXBlV2l0aG91dENvbmNhdEF4aXMpKSB7XG4gICAgICAgICAgZXhpc3RzID0gdHJ1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFleGlzdHMpIHtcbiAgICAgICAgc2hhcGVTZXQucHVzaChzaGFwZVdpdGhvdXRDb25jYXRBeGlzKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNoYXBlU2V0Lmxlbmd0aCA+IDEpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdBIGBDb25jYXRlbmF0ZWAgbGF5ZXIgcmVxdWlyZXMgaW5wdXRzIHdpdGggbWF0Y2hpbmcgc2hhcGVzICcgK1xuICAgICAgICAgICdleGNlcHQgZm9yIHRoZSBjb25jYXQgYXhpcy4gR290IGlucHV0IHNoYXBlczogJyArXG4gICAgICAgICAgSlNPTi5zdHJpbmdpZnkoaW5wdXRTaGFwZSkpO1xuICAgIH1cbiAgfVxuXG4gIHByb3RlY3RlZCBtZXJnZUZ1bmN0aW9uKGlucHV0czogVGVuc29yW10pOiBUZW5zb3Ige1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIHJldHVybiBLLmNvbmNhdGVuYXRlKGlucHV0cywgdGhpcy5heGlzKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaWYgKCEoQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlKSAmJiBBcnJheS5pc0FycmF5KGlucHV0U2hhcGVbMF0pKSkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgJ0EgYENvbmNhdGVuYXRlYCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBpbnB1dHMuJyk7XG4gICAgfVxuICAgIGNvbnN0IGlucHV0U2hhcGVzID0gaW5wdXRTaGFwZSBhcyBTaGFwZVtdO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gaW5wdXRTaGFwZXNbMF0uc2xpY2UoKTtcbiAgICBjb25zdCBheGlzID0gdGhpcy5heGlzIDwgMCA/IG91dHB1dFNoYXBlLmxlbmd0aCArIHRoaXMuYXhpcyA6IHRoaXMuYXhpcztcbiAgICAvLyBQb3J0aW5nIE5vdGU6IHRoZSBsaW5lIGFib3ZlIGlzIGJlY2F1c2UgVHlwZVNjcmlwdCBkb2Vzbid0IHN1cHBvcnRcbiAgICAvLyAgIG5lZ2F0aXZlIGluZGljZXMuXG4gICAgZm9yIChjb25zdCBzaGFwZSBvZiBpbnB1dFNoYXBlcy5zbGljZSgxKSkge1xuICAgICAgaWYgKG91dHB1dFNoYXBlW2F4aXNdID09IG51bGwgfHwgc2hhcGVbYXhpc10gPT0gbnVsbCkge1xuICAgICAgICBvdXRwdXRTaGFwZVtheGlzXSA9IG51bGw7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgb3V0cHV0U2hhcGVbYXhpc10gKz0gc2hhcGVbYXhpc107XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgfVxuXG4gIGNvbXB1dGVNYXNrKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBtYXNrPzogVGVuc29yfFRlbnNvcltdKTogVGVuc29yIHtcbiAgICBpZiAobWFzayA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KG1hc2spKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcignYG1hc2tgIHNob3VsZCBiZSBhbiBhcnJheSBmb3IgQ29uY2F0ZW5hdGUnKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGlucHV0cykpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKCdgaW5wdXRzYCBzaG91bGQgYmUgYW4gYXJyYXkgZm9yIENvbmNhdGVuYXRlJyk7XG4gICAgfVxuICAgIGlmIChtYXNrLmxlbmd0aCAhPT0gaW5wdXRzLmxlbmd0aCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYE1pc21hdGNoIGluIHRoZSBsZW5ndGggb2YgbWFzayAoJHttYXNrLmxlbmd0aH0pIGAgK1xuICAgICAgICAgIGBhbmQgdGhlIGxlZ250aCBvZiBpbnB1dHMgKCR7aW5wdXRzLmxlbmd0aH0pYCk7XG4gICAgfVxuICAgIHJldHVybiB0ZmMudGlkeSgoKSA9PiB7XG4gICAgICBsZXQgYWxsTnVsbE1hc2tzID0gdHJ1ZTtcbiAgICAgIG1hc2suZm9yRWFjaChtID0+IHtcbiAgICAgICAgaWYgKG0gIT0gbnVsbCkge1xuICAgICAgICAgIGFsbE51bGxNYXNrcyA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoYWxsTnVsbE1hc2tzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuICAgICAgY29uc3Qgb3V0cHV0TWFza3M6IFRlbnNvcltdID0gW107XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGlucHV0cy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAobWFza1tpXSA9PSBudWxsKSB7XG4gICAgICAgICAgLy8gSW5wdXQgaXMgdW5tYXNrZWQuIEFwcGVuZCBhbGwgMSdzIHRvIG1hc2tzLlxuICAgICAgICAgIG91dHB1dE1hc2tzLnB1c2godGZjLmNhc3QodGZjLm9uZXNMaWtlKGlucHV0c1tpXSksICdib29sJykpO1xuICAgICAgICB9IGVsc2UgaWYgKG1hc2tbaV0ucmFuayA8IGlucHV0c1tpXS5yYW5rKSB7XG4gICAgICAgICAgLy8gTWFzayBpcyBzbWFsbGVyIHRoYW4gdGhlIGlucHV0LCBleHBhbmQgaXQuXG4gICAgICAgICAgb3V0cHV0TWFza3MucHVzaCh0ZmMuZXhwYW5kRGltcyhtYXNrW2ldLCAtMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dHB1dE1hc2tzLnB1c2gobWFza1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IGNvbmNhdGVuYXRlZE1hc2tzID0gdGZjLmNvbmNhdChvdXRwdXRNYXNrcywgdGhpcy5heGlzKTtcbiAgICAgIHJldHVybiB0ZmMuYWxsKGNvbmNhdGVuYXRlZE1hc2tzLCAtMSwgZmFsc2UpO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7XG4gICAgICAnYXhpcyc6IHRoaXMuYXhpcyxcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKENvbmNhdGVuYXRlKTtcblxuLyoqXG4gKiBDb25jYXRlbmF0ZSBhbiBgQXJyYXlgIG9mIGlucHV0cy5cbiAqXG4gKiBUaGlzIGZ1bmN0aW9uIGNhbiBiZSBpbnZva2VkIGluIHRocmVlIHdheXMuXG4gKlxuICogMS4gQ29uc3RydWN0IGFuIGluc3RhbmNlIG9mIGBDb25jYXRlbmF0ZWAgbGF5ZXIsIGJ5IHVzaW5nIG5vIGlucHV0IGFyZ3VtZW50XG4gKiAgICBvciBhIHNpbmdsZSBjb25maWd1cmF0aW9uIGFyZ3VtZW50LiBUaGUgcmVzdWx0YW50IGBDb25jYXRlbmF0ZWAgbGF5ZXIgY2FuXG4gKiAgICB0aGVuIGJlIHVzZWQgb24gYHRmLlN5bWJvbGljVGVuc29yYHMgb3IgYHRmLlRlbnNvcmBzLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgY29uY2F0TGF5ZXIgPSB0Zi5sYXllcnMuY29uY2F0ZW5hdGUoKTtcbiAqXG4gKiAvLyBUaGUgbGF5ZXIgY2FuIGJlIGFwcGxpZWQgdG8gaW5wdXRzLlxuICogY29uc3QgaW5wdXQxID0gdGYuaW5wdXQoe3NoYXBlOiBbMiwgM119KTtcbiAqIGNvbnN0IGlucHV0MiA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDRdfSk7XG4gKiBjb25zdCBvdXRwdXQgPSBjb25jYXRMYXllci5hcHBseShbaW5wdXQxLCBpbnB1dDJdKTtcbiAqIGNvbnNvbGUubG9nKG91dHB1dC5zaGFwZSk7XG4gKiAvLyBZb3UgZ2V0IFtudWxsLCAyLCA3XSwgd2l0aCB0aGUgZmlyc3QgZGltZW5zaW9uIGFzIHRoZSB1bmRldGVybWluZWQgYmF0Y2hcbiAqIC8vIGRpbWVuc2lvbiBhbmQgdGhlIGxhc3QgZGltZW5zaW9uIGFzIHRoZSByZXN1bHQgb2YgY29uY2F0ZW5hdGluZyB0aGVcbiAqIC8vIGxhc3QgZGltZW5zaW9ucyBvZiB0aGUgdHdvIGlucHV0cy5cbiAqIGBgYFxuICpcbiAqIDIuIEludm9rZSBkaXJlY3RseSBvbiBhbiBgQXJyYXlgIG9mIGB0Zi5TeW1ib2xpY1RlbnNvcmBzLiBUaGlzIGNvbnN0cnVjdHNcbiAqICAgIGFuIGBMYXllcmAgb2JqZWN0IGludGVybmFsbHkgYW5kIGNhbGxzIGl0cyBgYXBwbHlgIG1ldGhvZCBvbiB0aGUgaW5wdXRzLFxuICogICAgZ2VuZXJhdGluZyBhIG5ldyBgdGYuU3ltYm9saWNUZW5zb3JgLiBGb3IgZXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogY29uc3QgaW5wdXQxID0gdGYuaW5wdXQoe3NoYXBlOiBbMiwgM119KTtcbiAqIGNvbnN0IGlucHV0MiA9IHRmLmlucHV0KHtzaGFwZTogWzIsIDRdfSk7XG4gKiBjb25zdCBvdXRwdXQgPSB0Zi5sYXllcnMuY29uY2F0ZW5hdGUoW2lucHV0MSwgaW5wdXQyXSk7XG4gKiBjb25zb2xlLmxvZyhvdXRwdXQuc2hhcGUpO1xuICogLy8gWW91IGdldCBbbnVsbCwgMiwgMl0sIHdpdGggdGhlIGZpcnN0IGRpbWVuc2lvbiBhcyB0aGUgdW5kZXRlcm1pbmVkIGJhdGNoXG4gKiAvLyBkaW1lbnNpb24gYW5kIHRoZSBsYXN0IGRpbWVuc2lvbiBhcyB0aGUgcmVzdWx0IG9mIGNvbmNhdGVuYXRpbmcgdGhlXG4gKiAvLyBsYXN0IGRpbWVuc2lvbnMgb2YgdGhlIHR3byBpbnB1dHMuXG4gKiBgYGBcbiAqXG4gKiAzLiBJbnZva2UgZGlyZWN0bHkgb24gYHRmLlRlbnNvcmBzLCBpLmUuLCBjb25jcmV0ZSB2YWx1ZXMuIFRoaXMgY29uc3RydWN0c1xuICogICAgYW4gYExheWVyYCBvYmplY3QgaW50ZXJuYWxseSBhbmQgY2FsbHMgaXRzIGBhcHBseWAgbWV0aG9kIG9uIHRoZSBpbnB1dHMsXG4gKiAgICBnZW5lcmF0aW5nIGEgbmV3IGB0Zi5UZW5zb3JgIGFzIHRoZSByZXN1bHQgb2YgdGhlIGNvbXB1dGF0aW9uLiBGb3JcbiAqIGV4YW1wbGU6XG4gKlxuICogYGBganNcbiAqIGNvbnN0IGlucHV0MSA9IHRmLnRlbnNvcjJkKFtbMSwgMl0sIFszLCA0XV0sIFsyLCAyXSk7XG4gKiBjb25zdCBpbnB1dDIgPSB0Zi50ZW5zb3IyZChbWzEwLCAyMF0sIFszMCwgNDBdXSwgWzIsIDJdKTtcbiAqIHRmLmxheWVycy5jb25jYXRlbmF0ZShbaW5wdXQxLCBpbnB1dDJdKS5wcmludCgpO1xuICogLy8gR2l2ZXMgW1sxLCAyLCAxMCwgMjBdLCBbMywgNCwgMzAsIDQwXV0uXG4gKlxuICovXG5leHBvcnQgZnVuY3Rpb24gY29uY2F0ZW5hdGUoY29uZmlnPzogU3ltYm9saWNUZW5zb3JbXXxUZW5zb3JbXXxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBDb25jYXRlbmF0ZUxheWVyQXJncyk6IExheWVyfFN5bWJvbGljVGVuc29yfFRlbnNvciB7XG4gIGlmIChBcnJheS5pc0FycmF5KGNvbmZpZykpIHtcbiAgICBjb25zdCBsYXllciA9IG5ldyBDb25jYXRlbmF0ZSh7fSk7XG4gICAgcmV0dXJuIGxheWVyLmFwcGx5KGNvbmZpZykgYXMgU3ltYm9saWNUZW5zb3IgfCBUZW5zb3I7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG5ldyBDb25jYXRlbmF0ZShjb25maWcpO1xuICB9XG59XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBEb3RMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogQXhpcyBvciBheGVzIGFsb25nIHdoaWNoIHRoZSBkb3QgcHJvZHVjdCB3aWxsIGJlIHRha2VuLlxuICAgKlxuICAgKiBJbnRlZ2VyIG9yIGFuIEFycmF5IG9mIGludGVnZXJzLlxuICAgKi9cbiAgYXhlczogbnVtYmVyfFtudW1iZXIsIG51bWJlcl07XG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gTDItbm9ybWFsaXplIHNhbXBsZXMgYWxvbmcgdGhlIGRvdCBwcm9kdWN0IGF4aXNcbiAgICogYmVmb3JlIHRha2luZyB0aGUgZG90IHByb2R1Y3QuXG4gICAqXG4gICAqIElmIHNldCB0byBgdHJ1ZWAsIHRoZSBvdXRwdXQgb2YgdGhlIGRvdCBwcm9kdWN0IGlzdGhlIGNvc2luZVxuICAgKiBwcm94aW1pdHkgYmV0d2VlbiB0aGUgdHdvIHNhbXBsZXMuXG4gICAqL1xuICBub3JtYWxpemU/OiBib29sZWFuO1xufVxuXG4vKipcbiAqIEludGVycHJldGFibGUgcG90ZW50aWFsbHkgbmVnYXRpdmUgYXhpcyBpbmRleC5cbiAqXG4gKiBGb3IgZXhhbXBsZSwgZ2l2ZW4gYXhpcyA9IC0xLCBhbmQgZGltID0gMywgdGhpcyBmdW5jdGlvbiB3aWxsIHJldHVybiAyLlxuICpcbiAqIEBwYXJhbSBheGlzIFRoZSBheGlzIGluZGV4LCBtYXkgYmUgYSBwb3NpdGl2ZSwgemVybyBvciBuZWdhdGl2ZSBpbnRlZ2VyLlxuICogQHBhcmFtIGRpbSBUb3RhbCBudW1iZXIgb2YgZGltZW5zaW9ucywgYSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICogQHJldHVybnMgQSBub24tbmVnYXRpdmUgYXhpcyBpbmRleCBlcXVpdmFsZW50IHRvIHRoZSBpbnB1dCBgYXhpc2AuXG4gKi9cbmZ1bmN0aW9uIGludGVycHJldEF4aXMoYXhpczogbnVtYmVyLCBkaW06IG51bWJlcik6IG51bWJlciB7XG4gIHdoaWxlIChheGlzIDwgMCkge1xuICAgIGF4aXMgKz0gZGltO1xuICB9XG4gIHJldHVybiBheGlzO1xufVxuXG5mdW5jdGlvbiBiYXRjaERvdCh4OiBUZW5zb3IsIHk6IFRlbnNvciwgYXhlczogbnVtYmVyfFtudW1iZXIsIG51bWJlcl0pOiBUZW5zb3Ige1xuICBpZiAoeC5zaGFwZS5sZW5ndGggPiAzIHx8IHkuc2hhcGUubGVuZ3RoID4gMykge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAnYmF0Y2hEb3QgaXMgbm90IGltcGxlbWVudGVkIGZvciB0ZW5zb3JzIG9mIDREIG9yIGhpZ2hlciByYW5rIHlldCcpO1xuICB9XG4gIHRmYy51dGlsLmFzc2VydChcbiAgICAgIHguc2hhcGUubGVuZ3RoID49IDIsXG4gICAgICAoKSA9PiBgYmF0Y2hEb3QgcmVxdWlyZXMgdGhlIHJhbmsgb2YgeCB0byBiZSA+PSAyLCBgICtcbiAgICAgICAgICBgYnV0IGdvdCAke3guc2hhcGUubGVuZ3RofWApO1xuICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICB4LnNoYXBlLmxlbmd0aCA+PSAyLFxuICAgICAgKCkgPT4gYGJhdGNoRG90IHJlcXVpcmVzIHRoZSByYW5rIG9mIHkgdG8gYmUgPj0gMiwgYCArXG4gICAgICAgICAgYGJ1dCBnb3QgJHt5LnNoYXBlLmxlbmd0aH1gKTtcblxuICBpZiAodHlwZW9mIGF4ZXMgPT09ICdudW1iZXInKSB7XG4gICAgYXhlcyA9IFtheGVzLCBheGVzXTtcbiAgfVxuXG4gIGlmICh4LmR0eXBlID09PSAnY29tcGxleDY0JyB8fCB5LmR0eXBlID09PSAnY29tcGxleDY0Jykge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICAnYmF0Y2hEb3QgaXMgbm90IGltcGxlbWVudGVkIGZvciBjb21wbGV4NjQtdHlwZSBUZW5zb3JzIHlldC4nKTtcbiAgfVxuXG4gIGNvbnN0IHhORGltID0geC5zaGFwZS5sZW5ndGg7XG4gIGNvbnN0IHlORGltID0geS5zaGFwZS5sZW5ndGg7XG4gIGlmIChheGVzID09IG51bGwpIHtcbiAgICAvLyBCZWhhdmUgbGlrZSBiYXRjaE1hdG11bCBieSBkZWZhdWx0LlxuICAgIGF4ZXMgPSBbeE5EaW0gLSAxLCB5TkRpbSAtIDJdO1xuICB9XG4gIGNvbnN0IGF4ZXNBcnJheSA9IGF4ZXMgYXMgW251bWJlciwgbnVtYmVyXTtcblxuICByZXR1cm4gdGZjLnRpZHkoKCkgPT4ge1xuICAgIGxldCBkaWZmOiBudW1iZXI7XG4gICAgaWYgKHhORGltID4geU5EaW0pIHtcbiAgICAgIGRpZmYgPSB4TkRpbSAtIHlORGltO1xuICAgICAgY29uc3QgZGlmZlNoYXBlOiBTaGFwZSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBkaWZmOyArK2kpIHtcbiAgICAgICAgZGlmZlNoYXBlLnB1c2goMSk7XG4gICAgICB9XG4gICAgICB5ID0gdGZjLnJlc2hhcGUoeSwgeS5zaGFwZS5jb25jYXQoZGlmZlNoYXBlKSk7XG4gICAgfSBlbHNlIGlmICh5TkRpbSA+IHhORGltKSB7XG4gICAgICBkaWZmID0geU5EaW0gLSB4TkRpbTtcbiAgICAgIGNvbnN0IGRpZmZTaGFwZTogU2hhcGUgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGlmZjsgKytpKSB7XG4gICAgICAgIGRpZmZTaGFwZS5wdXNoKDEpO1xuICAgICAgfVxuICAgICAgeCA9IHRmYy5yZXNoYXBlKHgsIHguc2hhcGUuY29uY2F0KGRpZmZTaGFwZSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICBkaWZmID0gMDtcbiAgICB9XG5cbiAgICBsZXQgb3V0OiBUZW5zb3I7XG4gICAgaWYgKHguc2hhcGUubGVuZ3RoID09PSAyICYmIHkuc2hhcGUubGVuZ3RoID09PSAyKSB7XG4gICAgICBpZiAoYXhlc0FycmF5WzBdID09PSBheGVzQXJyYXlbMV0pIHtcbiAgICAgICAgb3V0ID0gdGZjLnN1bSh0ZmMubXVsKHgsIHkpLCBheGVzQXJyYXlbMF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3V0ID0gdGZjLnN1bSh0ZmMubXVsKHRmYy50cmFuc3Bvc2UoeCwgWzEsIDBdKSwgeSksIGF4ZXNBcnJheVsxXSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGFkalggPSBheGVzQXJyYXlbMF0gIT09IHguc2hhcGUubGVuZ3RoIC0gMTtcbiAgICAgIGNvbnN0IGFkalkgPSBheGVzQXJyYXlbMV0gPT09IHkuc2hhcGUubGVuZ3RoIC0gMTtcbiAgICAgIG91dCA9IHRmYy5tYXRNdWwoeCwgeSwgYWRqWCwgYWRqWSk7XG4gICAgfVxuXG4gICAgaWYgKGRpZmYgPiAwKSB7XG4gICAgICBsZXQgaWR4OiBudW1iZXI7XG4gICAgICBpZiAoeE5EaW0gPiB5TkRpbSkge1xuICAgICAgICBpZHggPSB4TkRpbSArIHlORGltIC0gMztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlkeCA9IHhORGltIC0gMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHNxdWVlemVBeGVzOiBudW1iZXJbXSA9IFtdO1xuICAgICAgZm9yIChsZXQgaSA9IGlkeDsgaSA8IGlkeCArIGRpZmY7ICsraSkge1xuICAgICAgICBzcXVlZXplQXhlcy5wdXNoKGkpO1xuICAgICAgfVxuICAgICAgb3V0ID0gdGZjLnNxdWVlemUob3V0LCBzcXVlZXplQXhlcyk7XG4gICAgfVxuICAgIGlmIChvdXQuc2hhcGUubGVuZ3RoID09PSAxKSB7XG4gICAgICBvdXQgPSB0ZmMuZXhwYW5kRGltcyhvdXQsIDEpO1xuICAgIH1cbiAgICByZXR1cm4gb3V0O1xuICB9KTtcbn1cblxuZXhwb3J0IGNsYXNzIERvdCBleHRlbmRzIE1lcmdlIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnRG90JztcblxuICBwcml2YXRlIGF4ZXM6IG51bWJlcnxbbnVtYmVyLCBudW1iZXJdO1xuICBwcml2YXRlIG5vcm1hbGl6ZTogYm9vbGVhbjtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBEb3RMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLmF4ZXMgPSBhcmdzLmF4ZXM7XG4gICAgdGhpcy5ub3JtYWxpemUgPSBhcmdzLm5vcm1hbGl6ZSA9PSBudWxsID8gZmFsc2UgOiBhcmdzLm5vcm1hbGl6ZTtcbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgdGhpcy5yZXNoYXBlUmVxdWlyZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGJ1aWxkKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiB2b2lkIHtcbiAgICB0ZmMudXRpbC5hc3NlcnQoXG4gICAgICAgIEFycmF5LmlzQXJyYXkoaW5wdXRTaGFwZSkgJiYgaW5wdXRTaGFwZS5sZW5ndGggPT09IDIgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkoaW5wdXRTaGFwZVswXSkgJiYgQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlWzFdKSxcbiAgICAgICAgKCkgPT4gJ0EgYERvdGAgbGF5ZXIgc2hvdWxkIGJlIGNhbGxlZCBvbiBhIGxpc3Qgb2YgZXhhY3RseSAyIGlucHV0cy4nKTtcbiAgICBjb25zdCBzaGFwZTEgPSBpbnB1dFNoYXBlWzBdIGFzIFNoYXBlO1xuICAgIGNvbnN0IHNoYXBlMiA9IGlucHV0U2hhcGVbMV0gYXMgU2hhcGU7XG4gICAgaWYgKHNoYXBlMS5sZW5ndGggPiAzIHx8IHNoYXBlMi5sZW5ndGggPiAzKSB7XG4gICAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcihcbiAgICAgICAgICAnRG90IGxheWVyIGRvZXMgbm90IHN1cHBvcnQgdGVuc29ycyBvZiA0RCBvciBoaWdoZXIgcmFuayB5ZXQuJyk7XG4gICAgfVxuXG4gICAgY29uc3QgYXhlcyA9IHRoaXMuaW50ZXJwcmV0QXhlcyhzaGFwZTEsIHNoYXBlMik7XG4gICAgaWYgKHNoYXBlMVtheGVzWzBdXSAhPT0gc2hhcGUyW2F4ZXNbMV1dKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgRGltZW5zaW9uIGluY29tcGF0aWJpbGl0eTogYCArXG4gICAgICAgICAgYCR7c2hhcGUxW2F4ZXNbMF1dfSAhPT0gJHtzaGFwZTJbYXhlc1sxXV19YCk7XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIG1lcmdlRnVuY3Rpb24oaW5wdXRzOiBUZW5zb3JbXSk6IFRlbnNvciB7XG4gICAgaWYgKGlucHV0cy5sZW5ndGggIT09IDIpIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICdBIGBEb3RgIGxheWVyIG11c3QgYmUgY2FsbGVkIG9uIGV4YWN0bHkgMiBpbnB1dHMsICcgK1xuICAgICAgICAgIGBidXQgcmVjZWl2ZWQgJHtpbnB1dHMubGVuZ3RofSBpbnB1dChzKS5gKTtcbiAgICB9XG5cbiAgICBsZXQgeDEgPSBpbnB1dHNbMF07XG4gICAgbGV0IHgyID0gaW5wdXRzWzFdO1xuICAgIGxldCBheGVzOiBbbnVtYmVyLCBudW1iZXJdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmF4ZXMpKSB7XG4gICAgICBheGVzID0gW1xuICAgICAgICBpbnRlcnByZXRBeGlzKHRoaXMuYXhlcywgeDEuc2hhcGUubGVuZ3RoKSxcbiAgICAgICAgaW50ZXJwcmV0QXhpcyh0aGlzLmF4ZXMsIHgyLnNoYXBlLmxlbmd0aClcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGF4ZXMgPSB0aGlzLmF4ZXMubWFwKFxuICAgICAgICAgICAgICAgICAoYXhpcywgaSkgPT4gaW50ZXJwcmV0QXhpcyhcbiAgICAgICAgICAgICAgICAgICAgIGF4aXMsIGlucHV0c1tpXS5zaGFwZS5sZW5ndGgpKSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgIH1cbiAgICBpZiAodGhpcy5ub3JtYWxpemUpIHtcbiAgICAgIHgxID0gbDJOb3JtYWxpemUoeDEsIGF4ZXNbMF0pO1xuICAgICAgeDIgPSBsMk5vcm1hbGl6ZSh4MiwgYXhlc1sxXSk7XG4gICAgfVxuICAgIHJldHVybiBiYXRjaERvdCh4MSwgeDIsIGF4ZXMpO1xuICB9XG5cbiAgcHJpdmF0ZSBpbnRlcnByZXRBeGVzKHNoYXBlMTogU2hhcGUsIHNoYXBlMjogU2hhcGUpOiBudW1iZXJbXSB7XG4gICAgbGV0IGF4ZXM6IG51bWJlcltdO1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLmF4ZXMpKSB7XG4gICAgICAvLyBgdGhpcy5heGVzYCBpcyBhIHNpbmdsZSBpbnRlZ2VyLlxuICAgICAgYXhlcyA9IFtcbiAgICAgICAgaW50ZXJwcmV0QXhpcyh0aGlzLmF4ZXMsIHNoYXBlMS5sZW5ndGgpLFxuICAgICAgICBpbnRlcnByZXRBeGlzKHRoaXMuYXhlcywgc2hhcGUyLmxlbmd0aClcbiAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGB0aGlzLmF4ZXNgIGlzIGFuIEFycmF5IG9mIGludGVnZXJzLlxuICAgICAgYXhlcyA9IHRoaXMuYXhlcztcbiAgICB9XG4gICAgcmV0dXJuIGF4ZXM7XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIHRmYy51dGlsLmFzc2VydChcbiAgICAgICAgQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlKSAmJiBpbnB1dFNoYXBlLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShpbnB1dFNoYXBlWzBdKSAmJiBBcnJheS5pc0FycmF5KGlucHV0U2hhcGVbMV0pLFxuICAgICAgICAoKSA9PiAnQSBgRG90YCBsYXllciBzaG91bGQgYmUgY2FsbGVkIG9uIGEgbGlzdCBvZiBleGFjdGx5IDIgaW5wdXRzLicpO1xuICAgIGNvbnN0IHNoYXBlMSA9IChpbnB1dFNoYXBlWzBdIGFzIFNoYXBlKS5zbGljZSgpO1xuICAgIGNvbnN0IHNoYXBlMiA9IChpbnB1dFNoYXBlWzFdIGFzIFNoYXBlKS5zbGljZSgpO1xuICAgIGlmIChzaGFwZTEubGVuZ3RoID4gMyB8fCBzaGFwZTIubGVuZ3RoID4gMykge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ0RvdCBsYXllciBkb2VzIG5vdCBzdXBwb3J0IHRlbnNvcnMgb2YgNEQgb3IgaGlnaGVyIHJhbmsgeWV0LicpO1xuICAgIH1cblxuICAgIGNvbnN0IGF4ZXMgPSB0aGlzLmludGVycHJldEF4ZXMoc2hhcGUxLCBzaGFwZTIpO1xuICAgIHNoYXBlMS5zcGxpY2UoYXhlc1swXSwgMSk7XG4gICAgc2hhcGUyLnNwbGljZShheGVzWzFdLCAxKTtcbiAgICBzaGFwZTIuc3BsaWNlKDAsIDEpO1xuICAgIGNvbnN0IG91dHB1dFNoYXBlID0gc2hhcGUxLmNvbmNhdChzaGFwZTIpO1xuICAgIGlmIChvdXRwdXRTaGFwZS5sZW5ndGggPT09IDEpIHtcbiAgICAgIG91dHB1dFNoYXBlLnB1c2goMSk7XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXRTaGFwZTtcbiAgfVxuXG4gIGNvbXB1dGVNYXNrKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBtYXNrPzogVGVuc29yfFRlbnNvcltdKTogVGVuc29yIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge1xuICAgICAgJ2F4ZXMnOiB0aGlzLmF4ZXMsXG4gICAgICAnbm9ybWFsaXplJzogdGhpcy5ub3JtYWxpemVcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKERvdCk7XG5cbi8vIFRPRE8oY2Fpcyk6IEFkZCBmdW5jdGlvbmFsIGludGVyZmFjZXMgZm9yIHRoZSBtZXJnZSBsYXllcnMuXG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Noise Layers.\n */\nimport { add, greaterEqual, mul, randomUniform, serialization, tidy } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { Layer } from '../engine/topology';\nimport { getExactlyOneTensor } from '../utils/types_utils';\nexport class GaussianNoise extends Layer {\n    constructor(args) {\n        super(args);\n        this.supportsMasking = true;\n        this.stddev = args.stddev;\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const config = { stddev: this.stddev };\n        Object.assign(config, baseConfig);\n        return config;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            const input = getExactlyOneTensor(inputs);\n            const noised = () => add(K.randomNormal(input.shape, 0, this.stddev), input);\n            const output = K.inTrainPhase(noised, () => input, kwargs['training'] || false);\n            return output;\n        });\n    }\n}\n/** @nocollapse */\nGaussianNoise.className = 'GaussianNoise';\nserialization.registerClass(GaussianNoise);\nexport class GaussianDropout extends Layer {\n    constructor(args) {\n        super(args);\n        this.supportsMasking = true;\n        this.rate = args.rate;\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const config = { rate: this.rate };\n        Object.assign(config, baseConfig);\n        return config;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            const input = getExactlyOneTensor(inputs);\n            if (this.rate > 0 && this.rate < 1) {\n                const noised = () => {\n                    const stddev = Math.sqrt(this.rate / (1 - this.rate));\n                    return mul(input, K.randomNormal(input.shape, 1, stddev));\n                };\n                return K.inTrainPhase(noised, () => input, kwargs['training'] || false);\n            }\n            return input;\n        });\n    }\n}\n/** @nocollapse */\nGaussianDropout.className = 'GaussianDropout';\nserialization.registerClass(GaussianDropout);\n/**\n * Applies Alpha Dropout to the input.\n *\n * As it is a regularization layer, it is only active at training time.\n *\n * Alpha Dropout is a `Dropout` that keeps mean and variance of inputs\n * to their original values, in order to ensure the self-normalizing property\n * even after this dropout.\n * Alpha Dropout fits well to Scaled Exponential Linear Units\n * by randomly setting activations to the negative saturation value.\n *\n * Arguments:\n *   - `rate`: float, drop probability (as with `Dropout`).\n *     The multiplicative noise will have\n *     standard deviation `sqrt(rate / (1 - rate))`.\n *   - `noise_shape`: A 1-D `Tensor` of type `int32`, representing the\n *     shape for randomly generated keep/drop flags.\n *\n * Input shape:\n *   Arbitrary. Use the keyword argument `inputShape`\n *   (tuple of integers, does not include the samples axis)\n *   when using this layer as the first layer in a model.\n *\n * Output shape:\n *   Same shape as input.\n *\n * References:\n *   - [Self-Normalizing Neural Networks](https://arxiv.org/abs/1706.02515)\n */\nexport class AlphaDropout extends Layer {\n    constructor(args) {\n        super(args);\n        this.supportsMasking = true;\n        this.rate = args.rate;\n        this.noiseShape = args.noiseShape;\n    }\n    _getNoiseShape(inputs) {\n        return this.noiseShape || getExactlyOneTensor(inputs).shape;\n    }\n    computeOutputShape(inputShape) {\n        return inputShape;\n    }\n    getConfig() {\n        const baseConfig = super.getConfig();\n        const config = { rate: this.rate };\n        Object.assign(config, baseConfig);\n        return config;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            if (this.rate < 1 && this.rate > 0) {\n                const noiseShape = this._getNoiseShape(inputs);\n                const droppedInputs = () => {\n                    const input = getExactlyOneTensor(inputs);\n                    const alpha = 1.6732632423543772848170429916717;\n                    const scale = 1.0507009873554804934193349852946;\n                    const alphaP = -alpha * scale;\n                    let keptIdx = greaterEqual(randomUniform(noiseShape), this.rate);\n                    keptIdx = K.cast(keptIdx, 'float32'); // get default dtype.\n                    // Get affine transformation params.\n                    const a = ((1 - this.rate) * (1 + this.rate * alphaP ** 2)) ** -0.5;\n                    const b = -a * alphaP * this.rate;\n                    // Apply mask.\n                    const x = add(mul(input, keptIdx), mul(add(keptIdx, -1), alphaP));\n                    return add(mul(x, a), b);\n                };\n                return K.inTrainPhase(droppedInputs, () => getExactlyOneTensor(inputs), kwargs['training'] || false);\n            }\n            return inputs;\n        });\n    }\n}\n/** @nocollapse */\nAlphaDropout.className = 'AlphaDropout';\nserialization.registerClass(AlphaDropout);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9pc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvbGF5ZXJzL25vaXNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEVBQUMsR0FBRyxFQUFFLFlBQVksRUFBRSxHQUFHLEVBQUUsYUFBYSxFQUFFLGFBQWEsRUFBVSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUV6RyxPQUFPLEtBQUssQ0FBQyxNQUFNLHlCQUF5QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxLQUFLLEVBQVksTUFBTSxvQkFBb0IsQ0FBQztBQUdwRCxPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQU96RCxNQUFNLE9BQU8sYUFBYyxTQUFRLEtBQUs7SUFLdEMsWUFBWSxJQUF1QjtRQUNqQyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDWixJQUFJLENBQUMsZUFBZSxHQUFHLElBQUksQ0FBQztRQUM1QixJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUM7SUFDNUIsQ0FBQztJQUVELGtCQUFrQixDQUFDLFVBQXlCO1FBQzFDLE9BQU8sVUFBVSxDQUFDO0lBQ3BCLENBQUM7SUFFRCxTQUFTO1FBQ1AsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JDLE1BQU0sTUFBTSxHQUFHLEVBQUMsTUFBTSxFQUFFLElBQUksQ0FBQyxNQUFNLEVBQUMsQ0FBQztRQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNsQyxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsSUFBSSxDQUFDLE1BQXVCLEVBQUUsTUFBYztRQUMxQyxPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7WUFDZixJQUFJLENBQUMsY0FBYyxDQUFDLE1BQU0sRUFB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LEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxPQUFPLEVBQUUsU0FBUyxDQUFDLENBQUMsQ0FBRSxxQkFBcUI7b0JBRTVELG9DQUFvQztvQkFDcEMsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUMsR0FBRyxJQUFJLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsSUFBSSxDQUFDLElBQUksR0FBRyxNQUFNLElBQUksQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQztvQkFDcEUsTUFBTSxDQUFDLEdBQUcsQ0FBQyxDQUFDLEdBQUcsTUFBTSxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7b0JBRWxDLGNBQWM7b0JBQ2QsTUFBTSxDQUFDLEdBQUcsR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsT0FBTyxDQUFDLEVBQUUsR0FBRyxDQUFDLEdBQUcsQ0FBQyxPQUFPLEVBQUUsQ0FBQyxDQUFDLENBQUMsRUFBRSxNQUFNLENBQUMsQ0FBQyxDQUFDO29CQUVsRSxPQUFPLEdBQUcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO2dCQUMzQixDQUFDLENBQUM7Z0JBQ0YsT0FBTyxDQUFDLENBQUMsWUFBWSxDQUNqQixhQUFhLEVBQUUsR0FBRyxFQUFFLENBQUMsbUJBQW1CLENBQUMsTUFBTSxDQUFDLEVBQ2hELE1BQU0sQ0FBQyxVQUFVLENBQUMsSUFBSSxLQUFLLENBQUMsQ0FBQzthQUNsQztZQUNELE9BQU8sTUFBTSxDQUFDO1FBQ2hCLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7QUEzREQsa0JBQWtCO0FBQ1gsc0JBQVMsR0FBRyxjQUFjLENBQUM7QUE0RHBDLGFBQWEsQ0FBQyxhQUFhLENBQUMsWUFBWSxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQGxpY2Vuc2VcclxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xyXG4gKlxyXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcclxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XHJcbiAqIGh0dHBzOi8vb3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvTUlULlxyXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBUZW5zb3JGbG93LmpzIExheWVyczogTm9pc2UgTGF5ZXJzLlxyXG4gKi9cclxuXHJcbmltcG9ydCB7YWRkLCBncmVhdGVyRXF1YWwsIG11bCwgcmFuZG9tVW5pZm9ybSwgc2VyaWFsaXphdGlvbiwgVGVuc29yLCB0aWR5fSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xyXG5cclxuaW1wb3J0ICogYXMgSyBmcm9tICcuLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XHJcbmltcG9ydCB7TGF5ZXIsIExheWVyQXJnc30gZnJvbSAnLi4vZW5naW5lL3RvcG9sb2d5JztcclxuaW1wb3J0IHtTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XHJcbmltcG9ydCB7S3dhcmdzfSBmcm9tICcuLi90eXBlcyc7XHJcbmltcG9ydCB7Z2V0RXhhY3RseU9uZVRlbnNvcn0gZnJvbSAnLi4vdXRpbHMvdHlwZXNfdXRpbHMnO1xyXG5cclxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIEdhdXNzaWFuTm9pc2VBcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcclxuICAvKiogU3RhbmRhcmQgRGV2aWF0aW9uLiAgKi9cclxuICBzdGRkZXY6IG51bWJlcjtcclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdhdXNzaWFuTm9pc2UgZXh0ZW5kcyBMYXllciB7XHJcbiAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdHYXVzc2lhbk5vaXNlJztcclxuICByZWFkb25seSBzdGRkZXY6IG51bWJlcjtcclxuXHJcbiAgY29uc3RydWN0b3IoYXJnczogR2F1c3NpYW5Ob2lzZUFyZ3MpIHtcclxuICAgIHN1cGVyKGFyZ3MpO1xyXG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5zdGRkZXYgPSBhcmdzLnN0ZGRldjtcclxuICB9XHJcblxyXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XHJcbiAgICByZXR1cm4gaW5wdXRTaGFwZTtcclxuICB9XHJcblxyXG4gIGdldENvbmZpZygpIHtcclxuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcclxuICAgIGNvbnN0IGNvbmZpZyA9IHtzdGRkZXY6IHRoaXMuc3RkZGV2fTtcclxuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcclxuICAgIHJldHVybiBjb25maWc7XHJcbiAgfVxyXG5cclxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XHJcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XHJcbiAgICAgIHRoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xyXG4gICAgICBjb25zdCBpbnB1dCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcclxuICAgICAgY29uc3Qgbm9pc2VkID0gKCkgPT5cclxuICAgICAgICAgIGFkZChLLnJhbmRvbU5vcm1hbChpbnB1dC5zaGFwZSwgMCwgdGhpcy5zdGRkZXYpLCBpbnB1dCk7XHJcbiAgICAgIGNvbnN0IG91dHB1dCA9XHJcbiAgICAgICAgICBLLmluVHJhaW5QaGFzZShub2lzZWQsICgpID0+IGlucHV0LCBrd2FyZ3NbJ3RyYWluaW5nJ10gfHwgZmFsc2UpO1xyXG4gICAgICByZXR1cm4gb3V0cHV0O1xyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHYXVzc2lhbk5vaXNlKTtcclxuXHJcbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBHYXVzc2lhbkRyb3BvdXRBcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcclxuICAvKiogZHJvcCBwcm9iYWJpbGl0eS4gICovXHJcbiAgcmF0ZTogbnVtYmVyO1xyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR2F1c3NpYW5Ecm9wb3V0IGV4dGVuZHMgTGF5ZXIge1xyXG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xyXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnR2F1c3NpYW5Ecm9wb3V0JztcclxuICByZWFkb25seSByYXRlOiBudW1iZXI7XHJcblxyXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IEdhdXNzaWFuRHJvcG91dEFyZ3MpIHtcclxuICAgIHN1cGVyKGFyZ3MpO1xyXG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xyXG4gICAgdGhpcy5yYXRlID0gYXJncy5yYXRlO1xyXG4gIH1cclxuXHJcbiAgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiBTaGFwZXxTaGFwZVtdIHtcclxuICAgIHJldHVybiBpbnB1dFNoYXBlO1xyXG4gIH1cclxuXHJcbiAgZ2V0Q29uZmlnKCkge1xyXG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xyXG4gICAgY29uc3QgY29uZmlnID0ge3JhdGU6IHRoaXMucmF0ZX07XHJcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XHJcbiAgICByZXR1cm4gY29uZmlnO1xyXG4gIH1cclxuXHJcbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xyXG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xyXG4gICAgICB0aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcclxuICAgICAgY29uc3QgaW5wdXQgPSBnZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XHJcbiAgICAgIGlmICh0aGlzLnJhdGUgPiAwICYmIHRoaXMucmF0ZSA8IDEpIHtcclxuICAgICAgICBjb25zdCBub2lzZWQgPSAoKSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBzdGRkZXYgPSBNYXRoLnNxcnQodGhpcy5yYXRlIC8gKDEgLSB0aGlzLnJhdGUpKTtcclxuICAgICAgICAgIHJldHVybiBtdWwoaW5wdXQsIEsucmFuZG9tTm9ybWFsKGlucHV0LnNoYXBlLCAxLCBzdGRkZXYpKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBLLmluVHJhaW5QaGFzZShub2lzZWQsICgpID0+IGlucHV0LCBrd2FyZ3NbJ3RyYWluaW5nJ10gfHwgZmFsc2UpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpbnB1dDtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2F1c3NpYW5Ecm9wb3V0KTtcclxuXHJcbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBBbHBoYURyb3BvdXRBcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcclxuICAvKiogZHJvcCBwcm9iYWJpbGl0eS4gICovXHJcbiAgcmF0ZTogbnVtYmVyO1xyXG4gIC8qKlxyXG4gICAqIEEgMS1EIGBUZW5zb3JgIG9mIHR5cGUgYGludDMyYCwgcmVwcmVzZW50aW5nIHRoZVxyXG4gICAqIHNoYXBlIGZvciByYW5kb21seSBnZW5lcmF0ZWQga2VlcC9kcm9wIGZsYWdzLlxyXG4gICAqL1xyXG4gIG5vaXNlU2hhcGU/OiBTaGFwZTtcclxufVxyXG5cclxuLyoqXHJcbiAqIEFwcGxpZXMgQWxwaGEgRHJvcG91dCB0byB0aGUgaW5wdXQuXHJcbiAqXHJcbiAqIEFzIGl0IGlzIGEgcmVndWxhcml6YXRpb24gbGF5ZXIsIGl0IGlzIG9ubHkgYWN0aXZlIGF0IHRyYWluaW5nIHRpbWUuXHJcbiAqXHJcbiAqIEFscGhhIERyb3BvdXQgaXMgYSBgRHJvcG91dGAgdGhhdCBrZWVwcyBtZWFuIGFuZCB2YXJpYW5jZSBvZiBpbnB1dHNcclxuICogdG8gdGhlaXIgb3JpZ2luYWwgdmFsdWVzLCBpbiBvcmRlciB0byBlbnN1cmUgdGhlIHNlbGYtbm9ybWFsaXppbmcgcHJvcGVydHlcclxuICogZXZlbiBhZnRlciB0aGlzIGRyb3BvdXQuXHJcbiAqIEFscGhhIERyb3BvdXQgZml0cyB3ZWxsIHRvIFNjYWxlZCBFeHBvbmVudGlhbCBMaW5lYXIgVW5pdHNcclxuICogYnkgcmFuZG9tbHkgc2V0dGluZyBhY3RpdmF0aW9ucyB0byB0aGUgbmVnYXRpdmUgc2F0dXJhdGlvbiB2YWx1ZS5cclxuICpcclxuICogQXJndW1lbnRzOlxyXG4gKiAgIC0gYHJhdGVgOiBmbG9hdCwgZHJvcCBwcm9iYWJpbGl0eSAoYXMgd2l0aCBgRHJvcG91dGApLlxyXG4gKiAgICAgVGhlIG11bHRpcGxpY2F0aXZlIG5vaXNlIHdpbGwgaGF2ZVxyXG4gKiAgICAgc3RhbmRhcmQgZGV2aWF0aW9uIGBzcXJ0KHJhdGUgLyAoMSAtIHJhdGUpKWAuXHJcbiAqICAgLSBgbm9pc2Vfc2hhcGVgOiBBIDEtRCBgVGVuc29yYCBvZiB0eXBlIGBpbnQzMmAsIHJlcHJlc2VudGluZyB0aGVcclxuICogICAgIHNoYXBlIGZvciByYW5kb21seSBnZW5lcmF0ZWQga2VlcC9kcm9wIGZsYWdzLlxyXG4gKlxyXG4gKiBJbnB1dCBzaGFwZTpcclxuICogICBBcmJpdHJhcnkuIFVzZSB0aGUga2V5d29yZCBhcmd1bWVudCBgaW5wdXRTaGFwZWBcclxuICogICAodHVwbGUgb2YgaW50ZWdlcnMsIGRvZXMgbm90IGluY2x1ZGUgdGhlIHNhbXBsZXMgYXhpcylcclxuICogICB3aGVuIHVzaW5nIHRoaXMgbGF5ZXIgYXMgdGhlIGZpcnN0IGxheWVyIGluIGEgbW9kZWwuXHJcbiAqXHJcbiAqIE91dHB1dCBzaGFwZTpcclxuICogICBTYW1lIHNoYXBlIGFzIGlucHV0LlxyXG4gKlxyXG4gKiBSZWZlcmVuY2VzOlxyXG4gKiAgIC0gW1NlbGYtTm9ybWFsaXppbmcgTmV1cmFsIE5ldHdvcmtzXShodHRwczovL2FyeGl2Lm9yZy9hYnMvMTcwNi4wMjUxNSlcclxuICovXHJcbmV4cG9ydCBjbGFzcyBBbHBoYURyb3BvdXQgZXh0ZW5kcyBMYXllciB7XHJcbiAgLyoqIEBub2NvbGxhcHNlICovXHJcbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdBbHBoYURyb3BvdXQnO1xyXG4gIHJlYWRvbmx5IHJhdGU6IG51bWJlcjtcclxuICByZWFkb25seSBub2lzZVNoYXBlOiBTaGFwZTtcclxuXHJcbiAgY29uc3RydWN0b3IoYXJnczogQWxwaGFEcm9wb3V0QXJncykge1xyXG4gICAgc3VwZXIoYXJncyk7XHJcbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XHJcbiAgICB0aGlzLnJhdGUgPSBhcmdzLnJhdGU7XHJcbiAgICB0aGlzLm5vaXNlU2hhcGUgPSBhcmdzLm5vaXNlU2hhcGU7XHJcbiAgfVxyXG5cclxuICBfZ2V0Tm9pc2VTaGFwZShpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSkge1xyXG4gICAgcmV0dXJuIHRoaXMubm9pc2VTaGFwZSB8fCBnZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cykuc2hhcGU7XHJcbiAgfVxyXG5cclxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xyXG4gICAgcmV0dXJuIGlucHV0U2hhcGU7XHJcbiAgfVxyXG5cclxuICBnZXRDb25maWcoKSB7XHJcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XHJcbiAgICBjb25zdCBjb25maWcgPSB7cmF0ZTogdGhpcy5yYXRlfTtcclxuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcclxuICAgIHJldHVybiBjb25maWc7XHJcbiAgfVxyXG5cclxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XHJcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XHJcbiAgICAgIGlmICh0aGlzLnJhdGUgPCAxICYmIHRoaXMucmF0ZSA+IDApIHtcclxuICAgICAgICBjb25zdCBub2lzZVNoYXBlID0gdGhpcy5fZ2V0Tm9pc2VTaGFwZShpbnB1dHMpO1xyXG5cclxuICAgICAgICBjb25zdCBkcm9wcGVkSW5wdXRzID0gKCkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgaW5wdXQgPSBnZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XHJcblxyXG4gICAgICAgICAgY29uc3QgYWxwaGEgPSAxLjY3MzI2MzI0MjM1NDM3NzI4NDgxNzA0Mjk5MTY3MTc7XHJcbiAgICAgICAgICBjb25zdCBzY2FsZSA9IDEuMDUwNzAwOTg3MzU1NDgwNDkzNDE5MzM0OTg1Mjk0NjtcclxuXHJcbiAgICAgICAgICBjb25zdCBhbHBoYVAgPSAtYWxwaGEgKiBzY2FsZTtcclxuXHJcbiAgICAgICAgICBsZXQga2VwdElkeCA9IGdyZWF0ZXJFcXVhbChyYW5kb21Vbmlmb3JtKG5vaXNlU2hhcGUpLCB0aGlzLnJhdGUpO1xyXG5cclxuICAgICAgICAgIGtlcHRJZHggPSBLLmNhc3Qoa2VwdElkeCwgJ2Zsb2F0MzInKTsgIC8vIGdldCBkZWZhdWx0IGR0eXBlLlxyXG5cclxuICAgICAgICAgIC8vIEdldCBhZmZpbmUgdHJhbnNmb3JtYXRpb24gcGFyYW1zLlxyXG4gICAgICAgICAgY29uc3QgYSA9ICgoMSAtIHRoaXMucmF0ZSkgKiAoMSArIHRoaXMucmF0ZSAqIGFscGhhUCAqKiAyKSkgKiogLTAuNTtcclxuICAgICAgICAgIGNvbnN0IGIgPSAtYSAqIGFscGhhUCAqIHRoaXMucmF0ZTtcclxuXHJcbiAgICAgICAgICAvLyBBcHBseSBtYXNrLlxyXG4gICAgICAgICAgY29uc3QgeCA9IGFkZChtdWwoaW5wdXQsIGtlcHRJZHgpLCBtdWwoYWRkKGtlcHRJZHgsIC0xKSwgYWxwaGFQKSk7XHJcblxyXG4gICAgICAgICAgcmV0dXJuIGFkZChtdWwoeCwgYSksIGIpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIEsuaW5UcmFpblBoYXNlKFxyXG4gICAgICAgICAgICBkcm9wcGVkSW5wdXRzLCAoKSA9PiBnZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyksXHJcbiAgICAgICAgICAgIGt3YXJnc1sndHJhaW5pbmcnXSB8fCBmYWxzZSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGlucHV0cztcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQWxwaGFEcm9wb3V0KTtcclxuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Normalization layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { moments, reshape, serialization, tidy, util } from '@tensorflow/tfjs-core';\nimport { getConstraint, serializeConstraint } from '../constraints';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { getInitializer, serializeInitializer } from '../initializers';\nimport { getRegularizer, serializeRegularizer } from '../regularizers';\nimport * as generic_utils from '../utils/generic_utils';\nimport * as math_utils from '../utils/math_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\n/**\n * Applies batch normalization on x given mean, var, beta and gamma.\n *\n * I.e. returns:\n *   `output = (x - mean) / (sqrt(var) + epsilon) * gamma + beta`\n *\n * @param x Input tensor.\n * @param mean Mean of batch.\n * @param variance Variance of batch.\n * @param beta Tensor with which to center the input.\n * @param gamma Tensor by which to scale the input.\n * @param epsilon Fuzz factor.\n * @returns The result of the batch normalization.\n */\nexport function batchNormalization(x, mean, variance, beta, gamma, epsilon = 1e-3) {\n    let out;\n    if (x.rank === 2) {\n        out = tfc.batchNorm2d(x, mean, variance, beta, gamma, epsilon);\n    }\n    else if (x.rank === 3) {\n        // TODO(cais): Check rank; give proper error message.\n        out = tfc.batchNorm3d(x, mean, variance, beta, gamma, epsilon);\n    }\n    else if (x.rank === 4) {\n        out = tfc.batchNorm4d(x, mean, variance, beta, gamma, epsilon);\n    }\n    else {\n        throw new NotImplementedError(`batchNormalization is not implemented for array of rank ${x.rank} ` +\n            `yet`);\n    }\n    return out;\n}\n/**\n * Non-broadcasting batch normalization for use in training (not inference).\n *\n * The input is normalized to zero mean and unit variance along the\n * `reductionAxes`, followed by scaling with `gamma` and shifted by `beta`.\n * The result of that is returned as the first element\n * of the returned `Array`. The other two elements are the mean and variance,\n * respectively.\n *\n * @param x Input tensor to be normalized.\n * @param gamma Tensor by which to scale the input.\n * @param beta Tensor by which to center the input.\n * @param reductionAxes Axes over which to normalize.\n * @param epsilon Fuzz factor.\n * @returns An `Array` of three `Tensors`:\n *   [normalized tensor, mean of input, variance of input].\n */\nfunction regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon = 1e-3) {\n    return tidy(() => {\n        const meanAndVariance = tfc.moments(x, reductionAxes);\n        const mean = meanAndVariance.mean;\n        const variance = meanAndVariance.variance;\n        const normed = batchNormalization(x, mean, variance, beta, gamma, epsilon);\n        return [normed, mean, variance];\n    });\n}\n/**\n * Broadcasting batch normalization for use in training (not inference).\n *\n * The input is normalized to zero mean and unit variance along the\n * `reductionAxes`, followed by scaling with `gamma` and shifted by `beta`.\n * The result of that is returned as the first element\n * of the returned `Array`. The other two elements are the mean and variance,\n * respectively.\n *\n * @param x Input tensor to be normalized.\n * @param gamma Tensor by which to scale the input.\n * @param beta Tensor by which to center the input.\n * @param reductionAxes Axes over which to normalize.\n * @param epsilon Fuzz factor.\n * @returns An `Array` of three `Tensors`:\n *   [normalized tensor, mean of input, variance of input].\n */\nfunction broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon = 1e-3) {\n    return tidy(() => {\n        const meanAndVariance = tfc.moments(x, reductionAxes);\n        const mean = meanAndVariance.mean;\n        const variance = meanAndVariance.variance;\n        const targetShape = [];\n        for (const axis of math_utils.range(0, x.rank)) {\n            if (reductionAxes.indexOf(axis) !== -1) {\n                targetShape.push(1);\n            }\n            else {\n                targetShape.push(x.shape[axis]);\n            }\n        }\n        const broadcastMean = reshape(mean, targetShape);\n        const broadcastVariance = reshape(variance, targetShape);\n        const broadcastGamma = gamma == null ? null : reshape(gamma, targetShape);\n        const broadcastBeta = beta == null ? null : reshape(beta, targetShape);\n        const normed = batchNormalization(x, broadcastMean, broadcastVariance, broadcastBeta, broadcastGamma, epsilon);\n        return [normed, mean, variance];\n    });\n}\n/**\n * Batch normalization for use in training (not inference).\n *\n * @param x Input tensor to be normalized.\n * @param gamma Tensor by which to scale the input.\n * @param beta Tensor by which to center the input.\n * @param reductionAxes Axes over which to normalize.\n * @param epsilon Fuzz factor.\n * @returns An `Array` of three `Tensors`:\n *   [normalized tensor, mean of input, variance of input].\n */\nexport function normalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon = 1e-3) {\n    if (util.arraysEqual(reductionAxes.slice().sort(), math_utils.range(0, x.rank - 1))) {\n        return regularNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon);\n    }\n    else {\n        return broadcastNormalizeBatchInTraining(x, gamma, beta, reductionAxes, epsilon);\n    }\n}\nexport class BatchNormalization extends Layer {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        super(args);\n        this.supportsMasking = true;\n        this.axis = args.axis == null ? -1 : args.axis;\n        this.momentum = args.momentum == null ? 0.99 : args.momentum;\n        this.epsilon = args.epsilon == null ? 1e-3 : args.epsilon;\n        this.center = args.center == null ? true : args.center;\n        this.scale = args.scale == null ? true : args.scale;\n        this.betaInitializer = getInitializer(args.betaInitializer || 'zeros');\n        this.gammaInitializer = getInitializer(args.gammaInitializer || 'ones');\n        this.movingMeanInitializer =\n            getInitializer(args.movingMeanInitializer || 'zeros');\n        this.movingVarianceInitializer =\n            getInitializer(args.movingVarianceInitializer || 'ones');\n        this.betaConstraint = getConstraint(args.betaConstraint);\n        this.gammaConstraint = getConstraint(args.gammaConstraint);\n        this.betaRegularizer = getRegularizer(args.betaRegularizer);\n        this.gammaRegularizer = getRegularizer(args.gammaRegularizer);\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const axis = this.axis >= 0 ? this.axis : (this.axis + inputShape.length);\n        const dim = inputShape[axis];\n        if (dim == null) {\n            throw new ValueError(`Axis ${axis} of input tensor should have a defined dimension but ` +\n                `the layer received an input with shape ` +\n                `${JSON.stringify(inputShape)}.`);\n        }\n        this.inputSpec =\n            [new InputSpec({ ndim: inputShape.length, axes: { [axis]: dim } })];\n        const shape = [dim];\n        if (this.scale) {\n            this.gamma = this.addWeight('gamma', shape, null, this.gammaInitializer, this.gammaRegularizer, true, this.gammaConstraint);\n        }\n        if (this.center) {\n            this.beta = this.addWeight('beta', shape, null, this.betaInitializer, this.betaRegularizer, true, this.betaConstraint);\n        }\n        this.movingMean = this.addWeight('moving_mean', shape, null, this.movingMeanInitializer, null, false);\n        this.movingVariance = this.addWeight('moving_variance', shape, null, this.movingVarianceInitializer, null, false);\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const training = kwargs['training'] == null ? false : kwargs['training'];\n            const input = getExactlyOneTensor(inputs);\n            const inputShape = input.shape;\n            const ndim = inputShape.length;\n            const reductionAxes = math_utils.range(0, ndim);\n            const axis = this.axis >= 0 ? this.axis : (this.axis + ndim);\n            reductionAxes.splice(axis, 1);\n            const broadcastShape = generic_utils.pyListRepeat(1, ndim);\n            broadcastShape[axis] = inputShape[axis];\n            const sortedReductionAxes = reductionAxes.slice();\n            sortedReductionAxes.sort();\n            const needsBroadcasting = !util.arraysEqual(sortedReductionAxes, math_utils.range(0, ndim).slice(0, ndim - 1));\n            const normalizeInference = () => {\n                if (needsBroadcasting) {\n                    const broadcastMovingMean = reshape(this.movingMean.read(), broadcastShape);\n                    const broadcastMovingVariance = reshape(this.movingVariance.read(), broadcastShape);\n                    const broadcastBeta = this.center ? reshape(this.beta.read(), broadcastShape) : null;\n                    const broadcastGamma = this.scale ? reshape(this.gamma.read(), broadcastShape) : null;\n                    return batchNormalization(input, broadcastMovingMean, broadcastMovingVariance, broadcastBeta, broadcastGamma, this.epsilon);\n                }\n                else {\n                    return batchNormalization(input, this.movingMean.read(), this.movingVariance.read(), this.beta == null ? null : this.beta.read(), this.gamma == null ? null : this.gamma.read(), this.epsilon);\n                }\n            };\n            if (!training) {\n                return normalizeInference();\n            }\n            const [normedTraining, mean, variance] = normalizeBatchInTraining(input, this.gamma.read(), this.beta.read(), reductionAxes, this.epsilon);\n            const doMovingAverage = (variable, value, momentum) => {\n                tfc.tidy(() => {\n                    const decay = 1 - momentum;\n                    const origValue = variable.read();\n                    const updateDelta = tfc.mul(tfc.sub(origValue, value), decay);\n                    variable.write(tfc.sub(origValue, updateDelta));\n                });\n            };\n            // Perform updates to moving mean and moving variance for training.\n            // Porting Note: In PyKeras, these updates to `movingMean` and\n            //   `movingAverage` are done as a deferred Graph, added to the `Layer`'s\n            //   `update`s using the `add_update()` method. Here we do it imperatively\n            //   and encapsulate the updates in a function that is invoked\n            //   immediately.\n            const updateMovingMeanAndVariance = () => {\n                doMovingAverage(this.movingMean, mean, this.momentum);\n                doMovingAverage(this.movingVariance, variance, this.momentum);\n            };\n            updateMovingMeanAndVariance();\n            return normedTraining;\n        });\n    }\n    getConfig() {\n        const config = {\n            axis: this.axis,\n            momentum: this.momentum,\n            epsilon: this.epsilon,\n            center: this.center,\n            scale: this.scale,\n            betaInitializer: serializeInitializer(this.betaInitializer),\n            gammaInitializer: serializeInitializer(this.gammaInitializer),\n            movingMeanInitializer: serializeInitializer(this.movingMeanInitializer),\n            movingVarianceInitializer: serializeInitializer(this.movingVarianceInitializer),\n            betaRegularizer: serializeRegularizer(this.betaRegularizer),\n            gammaRegularizer: serializeRegularizer(this.gammaRegularizer),\n            betaConstraint: serializeConstraint(this.betaConstraint),\n            gammaConstraint: serializeConstraint(this.gammaConstraint)\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nBatchNormalization.className = 'BatchNormalization';\nserialization.registerClass(BatchNormalization);\nexport class LayerNormalization extends Layer {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        super(args);\n        this.axis = args.axis == null ? -1 : args.axis;\n        if (typeof this.axis === 'number') {\n            if (!Number.isInteger(this.axis)) {\n                throw new Error(`Expected axis to be an integer, but received ${this.axis}`);\n            }\n        }\n        else if (Array.isArray(this.axis)) {\n            for (const axis of this.axis) {\n                if (!Number.isInteger(axis)) {\n                    throw new Error(`Expected axis to be an array of integers, ` +\n                        `but received ${JSON.stringify(this.axis)}`);\n                }\n            }\n        }\n        else {\n            throw new Error(`Expected axis to be an integer or an array of integers, ` +\n                `but received ${JSON.stringify(this.axis)}`);\n        }\n        this.epsilon = args.epsilon == null ? 1e-3 : args.epsilon;\n        this.center = args.center == null ? true : args.center;\n        this.scale = args.scale == null ? true : args.scale;\n        this.betaInitializer = getInitializer(args.betaInitializer || 'zeros');\n        this.gammaInitializer = getInitializer(args.gammaInitializer || 'ones');\n        this.betaRegularizer = getRegularizer(args.betaRegularizer);\n        this.gammaRegularizer = getRegularizer(args.gammaRegularizer);\n        this.supportsMasking = true;\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const nDims = inputShape.length;\n        // Convert axis to array and resolve negatives.\n        if (typeof this.axis === 'number') {\n            this.axis = [this.axis];\n        }\n        for (let i = 0; i < this.axis.length; ++i) {\n            if (this.axis[i] < 0) {\n                this.axis[i] += nDims;\n            }\n        }\n        // Further validate axes.\n        for (const axis of this.axis) {\n            if (axis < 0 || axis >= nDims) {\n                throw new Error(`Invalid axis: ${axis}`);\n            }\n        }\n        if (this.axis.length !== generic_utils.unique(this.axis).length) {\n            throw new Error(`Found duplicate axes in: ${this.axis}`);\n        }\n        const paramShape = this.axis.map(axis => inputShape[axis]);\n        const trainable = true;\n        if (this.scale) {\n            this.gamma = this.addWeight('gamma', paramShape, 'float32', this.gammaInitializer, this.gammaRegularizer, trainable);\n        }\n        else {\n            this.gamma = null;\n        }\n        if (this.center) {\n            this.beta = this.addWeight('beta', paramShape, 'float32', this.betaInitializer, this.betaRegularizer, trainable);\n        }\n        else {\n            this.beta = null;\n        }\n        this.built = true;\n    }\n    call(inputs, kwargs) {\n        const input = getExactlyOneTensor(inputs);\n        const inputShape = input.shape;\n        const nDims = inputShape.length;\n        return tidy(() => {\n            const keepDims = true;\n            let { mean, variance } = moments(input, this.axis, keepDims);\n            const broadcastShape = generic_utils.pyListRepeat(1, nDims);\n            for (const dim of this.axis) {\n                broadcastShape[dim] = inputShape[dim];\n            }\n            const broadcast = (v) => {\n                if (v != null && v.shape.length !== nDims) {\n                    return tfc.reshape(v, broadcastShape);\n                }\n                else {\n                    return v;\n                }\n            };\n            let scale = this.scale ? broadcast(this.gamma.read()) : null;\n            let offset = this.center ? broadcast(this.beta.read()) : null;\n            // TODO(https://github.com/tensorflow/tfjs/issues/2120): The tiling below\n            // is a workaround for the limitation of core's batchNormalization?d don't\n            // support broadcasting in their gradients. In addition, the tiling is\n            // necessary to ensure correctness on the browser CPU backend regardless\n            // of forward or backward computation. Remove this workaround once the\n            // limitation is addressed. See .\n            const momentsTiling = [];\n            const scaleOffsetTiling = [];\n            for (let i = 0; i < nDims; ++i) {\n                if (this.axis.indexOf(i) !== -1) {\n                    momentsTiling.push(inputShape[i]);\n                    scaleOffsetTiling.push(1);\n                }\n                else {\n                    momentsTiling.push(1);\n                    scaleOffsetTiling.push(inputShape[i]);\n                }\n            }\n            mean = tfc.tile(mean, momentsTiling);\n            variance = tfc.tile(variance, momentsTiling);\n            if (scale != null) {\n                scale = tfc.tile(scale, scaleOffsetTiling);\n            }\n            if (offset != null) {\n                offset = tfc.tile(offset, scaleOffsetTiling);\n            }\n            return batchNormalization(input, mean, variance, offset, scale, this.epsilon);\n        });\n    }\n    getConfig() {\n        const config = {\n            axis: this.axis,\n            epsilon: this.epsilon,\n            center: this.center,\n            scale: this.scale,\n            betaInitializer: serializeInitializer(this.betaInitializer),\n            gammaInitializer: serializeInitializer(this.gammaInitializer),\n            betaRegularizer: serializeRegularizer(this.betaRegularizer),\n            gammaRegularizer: serializeRegularizer(this.gammaRegularizer)\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nLayerNormalization.className = 'LayerNormalization';\nserialization.registerClass(LayerNormalization);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9ybWFsaXphdGlvbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvbm9ybWFsaXphdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxhQUFhLEVBQWtELElBQUksRUFBRSxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVsSSxPQUFPLEVBQW1DLGFBQWEsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLGdCQUFnQixDQUFDO0FBQ3BHLE9BQU8sRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFZLE1BQU0sb0JBQW9CLENBQUM7QUFDL0QsT0FBTyxFQUFDLG1CQUFtQixFQUFFLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUMxRCxPQUFPLEVBQUMsY0FBYyxFQUFzQyxvQkFBb0IsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBRXpHLE9BQU8sRUFBQyxjQUFjLEVBQXNDLG9CQUFvQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFekcsT0FBTyxLQUFLLGFBQWEsTUFBTSx3QkFBd0IsQ0FBQztBQUN4RCxPQUFPLEtBQUssVUFBVSxNQUFNLHFCQUFxQixDQUFDO0FBQ2xELE9BQU8sRUFBQyxrQkFBa0IsRUFBRSxtQkFBbUIsRUFBQyxNQUFNLHNCQUFzQixDQUFDO0FBRzdFOzs7Ozs7Ozs7Ozs7O0dBYUc7QUFDSCxNQUFNLFVBQVUsa0JBQWtCLENBQzlCLENBQVMsRUFBRSxJQUFZLEVBQUUsUUFBZ0IsRUFBRSxJQUFhLEVBQUUsS0FBYyxFQUN4RSxPQUFPLEdBQUcsSUFBSTtJQUNoQixJQUFJLEdBQVcsQ0FBQztJQUNoQixJQUFJLENBQUMsQ0FBQyxJQUFJLEtBQUssQ0FBQyxFQUFFO1FBQ2hCLEdBQUcsR0FB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UUFDUCxNQUFNLE1BQU0sR0FBNkI7WUFDdkMsSUFBSSxFQUFFLElBQUksQ0FBQyxJQUFJO1lBQ2YsT0FBTyxFQUFFLElBQUksQ0FBQyxPQUFPO1lBQ3JCLE1BQU0sRUFBRSxJQUFJLENBQUMsTUFBTTtZQUNuQixLQUFLLEVBQUUsSUFBSSxDQUFDLEtBQUs7WUFDakIsZUFBZSxFQUFFLG9CQUFvQixDQUFDLElBQUksQ0FBQyxlQUFlLENBQUM7WUFDM0QsZ0JBQWdCLEVBQUUsb0JBQW9CLENBQUMsSUFBSSxDQUFDLGdCQUFnQixDQUFDO1lBQzdELGVBQWUsRUFBRSxvQkFBb0IsQ0FBQyxJQUFJLENBQUMsZUFBZSxDQUFDO1lBQzNELGdCQUFnQixFQUFFLG9CQUFvQixDQUFDLElBQUksQ0FBQyxnQkFBZ0IsQ0FBQztTQUM5RCxDQUFDO1FBQ0YsTUFBTSxVQUFVLEdBQUcsS0FBSyxDQUFDLFNBQVMsRUFBRSxDQUFDO1FBQ3JDLE1BQU0sQ0FBQyxNQUFNLENBQUMsTUFBTSxFQUFFLFVBQVUsQ0FBQyxDQUFDO1FBQ2xDLE9BQU8sTUFBTSxDQUFDO0lBQ2hCLENBQUM7O0FBdEtELGtCQUFrQjtBQUNYLDRCQUFTLEdBQUcsb0JBQW9CLENBQUM7QUF1SzFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsa0JBQWtCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogTm9ybWFsaXphdGlvbiBsYXllcnMuXG4gKi9cblxuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge21vbWVudHMsIHJlc2hhcGUsIHNlcmlhbGl6YXRpb24sIFRlbnNvciwgVGVuc29yMUQsIFRlbnNvcjJELCBUZW5zb3IzRCwgVGVuc29yNEQsIHRpZHksIHV0aWx9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7Q29uc3RyYWludCwgQ29uc3RyYWludElkZW50aWZpZXIsIGdldENvbnN0cmFpbnQsIHNlcmlhbGl6ZUNvbnN0cmFpbnR9IGZyb20gJy4uL2NvbnN0cmFpbnRzJztcbmltcG9ydCB7SW5wdXRTcGVjLCBMYXllciwgTGF5ZXJBcmdzfSBmcm9tICcuLi9lbmdpbmUvdG9wb2xvZ3knO1xuaW1wb3J0IHtOb3RJbXBsZW1lbnRlZEVycm9yLCBWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtnZXRJbml0aWFsaXplciwgSW5pdGlhbGl6ZXIsIEluaXRpYWxpemVySWRlbnRpZmllciwgc2VyaWFsaXplSW5pdGlhbGl6ZXJ9IGZyb20gJy4uL2luaXRpYWxpemVycyc7XG5pbXBvcnQge1NoYXBlfSBmcm9tICcuLi9rZXJhc19mb3JtYXQvY29tbW9uJztcbmltcG9ydCB7Z2V0UmVndWxhcml6ZXIsIFJlZ3VsYXJpemVyLCBSZWd1bGFyaXplcklkZW50aWZpZXIsIHNlcmlhbGl6ZVJlZ3VsYXJpemVyfSBmcm9tICcuLi9yZWd1bGFyaXplcnMnO1xuaW1wb3J0IHtLd2FyZ3N9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCAqIGFzIGdlbmVyaWNfdXRpbHMgZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQgKiBhcyBtYXRoX3V0aWxzIGZyb20gJy4uL3V0aWxzL21hdGhfdXRpbHMnO1xuaW1wb3J0IHtnZXRFeGFjdGx5T25lU2hhcGUsIGdldEV4YWN0bHlPbmVUZW5zb3J9IGZyb20gJy4uL3V0aWxzL3R5cGVzX3V0aWxzJztcbmltcG9ydCB7TGF5ZXJWYXJpYWJsZX0gZnJvbSAnLi4vdmFyaWFibGVzJztcblxuLyoqXG4gKiBBcHBsaWVzIGJhdGNoIG5vcm1hbGl6YXRpb24gb24geCBnaXZlbiBtZWFuLCB2YXIsIGJldGEgYW5kIGdhbW1hLlxuICpcbiAqIEkuZS4gcmV0dXJuczpcbiAqICAgYG91dHB1dCA9ICh4IC0gbWVhbikgLyAoc3FydCh2YXIpICsgZXBzaWxvbikgKiBnYW1tYSArIGJldGFgXG4gKlxuICogQHBhcmFtIHggSW5wdXQgdGVuc29yLlxuICogQHBhcmFtIG1lYW4gTWVhbiBvZiBiYXRjaC5cbiAqIEBwYXJhbSB2YXJpYW5jZSBWYXJpYW5jZSBvZiBiYXRjaC5cbiAqIEBwYXJhbSBiZXRhIFRlbnNvciB3aXRoIHdoaWNoIHRvIGNlbnRlciB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gZ2FtbWEgVGVuc29yIGJ5IHdoaWNoIHRvIHNjYWxlIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSBlcHNpbG9uIEZ1enogZmFjdG9yLlxuICogQHJldHVybnMgVGhlIHJlc3VsdCBvZiB0aGUgYmF0Y2ggbm9ybWFsaXphdGlvbi5cbiAqL1xuZXhwb3J0IGZ1bmN0aW9uIGJhdGNoTm9ybWFsaXphdGlvbihcbiAgICB4OiBUZW5zb3IsIG1lYW46IFRlbnNvciwgdmFyaWFuY2U6IFRlbnNvciwgYmV0YT86IFRlbnNvciwgZ2FtbWE/OiBUZW5zb3IsXG4gICAgZXBzaWxvbiA9IDFlLTMpOiBUZW5zb3Ige1xuICBsZXQgb3V0OiBUZW5zb3I7XG4gIGlmICh4LnJhbmsgPT09IDIpIHtcbiAgICBvdXQgPSB0ZmMuYmF0Y2hOb3JtMmQoXG4gICAgICAgIHggYXMgVGVuc29yMkQsIG1lYW4gYXMgVGVuc29yMkQgfCBUZW5zb3IxRCxcbiAgICAgICAgdmFyaWFuY2UgYXMgVGVuc29yMkQgfCBUZW5zb3IxRCwgYmV0YSBhcyBUZW5zb3IyRCB8IFRlbnNvcjFELFxuICAgICAgICBnYW1tYSBhcyBUZW5zb3IyRCB8IFRlbnNvcjFELCBlcHNpbG9uKTtcbiAgfSBlbHNlIGlmICh4LnJhbmsgPT09IDMpIHtcbiAgICAvLyBUT0RPKGNhaXMpOiBDaGVjayByYW5rOyBnaXZlIHByb3BlciBlcnJvciBtZXNzYWdlLlxuICAgIG91dCA9IHRmYy5iYXRjaE5vcm0zZChcbiAgICAgICAgeCBhcyBUZW5zb3IzRCwgbWVhbiBhcyBUZW5zb3IzRCB8IFRlbnNvcjFELFxuICAgICAgICB2YXJpYW5jZSBhcyBUZW5zb3IzRCB8IFRlbnNvcjFELCBiZXRhIGFzIFRlbnNvcjNEIHwgVGVuc29yMUQsXG4gICAgICAgIGdhbW1hIGFzIFRlbnNvcjNEIHwgVGVuc29yMUQsIGVwc2lsb24pO1xuICB9IGVsc2UgaWYgKHgucmFuayA9PT0gNCkge1xuICAgIG91dCA9IHRmYy5iYXRjaE5vcm00ZChcbiAgICAgICAgeCBhcyBUZW5zb3I0RCwgbWVhbiBhcyBUZW5zb3I0RCB8IFRlbnNvcjFELFxuICAgICAgICB2YXJpYW5jZSBhcyBUZW5zb3I0RCB8IFRlbnNvcjFELCBiZXRhIGFzIFRlbnNvcjREIHwgVGVuc29yMUQsXG4gICAgICAgIGdhbW1hIGFzIFRlbnNvcjREIHwgVGVuc29yMUQsIGVwc2lsb24pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBOb3RJbXBsZW1lbnRlZEVycm9yKFxuICAgICAgICBgYmF0Y2hOb3JtYWxpemF0aW9uIGlzIG5vdCBpbXBsZW1lbnRlZCBmb3IgYXJyYXkgb2YgcmFuayAke3gucmFua30gYCArXG4gICAgICAgIGB5ZXRgKTtcbiAgfVxuICByZXR1cm4gb3V0O1xufVxuXG4vKipcbiAqIE5vbi1icm9hZGNhc3RpbmcgYmF0Y2ggbm9ybWFsaXphdGlvbiBmb3IgdXNlIGluIHRyYWluaW5nIChub3QgaW5mZXJlbmNlKS5cbiAqXG4gKiBUaGUgaW5wdXQgaXMgbm9ybWFsaXplZCB0byB6ZXJvIG1lYW4gYW5kIHVuaXQgdmFyaWFuY2UgYWxvbmcgdGhlXG4gKiBgcmVkdWN0aW9uQXhlc2AsIGZvbGxvd2VkIGJ5IHNjYWxpbmcgd2l0aCBgZ2FtbWFgIGFuZCBzaGlmdGVkIGJ5IGBiZXRhYC5cbiAqIFRoZSByZXN1bHQgb2YgdGhhdCBpcyByZXR1cm5lZCBhcyB0aGUgZmlyc3QgZWxlbWVudFxuICogb2YgdGhlIHJldHVybmVkIGBBcnJheWAuIFRoZSBvdGhlciB0d28gZWxlbWVudHMgYXJlIHRoZSBtZWFuIGFuZCB2YXJpYW5jZSxcbiAqIHJlc3BlY3RpdmVseS5cbiAqXG4gKiBAcGFyYW0geCBJbnB1dCB0ZW5zb3IgdG8gYmUgbm9ybWFsaXplZC5cbiAqIEBwYXJhbSBnYW1tYSBUZW5zb3IgYnkgd2hpY2ggdG8gc2NhbGUgdGhlIGlucHV0LlxuICogQHBhcmFtIGJldGEgVGVuc29yIGJ5IHdoaWNoIHRvIGNlbnRlciB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gcmVkdWN0aW9uQXhlcyBBeGVzIG92ZXIgd2hpY2ggdG8gbm9ybWFsaXplLlxuICogQHBhcmFtIGVwc2lsb24gRnV6eiBmYWN0b3IuXG4gKiBAcmV0dXJucyBBbiBgQXJyYXlgIG9mIHRocmVlIGBUZW5zb3JzYDpcbiAqICAgW25vcm1hbGl6ZWQgdGVuc29yLCBtZWFuIG9mIGlucHV0LCB2YXJpYW5jZSBvZiBpbnB1dF0uXG4gKi9cbmZ1bmN0aW9uIHJlZ3VsYXJOb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoXG4gICAgeDogVGVuc29yLCBnYW1tYTogVGVuc29yLCBiZXRhOiBUZW5zb3IsIHJlZHVjdGlvbkF4ZXM6IG51bWJlcltdLFxuICAgIGVwc2lsb24gPSAxZS0zKTogW1RlbnNvciwgVGVuc29yLCBUZW5zb3JdIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgICAgICBjb25zdCBtZWFuQW5kVmFyaWFuY2UgPSB0ZmMubW9tZW50cyh4LCByZWR1Y3Rpb25BeGVzKTtcbiAgICAgICAgICAgY29uc3QgbWVhbiA9IG1lYW5BbmRWYXJpYW5jZS5tZWFuO1xuICAgICAgICAgICBjb25zdCB2YXJpYW5jZSA9IG1lYW5BbmRWYXJpYW5jZS52YXJpYW5jZTtcbiAgICAgICAgICAgY29uc3Qgbm9ybWVkID1cbiAgICAgICAgICAgICAgIGJhdGNoTm9ybWFsaXphdGlvbih4LCBtZWFuLCB2YXJpYW5jZSwgYmV0YSwgZ2FtbWEsIGVwc2lsb24pO1xuICAgICAgICAgICByZXR1cm4gW25vcm1lZCwgbWVhbiwgdmFyaWFuY2VdO1xuICAgICAgICAgfSkgYXMgW1RlbnNvciwgVGVuc29yLCBUZW5zb3JdO1xufVxuXG4vKipcbiAqIEJyb2FkY2FzdGluZyBiYXRjaCBub3JtYWxpemF0aW9uIGZvciB1c2UgaW4gdHJhaW5pbmcgKG5vdCBpbmZlcmVuY2UpLlxuICpcbiAqIFRoZSBpbnB1dCBpcyBub3JtYWxpemVkIHRvIHplcm8gbWVhbiBhbmQgdW5pdCB2YXJpYW5jZSBhbG9uZyB0aGVcbiAqIGByZWR1Y3Rpb25BeGVzYCwgZm9sbG93ZWQgYnkgc2NhbGluZyB3aXRoIGBnYW1tYWAgYW5kIHNoaWZ0ZWQgYnkgYGJldGFgLlxuICogVGhlIHJlc3VsdCBvZiB0aGF0IGlzIHJldHVybmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50XG4gKiBvZiB0aGUgcmV0dXJuZWQgYEFycmF5YC4gVGhlIG90aGVyIHR3byBlbGVtZW50cyBhcmUgdGhlIG1lYW4gYW5kIHZhcmlhbmNlLFxuICogcmVzcGVjdGl2ZWx5LlxuICpcbiAqIEBwYXJhbSB4IElucHV0IHRlbnNvciB0byBiZSBub3JtYWxpemVkLlxuICogQHBhcmFtIGdhbW1hIFRlbnNvciBieSB3aGljaCB0byBzY2FsZSB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gYmV0YSBUZW5zb3IgYnkgd2hpY2ggdG8gY2VudGVyIHRoZSBpbnB1dC5cbiAqIEBwYXJhbSByZWR1Y3Rpb25BeGVzIEF4ZXMgb3ZlciB3aGljaCB0byBub3JtYWxpemUuXG4gKiBAcGFyYW0gZXBzaWxvbiBGdXp6IGZhY3Rvci5cbiAqIEByZXR1cm5zIEFuIGBBcnJheWAgb2YgdGhyZWUgYFRlbnNvcnNgOlxuICogICBbbm9ybWFsaXplZCB0ZW5zb3IsIG1lYW4gb2YgaW5wdXQsIHZhcmlhbmNlIG9mIGlucHV0XS5cbiAqL1xuZnVuY3Rpb24gYnJvYWRjYXN0Tm9ybWFsaXplQmF0Y2hJblRyYWluaW5nKFxuICAgIHg6IFRlbnNvciwgZ2FtbWE6IFRlbnNvciwgYmV0YTogVGVuc29yLCByZWR1Y3Rpb25BeGVzOiBudW1iZXJbXSxcbiAgICBlcHNpbG9uID0gMWUtMyk6IFtUZW5zb3IsIFRlbnNvciwgVGVuc29yXSB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgICAgICAgY29uc3QgbWVhbkFuZFZhcmlhbmNlID0gdGZjLm1vbWVudHMoeCwgcmVkdWN0aW9uQXhlcyk7XG4gICAgICAgICAgIGNvbnN0IG1lYW4gPSBtZWFuQW5kVmFyaWFuY2UubWVhbjtcbiAgICAgICAgICAgY29uc3QgdmFyaWFuY2UgPSBtZWFuQW5kVmFyaWFuY2UudmFyaWFuY2U7XG4gICAgICAgICAgIGNvbnN0IHRhcmdldFNoYXBlOiBudW1iZXJbXSA9IFtdO1xuICAgICAgICAgICBmb3IgKGNvbnN0IGF4aXMgb2YgbWF0aF91dGlscy5yYW5nZSgwLCB4LnJhbmspKSB7XG4gICAgICAgICAgICAgaWYgKHJlZHVjdGlvbkF4ZXMuaW5kZXhPZihheGlzKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgIHRhcmdldFNoYXBlLnB1c2goMSk7XG4gICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgIHRhcmdldFNoYXBlLnB1c2goeC5zaGFwZVtheGlzXSk7XG4gICAgICAgICAgICAgfVxuICAgICAgICAgICB9XG4gICAgICAgICAgIGNvbnN0IGJyb2FkY2FzdE1lYW4gPSByZXNoYXBlKG1lYW4sIHRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgY29uc3QgYnJvYWRjYXN0VmFyaWFuY2UgPSByZXNoYXBlKHZhcmlhbmNlLCB0YXJnZXRTaGFwZSk7XG4gICAgICAgICAgIGNvbnN0IGJyb2FkY2FzdEdhbW1hID1cbiAgICAgICAgICAgICAgIGdhbW1hID09IG51bGwgPyBudWxsIDogcmVzaGFwZShnYW1tYSwgdGFyZ2V0U2hhcGUpO1xuICAgICAgICAgICBjb25zdCBicm9hZGNhc3RCZXRhID1cbiAgICAgICAgICAgICAgIGJldGEgPT0gbnVsbCA/IG51bGwgOiByZXNoYXBlKGJldGEsIHRhcmdldFNoYXBlKTtcbiAgICAgICAgICAgY29uc3Qgbm9ybWVkID0gYmF0Y2hOb3JtYWxpemF0aW9uKFxuICAgICAgICAgICAgICAgeCwgYnJvYWRjYXN0TWVhbiwgYnJvYWRjYXN0VmFyaWFuY2UsIGJyb2FkY2FzdEJldGEsXG4gICAgICAgICAgICAgICBicm9hZGNhc3RHYW1tYSwgZXBzaWxvbik7XG4gICAgICAgICAgIHJldHVybiBbbm9ybWVkLCBtZWFuLCB2YXJpYW5jZV07XG4gICAgICAgICB9KSBhcyBbVGVuc29yLCBUZW5zb3IsIFRlbnNvcl07XG59XG5cbi8qKlxuICogQmF0Y2ggbm9ybWFsaXphdGlvbiBmb3IgdXNlIGluIHRyYWluaW5nIChub3QgaW5mZXJlbmNlKS5cbiAqXG4gKiBAcGFyYW0geCBJbnB1dCB0ZW5zb3IgdG8gYmUgbm9ybWFsaXplZC5cbiAqIEBwYXJhbSBnYW1tYSBUZW5zb3IgYnkgd2hpY2ggdG8gc2NhbGUgdGhlIGlucHV0LlxuICogQHBhcmFtIGJldGEgVGVuc29yIGJ5IHdoaWNoIHRvIGNlbnRlciB0aGUgaW5wdXQuXG4gKiBAcGFyYW0gcmVkdWN0aW9uQXhlcyBBeGVzIG92ZXIgd2hpY2ggdG8gbm9ybWFsaXplLlxuICogQHBhcmFtIGVwc2lsb24gRnV6eiBmYWN0b3IuXG4gKiBAcmV0dXJucyBBbiBgQXJyYXlgIG9mIHRocmVlIGBUZW5zb3JzYDpcbiAqICAgW25vcm1hbGl6ZWQgdGVuc29yLCBtZWFuIG9mIGlucHV0LCB2YXJpYW5jZSBvZiBpbnB1dF0uXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBub3JtYWxpemVCYXRjaEluVHJhaW5pbmcoXG4gICAgeDogVGVuc29yLCBnYW1tYTogVGVuc29yLCBiZXRhOiBUZW5zb3IsIHJlZHVjdGlvbkF4ZXM6IG51bWJlcltdLFxuICAgIGVwc2lsb24gPSAxZS0zKTogW1RlbnNvciwgVGVuc29yLCBUZW5zb3JdIHtcbiAgaWYgKHV0aWwuYXJyYXlzRXF1YWwoXG4gICAgICAgICAgcmVkdWN0aW9uQXhlcy5zbGljZSgpLnNvcnQoKSwgbWF0aF91dGlscy5yYW5nZSgwLCB4LnJhbmsgLSAxKSkpIHtcbiAgICByZXR1cm4gcmVndWxhck5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhcbiAgICAgICAgeCwgZ2FtbWEsIGJldGEsIHJlZHVjdGlvbkF4ZXMsIGVwc2lsb24pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBicm9hZGNhc3ROb3JtYWxpemVCYXRjaEluVHJhaW5pbmcoXG4gICAgICAgIHgsIGdhbW1hLCBiZXRhLCByZWR1Y3Rpb25BeGVzLCBlcHNpbG9uKTtcbiAgfVxufVxuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgQmF0Y2hOb3JtYWxpemF0aW9uTGF5ZXJBcmdzIGV4dGVuZHMgTGF5ZXJBcmdzIHtcbiAgLyoqXG4gICAqIFRoZSBpbnRlZ2VyIGF4aXMgdGhhdCBzaG91bGQgYmUgbm9ybWFsaXplZCAodHlwaWNhbGx5IHRoZSBmZWF0dXJlcyBheGlzKS5cbiAgICogRGVmYXVsdHMgdG8gLTEuXG4gICAqXG4gICAqIEZvciBpbnN0YW5jZSwgYWZ0ZXIgYSBgQ29udjJEYCBsYXllciB3aXRoIGBkYXRhX2Zvcm1hdD1cImNoYW5uZWxzX2ZpcnN0XCJgLFxuICAgKiBzZXQgYGF4aXM9MWAgaW4gYGJhdGNoTm9ybWFsaXphdGlvbmAuXG4gICAqL1xuICBheGlzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBNb21lbnR1bSBvZiB0aGUgbW92aW5nIGF2ZXJhZ2UuIERlZmF1bHRzIHRvIDAuOTkuXG4gICAqL1xuICBtb21lbnR1bT86IG51bWJlcjtcblxuICAvKipcbiAgICogU21hbGwgZmxvYXQgYWRkZWQgdG8gdGhlIHZhcmlhbmNlIHRvIGF2b2lkIGRpdmlkaW5nIGJ5IHplcm8uIERlZmF1bHRzIHRvXG4gICAqIDFlLTMuXG4gICAqL1xuICBlcHNpbG9uPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBJZiBgdHJ1ZWAsIGFkZCBvZmZzZXQgb2YgYGJldGFgIHRvIG5vcm1hbGl6ZWQgdGVuc29yLlxuICAgKiBJZiBgZmFsc2VgLCBgYmV0YWAgaXMgaWdub3JlZC5cbiAgICogRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgY2VudGVyPzogYm9vbGVhbjtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBtdWx0aXBseSBieSBgZ2FtbWFgLlxuICAgKiBJZiBgZmFsc2VgLCBgZ2FtbWFgIGlzIG5vdCB1c2VkLlxuICAgKiBXaGVuIHRoZSBuZXh0IGxheWVyIGlzIGxpbmVhciAoYWxzbyBlLmcuIGBubi5yZWx1YCksXG4gICAqIHRoaXMgY2FuIGJlIGRpc2FibGVkIHNpbmNlIHRoZSBzY2FsaW5nIHdpbGwgYmUgZG9uZSBieSB0aGUgbmV4dCBsYXllci5cbiAgICogRGVmYXVsdHMgdG8gYHRydWVgLlxuICAgKi9cbiAgc2NhbGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBmb3IgdGhlIGJldGEgd2VpZ2h0LlxuICAgKiAgRGVmYXVsdHMgdG8gJ3plcm9zJy5cbiAgICovXG4gIGJldGFJbml0aWFsaXplcj86IEluaXRpYWxpemVySWRlbnRpZmllcnxJbml0aWFsaXplcjtcblxuICAvKipcbiAgICogSW5pdGlhbGl6ZXIgZm9yIHRoZSBnYW1tYSB3ZWlnaHQuXG4gICAqICBEZWZhdWx0cyB0byBgb25lc2AuXG4gICAqL1xuICBnYW1tYUluaXRpYWxpemVyPzogSW5pdGlhbGl6ZXJJZGVudGlmaWVyfEluaXRpYWxpemVyO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBmb3IgdGhlIG1vdmluZyBtZWFuLlxuICAgKiBEZWZhdWx0cyB0byBgemVyb3NgXG4gICAqL1xuICBtb3ZpbmdNZWFuSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXJ8SW5pdGlhbGl6ZXI7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIGZvciB0aGUgbW92aW5nIHZhcmlhbmNlLlxuICAgKiAgRGVmYXVsdHMgdG8gJ09uZXMnLlxuICAgKi9cbiAgbW92aW5nVmFyaWFuY2VJbml0aWFsaXplcj86IEluaXRpYWxpemVySWRlbnRpZmllcnxJbml0aWFsaXplcjtcblxuICAvKipcbiAgICogQ29uc3RyYWludCBmb3IgdGhlIGJldGEgd2VpZ2h0LlxuICAgKi9cbiAgYmV0YUNvbnN0cmFpbnQ/OiBDb25zdHJhaW50SWRlbnRpZmllcnxDb25zdHJhaW50O1xuXG4gIC8qKlxuICAgKiBDb25zdHJhaW50IGZvciBnYW1tYSB3ZWlnaHQuXG4gICAqL1xuICBnYW1tYUNvbnN0cmFpbnQ/OiBDb25zdHJhaW50SWRlbnRpZmllcnxDb25zdHJhaW50O1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmb3IgdGhlIGJldGEgd2VpZ2h0LlxuICAgKi9cbiAgYmV0YVJlZ3VsYXJpemVyPzogUmVndWxhcml6ZXJJZGVudGlmaWVyfFJlZ3VsYXJpemVyO1xuXG4gIC8qKlxuICAgKiBSZWd1bGFyaXplciBmb3IgdGhlIGdhbW1hIHdlaWdodC5cbiAgICovXG4gIGdhbW1hUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXJ8UmVndWxhcml6ZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBCYXRjaE5vcm1hbGl6YXRpb24gZXh0ZW5kcyBMYXllciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ0JhdGNoTm9ybWFsaXphdGlvbic7XG4gIHByaXZhdGUgcmVhZG9ubHkgYXhpczogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IG1vbWVudHVtOiBudW1iZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZXBzaWxvbjogbnVtYmVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGNlbnRlcjogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBzY2FsZTogYm9vbGVhbjtcbiAgcHJpdmF0ZSByZWFkb25seSBiZXRhSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyO1xuICBwcml2YXRlIHJlYWRvbmx5IGdhbW1hSW5pdGlhbGl6ZXI6IEluaXRpYWxpemVyO1xuICBwcml2YXRlIHJlYWRvbmx5IG1vdmluZ01lYW5Jbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgbW92aW5nVmFyaWFuY2VJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgYmV0YUNvbnN0cmFpbnQ6IENvbnN0cmFpbnQ7XG4gIHByaXZhdGUgcmVhZG9ubHkgZ2FtbWFDb25zdHJhaW50OiBDb25zdHJhaW50O1xuICBwcml2YXRlIHJlYWRvbmx5IGJldGFSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG4gIHByaXZhdGUgcmVhZG9ubHkgZ2FtbWFSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG4gIHByaXZhdGUgZ2FtbWE6IExheWVyVmFyaWFibGU7XG4gIHByaXZhdGUgYmV0YTogTGF5ZXJWYXJpYWJsZTtcbiAgcHJpdmF0ZSBtb3ZpbmdNZWFuOiBMYXllclZhcmlhYmxlO1xuICBwcml2YXRlIG1vdmluZ1ZhcmlhbmNlOiBMYXllclZhcmlhYmxlO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBCYXRjaE5vcm1hbGl6YXRpb25MYXllckFyZ3MpIHtcbiAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICBhcmdzID0ge307XG4gICAgfVxuICAgIHN1cGVyKGFyZ3MpO1xuXG4gICAgdGhpcy5zdXBwb3J0c01hc2tpbmcgPSB0cnVlO1xuICAgIHRoaXMuYXhpcyA9IGFyZ3MuYXhpcyA9PSBudWxsID8gLTEgOiBhcmdzLmF4aXM7XG4gICAgdGhpcy5tb21lbnR1bSA9IGFyZ3MubW9tZW50dW0gPT0gbnVsbCA/IDAuOTkgOiBhcmdzLm1vbWVudHVtO1xuICAgIHRoaXMuZXBzaWxvbiA9IGFyZ3MuZXBzaWxvbiA9PSBudWxsID8gMWUtMyA6IGFyZ3MuZXBzaWxvbjtcbiAgICB0aGlzLmNlbnRlciA9IGFyZ3MuY2VudGVyID09IG51bGwgPyB0cnVlIDogYXJncy5jZW50ZXI7XG4gICAgdGhpcy5zY2FsZSA9IGFyZ3Muc2NhbGUgPT0gbnVsbCA/IHRydWUgOiBhcmdzLnNjYWxlO1xuICAgIHRoaXMuYmV0YUluaXRpYWxpemVyID0gZ2V0SW5pdGlhbGl6ZXIoYXJncy5iZXRhSW5pdGlhbGl6ZXIgfHwgJ3plcm9zJyk7XG4gICAgdGhpcy5nYW1tYUluaXRpYWxpemVyID0gZ2V0SW5pdGlhbGl6ZXIoYXJncy5nYW1tYUluaXRpYWxpemVyIHx8ICdvbmVzJyk7XG4gICAgdGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIgPVxuICAgICAgICBnZXRJbml0aWFsaXplcihhcmdzLm1vdmluZ01lYW5Jbml0aWFsaXplciB8fCAnemVyb3MnKTtcbiAgICB0aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIgPVxuICAgICAgICBnZXRJbml0aWFsaXplcihhcmdzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIgfHwgJ29uZXMnKTtcbiAgICB0aGlzLmJldGFDb25zdHJhaW50ID0gZ2V0Q29uc3RyYWludChhcmdzLmJldGFDb25zdHJhaW50KTtcbiAgICB0aGlzLmdhbW1hQ29uc3RyYWludCA9IGdldENvbnN0cmFpbnQoYXJncy5nYW1tYUNvbnN0cmFpbnQpO1xuICAgIHRoaXMuYmV0YVJlZ3VsYXJpemVyID0gZ2V0UmVndWxhcml6ZXIoYXJncy5iZXRhUmVndWxhcml6ZXIpO1xuICAgIHRoaXMuZ2FtbWFSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3MuZ2FtbWFSZWd1bGFyaXplcik7XG4gIH1cblxuICBwdWJsaWMgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgY29uc3QgYXhpcyA9IHRoaXMuYXhpcyA+PSAwID8gdGhpcy5heGlzIDogKHRoaXMuYXhpcyArIGlucHV0U2hhcGUubGVuZ3RoKTtcbiAgICBjb25zdCBkaW0gPSBpbnB1dFNoYXBlW2F4aXNdO1xuICAgIGlmIChkaW0gPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYEF4aXMgJHtheGlzfSBvZiBpbnB1dCB0ZW5zb3Igc2hvdWxkIGhhdmUgYSBkZWZpbmVkIGRpbWVuc2lvbiBidXQgYCArXG4gICAgICAgICAgYHRoZSBsYXllciByZWNlaXZlZCBhbiBpbnB1dCB3aXRoIHNoYXBlIGAgK1xuICAgICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGlucHV0U2hhcGUpfS5gKTtcbiAgICB9XG4gICAgdGhpcy5pbnB1dFNwZWMgPVxuICAgICAgICBbbmV3IElucHV0U3BlYyh7bmRpbTogaW5wdXRTaGFwZS5sZW5ndGgsIGF4ZXM6IHtbYXhpc106IGRpbX19KV07XG4gICAgY29uc3Qgc2hhcGUgPSBbZGltXTtcbiAgICBpZiAodGhpcy5zY2FsZSkge1xuICAgICAgdGhpcy5nYW1tYSA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAgICdnYW1tYScsIHNoYXBlLCBudWxsLCB0aGlzLmdhbW1hSW5pdGlhbGl6ZXIsIHRoaXMuZ2FtbWFSZWd1bGFyaXplcixcbiAgICAgICAgICB0cnVlLCB0aGlzLmdhbW1hQ29uc3RyYWludCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgdGhpcy5iZXRhID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICAgJ2JldGEnLCBzaGFwZSwgbnVsbCwgdGhpcy5iZXRhSW5pdGlhbGl6ZXIsIHRoaXMuYmV0YVJlZ3VsYXJpemVyLCB0cnVlLFxuICAgICAgICAgIHRoaXMuYmV0YUNvbnN0cmFpbnQpO1xuICAgIH1cbiAgICB0aGlzLm1vdmluZ01lYW4gPSB0aGlzLmFkZFdlaWdodChcbiAgICAgICAgJ21vdmluZ19tZWFuJywgc2hhcGUsIG51bGwsIHRoaXMubW92aW5nTWVhbkluaXRpYWxpemVyLCBudWxsLCBmYWxzZSk7XG4gICAgdGhpcy5tb3ZpbmdWYXJpYW5jZSA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAnbW92aW5nX3ZhcmlhbmNlJywgc2hhcGUsIG51bGwsIHRoaXMubW92aW5nVmFyaWFuY2VJbml0aWFsaXplciwgbnVsbCxcbiAgICAgICAgZmFsc2UpO1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IHRyYWluaW5nID0ga3dhcmdzWyd0cmFpbmluZyddID09IG51bGwgPyBmYWxzZSA6IGt3YXJnc1sndHJhaW5pbmcnXTtcbiAgICAgIGNvbnN0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgY29uc3QgaW5wdXRTaGFwZSA9IGlucHV0LnNoYXBlO1xuICAgICAgY29uc3QgbmRpbSA9IGlucHV0U2hhcGUubGVuZ3RoO1xuICAgICAgY29uc3QgcmVkdWN0aW9uQXhlcyA9IG1hdGhfdXRpbHMucmFuZ2UoMCwgbmRpbSk7XG4gICAgICBjb25zdCBheGlzID0gdGhpcy5heGlzID49IDAgPyB0aGlzLmF4aXMgOiAodGhpcy5heGlzICsgbmRpbSk7XG4gICAgICByZWR1Y3Rpb25BeGVzLnNwbGljZShheGlzLCAxKTtcbiAgICAgIGNvbnN0IGJyb2FkY2FzdFNoYXBlID0gZ2VuZXJpY191dGlscy5weUxpc3RSZXBlYXQoMSwgbmRpbSk7XG4gICAgICBicm9hZGNhc3RTaGFwZVtheGlzXSA9IGlucHV0U2hhcGVbYXhpc107XG5cbiAgICAgIGNvbnN0IHNvcnRlZFJlZHVjdGlvbkF4ZXMgPSByZWR1Y3Rpb25BeGVzLnNsaWNlKCk7XG4gICAgICBzb3J0ZWRSZWR1Y3Rpb25BeGVzLnNvcnQoKTtcbiAgICAgIGNvbnN0IG5lZWRzQnJvYWRjYXN0aW5nID0gIXV0aWwuYXJyYXlzRXF1YWwoXG4gICAgICAgICAgc29ydGVkUmVkdWN0aW9uQXhlcywgbWF0aF91dGlscy5yYW5nZSgwLCBuZGltKS5zbGljZSgwLCBuZGltIC0gMSkpO1xuXG4gICAgICBjb25zdCBub3JtYWxpemVJbmZlcmVuY2U6ICgpID0+IFRlbnNvciA9ICgpID0+IHtcbiAgICAgICAgaWYgKG5lZWRzQnJvYWRjYXN0aW5nKSB7XG4gICAgICAgICAgY29uc3QgYnJvYWRjYXN0TW92aW5nTWVhbiA9XG4gICAgICAgICAgICAgIHJlc2hhcGUodGhpcy5tb3ZpbmdNZWFuLnJlYWQoKSwgYnJvYWRjYXN0U2hhcGUpO1xuICAgICAgICAgIGNvbnN0IGJyb2FkY2FzdE1vdmluZ1ZhcmlhbmNlID1cbiAgICAgICAgICAgICAgcmVzaGFwZSh0aGlzLm1vdmluZ1ZhcmlhbmNlLnJlYWQoKSwgYnJvYWRjYXN0U2hhcGUpO1xuICAgICAgICAgIGNvbnN0IGJyb2FkY2FzdEJldGEgPVxuICAgICAgICAgICAgICB0aGlzLmNlbnRlciA/IHJlc2hhcGUodGhpcy5iZXRhLnJlYWQoKSwgYnJvYWRjYXN0U2hhcGUpIDogbnVsbDtcbiAgICAgICAgICBjb25zdCBicm9hZGNhc3RHYW1tYSA9XG4gICAgICAgICAgICAgIHRoaXMuc2NhbGUgPyByZXNoYXBlKHRoaXMuZ2FtbWEucmVhZCgpLCBicm9hZGNhc3RTaGFwZSkgOiBudWxsO1xuICAgICAgICAgIHJldHVybiBiYXRjaE5vcm1hbGl6YXRpb24oXG4gICAgICAgICAgICAgIGlucHV0LCBicm9hZGNhc3RNb3ZpbmdNZWFuLCBicm9hZGNhc3RNb3ZpbmdWYXJpYW5jZSxcbiAgICAgICAgICAgICAgYnJvYWRjYXN0QmV0YSwgYnJvYWRjYXN0R2FtbWEsIHRoaXMuZXBzaWxvbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmV0dXJuIGJhdGNoTm9ybWFsaXphdGlvbihcbiAgICAgICAgICAgICAgaW5wdXQsIHRoaXMubW92aW5nTWVhbi5yZWFkKCksIHRoaXMubW92aW5nVmFyaWFuY2UucmVhZCgpLFxuICAgICAgICAgICAgICB0aGlzLmJldGEgPT0gbnVsbCA/IG51bGwgOiB0aGlzLmJldGEucmVhZCgpLFxuICAgICAgICAgICAgICB0aGlzLmdhbW1hID09IG51bGwgPyBudWxsIDogdGhpcy5nYW1tYS5yZWFkKCksIHRoaXMuZXBzaWxvbik7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmICghdHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuIG5vcm1hbGl6ZUluZmVyZW5jZSgpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBbbm9ybWVkVHJhaW5pbmcsIG1lYW4sIHZhcmlhbmNlXSA9IG5vcm1hbGl6ZUJhdGNoSW5UcmFpbmluZyhcbiAgICAgICAgICBpbnB1dCwgdGhpcy5nYW1tYS5yZWFkKCksIHRoaXMuYmV0YS5yZWFkKCksIHJlZHVjdGlvbkF4ZXMsXG4gICAgICAgICAgdGhpcy5lcHNpbG9uKTtcblxuICAgICAgY29uc3QgZG9Nb3ZpbmdBdmVyYWdlID1cbiAgICAgICAgICAodmFyaWFibGU6IExheWVyVmFyaWFibGUsIHZhbHVlOiBUZW5zb3IsIG1vbWVudHVtOiBudW1iZXIpOiB2b2lkID0+IHtcbiAgICAgICAgICAgIHRmYy50aWR5KCgpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgZGVjYXkgPSAxIC0gbW9tZW50dW07XG4gICAgICAgICAgICAgIGNvbnN0IG9yaWdWYWx1ZSA9IHZhcmlhYmxlLnJlYWQoKTtcbiAgICAgICAgICAgICAgY29uc3QgdXBkYXRlRGVsdGEgPSB0ZmMubXVsKHRmYy5zdWIob3JpZ1ZhbHVlLCB2YWx1ZSksIGRlY2F5KTtcbiAgICAgICAgICAgICAgdmFyaWFibGUud3JpdGUodGZjLnN1YihvcmlnVmFsdWUsIHVwZGF0ZURlbHRhKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuXG4gICAgICAvLyBQZXJmb3JtIHVwZGF0ZXMgdG8gbW92aW5nIG1lYW4gYW5kIG1vdmluZyB2YXJpYW5jZSBmb3IgdHJhaW5pbmcuXG4gICAgICAvLyBQb3J0aW5nIE5vdGU6IEluIFB5S2VyYXMsIHRoZXNlIHVwZGF0ZXMgdG8gYG1vdmluZ01lYW5gIGFuZFxuICAgICAgLy8gICBgbW92aW5nQXZlcmFnZWAgYXJlIGRvbmUgYXMgYSBkZWZlcnJlZCBHcmFwaCwgYWRkZWQgdG8gdGhlIGBMYXllcmAnc1xuICAgICAgLy8gICBgdXBkYXRlYHMgdXNpbmcgdGhlIGBhZGRfdXBkYXRlKClgIG1ldGhvZC4gSGVyZSB3ZSBkbyBpdCBpbXBlcmF0aXZlbHlcbiAgICAgIC8vICAgYW5kIGVuY2Fwc3VsYXRlIHRoZSB1cGRhdGVzIGluIGEgZnVuY3Rpb24gdGhhdCBpcyBpbnZva2VkXG4gICAgICAvLyAgIGltbWVkaWF0ZWx5LlxuICAgICAgY29uc3QgdXBkYXRlTW92aW5nTWVhbkFuZFZhcmlhbmNlID0gKCkgPT4ge1xuICAgICAgICBkb01vdmluZ0F2ZXJhZ2UodGhpcy5tb3ZpbmdNZWFuLCBtZWFuLCB0aGlzLm1vbWVudHVtKTtcbiAgICAgICAgZG9Nb3ZpbmdBdmVyYWdlKHRoaXMubW92aW5nVmFyaWFuY2UsIHZhcmlhbmNlLCB0aGlzLm1vbWVudHVtKTtcbiAgICAgIH07XG4gICAgICB1cGRhdGVNb3ZpbmdNZWFuQW5kVmFyaWFuY2UoKTtcblxuICAgICAgcmV0dXJuIG5vcm1lZFRyYWluaW5nO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7XG4gICAgICBheGlzOiB0aGlzLmF4aXMsXG4gICAgICBtb21lbnR1bTogdGhpcy5tb21lbnR1bSxcbiAgICAgIGVwc2lsb246IHRoaXMuZXBzaWxvbixcbiAgICAgIGNlbnRlcjogdGhpcy5jZW50ZXIsXG4gICAgICBzY2FsZTogdGhpcy5zY2FsZSxcbiAgICAgIGJldGFJbml0aWFsaXplcjogc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5iZXRhSW5pdGlhbGl6ZXIpLFxuICAgICAgZ2FtbWFJbml0aWFsaXplcjogc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5nYW1tYUluaXRpYWxpemVyKSxcbiAgICAgIG1vdmluZ01lYW5Jbml0aWFsaXplcjogc2VyaWFsaXplSW5pdGlhbGl6ZXIodGhpcy5tb3ZpbmdNZWFuSW5pdGlhbGl6ZXIpLFxuICAgICAgbW92aW5nVmFyaWFuY2VJbml0aWFsaXplcjpcbiAgICAgICAgICBzZXJpYWxpemVJbml0aWFsaXplcih0aGlzLm1vdmluZ1ZhcmlhbmNlSW5pdGlhbGl6ZXIpLFxuICAgICAgYmV0YVJlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmJldGFSZWd1bGFyaXplciksXG4gICAgICBnYW1tYVJlZ3VsYXJpemVyOiBzZXJpYWxpemVSZWd1bGFyaXplcih0aGlzLmdhbW1hUmVndWxhcml6ZXIpLFxuICAgICAgYmV0YUNvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5iZXRhQ29uc3RyYWludCksXG4gICAgICBnYW1tYUNvbnN0cmFpbnQ6IHNlcmlhbGl6ZUNvbnN0cmFpbnQodGhpcy5nYW1tYUNvbnN0cmFpbnQpXG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhCYXRjaE5vcm1hbGl6YXRpb24pO1xuXG5leHBvcnQgaW50ZXJmYWNlIExheWVyTm9ybWFsaXphdGlvbkxheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBUaGUgYXhpcyBvciBheGVzIHRoYXQgc2hvdWxkIGJlIG5vcm1hbGl6ZWQgKHR5cGljYWxseSwgdGhlIGZlYXR1cmUgYXhpcy4pXG4gICAqIERlZmF1bHRzIHRvIC0xICh0aGUgbGFzdCBheGlzLilcbiAgICovXG4gIGF4aXM/OiBudW1iZXJ8bnVtYmVyW107XG5cbiAgLyoqXG4gICAqIEEgc21hbGwgcG9zaXRpdmUgZmxvYXQgYWRkZWQgdG8gdmFyaWFuY2UgdG8gYXZvaWQgZGl2aXNvbiBieSB6ZXJvLlxuICAgKiBEZWZhdWx0cyB0byAxZS0zLlxuICAgKi9cbiAgZXBzaWxvbj86IG51bWJlcjtcblxuICAvKipcbiAgICogSWYgYHRydWVgLCBhZGQgb2Zmc2V0IG9mIGBiZXRhYCB0byBub3JtYWxpemVkIHRlbnNvci5cbiAgICogSWYgYGZhbHNlYCwgYGJldGFgIGlzIGlnbm9yZWQuXG4gICAqIERlZmF1bHQ6IGB0cnVlYC5cbiAgICovXG4gIGNlbnRlcj86IGJvb2xlYW47XG5cbiAgLyoqXG4gICAqIElmIGB0cnVlYCwgbXVsdGlwbHkgb3V0cHV0IGJ5IGBnYW1tYWAuXG4gICAqIElmIGBmYWxzZWAsIGBnYW1tYWAgaXMgbm90IHVzZWQuXG4gICAqIFdoZW4gdGhlIG5leHQgbGF5ZXIgaXMgbGluZWFyLCB0aGlzIGNhbiBiZSBkaXNhYmxlZCBzaW5jZSBzY2FsaW5nIHdpbGxcbiAgICogYmUgZG9uZSBieSB0aGUgbmV4dCBsYXllci5cbiAgICogRGVmYXVsdDogYHRydWVgLlxuICAgKi9cbiAgc2NhbGU/OiBib29sZWFuO1xuXG4gIC8qKlxuICAgKiBJbml0aWFsaXplciBmb3IgdGhlIGJldGEgd2VpZ2h0LlxuICAgKiBEZWZhdWx0OiBgJ3plcm9zJ2AuXG4gICAqL1xuICBiZXRhSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXJ8SW5pdGlhbGl6ZXI7XG5cbiAgLyoqXG4gICAqIEluaXRpYWxpemVyIGZvciB0aGUgZ2FtbWEgd2VpZ2h0LlxuICAgKiBEZWZhdWx0OiBgJ29uZXMnYC5cbiAgICovXG4gIGdhbW1hSW5pdGlhbGl6ZXI/OiBJbml0aWFsaXplcklkZW50aWZpZXJ8SW5pdGlhbGl6ZXI7XG5cbiAgLyoqIFJlZ3VsYXJpemVyIGZvciB0aGUgYmV0YSB3ZWlnaHQuICovXG4gIGJldGFSZWd1bGFyaXplcj86IFJlZ3VsYXJpemVySWRlbnRpZmllcnxSZWd1bGFyaXplcjtcblxuICAvKiogUmVndWxhcml6ZXIgZm9yIHRoZSBnYW1tYSB3ZWlnaHQuICovXG4gIGdhbW1hUmVndWxhcml6ZXI/OiBSZWd1bGFyaXplcklkZW50aWZpZXJ8UmVndWxhcml6ZXI7XG59XG5cbmV4cG9ydCBjbGFzcyBMYXllck5vcm1hbGl6YXRpb24gZXh0ZW5kcyBMYXllciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ0xheWVyTm9ybWFsaXphdGlvbic7XG5cbiAgcHJpdmF0ZSBheGlzOiBudW1iZXJ8bnVtYmVyW107XG4gIHJlYWRvbmx5IGVwc2lsb246IG51bWJlcjtcbiAgcmVhZG9ubHkgY2VudGVyOiBib29sZWFuO1xuICByZWFkb25seSBzY2FsZTogYm9vbGVhbjtcbiAgcmVhZG9ubHkgYmV0YUluaXRpYWxpemVyOiBJbml0aWFsaXplcjtcbiAgcmVhZG9ubHkgZ2FtbWFJbml0aWFsaXplcjogSW5pdGlhbGl6ZXI7XG4gIHJlYWRvbmx5IGJldGFSZWd1bGFyaXplcjogUmVndWxhcml6ZXI7XG4gIHJlYWRvbmx5IGdhbW1hUmVndWxhcml6ZXI6IFJlZ3VsYXJpemVyO1xuXG4gIHByaXZhdGUgZ2FtbWE6IExheWVyVmFyaWFibGU7XG4gIHByaXZhdGUgYmV0YTogTGF5ZXJWYXJpYWJsZTtcblxuICBjb25zdHJ1Y3RvcihhcmdzPzogTGF5ZXJOb3JtYWxpemF0aW9uTGF5ZXJBcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgYXJncyA9IHt9O1xuICAgIH1cbiAgICBzdXBlcihhcmdzKTtcblxuICAgIHRoaXMuYXhpcyA9IGFyZ3MuYXhpcyA9PSBudWxsID8gLTEgOiBhcmdzLmF4aXM7XG4gICAgaWYgKHR5cGVvZiB0aGlzLmF4aXMgPT09ICdudW1iZXInKSB7XG4gICAgICBpZiAoIU51bWJlci5pc0ludGVnZXIodGhpcy5heGlzKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICBgRXhwZWN0ZWQgYXhpcyB0byBiZSBhbiBpbnRlZ2VyLCBidXQgcmVjZWl2ZWQgJHt0aGlzLmF4aXN9YCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHRoaXMuYXhpcykpIHtcbiAgICAgIGZvciAoY29uc3QgYXhpcyBvZiB0aGlzLmF4aXMpIHtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNJbnRlZ2VyKGF4aXMpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgRXhwZWN0ZWQgYXhpcyB0byBiZSBhbiBhcnJheSBvZiBpbnRlZ2VycywgYCArXG4gICAgICAgICAgICAgIGBidXQgcmVjZWl2ZWQgJHtKU09OLnN0cmluZ2lmeSh0aGlzLmF4aXMpfWApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICBgRXhwZWN0ZWQgYXhpcyB0byBiZSBhbiBpbnRlZ2VyIG9yIGFuIGFycmF5IG9mIGludGVnZXJzLCBgICtcbiAgICAgICAgICBgYnV0IHJlY2VpdmVkICR7SlNPTi5zdHJpbmdpZnkodGhpcy5heGlzKX1gKTtcbiAgICB9XG5cbiAgICB0aGlzLmVwc2lsb24gPSBhcmdzLmVwc2lsb24gPT0gbnVsbCA/IDFlLTMgOiBhcmdzLmVwc2lsb247XG4gICAgdGhpcy5jZW50ZXIgPSBhcmdzLmNlbnRlciA9PSBudWxsID8gdHJ1ZSA6IGFyZ3MuY2VudGVyO1xuICAgIHRoaXMuc2NhbGUgPSBhcmdzLnNjYWxlID09IG51bGwgPyB0cnVlIDogYXJncy5zY2FsZTtcbiAgICB0aGlzLmJldGFJbml0aWFsaXplciA9IGdldEluaXRpYWxpemVyKGFyZ3MuYmV0YUluaXRpYWxpemVyIHx8ICd6ZXJvcycpO1xuICAgIHRoaXMuZ2FtbWFJbml0aWFsaXplciA9IGdldEluaXRpYWxpemVyKGFyZ3MuZ2FtbWFJbml0aWFsaXplciB8fCAnb25lcycpO1xuICAgIHRoaXMuYmV0YVJlZ3VsYXJpemVyID0gZ2V0UmVndWxhcml6ZXIoYXJncy5iZXRhUmVndWxhcml6ZXIpO1xuICAgIHRoaXMuZ2FtbWFSZWd1bGFyaXplciA9IGdldFJlZ3VsYXJpemVyKGFyZ3MuZ2FtbWFSZWd1bGFyaXplcik7XG5cbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gIH1cblxuICBwdWJsaWMgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgY29uc3QgbkRpbXMgPSBpbnB1dFNoYXBlLmxlbmd0aDtcblxuICAgIC8vIENvbnZlcnQgYXhpcyB0byBhcnJheSBhbmQgcmVzb2x2ZSBuZWdhdGl2ZXMuXG4gICAgaWYgKHR5cGVvZiB0aGlzLmF4aXMgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLmF4aXMgPSBbdGhpcy5heGlzXTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmF4aXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIGlmICh0aGlzLmF4aXNbaV0gPCAwKSB7XG4gICAgICAgIHRoaXMuYXhpc1tpXSArPSBuRGltcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGdXJ0aGVyIHZhbGlkYXRlIGF4ZXMuXG4gICAgZm9yIChjb25zdCBheGlzIG9mIHRoaXMuYXhpcykge1xuICAgICAgaWYgKGF4aXMgPCAwIHx8IGF4aXMgPj0gbkRpbXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIGF4aXM6ICR7YXhpc31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKHRoaXMuYXhpcy5sZW5ndGggIT09IGdlbmVyaWNfdXRpbHMudW5pcXVlKHRoaXMuYXhpcykubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEZvdW5kIGR1cGxpY2F0ZSBheGVzIGluOiAke3RoaXMuYXhpc31gKTtcbiAgICB9XG5cbiAgICBjb25zdCBwYXJhbVNoYXBlID0gdGhpcy5heGlzLm1hcChheGlzID0+IGlucHV0U2hhcGVbYXhpc10pIGFzIG51bWJlcltdO1xuXG4gICAgY29uc3QgdHJhaW5hYmxlID0gdHJ1ZTtcbiAgICBpZiAodGhpcy5zY2FsZSkge1xuICAgICAgdGhpcy5nYW1tYSA9IHRoaXMuYWRkV2VpZ2h0KFxuICAgICAgICAgICdnYW1tYScsIHBhcmFtU2hhcGUsICdmbG9hdDMyJywgdGhpcy5nYW1tYUluaXRpYWxpemVyLFxuICAgICAgICAgIHRoaXMuZ2FtbWFSZWd1bGFyaXplciwgdHJhaW5hYmxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5nYW1tYSA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGlzLmNlbnRlcikge1xuICAgICAgdGhpcy5iZXRhID0gdGhpcy5hZGRXZWlnaHQoXG4gICAgICAgICAgJ2JldGEnLCBwYXJhbVNoYXBlLCAnZmxvYXQzMicsIHRoaXMuYmV0YUluaXRpYWxpemVyLFxuICAgICAgICAgIHRoaXMuYmV0YVJlZ3VsYXJpemVyLCB0cmFpbmFibGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmJldGEgPSBudWxsO1xuICAgIH1cblxuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIGNvbnN0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgIGNvbnN0IGlucHV0U2hhcGUgPSBpbnB1dC5zaGFwZTtcbiAgICBjb25zdCBuRGltcyA9IGlucHV0U2hhcGUubGVuZ3RoO1xuXG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgY29uc3Qga2VlcERpbXMgPSB0cnVlO1xuICAgICAgbGV0IHttZWFuLCB2YXJpYW5jZX0gPSBtb21lbnRzKGlucHV0LCB0aGlzLmF4aXMsIGtlZXBEaW1zKTtcbiAgICAgIGNvbnN0IGJyb2FkY2FzdFNoYXBlID0gZ2VuZXJpY191dGlscy5weUxpc3RSZXBlYXQoMSwgbkRpbXMpO1xuICAgICAgZm9yIChjb25zdCBkaW0gb2YgdGhpcy5heGlzIGFzIG51bWJlcltdKSB7XG4gICAgICAgIGJyb2FkY2FzdFNoYXBlW2RpbV0gPSBpbnB1dFNoYXBlW2RpbV07XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IGJyb2FkY2FzdCA9ICh2OiBUZW5zb3IpID0+IHtcbiAgICAgICAgaWYgKHYgIT0gbnVsbCAmJiB2LnNoYXBlLmxlbmd0aCAhPT0gbkRpbXMpIHtcbiAgICAgICAgICByZXR1cm4gdGZjLnJlc2hhcGUodiwgYnJvYWRjYXN0U2hhcGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB2O1xuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBsZXQgc2NhbGUgPSB0aGlzLnNjYWxlID8gYnJvYWRjYXN0KHRoaXMuZ2FtbWEucmVhZCgpKSA6IG51bGw7XG4gICAgICBsZXQgb2Zmc2V0ID0gdGhpcy5jZW50ZXIgPyBicm9hZGNhc3QodGhpcy5iZXRhLnJlYWQoKSkgOiBudWxsO1xuXG4gICAgICAvLyBUT0RPKGh0dHBzOi8vZ2l0aHViLmNvbS90ZW5zb3JmbG93L3RmanMvaXNzdWVzLzIxMjApOiBUaGUgdGlsaW5nIGJlbG93XG4gICAgICAvLyBpcyBhIHdvcmthcm91bmQgZm9yIHRoZSBsaW1pdGF0aW9uIG9mIGNvcmUncyBiYXRjaE5vcm1hbGl6YXRpb24/ZCBkb24ndFxuICAgICAgLy8gc3VwcG9ydCBicm9hZGNhc3RpbmcgaW4gdGhlaXIgZ3JhZGllbnRzLiBJbiBhZGRpdGlvbiwgdGhlIHRpbGluZyBpc1xuICAgICAgLy8gbmVjZXNzYXJ5IHRvIGVuc3VyZSBjb3JyZWN0bmVzcyBvbiB0aGUgYnJvd3NlciBDUFUgYmFja2VuZCByZWdhcmRsZXNzXG4gICAgICAvLyBvZiBmb3J3YXJkIG9yIGJhY2t3YXJkIGNvbXB1dGF0aW9uLiBSZW1vdmUgdGhpcyB3b3JrYXJvdW5kIG9uY2UgdGhlXG4gICAgICAvLyBsaW1pdGF0aW9uIGlzIGFkZHJlc3NlZC4gU2VlIC5cbiAgICAgIGNvbnN0IG1vbWVudHNUaWxpbmc6IG51bWJlcltdID0gW107XG4gICAgICBjb25zdCBzY2FsZU9mZnNldFRpbGluZzogbnVtYmVyW10gPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbkRpbXM7ICsraSkge1xuICAgICAgICBpZiAoKHRoaXMuYXhpcyBhcyBudW1iZXJbXSkuaW5kZXhPZihpKSAhPT0gLTEpIHtcbiAgICAgICAgICBtb21lbnRzVGlsaW5nLnB1c2goaW5wdXRTaGFwZVtpXSk7XG4gICAgICAgICAgc2NhbGVPZmZzZXRUaWxpbmcucHVzaCgxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtb21lbnRzVGlsaW5nLnB1c2goMSk7XG4gICAgICAgICAgc2NhbGVPZmZzZXRUaWxpbmcucHVzaChpbnB1dFNoYXBlW2ldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgbWVhbiA9IHRmYy50aWxlKG1lYW4sIG1vbWVudHNUaWxpbmcpO1xuICAgICAgdmFyaWFuY2UgPSB0ZmMudGlsZSh2YXJpYW5jZSwgbW9tZW50c1RpbGluZyk7XG4gICAgICBpZiAoc2NhbGUgIT0gbnVsbCkge1xuICAgICAgICBzY2FsZSA9IHRmYy50aWxlKHNjYWxlLCBzY2FsZU9mZnNldFRpbGluZyk7XG4gICAgICB9XG4gICAgICBpZiAob2Zmc2V0ICE9IG51bGwpIHtcbiAgICAgICAgb2Zmc2V0ID0gdGZjLnRpbGUob2Zmc2V0LCBzY2FsZU9mZnNldFRpbGluZyk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBiYXRjaE5vcm1hbGl6YXRpb24oXG4gICAgICAgICAgaW5wdXQsIG1lYW4sIHZhcmlhbmNlLCBvZmZzZXQsIHNjYWxlLCB0aGlzLmVwc2lsb24pO1xuICAgIH0pO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7XG4gICAgICBheGlzOiB0aGlzLmF4aXMsXG4gICAgICBlcHNpbG9uOiB0aGlzLmVwc2lsb24sXG4gICAgICBjZW50ZXI6IHRoaXMuY2VudGVyLFxuICAgICAgc2NhbGU6IHRoaXMuc2NhbGUsXG4gICAgICBiZXRhSW5pdGlhbGl6ZXI6IHNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuYmV0YUluaXRpYWxpemVyKSxcbiAgICAgIGdhbW1hSW5pdGlhbGl6ZXI6IHNlcmlhbGl6ZUluaXRpYWxpemVyKHRoaXMuZ2FtbWFJbml0aWFsaXplciksXG4gICAgICBiZXRhUmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuYmV0YVJlZ3VsYXJpemVyKSxcbiAgICAgIGdhbW1hUmVndWxhcml6ZXI6IHNlcmlhbGl6ZVJlZ3VsYXJpemVyKHRoaXMuZ2FtbWFSZWd1bGFyaXplcilcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKExheWVyTm9ybWFsaXphdGlvbik7XG4iXX0=","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Padding Layers.\n */\n// Porting Note: In Python Keras, the padding layers are in convolutional.py,\n//   but we decided to put them in a separate file (padding.ts) for clarity.\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport { InputSpec, Layer } from '../engine/topology';\nimport { ValueError } from '../errors';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\n/**\n * Pads the middle dimension of a 3D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of 2 integers, how many zeros to add at the start and\n *   end of the middle dimension (i.e., dimension 1).\n * @return A padded 3D `tf.Tensor`.\n */\nexport function temporalPadding(x, padding) {\n    return tidy(() => {\n        if (x.rank !== 3) {\n            throw new ValueError(`temporalPadding expects input tensor to be 3-D, but received a ` +\n                `${x.rank}-D tensor.`);\n        }\n        if (padding == null) {\n            padding = [1, 1];\n        }\n        if (padding.length !== 2) {\n            throw new ValueError(`temporalPadding expects input padding pattern to be a length-2 ` +\n                `array, but received a length-${padding.length} array.`);\n        }\n        const pattern = [[0, 0], padding, [0, 0]];\n        return tfc.pad(x, pattern);\n    });\n}\n/**\n * Pads the 2nd and 3rd dimensions of a 4D tensor.\n *\n * @param x Input `tf.Tensor` to be padded.\n * @param padding `Array` of two `Array`s, each of which is an `Array` of two\n *   integers. The amount of padding at the beginning and end of the 2nd and 3rd\n *   dimensions, respectively.\n * @param dataFormat 'channelsLast' (default) or 'channelsFirst'.\n * @return Padded 4D `tf.Tensor`.\n */\nexport function spatial2dPadding(x, padding, dataFormat) {\n    return tidy(() => {\n        if (x.rank !== 4) {\n            throw new ValueError(`temporalPadding expects input tensor to be 4-D, but received a ` +\n                `${x.rank}-D tensor.`);\n        }\n        if (padding == null) {\n            padding = [[1, 1], [1, 1]];\n        }\n        if (padding.length !== 2 || padding[0].length !== 2 ||\n            padding[1].length !== 2) {\n            throw new ValueError('spatial2dPadding expects `padding` to be an Array of two Arrays, ' +\n                'each of which is an Array of two integers.');\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (dataFormat !== 'channelsLast' && dataFormat !== 'channelsFirst') {\n            throw new ValueError(`Unknown data format: ${dataFormat}. ` +\n                `Supported data formats are 'channelsLast' and 'channelsFirst.`);\n        }\n        let pattern;\n        if (dataFormat === 'channelsFirst') {\n            pattern = [[0, 0], [0, 0], padding[0], padding[1]];\n        }\n        else {\n            pattern = [[0, 0], padding[0], padding[1], [0, 0]];\n        }\n        return tfc.pad(x, pattern);\n    });\n}\nexport class ZeroPadding2D extends Layer {\n    constructor(args) {\n        if (args == null) {\n            args = {};\n        }\n        super(args);\n        this.dataFormat =\n            args.dataFormat == null ? imageDataFormat() : args.dataFormat;\n        // TODO(cais): Maybe refactor the following logic surrounding `padding`\n        //   into a helper method.\n        if (args.padding == null) {\n            this.padding = [[1, 1], [1, 1]];\n        }\n        else if (typeof args.padding === 'number') {\n            this.padding =\n                [[args.padding, args.padding], [args.padding, args.padding]];\n        }\n        else {\n            args.padding = args.padding;\n            if (args.padding.length !== 2) {\n                throw new ValueError(`ZeroPadding2D expects padding to be a length-2 array, but ` +\n                    `received a length-${args.padding.length} array.`);\n            }\n            let heightPadding;\n            let widthPadding;\n            if (typeof args.padding[0] === 'number') {\n                heightPadding = [args.padding[0], args.padding[0]];\n                widthPadding = [args.padding[1], args.padding[1]];\n            }\n            else {\n                args.padding = args.padding;\n                if (args.padding[0].length !== 2) {\n                    throw new ValueError(`ZeroPadding2D expects height padding to be a length-2 array, ` +\n                        `but received a length-${args.padding[0].length} array.`);\n                }\n                heightPadding = args.padding[0];\n                if (args.padding[1].length !== 2) {\n                    throw new ValueError(`ZeroPadding2D expects width padding to be a length-2 array, ` +\n                        `but received a length-${args.padding[1].length} array.`);\n                }\n                widthPadding = args.padding[1];\n            }\n            this.padding = [heightPadding, widthPadding];\n        }\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let rows;\n        let cols;\n        if (this.dataFormat === 'channelsFirst') {\n            if (inputShape[2] != null && inputShape[2] >= 0) {\n                rows = inputShape[2] + this.padding[0][0] + this.padding[0][1];\n            }\n            else {\n                rows = null;\n            }\n            if (inputShape[3] != null && inputShape[3] >= 0) {\n                cols = inputShape[3] + this.padding[1][0] + this.padding[1][1];\n            }\n            else {\n                cols = null;\n            }\n            return [inputShape[0], inputShape[1], rows, cols];\n        }\n        else {\n            if (inputShape[1] != null && inputShape[1] >= 0) {\n                rows = inputShape[1] + this.padding[0][0] + this.padding[0][1];\n            }\n            else {\n                rows = null;\n            }\n            if (inputShape[2] != null && inputShape[2] >= 0) {\n                cols = inputShape[2] + this.padding[1][0] + this.padding[1][1];\n            }\n            else {\n                cols = null;\n            }\n            return [inputShape[0], rows, cols, inputShape[3]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => spatial2dPadding(getExactlyOneTensor(inputs), this.padding, this.dataFormat));\n    }\n    getConfig() {\n        const config = {\n            padding: this.padding,\n            dataFormat: this.dataFormat,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\n/** @nocollapse */\nZeroPadding2D.className = 'ZeroPadding2D';\nserialization.registerClass(ZeroPadding2D);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFkZGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvcGFkZGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsNkVBQTZFO0FBQzdFLDRFQUE0RTtBQUU1RSxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxhQUFhLEVBQVUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFFbEUsT0FBTyxFQUFDLGVBQWUsRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBQ2xELE9BQU8sRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFZLE1BQU0sb0JBQW9CLENBQUM7QUFDL0QsT0FBTyxFQUFDLFVBQVUsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUdyQyxPQUFPLEVBQUMsa0JBQWtCLEVBQUUsbUJBQW1CLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUU3RTs7Ozs7OztHQU9HO0FBQ0gsTUFBTSxVQUFVLGVBQWUsQ0FBQyxDQUFTLEVBQUUsT0FBMEI7SUFDbkUsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFO1FBQ2YsSUFBSSxDQUFDLENBQUMsSUFBSSxLQUFLLENBQUMsRUFBRTtZQUNoQixNQUFNLElBQUksVUFBVSxDQUNoQixpRUFBaUU7Z0JBQ2pFLEdBQUcsQ0FBQyxDQUFDLElBQUksWUFBWSxDQUFDLENBQUM7U0FDNUI7UUFFRCxJQUFJLE9BQU8sSUFBSSxJQUFJLEVBQUU7WUFDbkIsT0FBTyxHQUFHLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxDQUFDO1NBQ2xCO1FBQ0QsSUFBSSxPQUFPLENBQUMsTUFBTSxLQUFLLENBQUMsRUFBRTtZQUN4QixNQUFNLElBQUksVUFBVSxDQUNoQixpRUFBaUU7Z0JBQ2pFLGdDQUFnQyxPQUFPLENBQUMsTUFBTSxTQUFTLENBQUMsQ0FBQztTQUM5RDtRQUVELE1B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LENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUNuRDtJQUNILENBQUM7SUFFRCxJQUFJLENBQUMsTUFBdUIsRUFBRSxNQUFjO1FBQzFDLE9BQU8sSUFBSSxDQUNQLEdBQUcsRUFBRSxDQUFDLGdCQUFnQixDQUNsQixtQkFBbUIsQ0FBQyxNQUFNLENBQUMsRUFBRSxJQUFJLENBQUMsT0FBTyxFQUFFLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQyxDQUFDO0lBQ3ZFLENBQUM7SUFFRCxTQUFTO1FBQ1AsTUFBTSxNQUFNLEdBQTZCO1lBQ3ZDLE9BQU8sRUFBRSxJQUFJLENBQUMsT0FBTztZQUNyQixVQUFVLEVBQUUsSUFBSSxDQUFDLFVBQVU7U0FDNUIsQ0FBQztRQUNGLE1BQU0sVUFBVSxHQUFHLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNsQyxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDOztBQXJHRCxrQkFBa0I7QUFDWCx1QkFBUyxHQUFHLGVBQWUsQ0FBQztBQXNHckMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogUGFkZGluZyBMYXllcnMuXG4gKi9cblxuLy8gUG9ydGluZyBOb3RlOiBJbiBQeXRob24gS2VyYXMsIHRoZSBwYWRkaW5nIGxheWVycyBhcmUgaW4gY29udm9sdXRpb25hbC5weSxcbi8vICAgYnV0IHdlIGRlY2lkZWQgdG8gcHV0IHRoZW0gaW4gYSBzZXBhcmF0ZSBmaWxlIChwYWRkaW5nLnRzKSBmb3IgY2xhcml0eS5cblxuaW1wb3J0ICogYXMgdGZjIGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5pbXBvcnQge3NlcmlhbGl6YXRpb24sIFRlbnNvciwgdGlkeX0gZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcblxuaW1wb3J0IHtpbWFnZURhdGFGb3JtYXR9IGZyb20gJy4uL2JhY2tlbmQvY29tbW9uJztcbmltcG9ydCB7SW5wdXRTcGVjLCBMYXllciwgTGF5ZXJBcmdzfSBmcm9tICcuLi9lbmdpbmUvdG9wb2xvZ3knO1xuaW1wb3J0IHtWYWx1ZUVycm9yfSBmcm9tICcuLi9lcnJvcnMnO1xuaW1wb3J0IHtEYXRhRm9ybWF0LCBTaGFwZX0gZnJvbSAnLi4va2VyYXNfZm9ybWF0L2NvbW1vbic7XG5pbXBvcnQge0t3YXJnc30gZnJvbSAnLi4vdHlwZXMnO1xuaW1wb3J0IHtnZXRFeGFjdGx5T25lU2hhcGUsIGdldEV4YWN0bHlPbmVUZW5zb3J9IGZyb20gJy4uL3V0aWxzL3R5cGVzX3V0aWxzJztcblxuLyoqXG4gKiBQYWRzIHRoZSBtaWRkbGUgZGltZW5zaW9uIG9mIGEgM0QgdGVuc29yLlxuICpcbiAqIEBwYXJhbSB4IElucHV0IGB0Zi5UZW5zb3JgIHRvIGJlIHBhZGRlZC5cbiAqIEBwYXJhbSBwYWRkaW5nIGBBcnJheWAgb2YgMiBpbnRlZ2VycywgaG93IG1hbnkgemVyb3MgdG8gYWRkIGF0IHRoZSBzdGFydCBhbmRcbiAqICAgZW5kIG9mIHRoZSBtaWRkbGUgZGltZW5zaW9uIChpLmUuLCBkaW1lbnNpb24gMSkuXG4gKiBAcmV0dXJuIEEgcGFkZGVkIDNEIGB0Zi5UZW5zb3JgLlxuICovXG5leHBvcnQgZnVuY3Rpb24gdGVtcG9yYWxQYWRkaW5nKHg6IFRlbnNvciwgcGFkZGluZz86IFtudW1iZXIsIG51bWJlcl0pOiBUZW5zb3Ige1xuICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgaWYgKHgucmFuayAhPT0gMykge1xuICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgYHRlbXBvcmFsUGFkZGluZyBleHBlY3RzIGlucHV0IHRlbnNvciB0byBiZSAzLUQsIGJ1dCByZWNlaXZlZCBhIGAgK1xuICAgICAgICAgIGAke3gucmFua30tRCB0ZW5zb3IuYCk7XG4gICAgfVxuXG4gICAgaWYgKHBhZGRpbmcgPT0gbnVsbCkge1xuICAgICAgcGFkZGluZyA9IFsxLCAxXTtcbiAgICB9XG4gICAgaWYgKHBhZGRpbmcubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgdGVtcG9yYWxQYWRkaW5nIGV4cGVjdHMgaW5wdXQgcGFkZGluZyBwYXR0ZXJuIHRvIGJlIGEgbGVuZ3RoLTIgYCArXG4gICAgICAgICAgYGFycmF5LCBidXQgcmVjZWl2ZWQgYSBsZW5ndGgtJHtwYWRkaW5nLmxlbmd0aH0gYXJyYXkuYCk7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0dGVybjogQXJyYXk8W251bWJlciwgbnVtYmVyXT4gPSBbWzAsIDBdLCBwYWRkaW5nLCBbMCwgMF1dO1xuICAgIHJldHVybiB0ZmMucGFkKHgsIHBhdHRlcm4pO1xuICB9KTtcbn1cblxuLyoqXG4gKiBQYWRzIHRoZSAybmQgYW5kIDNyZCBkaW1lbnNpb25zIG9mIGEgNEQgdGVuc29yLlxuICpcbiAqIEBwYXJhbSB4IElucHV0IGB0Zi5UZW5zb3JgIHRvIGJlIHBhZGRlZC5cbiAqIEBwYXJhbSBwYWRkaW5nIGBBcnJheWAgb2YgdHdvIGBBcnJheWBzLCBlYWNoIG9mIHdoaWNoIGlzIGFuIGBBcnJheWAgb2YgdHdvXG4gKiAgIGludGVnZXJzLiBUaGUgYW1vdW50IG9mIHBhZGRpbmcgYXQgdGhlIGJlZ2lubmluZyBhbmQgZW5kIG9mIHRoZSAybmQgYW5kIDNyZFxuICogICBkaW1lbnNpb25zLCByZXNwZWN0aXZlbHkuXG4gKiBAcGFyYW0gZGF0YUZvcm1hdCAnY2hhbm5lbHNMYXN0JyAoZGVmYXVsdCkgb3IgJ2NoYW5uZWxzRmlyc3QnLlxuICogQHJldHVybiBQYWRkZWQgNEQgYHRmLlRlbnNvcmAuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBzcGF0aWFsMmRQYWRkaW5nKFxuICAgIHg6IFRlbnNvciwgcGFkZGluZz86IFtbbnVtYmVyLCBudW1iZXJdLCBbbnVtYmVyLCBudW1iZXJdXSxcbiAgICBkYXRhRm9ybWF0PzogRGF0YUZvcm1hdCk6IFRlbnNvciB7XG4gIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICBpZiAoeC5yYW5rICE9PSA0KSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgdGVtcG9yYWxQYWRkaW5nIGV4cGVjdHMgaW5wdXQgdGVuc29yIHRvIGJlIDQtRCwgYnV0IHJlY2VpdmVkIGEgYCArXG4gICAgICAgICAgYCR7eC5yYW5rfS1EIHRlbnNvci5gKTtcbiAgICB9XG5cbiAgICBpZiAocGFkZGluZyA9PSBudWxsKSB7XG4gICAgICBwYWRkaW5nID0gW1sxLCAxXSwgWzEsIDFdXTtcbiAgICB9XG4gICAgaWYgKHBhZGRpbmcubGVuZ3RoICE9PSAyIHx8IHBhZGRpbmdbMF0ubGVuZ3RoICE9PSAyIHx8XG4gICAgICAgIHBhZGRpbmdbMV0ubGVuZ3RoICE9PSAyKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAnc3BhdGlhbDJkUGFkZGluZyBleHBlY3RzIGBwYWRkaW5nYCB0byBiZSBhbiBBcnJheSBvZiB0d28gQXJyYXlzLCAnICtcbiAgICAgICAgICAnZWFjaCBvZiB3aGljaCBpcyBhbiBBcnJheSBvZiB0d28gaW50ZWdlcnMuJyk7XG4gICAgfVxuXG4gICAgaWYgKGRhdGFGb3JtYXQgPT0gbnVsbCkge1xuICAgICAgZGF0YUZvcm1hdCA9IGltYWdlRGF0YUZvcm1hdCgpO1xuICAgIH1cbiAgICBpZiAoZGF0YUZvcm1hdCAhPT0gJ2NoYW5uZWxzTGFzdCcgJiYgZGF0YUZvcm1hdCAhPT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgVW5rbm93biBkYXRhIGZvcm1hdDogJHtkYXRhRm9ybWF0fS4gYCArXG4gICAgICAgICAgYFN1cHBvcnRlZCBkYXRhIGZvcm1hdHMgYXJlICdjaGFubmVsc0xhc3QnIGFuZCAnY2hhbm5lbHNGaXJzdC5gKTtcbiAgICB9XG5cbiAgICBsZXQgcGF0dGVybjogQXJyYXk8W251bWJlciwgbnVtYmVyXT47XG4gICAgaWYgKGRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgcGF0dGVybiA9IFtbMCwgMF0sIFswLCAwXSwgcGFkZGluZ1swXSwgcGFkZGluZ1sxXV07XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdHRlcm4gPSBbWzAsIDBdLCBwYWRkaW5nWzBdLCBwYWRkaW5nWzFdLCBbMCwgMF1dO1xuICAgIH1cblxuICAgIHJldHVybiB0ZmMucGFkKHgsIHBhdHRlcm4pO1xuICB9KTtcbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFplcm9QYWRkaW5nMkRMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogSW50ZWdlciwgb3IgYEFycmF5YCBvZiAyIGludGVnZXJzLCBvciBgQXJyYXlgIG9mIDIgYEFycmF5YHMsIGVhY2ggb2ZcbiAgICogd2hpY2ggaXMgYW4gYEFycmF5YCBvZiAyIGludGVnZXJzLlxuICAgKiAtIElmIGludGVnZXIsIHRoZSBzYW1lIHN5bW1ldHJpYyBwYWRkaW5nIGlzIGFwcGxpZWQgdG8gd2lkdGggYW5kIGhlaWdodC5cbiAgICogLSBJZiBBcnJheWAgb2YgMiBpbnRlZ2VycywgaW50ZXJwcmV0ZWQgYXMgdHdvIGRpZmZlcmVudCBzeW1tZXRyaWMgdmFsdWVzXG4gICAqICAgZm9yIGhlaWdodCBhbmQgd2lkdGg6XG4gICAqICAgYFtzeW1tZXRyaWNIZWlnaHRQYWQsIHN5bW1ldHJpY1dpZHRoUGFkXWAuXG4gICAqIC0gSWYgYEFycmF5YCBvZiAyIGBBcnJheWBzLCBpbnRlcnByZXRlZCBhczpcbiAgICogICBgW1t0b3BQYWQsIGJvdHRvbVBhZF0sIFtsZWZ0UGFkLCByaWdodFBhZF1dYC5cbiAgICovXG4gIHBhZGRpbmc/OiBudW1iZXJ8W251bWJlciwgbnVtYmVyXXxbW251bWJlciwgbnVtYmVyXSwgW251bWJlciwgbnVtYmVyXV07XG5cbiAgLyoqXG4gICAqIE9uZSBvZiBgJ2NoYW5uZWxzTGFzdCdgIChkZWZhdWx0KSBhbmQgYCdjaGFubmVsc0ZpcnN0J2AuXG4gICAqXG4gICAqIFRoZSBvcmRlcmluZyBvZiB0aGUgZGltZW5zaW9ucyBpbiB0aGUgaW5wdXRzLlxuICAgKiBgY2hhbm5lbHNMYXN0YCBjb3JyZXNwb25kcyB0byBpbnB1dHMgd2l0aCBzaGFwZVxuICAgKiBgW2JhdGNoLCBoZWlnaHQsIHdpZHRoLCBjaGFubmVsc11gIHdoaWxlIGBjaGFubmVsc0ZpcnN0YFxuICAgKiBjb3JyZXNwb25kcyB0byBpbnB1dHMgd2l0aCBzaGFwZVxuICAgKiBgW2JhdGNoLCBjaGFubmVscywgaGVpZ2h0LCB3aWR0aF1gLlxuICAgKi9cbiAgZGF0YUZvcm1hdD86IERhdGFGb3JtYXQ7XG59XG5cbmV4cG9ydCBjbGFzcyBaZXJvUGFkZGluZzJEIGV4dGVuZHMgTGF5ZXIge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdaZXJvUGFkZGluZzJEJztcbiAgcmVhZG9ubHkgZGF0YUZvcm1hdDogRGF0YUZvcm1hdDtcbiAgcmVhZG9ubHkgcGFkZGluZzogW1tudW1iZXIsIG51bWJlcl0sIFtudW1iZXIsIG51bWJlcl1dO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M/OiBaZXJvUGFkZGluZzJETGF5ZXJBcmdzKSB7XG4gICAgaWYgKGFyZ3MgPT0gbnVsbCkge1xuICAgICAgYXJncyA9IHt9O1xuICAgIH1cbiAgICBzdXBlcihhcmdzKTtcblxuICAgIHRoaXMuZGF0YUZvcm1hdCA9XG4gICAgICAgIGFyZ3MuZGF0YUZvcm1hdCA9PSBudWxsID8gaW1hZ2VEYXRhRm9ybWF0KCkgOiBhcmdzLmRhdGFGb3JtYXQ7XG4gICAgLy8gVE9ETyhjYWlzKTogTWF5YmUgcmVmYWN0b3IgdGhlIGZvbGxvd2luZyBsb2dpYyBzdXJyb3VuZGluZyBgcGFkZGluZ2BcbiAgICAvLyAgIGludG8gYSBoZWxwZXIgbWV0aG9kLlxuICAgIGlmIChhcmdzLnBhZGRpbmcgPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWRkaW5nID0gW1sxLCAxXSwgWzEsIDFdXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmdzLnBhZGRpbmcgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBhZGRpbmcgPVxuICAgICAgICAgIFtbYXJncy5wYWRkaW5nLCBhcmdzLnBhZGRpbmddLCBbYXJncy5wYWRkaW5nLCBhcmdzLnBhZGRpbmddXTtcbiAgICB9IGVsc2Uge1xuICAgICAgYXJncy5wYWRkaW5nID0gYXJncy5wYWRkaW5nO1xuICAgICAgaWYgKGFyZ3MucGFkZGluZy5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICBgWmVyb1BhZGRpbmcyRCBleHBlY3RzIHBhZGRpbmcgdG8gYmUgYSBsZW5ndGgtMiBhcnJheSwgYnV0IGAgK1xuICAgICAgICAgICAgYHJlY2VpdmVkIGEgbGVuZ3RoLSR7YXJncy5wYWRkaW5nLmxlbmd0aH0gYXJyYXkuYCk7XG4gICAgICB9XG5cbiAgICAgIGxldCBoZWlnaHRQYWRkaW5nOiBbbnVtYmVyLCBudW1iZXJdO1xuICAgICAgbGV0IHdpZHRoUGFkZGluZzogW251bWJlciwgbnVtYmVyXTtcbiAgICAgIGlmICh0eXBlb2YgYXJncy5wYWRkaW5nWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgICBoZWlnaHRQYWRkaW5nID0gW2FyZ3MucGFkZGluZ1swXSwgYXJncy5wYWRkaW5nWzBdXTtcbiAgICAgICAgd2lkdGhQYWRkaW5nID0gW2FyZ3MucGFkZGluZ1sxXSBhcyBudW1iZXIsIGFyZ3MucGFkZGluZ1sxXSBhcyBudW1iZXJdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXJncy5wYWRkaW5nID0gYXJncy5wYWRkaW5nIGFzIFtbbnVtYmVyLCBudW1iZXJdLCBbbnVtYmVyLCBudW1iZXJdXTtcblxuICAgICAgICBpZiAoYXJncy5wYWRkaW5nWzBdLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgICBgWmVyb1BhZGRpbmcyRCBleHBlY3RzIGhlaWdodCBwYWRkaW5nIHRvIGJlIGEgbGVuZ3RoLTIgYXJyYXksIGAgK1xuICAgICAgICAgICAgICBgYnV0IHJlY2VpdmVkIGEgbGVuZ3RoLSR7YXJncy5wYWRkaW5nWzBdLmxlbmd0aH0gYXJyYXkuYCk7XG4gICAgICAgIH1cbiAgICAgICAgaGVpZ2h0UGFkZGluZyA9IGFyZ3MucGFkZGluZ1swXSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuXG4gICAgICAgIGlmIChhcmdzLnBhZGRpbmdbMV0ubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAgIGBaZXJvUGFkZGluZzJEIGV4cGVjdHMgd2lkdGggcGFkZGluZyB0byBiZSBhIGxlbmd0aC0yIGFycmF5LCBgICtcbiAgICAgICAgICAgICAgYGJ1dCByZWNlaXZlZCBhIGxlbmd0aC0ke2FyZ3MucGFkZGluZ1sxXS5sZW5ndGh9IGFycmF5LmApO1xuICAgICAgICB9XG4gICAgICAgIHdpZHRoUGFkZGluZyA9IGFyZ3MucGFkZGluZ1sxXSBhcyBbbnVtYmVyLCBudW1iZXJdO1xuICAgICAgfVxuICAgICAgdGhpcy5wYWRkaW5nID0gW2hlaWdodFBhZGRpbmcsIHdpZHRoUGFkZGluZ107XG4gICAgfVxuICAgIHRoaXMuaW5wdXRTcGVjID0gW25ldyBJbnB1dFNwZWMoe25kaW06IDR9KV07XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG5cbiAgICBsZXQgcm93czogbnVtYmVyO1xuICAgIGxldCBjb2xzOiBudW1iZXI7XG4gICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICBpZiAoaW5wdXRTaGFwZVsyXSAhPSBudWxsICYmIGlucHV0U2hhcGVbMl0gPj0gMCkge1xuICAgICAgICByb3dzID0gaW5wdXRTaGFwZVsyXSArIHRoaXMucGFkZGluZ1swXVswXSArIHRoaXMucGFkZGluZ1swXVsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJvd3MgPSBudWxsO1xuICAgICAgfVxuICAgICAgaWYgKGlucHV0U2hhcGVbM10gIT0gbnVsbCAmJiBpbnB1dFNoYXBlWzNdID49IDApIHtcbiAgICAgICAgY29scyA9IGlucHV0U2hhcGVbM10gKyB0aGlzLnBhZGRpbmdbMV1bMF0gKyB0aGlzLnBhZGRpbmdbMV1bMV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb2xzID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsxXSwgcm93cywgY29sc107XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpbnB1dFNoYXBlWzFdICE9IG51bGwgJiYgaW5wdXRTaGFwZVsxXSA+PSAwKSB7XG4gICAgICAgIHJvd3MgPSBpbnB1dFNoYXBlWzFdICsgdGhpcy5wYWRkaW5nWzBdWzBdICsgdGhpcy5wYWRkaW5nWzBdWzFdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcm93cyA9IG51bGw7XG4gICAgICB9XG4gICAgICBpZiAoaW5wdXRTaGFwZVsyXSAhPSBudWxsICYmIGlucHV0U2hhcGVbMl0gPj0gMCkge1xuICAgICAgICBjb2xzID0gaW5wdXRTaGFwZVsyXSArIHRoaXMucGFkZGluZ1sxXVswXSArIHRoaXMucGFkZGluZ1sxXVsxXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbHMgPSBudWxsO1xuICAgICAgfVxuICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCByb3dzLCBjb2xzLCBpbnB1dFNoYXBlWzNdXTtcbiAgICB9XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoXG4gICAgICAgICgpID0+IHNwYXRpYWwyZFBhZGRpbmcoXG4gICAgICAgICAgICBnZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyksIHRoaXMucGFkZGluZywgdGhpcy5kYXRhRm9ybWF0KSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWc6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCA9IHtcbiAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyxcbiAgICAgIGRhdGFGb3JtYXQ6IHRoaXMuZGF0YUZvcm1hdCxcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFplcm9QYWRkaW5nMkQpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * TensorFlow.js Layers: Pooling Layers.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport { imageDataFormat } from '../backend/common';\nimport * as K from '../backend/tfjs_backend';\nimport { checkDataFormat, checkPaddingMode, checkPoolMode } from '../common';\nimport { InputSpec } from '../engine/topology';\nimport { Layer } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { convOutputLength } from '../utils/conv_utils';\nimport { assertPositiveInteger } from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { preprocessConv2DInput, preprocessConv3DInput } from './convolutional';\n/**\n * 2D pooling.\n * @param x\n * @param poolSize\n * @param stridesdes strides. Defaults to [1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 2D pooling.\n */\nexport function pool2d(x, poolSize, strides, padding, dataFormat, poolMode) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        checkPoolMode(poolMode);\n        checkPaddingMode(padding);\n        if (strides == null) {\n            strides = [1, 1];\n        }\n        if (padding == null) {\n            padding = 'valid';\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (poolMode == null) {\n            poolMode = 'max';\n        }\n        // TODO(cais): Remove the preprocessing step once deeplearn.js supports\n        // dataFormat as an input argument.\n        x = preprocessConv2DInput(x, dataFormat); // x is NHWC after preprocessing.\n        let y;\n        const paddingString = (padding === 'same') ? 'same' : 'valid';\n        if (poolMode === 'max') {\n            // TODO(cais): Rank check?\n            y = tfc.maxPool(x, poolSize, strides, paddingString);\n        }\n        else { // 'avg'\n            // TODO(cais): Check the dtype and rank of x and give clear error message\n            //   if those are incorrect.\n            y = tfc.avgPool(\n            // TODO(cais): Rank check?\n            x, poolSize, strides, paddingString);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 3, 1, 2]); // NHWC -> NCHW.\n        }\n        return y;\n    });\n}\n/**\n * 3D pooling.\n * @param x\n * @param poolSize. Default to [1, 1, 1].\n * @param strides strides. Defaults to [1, 1, 1].\n * @param padding padding. Defaults to 'valid'.\n * @param dataFormat data format. Defaults to 'channelsLast'.\n * @param poolMode Mode of pooling. Defaults to 'max'.\n * @returns Result of the 3D pooling.\n */\nexport function pool3d(x, poolSize, strides, padding, dataFormat, poolMode) {\n    return tidy(() => {\n        checkDataFormat(dataFormat);\n        checkPoolMode(poolMode);\n        checkPaddingMode(padding);\n        if (strides == null) {\n            strides = [1, 1, 1];\n        }\n        if (padding == null) {\n            padding = 'valid';\n        }\n        if (dataFormat == null) {\n            dataFormat = imageDataFormat();\n        }\n        if (poolMode == null) {\n            poolMode = 'max';\n        }\n        // x is NDHWC after preprocessing.\n        x = preprocessConv3DInput(x, dataFormat);\n        let y;\n        const paddingString = (padding === 'same') ? 'same' : 'valid';\n        if (poolMode === 'max') {\n            y = tfc.maxPool3d(x, poolSize, strides, paddingString);\n        }\n        else { // 'avg'\n            y = tfc.avgPool3d(x, poolSize, strides, paddingString);\n        }\n        if (dataFormat === 'channelsFirst') {\n            y = tfc.transpose(y, [0, 4, 1, 2, 3]); // NDHWC -> NCDHW.\n        }\n        return y;\n    });\n}\n/**\n * Abstract class for different pooling 1D layers.\n */\nexport class Pooling1D extends Layer {\n    /**\n     *\n     * @param args Parameters for the Pooling layer.\n     *\n     * config.poolSize defaults to 2.\n     */\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = 2;\n        }\n        super(args);\n        if (typeof args.poolSize === 'number') {\n            this.poolSize = [args.poolSize];\n        }\n        else if (Array.isArray(args.poolSize) &&\n            args.poolSize.length === 1 &&\n            typeof args.poolSize[0] === 'number') {\n            this.poolSize = args.poolSize;\n        }\n        else {\n            throw new ValueError(`poolSize for 1D convolutional layer must be a number or an ` +\n                `Array of a single number, but received ` +\n                `${JSON.stringify(args.poolSize)}`);\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else {\n            if (typeof args.strides === 'number') {\n                this.strides = [args.strides];\n            }\n            else if (Array.isArray(args.strides) &&\n                args.strides.length === 1 &&\n                typeof args.strides[0] === 'number') {\n                this.strides = args.strides;\n            }\n            else {\n                throw new ValueError(`strides for 1D convolutional layer must be a number or an ` +\n                    `Array of a single number, but received ` +\n                    `${JSON.stringify(args.strides)}`);\n            }\n        }\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const length = convOutputLength(inputShape[1], this.poolSize[0], this.padding, this.strides[0]);\n        return [inputShape[0], length, inputShape[2]];\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            // Add dummy last dimension.\n            inputs = K.expandDims(getExactlyOneTensor(inputs), 2);\n            const output = this.poolingFunction(getExactlyOneTensor(inputs), [this.poolSize[0], 1], [this.strides[0], 1], this.padding, 'channelsLast');\n            // Remove dummy last dimension.\n            return tfc.squeeze(output, [2]);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling1D extends Pooling1D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling1D.className = 'MaxPooling1D';\nserialization.registerClass(MaxPooling1D);\nexport class AveragePooling1D extends Pooling1D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling1D.className = 'AveragePooling1D';\nserialization.registerClass(AveragePooling1D);\n/**\n * Abstract class for different pooling 2D layers.\n */\nexport class Pooling2D extends Layer {\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = [2, 2];\n        }\n        super(args);\n        this.poolSize = Array.isArray(args.poolSize) ?\n            args.poolSize :\n            [args.poolSize, args.poolSize];\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else if (Array.isArray(args.strides)) {\n            if (args.strides.length !== 2) {\n                throw new ValueError(`If the strides property of a 2D pooling layer is an Array, ` +\n                    `it is expected to have a length of 2, but received length ` +\n                    `${args.strides.length}.`);\n            }\n            this.strides = args.strides;\n        }\n        else {\n            // `config.strides` is a number.\n            this.strides = [args.strides, args.strides];\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let rows = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        let cols = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        rows =\n            convOutputLength(rows, this.poolSize[0], this.padding, this.strides[0]);\n        cols =\n            convOutputLength(cols, this.poolSize[1], this.padding, this.strides[1]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], inputShape[1], rows, cols];\n        }\n        else {\n            return [inputShape[0], rows, cols, inputShape[3]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n            dataFormat: this.dataFormat\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling2D extends Pooling2D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling2D.className = 'MaxPooling2D';\nserialization.registerClass(MaxPooling2D);\nexport class AveragePooling2D extends Pooling2D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool2d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling2D.className = 'AveragePooling2D';\nserialization.registerClass(AveragePooling2D);\n/**\n * Abstract class for different pooling 3D layers.\n */\nexport class Pooling3D extends Layer {\n    constructor(args) {\n        if (args.poolSize == null) {\n            args.poolSize = [2, 2, 2];\n        }\n        super(args);\n        this.poolSize = Array.isArray(args.poolSize) ?\n            args.poolSize :\n            [args.poolSize, args.poolSize, args.poolSize];\n        if (args.strides == null) {\n            this.strides = this.poolSize;\n        }\n        else if (Array.isArray(args.strides)) {\n            if (args.strides.length !== 3) {\n                throw new ValueError(`If the strides property of a 3D pooling layer is an Array, ` +\n                    `it is expected to have a length of 3, but received length ` +\n                    `${args.strides.length}.`);\n            }\n            this.strides = args.strides;\n        }\n        else {\n            // `config.strides` is a number.\n            this.strides = [args.strides, args.strides, args.strides];\n        }\n        assertPositiveInteger(this.poolSize, 'poolSize');\n        assertPositiveInteger(this.strides, 'strides');\n        this.padding = args.padding == null ? 'valid' : args.padding;\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        checkPaddingMode(this.padding);\n        this.inputSpec = [new InputSpec({ ndim: 5 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        let depths = this.dataFormat === 'channelsFirst' ? inputShape[2] : inputShape[1];\n        let rows = this.dataFormat === 'channelsFirst' ? inputShape[3] : inputShape[2];\n        let cols = this.dataFormat === 'channelsFirst' ? inputShape[4] : inputShape[3];\n        depths = convOutputLength(depths, this.poolSize[0], this.padding, this.strides[0]);\n        rows =\n            convOutputLength(rows, this.poolSize[1], this.padding, this.strides[1]);\n        cols =\n            convOutputLength(cols, this.poolSize[2], this.padding, this.strides[2]);\n        if (this.dataFormat === 'channelsFirst') {\n            return [inputShape[0], inputShape[1], depths, rows, cols];\n        }\n        else {\n            return [inputShape[0], depths, rows, cols, inputShape[4]];\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            this.invokeCallHook(inputs, kwargs);\n            return this.poolingFunction(getExactlyOneTensor(inputs), this.poolSize, this.strides, this.padding, this.dataFormat);\n        });\n    }\n    getConfig() {\n        const config = {\n            poolSize: this.poolSize,\n            padding: this.padding,\n            strides: this.strides,\n            dataFormat: this.dataFormat\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class MaxPooling3D extends Pooling3D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool3d(inputs, poolSize, strides, padding, dataFormat, 'max');\n    }\n}\n/** @nocollapse */\nMaxPooling3D.className = 'MaxPooling3D';\nserialization.registerClass(MaxPooling3D);\nexport class AveragePooling3D extends Pooling3D {\n    constructor(args) {\n        super(args);\n    }\n    poolingFunction(inputs, poolSize, strides, padding, dataFormat) {\n        checkDataFormat(dataFormat);\n        checkPaddingMode(padding);\n        return pool3d(inputs, poolSize, strides, padding, dataFormat, 'avg');\n    }\n}\n/** @nocollapse */\nAveragePooling3D.className = 'AveragePooling3D';\nserialization.registerClass(AveragePooling3D);\n/**\n * Abstract class for different global pooling 1D layers.\n */\nexport class GlobalPooling1D extends Layer {\n    constructor(args) {\n        super(args);\n        this.inputSpec = [new InputSpec({ ndim: 3 })];\n    }\n    computeOutputShape(inputShape) {\n        return [inputShape[0], inputShape[2]];\n    }\n    call(inputs, kwargs) {\n        throw new NotImplementedError();\n    }\n}\nexport class GlobalAveragePooling1D extends GlobalPooling1D {\n    constructor(args) {\n        super(args || {});\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            return tfc.mean(input, 1);\n        });\n    }\n}\n/** @nocollapse */\nGlobalAveragePooling1D.className = 'GlobalAveragePooling1D';\nserialization.registerClass(GlobalAveragePooling1D);\nexport class GlobalMaxPooling1D extends GlobalPooling1D {\n    constructor(args) {\n        super(args || {});\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            return tfc.max(input, 1);\n        });\n    }\n}\n/** @nocollapse */\nGlobalMaxPooling1D.className = 'GlobalMaxPooling1D';\nserialization.registerClass(GlobalMaxPooling1D);\n/**\n * Abstract class for different global pooling 2D layers.\n */\nexport class GlobalPooling2D extends Layer {\n    constructor(args) {\n        super(args);\n        this.dataFormat =\n            args.dataFormat == null ? 'channelsLast' : args.dataFormat;\n        checkDataFormat(this.dataFormat);\n        this.inputSpec = [new InputSpec({ ndim: 4 })];\n    }\n    computeOutputShape(inputShape) {\n        inputShape = inputShape;\n        if (this.dataFormat === 'channelsLast') {\n            return [inputShape[0], inputShape[3]];\n        }\n        else {\n            return [inputShape[0], inputShape[1]];\n        }\n    }\n    call(inputs, kwargs) {\n        throw new NotImplementedError();\n    }\n    getConfig() {\n        const config = { dataFormat: this.dataFormat };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n}\nexport class GlobalAveragePooling2D extends GlobalPooling2D {\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                return tfc.mean(input, [1, 2]);\n            }\n            else {\n                return tfc.mean(input, [2, 3]);\n            }\n        });\n    }\n}\n/** @nocollapse */\nGlobalAveragePooling2D.className = 'GlobalAveragePooling2D';\nserialization.registerClass(GlobalAveragePooling2D);\nexport class GlobalMaxPooling2D extends GlobalPooling2D {\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const input = getExactlyOneTensor(inputs);\n            if (this.dataFormat === 'channelsLast') {\n                return tfc.max(input, [1, 2]);\n            }\n            else {\n                return tfc.max(input, [2, 3]);\n            }\n        });\n    }\n}\n/** @nocollapse */\nGlobalMaxPooling2D.className = 'GlobalMaxPooling2D';\nserialization.registerClass(GlobalMaxPooling2D);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicG9vbGluZy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uL3RmanMtbGF5ZXJzL3NyYy9sYXllcnMvcG9vbGluZy50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7R0FRRztBQUVIOztHQUVHO0FBRUgsT0FBTyxLQUFLLEdBQUcsTUFBTSx1QkFBdUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsYUFBYSxFQUF3QyxJQUFJLEVBQUMsTUFBTSx1QkFBdUIsQ0FBQztBQUVoRyxPQUFPLEVBQUMsZUFBZSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFDbEQsT0FBTyxLQUFLLENBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsZUFBZSxFQUFFLGdCQUFnQixFQUFFLGFBQWEsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUMzRSxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sb0JBQW9CLENBQUM7QUFDN0MsT0FBTyxFQUFDLEtBQUssRUFBWSxNQUFNLG9CQUFvQixDQUFDO0FBQ3BELE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFHMUQsT0FBTyxFQUFDLGdCQUFnQixFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDckQsT0FBTyxFQUFDLHFCQUFxQixFQUFDLE1BQU0sd0JBQXdCLENBQUM7QUFDN0QsT0FBTyxFQUFDLGtCQUFrQixFQUFFLG1CQUFtQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFFN0UsT0FBTyxFQUFDLHFCQUFxQixFQUFFLHFCQUFxQixFQUFDLE1BQU0saUJBQWlCLENBQUM7QUFFN0U7Ozs7Ozs7OztHQVNHO0FBQ0gsTUFBTSxVQUFVLE1BQU0sQ0FDbEIsQ0FBUyxFQUFFLFFBQTBCLEVBQUUsT0FBMEIsRUFDakUsT0FBcUIsRUFBRSxVQUF1QixFQUM5QyxRQUFtQjtJQUNyQixPQUFPLElBQUksQ0FBQyxHQUFHLEVBQUU7UUFDZixlQUFlLENBQUMsVUFB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TCxDQUFDOztBQVpELGtCQUFrQjtBQUNYLGdDQUFTLEdBQUcsd0JBQXdCLENBQUM7QUFhOUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxzQkFBc0IsQ0FBQyxDQUFDO0FBRXBELE1BQU0sT0FBTyxrQkFBbUIsU0FBUSxlQUFlO0lBSXJELElBQUksQ0FBQyxNQUF1QixFQUFFLE1BQWM7UUFDMUMsT0FBTyxJQUFJLENBQUMsR0FBRyxFQUFFO1lBQ2YsTUFBTSxLQUFLLEdBQUcsbUJBQW1CLENBQUMsTUFBTSxDQUFDLENBQUM7WUFDMUMsSUFBSSxJQUFJLENBQUMsVUFBVSxLQUFLLGNBQWMsRUFBRTtnQkFDdEMsT0FBTyxHQUFHLENBQUMsR0FBRyxDQUFDLEtBQUssRUFBRSxDQUFDLENBQUMsRUFBRSxDQUFDLENBQUMsQ0FBQyxDQUFDO2FBQy9CO2lCQUFNO2dCQUNMLE9BQU8sR0FBRyxDQUFDLEdBQUcsQ0FBQyxLQUFLLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLENBQUMsQ0FBQzthQUMvQjtRQUNILENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQzs7QUFaRCxrQkFBa0I7QUFDWCw0QkFBUyxHQUFHLG9CQUFvQixDQUFDO0FBYTFDLGFBQWEsQ0FBQyxhQUFhLENBQUMsa0JBQWtCLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE4IEdvb2dsZSBMTENcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGVcbiAqIGxpY2Vuc2UgdGhhdCBjYW4gYmUgZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBvciBhdFxuICogaHR0cHM6Ly9vcGVuc291cmNlLm9yZy9saWNlbnNlcy9NSVQuXG4gKiA9PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PVxuICovXG5cbi8qKlxuICogVGVuc29yRmxvdy5qcyBMYXllcnM6IFBvb2xpbmcgTGF5ZXJzLlxuICovXG5cbmltcG9ydCAqIGFzIHRmYyBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0IHtzZXJpYWxpemF0aW9uLCBUZW5zb3IsIFRlbnNvcjNELCBUZW5zb3I0RCwgVGVuc29yNUQsIHRpZHl9IGZyb20gJ0B0ZW5zb3JmbG93L3RmanMtY29yZSc7XG5cbmltcG9ydCB7aW1hZ2VEYXRhRm9ybWF0fSBmcm9tICcuLi9iYWNrZW5kL2NvbW1vbic7XG5pbXBvcnQgKiBhcyBLIGZyb20gJy4uL2JhY2tlbmQvdGZqc19iYWNrZW5kJztcbmltcG9ydCB7Y2hlY2tEYXRhRm9ybWF0LCBjaGVja1BhZGRpbmdNb2RlLCBjaGVja1Bvb2xNb2RlfSBmcm9tICcuLi9jb21tb24nO1xuaW1wb3J0IHtJbnB1dFNwZWN9IGZyb20gJy4uL2VuZ2luZS90b3BvbG9neSc7XG5pbXBvcnQge0xheWVyLCBMYXllckFyZ3N9IGZyb20gJy4uL2VuZ2luZS90b3BvbG9neSc7XG5pbXBvcnQge05vdEltcGxlbWVudGVkRXJyb3IsIFZhbHVlRXJyb3J9IGZyb20gJy4uL2Vycm9ycyc7XG5pbXBvcnQge0RhdGFGb3JtYXQsIFBhZGRpbmdNb2RlLCBQb29sTW9kZSwgU2hhcGV9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuaW1wb3J0IHtLd2FyZ3N9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7Y29udk91dHB1dExlbmd0aH0gZnJvbSAnLi4vdXRpbHMvY29udl91dGlscyc7XG5pbXBvcnQge2Fzc2VydFBvc2l0aXZlSW50ZWdlcn0gZnJvbSAnLi4vdXRpbHMvZ2VuZXJpY191dGlscyc7XG5pbXBvcnQge2dldEV4YWN0bHlPbmVTaGFwZSwgZ2V0RXhhY3RseU9uZVRlbnNvcn0gZnJvbSAnLi4vdXRpbHMvdHlwZXNfdXRpbHMnO1xuXG5pbXBvcnQge3ByZXByb2Nlc3NDb252MkRJbnB1dCwgcHJlcHJvY2Vzc0NvbnYzRElucHV0fSBmcm9tICcuL2NvbnZvbHV0aW9uYWwnO1xuXG4vKipcbiAqIDJEIHBvb2xpbmcuXG4gKiBAcGFyYW0geFxuICogQHBhcmFtIHBvb2xTaXplXG4gKiBAcGFyYW0gc3RyaWRlc2RlcyBzdHJpZGVzLiBEZWZhdWx0cyB0byBbMSwgMV0uXG4gKiBAcGFyYW0gcGFkZGluZyBwYWRkaW5nLiBEZWZhdWx0cyB0byAndmFsaWQnLlxuICogQHBhcmFtIGRhdGFGb3JtYXQgZGF0YSBmb3JtYXQuIERlZmF1bHRzIHRvICdjaGFubmVsc0xhc3QnLlxuICogQHBhcmFtIHBvb2xNb2RlIE1vZGUgb2YgcG9vbGluZy4gRGVmYXVsdHMgdG8gJ21heCcuXG4gKiBAcmV0dXJucyBSZXN1bHQgb2YgdGhlIDJEIHBvb2xpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb29sMmQoXG4gICAgeDogVGVuc29yLCBwb29sU2l6ZTogW251bWJlciwgbnVtYmVyXSwgc3RyaWRlcz86IFtudW1iZXIsIG51bWJlcl0sXG4gICAgcGFkZGluZz86IFBhZGRpbmdNb2RlLCBkYXRhRm9ybWF0PzogRGF0YUZvcm1hdCxcbiAgICBwb29sTW9kZT86IFBvb2xNb2RlKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBjaGVja1Bvb2xNb2RlKHBvb2xNb2RlKTtcbiAgICBjaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgIGlmIChzdHJpZGVzID09IG51bGwpIHtcbiAgICAgIHN0cmlkZXMgPSBbMSwgMV07XG4gICAgfVxuICAgIGlmIChwYWRkaW5nID09IG51bGwpIHtcbiAgICAgIHBhZGRpbmcgPSAndmFsaWQnO1xuICAgIH1cbiAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICBkYXRhRm9ybWF0ID0gaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgfVxuICAgIGlmIChwb29sTW9kZSA9PSBudWxsKSB7XG4gICAgICBwb29sTW9kZSA9ICdtYXgnO1xuICAgIH1cblxuICAgIC8vIFRPRE8oY2Fpcyk6IFJlbW92ZSB0aGUgcHJlcHJvY2Vzc2luZyBzdGVwIG9uY2UgZGVlcGxlYXJuLmpzIHN1cHBvcnRzXG4gICAgLy8gZGF0YUZvcm1hdCBhcyBhbiBpbnB1dCBhcmd1bWVudC5cbiAgICB4ID0gcHJlcHJvY2Vzc0NvbnYyRElucHV0KHgsIGRhdGFGb3JtYXQpOyAgLy8geCBpcyBOSFdDIGFmdGVyIHByZXByb2Nlc3NpbmcuXG4gICAgbGV0IHk6IFRlbnNvcjtcbiAgICBjb25zdCBwYWRkaW5nU3RyaW5nID0gKHBhZGRpbmcgPT09ICdzYW1lJykgPyAnc2FtZScgOiAndmFsaWQnO1xuICAgIGlmIChwb29sTW9kZSA9PT0gJ21heCcpIHtcbiAgICAgIC8vIFRPRE8oY2Fpcyk6IFJhbmsgY2hlY2s/XG4gICAgICB5ID0gdGZjLm1heFBvb2woeCBhcyBUZW5zb3I0RCwgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmdTdHJpbmcpO1xuICAgIH0gZWxzZSB7ICAvLyAnYXZnJ1xuICAgICAgLy8gVE9ETyhjYWlzKTogQ2hlY2sgdGhlIGR0eXBlIGFuZCByYW5rIG9mIHggYW5kIGdpdmUgY2xlYXIgZXJyb3IgbWVzc2FnZVxuICAgICAgLy8gICBpZiB0aG9zZSBhcmUgaW5jb3JyZWN0LlxuICAgICAgeSA9IHRmYy5hdmdQb29sKFxuICAgICAgICAgIC8vIFRPRE8oY2Fpcyk6IFJhbmsgY2hlY2s/XG4gICAgICAgICAgeCBhcyBUZW5zb3IzRCB8IFRlbnNvcjRELCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZ1N0cmluZyk7XG4gICAgfVxuICAgIGlmIChkYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgIHkgPSB0ZmMudHJhbnNwb3NlKHksIFswLCAzLCAxLCAyXSk7ICAvLyBOSFdDIC0+IE5DSFcuXG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9KTtcbn1cblxuLyoqXG4gKiAzRCBwb29saW5nLlxuICogQHBhcmFtIHhcbiAqIEBwYXJhbSBwb29sU2l6ZS4gRGVmYXVsdCB0byBbMSwgMSwgMV0uXG4gKiBAcGFyYW0gc3RyaWRlcyBzdHJpZGVzLiBEZWZhdWx0cyB0byBbMSwgMSwgMV0uXG4gKiBAcGFyYW0gcGFkZGluZyBwYWRkaW5nLiBEZWZhdWx0cyB0byAndmFsaWQnLlxuICogQHBhcmFtIGRhdGFGb3JtYXQgZGF0YSBmb3JtYXQuIERlZmF1bHRzIHRvICdjaGFubmVsc0xhc3QnLlxuICogQHBhcmFtIHBvb2xNb2RlIE1vZGUgb2YgcG9vbGluZy4gRGVmYXVsdHMgdG8gJ21heCcuXG4gKiBAcmV0dXJucyBSZXN1bHQgb2YgdGhlIDNEIHBvb2xpbmcuXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBwb29sM2QoXG4gICAgeDogVGVuc29yNUQsIHBvb2xTaXplOiBbbnVtYmVyLCBudW1iZXIsIG51bWJlcl0sXG4gICAgc3RyaWRlcz86IFtudW1iZXIsIG51bWJlciwgbnVtYmVyXSwgcGFkZGluZz86IFBhZGRpbmdNb2RlLFxuICAgIGRhdGFGb3JtYXQ/OiBEYXRhRm9ybWF0LCBwb29sTW9kZT86IFBvb2xNb2RlKTogVGVuc29yIHtcbiAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBjaGVja1Bvb2xNb2RlKHBvb2xNb2RlKTtcbiAgICBjaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgIGlmIChzdHJpZGVzID09IG51bGwpIHtcbiAgICAgIHN0cmlkZXMgPSBbMSwgMSwgMV07XG4gICAgfVxuICAgIGlmIChwYWRkaW5nID09IG51bGwpIHtcbiAgICAgIHBhZGRpbmcgPSAndmFsaWQnO1xuICAgIH1cbiAgICBpZiAoZGF0YUZvcm1hdCA9PSBudWxsKSB7XG4gICAgICBkYXRhRm9ybWF0ID0gaW1hZ2VEYXRhRm9ybWF0KCk7XG4gICAgfVxuICAgIGlmIChwb29sTW9kZSA9PSBudWxsKSB7XG4gICAgICBwb29sTW9kZSA9ICdtYXgnO1xuICAgIH1cblxuICAgIC8vIHggaXMgTkRIV0MgYWZ0ZXIgcHJlcHJvY2Vzc2luZy5cbiAgICB4ID0gcHJlcHJvY2Vzc0NvbnYzRElucHV0KHggYXMgVGVuc29yLCBkYXRhRm9ybWF0KSBhcyBUZW5zb3I1RDtcbiAgICBsZXQgeTogVGVuc29yO1xuICAgIGNvbnN0IHBhZGRpbmdTdHJpbmcgPSAocGFkZGluZyA9PT0gJ3NhbWUnKSA/ICdzYW1lJyA6ICd2YWxpZCc7XG4gICAgaWYgKHBvb2xNb2RlID09PSAnbWF4Jykge1xuICAgICAgeSA9IHRmYy5tYXhQb29sM2QoeCwgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmdTdHJpbmcpO1xuICAgIH0gZWxzZSB7ICAvLyAnYXZnJ1xuICAgICAgeSA9IHRmYy5hdmdQb29sM2QoeCwgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmdTdHJpbmcpO1xuICAgIH1cbiAgICBpZiAoZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnKSB7XG4gICAgICB5ID0gdGZjLnRyYW5zcG9zZSh5LCBbMCwgNCwgMSwgMiwgM10pOyAgLy8gTkRIV0MgLT4gTkNESFcuXG4gICAgfVxuICAgIHJldHVybiB5O1xuICB9KTtcbn1cblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFBvb2xpbmcxRExheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBTaXplIG9mIHRoZSB3aW5kb3cgdG8gcG9vbCBvdmVyLCBzaG91bGQgYmUgYW4gaW50ZWdlci5cbiAgICovXG4gIHBvb2xTaXplPzogbnVtYmVyfFtudW1iZXJdO1xuICAvKipcbiAgICogUGVyaW9kIGF0IHdoaWNoIHRvIHNhbXBsZSB0aGUgcG9vbGVkIHZhbHVlcy5cbiAgICpcbiAgICogSWYgYG51bGxgLCBkZWZhdWx0cyB0byBgcG9vbFNpemVgLlxuICAgKi9cbiAgc3RyaWRlcz86IG51bWJlcnxbbnVtYmVyXTtcbiAgLyoqIEhvdyB0byBmaWxsIGluIGRhdGEgdGhhdCdzIG5vdCBhbiBpbnRlZ2VyIG11bHRpcGxlIG9mIHBvb2xTaXplLiAqL1xuICBwYWRkaW5nPzogUGFkZGluZ01vZGU7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIGRpZmZlcmVudCBwb29saW5nIDFEIGxheWVycy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFBvb2xpbmcxRCBleHRlbmRzIExheWVyIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHBvb2xTaXplOiBbbnVtYmVyXTtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IHN0cmlkZXM6IFtudW1iZXJdO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGFkZGluZzogUGFkZGluZ01vZGU7XG5cbiAgLyoqXG4gICAqXG4gICAqIEBwYXJhbSBhcmdzIFBhcmFtZXRlcnMgZm9yIHRoZSBQb29saW5nIGxheWVyLlxuICAgKlxuICAgKiBjb25maWcucG9vbFNpemUgZGVmYXVsdHMgdG8gMi5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFBvb2xpbmcxRExheWVyQXJncykge1xuICAgIGlmIChhcmdzLnBvb2xTaXplID09IG51bGwpIHtcbiAgICAgIGFyZ3MucG9vbFNpemUgPSAyO1xuICAgIH1cbiAgICBzdXBlcihhcmdzKTtcbiAgICBpZiAodHlwZW9mIGFyZ3MucG9vbFNpemUgPT09ICdudW1iZXInKSB7XG4gICAgICB0aGlzLnBvb2xTaXplID0gW2FyZ3MucG9vbFNpemVdO1xuICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIEFycmF5LmlzQXJyYXkoYXJncy5wb29sU2l6ZSkgJiZcbiAgICAgICAgKGFyZ3MucG9vbFNpemUgYXMgbnVtYmVyW10pLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICB0eXBlb2YgKGFyZ3MucG9vbFNpemUgYXMgbnVtYmVyW10pWzBdID09PSAnbnVtYmVyJykge1xuICAgICAgdGhpcy5wb29sU2l6ZSA9IGFyZ3MucG9vbFNpemU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgIGBwb29sU2l6ZSBmb3IgMUQgY29udm9sdXRpb25hbCBsYXllciBtdXN0IGJlIGEgbnVtYmVyIG9yIGFuIGAgK1xuICAgICAgICAgIGBBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCBgICtcbiAgICAgICAgICBgJHtKU09OLnN0cmluZ2lmeShhcmdzLnBvb2xTaXplKX1gKTtcbiAgICB9XG4gICAgYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKHRoaXMucG9vbFNpemUsICdwb29sU2l6ZScpO1xuICAgIGlmIChhcmdzLnN0cmlkZXMgPT0gbnVsbCkge1xuICAgICAgdGhpcy5zdHJpZGVzID0gdGhpcy5wb29sU2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHR5cGVvZiBhcmdzLnN0cmlkZXMgPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuc3RyaWRlcyA9IFthcmdzLnN0cmlkZXNdO1xuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICBBcnJheS5pc0FycmF5KGFyZ3Muc3RyaWRlcykgJiZcbiAgICAgICAgICAoYXJncy5zdHJpZGVzIGFzIG51bWJlcltdKS5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICB0eXBlb2YgKGFyZ3Muc3RyaWRlcyBhcyBudW1iZXJbXSlbMF0gPT09ICdudW1iZXInKSB7XG4gICAgICAgIHRoaXMuc3RyaWRlcyA9IGFyZ3Muc3RyaWRlcztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYHN0cmlkZXMgZm9yIDFEIGNvbnZvbHV0aW9uYWwgbGF5ZXIgbXVzdCBiZSBhIG51bWJlciBvciBhbiBgICtcbiAgICAgICAgICAgIGBBcnJheSBvZiBhIHNpbmdsZSBudW1iZXIsIGJ1dCByZWNlaXZlZCBgICtcbiAgICAgICAgICAgIGAke0pTT04uc3RyaW5naWZ5KGFyZ3Muc3RyaWRlcyl9YCk7XG4gICAgICB9XG4gICAgfVxuICAgIGFzc2VydFBvc2l0aXZlSW50ZWdlcih0aGlzLnN0cmlkZXMsICdzdHJpZGVzJyk7XG5cbiAgICB0aGlzLnBhZGRpbmcgPSBhcmdzLnBhZGRpbmcgPT0gbnVsbCA/ICd2YWxpZCcgOiBhcmdzLnBhZGRpbmc7XG4gICAgY2hlY2tQYWRkaW5nTW9kZSh0aGlzLnBhZGRpbmcpO1xuICAgIHRoaXMuaW5wdXRTcGVjID0gW25ldyBJbnB1dFNwZWMoe25kaW06IDN9KV07XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgY29uc3QgbGVuZ3RoID0gY29udk91dHB1dExlbmd0aChcbiAgICAgICAgaW5wdXRTaGFwZVsxXSwgdGhpcy5wb29sU2l6ZVswXSwgdGhpcy5wYWRkaW5nLCB0aGlzLnN0cmlkZXNbMF0pO1xuICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgbGVuZ3RoLCBpbnB1dFNoYXBlWzJdXTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBwb29saW5nRnVuY3Rpb24oXG4gICAgICBpbnB1dHM6IFRlbnNvciwgcG9vbFNpemU6IFtudW1iZXIsIG51bWJlcl0sIHN0cmlkZXM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBwYWRkaW5nOiBQYWRkaW5nTW9kZSwgZGF0YUZvcm1hdDogRGF0YUZvcm1hdCk6IFRlbnNvcjtcblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgdGhpcy5pbnZva2VDYWxsSG9vayhpbnB1dHMsIGt3YXJncyk7XG4gICAgICAvLyBBZGQgZHVtbXkgbGFzdCBkaW1lbnNpb24uXG4gICAgICBpbnB1dHMgPSBLLmV4cGFuZERpbXMoZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpLCAyKTtcbiAgICAgIGNvbnN0IG91dHB1dCA9IHRoaXMucG9vbGluZ0Z1bmN0aW9uKFxuICAgICAgICAgIGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKSwgW3RoaXMucG9vbFNpemVbMF0sIDFdLFxuICAgICAgICAgIFt0aGlzLnN0cmlkZXNbMF0sIDFdLCB0aGlzLnBhZGRpbmcsICdjaGFubmVsc0xhc3QnKTtcbiAgICAgIC8vIFJlbW92ZSBkdW1teSBsYXN0IGRpbWVuc2lvbi5cbiAgICAgIHJldHVybiB0ZmMuc3F1ZWV6ZShvdXRwdXQsIFsyXSk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwb29sU2l6ZTogdGhpcy5wb29sU2l6ZSxcbiAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyxcbiAgICAgIHN0cmlkZXM6IHRoaXMuc3RyaWRlcyxcbiAgICB9O1xuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgTWF4UG9vbGluZzFEIGV4dGVuZHMgUG9vbGluZzFEIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnTWF4UG9vbGluZzFEJztcbiAgY29uc3RydWN0b3IoYXJnczogUG9vbGluZzFETGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcG9vbGluZ0Z1bmN0aW9uKFxuICAgICAgaW5wdXRzOiBUZW5zb3IsIHBvb2xTaXplOiBbbnVtYmVyLCBudW1iZXJdLCBzdHJpZGVzOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgcGFkZGluZzogUGFkZGluZ01vZGUsIGRhdGFGb3JtYXQ6IERhdGFGb3JtYXQpOiBUZW5zb3Ige1xuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBjaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgIHJldHVybiBwb29sMmQoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgJ21heCcpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoTWF4UG9vbGluZzFEKTtcblxuZXhwb3J0IGNsYXNzIEF2ZXJhZ2VQb29saW5nMUQgZXh0ZW5kcyBQb29saW5nMUQge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdBdmVyYWdlUG9vbGluZzFEJztcbiAgY29uc3RydWN0b3IoYXJnczogUG9vbGluZzFETGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyk7XG4gIH1cblxuICBwcm90ZWN0ZWQgcG9vbGluZ0Z1bmN0aW9uKFxuICAgICAgaW5wdXRzOiBUZW5zb3IsIHBvb2xTaXplOiBbbnVtYmVyLCBudW1iZXJdLCBzdHJpZGVzOiBbbnVtYmVyLCBudW1iZXJdLFxuICAgICAgcGFkZGluZzogUGFkZGluZ01vZGUsIGRhdGFGb3JtYXQ6IERhdGFGb3JtYXQpOiBUZW5zb3Ige1xuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBjaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgIHJldHVybiBwb29sMmQoaW5wdXRzLCBwb29sU2l6ZSwgc3RyaWRlcywgcGFkZGluZywgZGF0YUZvcm1hdCwgJ2F2ZycpO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoQXZlcmFnZVBvb2xpbmcxRCk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBQb29saW5nMkRMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogRmFjdG9ycyBieSB3aGljaCB0byBkb3duc2NhbGUgaW4gZWFjaCBkaW1lbnNpb24gW3ZlcnRpY2FsLCBob3Jpem9udGFsXS5cbiAgICogRXhwZWN0cyBhbiBpbnRlZ2VyIG9yIGFuIGFycmF5IG9mIDIgaW50ZWdlcnMuXG4gICAqXG4gICAqIEZvciBleGFtcGxlLCBgWzIsIDJdYCB3aWxsIGhhbHZlIHRoZSBpbnB1dCBpbiBib3RoIHNwYXRpYWwgZGltZW5zaW9uLlxuICAgKiBJZiBvbmx5IG9uZSBpbnRlZ2VyIGlzIHNwZWNpZmllZCwgdGhlIHNhbWUgd2luZG93IGxlbmd0aFxuICAgKiB3aWxsIGJlIHVzZWQgZm9yIGJvdGggZGltZW5zaW9ucy5cbiAgICovXG4gIHBvb2xTaXplPzogbnVtYmVyfFtudW1iZXIsIG51bWJlcl07XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBzdHJpZGUgaW4gZWFjaCBkaW1lbnNpb24gb2YgdGhlIHBvb2xpbmcgd2luZG93LiBFeHBlY3RzXG4gICAqIGFuIGludGVnZXIgb3IgYW4gYXJyYXkgb2YgMiBpbnRlZ2Vycy4gSW50ZWdlciwgdHVwbGUgb2YgMiBpbnRlZ2Vycywgb3JcbiAgICogTm9uZS5cbiAgICpcbiAgICogSWYgYG51bGxgLCBkZWZhdWx0cyB0byBgcG9vbFNpemVgLlxuICAgKi9cbiAgc3RyaWRlcz86IG51bWJlcnxbbnVtYmVyLCBudW1iZXJdO1xuXG4gIC8qKiBUaGUgcGFkZGluZyB0eXBlIHRvIHVzZSBmb3IgdGhlIHBvb2xpbmcgbGF5ZXIuICovXG4gIHBhZGRpbmc/OiBQYWRkaW5nTW9kZTtcbiAgLyoqIFRoZSBkYXRhIGZvcm1hdCB0byB1c2UgZm9yIHRoZSBwb29saW5nIGxheWVyLiAqL1xuICBkYXRhRm9ybWF0PzogRGF0YUZvcm1hdDtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCBjbGFzcyBmb3IgZGlmZmVyZW50IHBvb2xpbmcgMkQgbGF5ZXJzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgUG9vbGluZzJEIGV4dGVuZHMgTGF5ZXIge1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcG9vbFNpemU6IFtudW1iZXIsIG51bWJlcl07XG4gIHByb3RlY3RlZCByZWFkb25seSBzdHJpZGVzOiBbbnVtYmVyLCBudW1iZXJdO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGFkZGluZzogUGFkZGluZ01vZGU7XG4gIHByb3RlY3RlZCByZWFkb25seSBkYXRhRm9ybWF0OiBEYXRhRm9ybWF0O1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFBvb2xpbmcyRExheWVyQXJncykge1xuICAgIGlmIChhcmdzLnBvb2xTaXplID09IG51bGwpIHtcbiAgICAgIGFyZ3MucG9vbFNpemUgPSBbMiwgMl07XG4gICAgfVxuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMucG9vbFNpemUgPSBBcnJheS5pc0FycmF5KGFyZ3MucG9vbFNpemUpID9cbiAgICAgICAgYXJncy5wb29sU2l6ZSA6XG4gICAgICAgIFthcmdzLnBvb2xTaXplLCBhcmdzLnBvb2xTaXplXTtcbiAgICBpZiAoYXJncy5zdHJpZGVzID09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RyaWRlcyA9IHRoaXMucG9vbFNpemU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3Muc3RyaWRlcykpIHtcbiAgICAgIGlmIChhcmdzLnN0cmlkZXMubGVuZ3RoICE9PSAyKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYElmIHRoZSBzdHJpZGVzIHByb3BlcnR5IG9mIGEgMkQgcG9vbGluZyBsYXllciBpcyBhbiBBcnJheSwgYCArXG4gICAgICAgICAgICBgaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIGxlbmd0aCBvZiAyLCBidXQgcmVjZWl2ZWQgbGVuZ3RoIGAgK1xuICAgICAgICAgICAgYCR7YXJncy5zdHJpZGVzLmxlbmd0aH0uYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0cmlkZXMgPSBhcmdzLnN0cmlkZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBjb25maWcuc3RyaWRlc2AgaXMgYSBudW1iZXIuXG4gICAgICB0aGlzLnN0cmlkZXMgPSBbYXJncy5zdHJpZGVzLCBhcmdzLnN0cmlkZXNdO1xuICAgIH1cbiAgICBhc3NlcnRQb3NpdGl2ZUludGVnZXIodGhpcy5wb29sU2l6ZSwgJ3Bvb2xTaXplJyk7XG4gICAgYXNzZXJ0UG9zaXRpdmVJbnRlZ2VyKHRoaXMuc3RyaWRlcywgJ3N0cmlkZXMnKTtcbiAgICB0aGlzLnBhZGRpbmcgPSBhcmdzLnBhZGRpbmcgPT0gbnVsbCA/ICd2YWxpZCcgOiBhcmdzLnBhZGRpbmc7XG4gICAgdGhpcy5kYXRhRm9ybWF0ID1cbiAgICAgICAgYXJncy5kYXRhRm9ybWF0ID09IG51bGwgPyAnY2hhbm5lbHNMYXN0JyA6IGFyZ3MuZGF0YUZvcm1hdDtcbiAgICBjaGVja0RhdGFGb3JtYXQodGhpcy5kYXRhRm9ybWF0KTtcbiAgICBjaGVja1BhZGRpbmdNb2RlKHRoaXMucGFkZGluZyk7XG5cbiAgICB0aGlzLmlucHV0U3BlYyA9IFtuZXcgSW5wdXRTcGVjKHtuZGltOiA0fSldO1xuICB9XG5cbiAgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlfFNoYXBlW10pOiBTaGFwZXxTaGFwZVtdIHtcbiAgICBpbnB1dFNoYXBlID0gZ2V0RXhhY3RseU9uZVNoYXBlKGlucHV0U2hhcGUpO1xuICAgIGxldCByb3dzID1cbiAgICAgICAgdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyBpbnB1dFNoYXBlWzJdIDogaW5wdXRTaGFwZVsxXTtcbiAgICBsZXQgY29scyA9XG4gICAgICAgIHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gaW5wdXRTaGFwZVszXSA6IGlucHV0U2hhcGVbMl07XG4gICAgcm93cyA9XG4gICAgICAgIGNvbnZPdXRwdXRMZW5ndGgocm93cywgdGhpcy5wb29sU2l6ZVswXSwgdGhpcy5wYWRkaW5nLCB0aGlzLnN0cmlkZXNbMF0pO1xuICAgIGNvbHMgPVxuICAgICAgICBjb252T3V0cHV0TGVuZ3RoKGNvbHMsIHRoaXMucG9vbFNpemVbMV0sIHRoaXMucGFkZGluZywgdGhpcy5zdHJpZGVzWzFdKTtcbiAgICBpZiAodGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcpIHtcbiAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsxXSwgcm93cywgY29sc107XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgcm93cywgY29scywgaW5wdXRTaGFwZVszXV07XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHBvb2xpbmdGdW5jdGlvbihcbiAgICAgIGlucHV0czogVGVuc29yLCBwb29sU2l6ZTogW251bWJlciwgbnVtYmVyXSwgc3RyaWRlczogW251bWJlciwgbnVtYmVyXSxcbiAgICAgIHBhZGRpbmc6IFBhZGRpbmdNb2RlLCBkYXRhRm9ybWF0OiBEYXRhRm9ybWF0KTogVGVuc29yO1xuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICB0aGlzLmludm9rZUNhbGxIb29rKGlucHV0cywga3dhcmdzKTtcbiAgICAgIHJldHVybiB0aGlzLnBvb2xpbmdGdW5jdGlvbihcbiAgICAgICAgICBnZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyksIHRoaXMucG9vbFNpemUsIHRoaXMuc3RyaWRlcyxcbiAgICAgICAgICB0aGlzLnBhZGRpbmcsIHRoaXMuZGF0YUZvcm1hdCk7XG4gICAgfSk7XG4gIH1cblxuICBnZXRDb25maWcoKTogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0IHtcbiAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICBwb29sU2l6ZTogdGhpcy5wb29sU2l6ZSxcbiAgICAgIHBhZGRpbmc6IHRoaXMucGFkZGluZyxcbiAgICAgIHN0cmlkZXM6IHRoaXMuc3RyaWRlcyxcbiAgICAgIGRhdGFGb3JtYXQ6IHRoaXMuZGF0YUZvcm1hdFxuICAgIH07XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBNYXhQb29saW5nMkQgZXh0ZW5kcyBQb29saW5nMkQge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdNYXhQb29saW5nMkQnO1xuICBjb25zdHJ1Y3RvcihhcmdzOiBQb29saW5nMkRMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBwb29saW5nRnVuY3Rpb24oXG4gICAgICBpbnB1dHM6IFRlbnNvciwgcG9vbFNpemU6IFtudW1iZXIsIG51bWJlcl0sIHN0cmlkZXM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBwYWRkaW5nOiBQYWRkaW5nTW9kZSwgZGF0YUZvcm1hdDogRGF0YUZvcm1hdCk6IFRlbnNvciB7XG4gICAgY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgIGNoZWNrUGFkZGluZ01vZGUocGFkZGluZyk7XG4gICAgcmV0dXJuIHBvb2wyZChpbnB1dHMsIHBvb2xTaXplLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCAnbWF4Jyk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhNYXhQb29saW5nMkQpO1xuXG5leHBvcnQgY2xhc3MgQXZlcmFnZVBvb2xpbmcyRCBleHRlbmRzIFBvb2xpbmcyRCB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ0F2ZXJhZ2VQb29saW5nMkQnO1xuICBjb25zdHJ1Y3RvcihhcmdzOiBQb29saW5nMkRMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgfVxuXG4gIHByb3RlY3RlZCBwb29saW5nRnVuY3Rpb24oXG4gICAgICBpbnB1dHM6IFRlbnNvciwgcG9vbFNpemU6IFtudW1iZXIsIG51bWJlcl0sIHN0cmlkZXM6IFtudW1iZXIsIG51bWJlcl0sXG4gICAgICBwYWRkaW5nOiBQYWRkaW5nTW9kZSwgZGF0YUZvcm1hdDogRGF0YUZvcm1hdCk6IFRlbnNvciB7XG4gICAgY2hlY2tEYXRhRm9ybWF0KGRhdGFGb3JtYXQpO1xuICAgIGNoZWNrUGFkZGluZ01vZGUocGFkZGluZyk7XG4gICAgcmV0dXJuIHBvb2wyZChpbnB1dHMsIHBvb2xTaXplLCBzdHJpZGVzLCBwYWRkaW5nLCBkYXRhRm9ybWF0LCAnYXZnJyk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhBdmVyYWdlUG9vbGluZzJEKTtcblxuZXhwb3J0IGRlY2xhcmUgaW50ZXJmYWNlIFBvb2xpbmczRExheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBGYWN0b3JzIGJ5IHdoaWNoIHRvIGRvd25zY2FsZSBpbiBlYWNoIGRpbWVuc2lvbiBbZGVwdGgsIGhlaWdodCwgd2lkdGhdLlxuICAgKiBFeHBlY3RzIGFuIGludGVnZXIgb3IgYW4gYXJyYXkgb2YgMyBpbnRlZ2Vycy5cbiAgICpcbiAgICogRm9yIGV4YW1wbGUsIGBbMiwgMiwgMl1gIHdpbGwgaGFsdmUgdGhlIGlucHV0IGluIHRocmVlIGRpbWVuc2lvbnMuXG4gICAqIElmIG9ubHkgb25lIGludGVnZXIgaXMgc3BlY2lmaWVkLCB0aGUgc2FtZSB3aW5kb3cgbGVuZ3RoXG4gICAqIHdpbGwgYmUgdXNlZCBmb3IgYWxsIGRpbWVuc2lvbnMuXG4gICAqL1xuICBwb29sU2l6ZT86IG51bWJlcnxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbiAgLyoqXG4gICAqIFRoZSBzaXplIG9mIHRoZSBzdHJpZGUgaW4gZWFjaCBkaW1lbnNpb24gb2YgdGhlIHBvb2xpbmcgd2luZG93LiBFeHBlY3RzXG4gICAqIGFuIGludGVnZXIgb3IgYW4gYXJyYXkgb2YgMyBpbnRlZ2Vycy4gSW50ZWdlciwgdHVwbGUgb2YgMyBpbnRlZ2Vycywgb3JcbiAgICogTm9uZS5cbiAgICpcbiAgICogSWYgYG51bGxgLCBkZWZhdWx0cyB0byBgcG9vbFNpemVgLlxuICAgKi9cbiAgc3RyaWRlcz86IG51bWJlcnxbbnVtYmVyLCBudW1iZXIsIG51bWJlcl07XG5cbiAgLyoqIFRoZSBwYWRkaW5nIHR5cGUgdG8gdXNlIGZvciB0aGUgcG9vbGluZyBsYXllci4gKi9cbiAgcGFkZGluZz86IFBhZGRpbmdNb2RlO1xuICAvKiogVGhlIGRhdGEgZm9ybWF0IHRvIHVzZSBmb3IgdGhlIHBvb2xpbmcgbGF5ZXIuICovXG4gIGRhdGFGb3JtYXQ/OiBEYXRhRm9ybWF0O1xufVxuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZvciBkaWZmZXJlbnQgcG9vbGluZyAzRCBsYXllcnMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBQb29saW5nM0QgZXh0ZW5kcyBMYXllciB7XG4gIHByb3RlY3RlZCByZWFkb25seSBwb29sU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgc3RyaWRlczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdO1xuICBwcm90ZWN0ZWQgcmVhZG9ubHkgcGFkZGluZzogUGFkZGluZ01vZGU7XG4gIHByb3RlY3RlZCByZWFkb25seSBkYXRhRm9ybWF0OiBEYXRhRm9ybWF0O1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFBvb2xpbmczRExheWVyQXJncykge1xuICAgIGlmIChhcmdzLnBvb2xTaXplID09IG51bGwpIHtcbiAgICAgIGFyZ3MucG9vbFNpemUgPSBbMiwgMiwgMl07XG4gICAgfVxuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMucG9vbFNpemUgPSBBcnJheS5pc0FycmF5KGFyZ3MucG9vbFNpemUpID9cbiAgICAgICAgYXJncy5wb29sU2l6ZSA6XG4gICAgICAgIFthcmdzLnBvb2xTaXplLCBhcmdzLnBvb2xTaXplLCBhcmdzLnBvb2xTaXplXTtcbiAgICBpZiAoYXJncy5zdHJpZGVzID09IG51bGwpIHtcbiAgICAgIHRoaXMuc3RyaWRlcyA9IHRoaXMucG9vbFNpemU7XG4gICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZ3Muc3RyaWRlcykpIHtcbiAgICAgIGlmIChhcmdzLnN0cmlkZXMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBWYWx1ZUVycm9yKFxuICAgICAgICAgICAgYElmIHRoZSBzdHJpZGVzIHByb3BlcnR5IG9mIGEgM0QgcG9vbGluZyBsYXllciBpcyBhbiBBcnJheSwgYCArXG4gICAgICAgICAgICBgaXQgaXMgZXhwZWN0ZWQgdG8gaGF2ZSBhIGxlbmd0aCBvZiAzLCBidXQgcmVjZWl2ZWQgbGVuZ3RoIGAgK1xuICAgICAgICAgICAgYCR7YXJncy5zdHJpZGVzLmxlbmd0aH0uYCk7XG4gICAgICB9XG4gICAgICB0aGlzLnN0cmlkZXMgPSBhcmdzLnN0cmlkZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGBjb25maWcuc3RyaWRlc2AgaXMgYSBudW1iZXIuXG4gICAgICB0aGlzLnN0cmlkZXMgPSBbYXJncy5zdHJpZGVzLCBhcmdzLnN0cmlkZXMsIGFyZ3Muc3RyaWRlc107XG4gICAgfVxuICAgIGFzc2VydFBvc2l0aXZlSW50ZWdlcih0aGlzLnBvb2xTaXplLCAncG9vbFNpemUnKTtcbiAgICBhc3NlcnRQb3NpdGl2ZUludGVnZXIodGhpcy5zdHJpZGVzLCAnc3RyaWRlcycpO1xuICAgIHRoaXMucGFkZGluZyA9IGFyZ3MucGFkZGluZyA9PSBudWxsID8gJ3ZhbGlkJyA6IGFyZ3MucGFkZGluZztcbiAgICB0aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICBhcmdzLmRhdGFGb3JtYXQgPT0gbnVsbCA/ICdjaGFubmVsc0xhc3QnIDogYXJncy5kYXRhRm9ybWF0O1xuICAgIGNoZWNrRGF0YUZvcm1hdCh0aGlzLmRhdGFGb3JtYXQpO1xuICAgIGNoZWNrUGFkZGluZ01vZGUodGhpcy5wYWRkaW5nKTtcblxuICAgIHRoaXMuaW5wdXRTcGVjID0gW25ldyBJbnB1dFNwZWMoe25kaW06IDV9KV07XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIGlucHV0U2hhcGUgPSBnZXRFeGFjdGx5T25lU2hhcGUoaW5wdXRTaGFwZSk7XG4gICAgbGV0IGRlcHRocyA9XG4gICAgICAgIHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzRmlyc3QnID8gaW5wdXRTaGFwZVsyXSA6IGlucHV0U2hhcGVbMV07XG4gICAgbGV0IHJvd3MgPVxuICAgICAgICB0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0JyA/IGlucHV0U2hhcGVbM10gOiBpbnB1dFNoYXBlWzJdO1xuICAgIGxldCBjb2xzID1cbiAgICAgICAgdGhpcy5kYXRhRm9ybWF0ID09PSAnY2hhbm5lbHNGaXJzdCcgPyBpbnB1dFNoYXBlWzRdIDogaW5wdXRTaGFwZVszXTtcbiAgICBkZXB0aHMgPSBjb252T3V0cHV0TGVuZ3RoKFxuICAgICAgICBkZXB0aHMsIHRoaXMucG9vbFNpemVbMF0sIHRoaXMucGFkZGluZywgdGhpcy5zdHJpZGVzWzBdKTtcbiAgICByb3dzID1cbiAgICAgICAgY29udk91dHB1dExlbmd0aChyb3dzLCB0aGlzLnBvb2xTaXplWzFdLCB0aGlzLnBhZGRpbmcsIHRoaXMuc3RyaWRlc1sxXSk7XG4gICAgY29scyA9XG4gICAgICAgIGNvbnZPdXRwdXRMZW5ndGgoY29scywgdGhpcy5wb29sU2l6ZVsyXSwgdGhpcy5wYWRkaW5nLCB0aGlzLnN0cmlkZXNbMl0pO1xuICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0ZpcnN0Jykge1xuICAgICAgcmV0dXJuIFtpbnB1dFNoYXBlWzBdLCBpbnB1dFNoYXBlWzFdLCBkZXB0aHMsIHJvd3MsIGNvbHNdO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGRlcHRocywgcm93cywgY29scywgaW5wdXRTaGFwZVs0XV07XG4gICAgfVxuICB9XG5cbiAgcHJvdGVjdGVkIGFic3RyYWN0IHBvb2xpbmdGdW5jdGlvbihcbiAgICAgIGlucHV0czogVGVuc29yLCBwb29sU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgc3RyaWRlczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBwYWRkaW5nOiBQYWRkaW5nTW9kZSxcbiAgICAgIGRhdGFGb3JtYXQ6IERhdGFGb3JtYXQpOiBUZW5zb3I7XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIHRoaXMuaW52b2tlQ2FsbEhvb2soaW5wdXRzLCBrd2FyZ3MpO1xuICAgICAgcmV0dXJuIHRoaXMucG9vbGluZ0Z1bmN0aW9uKFxuICAgICAgICAgIGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKSwgdGhpcy5wb29sU2l6ZSwgdGhpcy5zdHJpZGVzLFxuICAgICAgICAgIHRoaXMucGFkZGluZywgdGhpcy5kYXRhRm9ybWF0KTtcbiAgICB9KTtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgIHBvb2xTaXplOiB0aGlzLnBvb2xTaXplLFxuICAgICAgcGFkZGluZzogdGhpcy5wYWRkaW5nLFxuICAgICAgc3RyaWRlczogdGhpcy5zdHJpZGVzLFxuICAgICAgZGF0YUZvcm1hdDogdGhpcy5kYXRhRm9ybWF0XG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIE1heFBvb2xpbmczRCBleHRlbmRzIFBvb2xpbmczRCB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ01heFBvb2xpbmczRCc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFBvb2xpbmczRExheWVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHBvb2xpbmdGdW5jdGlvbihcbiAgICAgIGlucHV0czogVGVuc29yLCBwb29sU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgc3RyaWRlczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBwYWRkaW5nOiBQYWRkaW5nTW9kZSxcbiAgICAgIGRhdGFGb3JtYXQ6IERhdGFGb3JtYXQpOiBUZW5zb3Ige1xuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBjaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgIHJldHVybiBwb29sM2QoXG4gICAgICAgIGlucHV0cyBhcyBUZW5zb3I1RCwgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsICdtYXgnKTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKE1heFBvb2xpbmczRCk7XG5cbmV4cG9ydCBjbGFzcyBBdmVyYWdlUG9vbGluZzNEIGV4dGVuZHMgUG9vbGluZzNEIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQXZlcmFnZVBvb2xpbmczRCc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFBvb2xpbmczRExheWVyQXJncykge1xuICAgIHN1cGVyKGFyZ3MpO1xuICB9XG5cbiAgcHJvdGVjdGVkIHBvb2xpbmdGdW5jdGlvbihcbiAgICAgIGlucHV0czogVGVuc29yLCBwb29sU2l6ZTogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLFxuICAgICAgc3RyaWRlczogW251bWJlciwgbnVtYmVyLCBudW1iZXJdLCBwYWRkaW5nOiBQYWRkaW5nTW9kZSxcbiAgICAgIGRhdGFGb3JtYXQ6IERhdGFGb3JtYXQpOiBUZW5zb3Ige1xuICAgIGNoZWNrRGF0YUZvcm1hdChkYXRhRm9ybWF0KTtcbiAgICBjaGVja1BhZGRpbmdNb2RlKHBhZGRpbmcpO1xuICAgIHJldHVybiBwb29sM2QoXG4gICAgICAgIGlucHV0cyBhcyBUZW5zb3I1RCwgcG9vbFNpemUsIHN0cmlkZXMsIHBhZGRpbmcsIGRhdGFGb3JtYXQsICdhdmcnKTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEF2ZXJhZ2VQb29saW5nM0QpO1xuXG4vKipcbiAqIEFic3RyYWN0IGNsYXNzIGZvciBkaWZmZXJlbnQgZ2xvYmFsIHBvb2xpbmcgMUQgbGF5ZXJzLlxuICovXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgR2xvYmFsUG9vbGluZzFEIGV4dGVuZHMgTGF5ZXIge1xuICBjb25zdHJ1Y3RvcihhcmdzOiBMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLmlucHV0U3BlYyA9IFtuZXcgSW5wdXRTcGVjKHtuZGltOiAzfSldO1xuICB9XG5cbiAgY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGU6IFNoYXBlKTogU2hhcGUge1xuICAgIHJldHVybiBbaW5wdXRTaGFwZVswXSwgaW5wdXRTaGFwZVsyXV07XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCBleHRlbmRzIEdsb2JhbFBvb2xpbmcxRCB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ0dsb2JhbEF2ZXJhZ2VQb29saW5nMUQnO1xuICBjb25zdHJ1Y3RvcihhcmdzPzogTGF5ZXJBcmdzKSB7XG4gICAgc3VwZXIoYXJncyB8fCB7fSk7XG4gIH1cblxuICBjYWxsKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBrd2FyZ3M6IEt3YXJncyk6IFRlbnNvcnxUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRpZHkoKCkgPT4ge1xuICAgICAgY29uc3QgaW5wdXQgPSBnZXRFeGFjdGx5T25lVGVuc29yKGlucHV0cyk7XG4gICAgICByZXR1cm4gdGZjLm1lYW4oaW5wdXQsIDEpO1xuICAgIH0pO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsQXZlcmFnZVBvb2xpbmcxRCk7XG5cbmV4cG9ydCBjbGFzcyBHbG9iYWxNYXhQb29saW5nMUQgZXh0ZW5kcyBHbG9iYWxQb29saW5nMUQge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdHbG9iYWxNYXhQb29saW5nMUQnO1xuICBjb25zdHJ1Y3RvcihhcmdzOiBMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzIHx8IHt9KTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgIHJldHVybiB0ZmMubWF4KGlucHV0LCAxKTtcbiAgICB9KTtcbiAgfVxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKEdsb2JhbE1heFBvb2xpbmcxRCk7XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBHbG9iYWxQb29saW5nMkRMYXllckFyZ3MgZXh0ZW5kcyBMYXllckFyZ3Mge1xuICAvKipcbiAgICogT25lIG9mIGBDSEFOTkVMX0xBU1RgIChkZWZhdWx0KSBvciBgQ0hBTk5FTF9GSVJTVGAuXG4gICAqXG4gICAqIFRoZSBvcmRlcmluZyBvZiB0aGUgZGltZW5zaW9ucyBpbiB0aGUgaW5wdXRzLiBgQ0hBTk5FTF9MQVNUYCBjb3JyZXNwb25kc1xuICAgKiB0byBpbnB1dHMgd2l0aCBzaGFwZSBgW2JhdGNoLCBoZWlnaHQsIHdpZHRoLCBjaGFubmVsc1tgIHdoaWxlXG4gICAqIGBDSEFOTkVMX0ZJUlNUYCBjb3JyZXNwb25kcyB0byBpbnB1dHMgd2l0aCBzaGFwZVxuICAgKiBgW2JhdGNoLCBjaGFubmVscywgaGVpZ2h0LCB3aWR0aF1gLlxuICAgKi9cbiAgZGF0YUZvcm1hdD86IERhdGFGb3JtYXQ7XG59XG5cbi8qKlxuICogQWJzdHJhY3QgY2xhc3MgZm9yIGRpZmZlcmVudCBnbG9iYWwgcG9vbGluZyAyRCBsYXllcnMuXG4gKi9cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBHbG9iYWxQb29saW5nMkQgZXh0ZW5kcyBMYXllciB7XG4gIHByb3RlY3RlZCBkYXRhRm9ybWF0OiBEYXRhRm9ybWF0O1xuICBjb25zdHJ1Y3RvcihhcmdzOiBHbG9iYWxQb29saW5nMkRMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLmRhdGFGb3JtYXQgPVxuICAgICAgICBhcmdzLmRhdGFGb3JtYXQgPT0gbnVsbCA/ICdjaGFubmVsc0xhc3QnIDogYXJncy5kYXRhRm9ybWF0O1xuICAgIGNoZWNrRGF0YUZvcm1hdCh0aGlzLmRhdGFGb3JtYXQpO1xuICAgIHRoaXMuaW5wdXRTcGVjID0gW25ldyBJbnB1dFNwZWMoe25kaW06IDR9KV07XG4gIH1cblxuICBjb21wdXRlT3V0cHV0U2hhcGUoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IFNoYXBlfFNoYXBlW10ge1xuICAgIGlucHV0U2hhcGUgPSBpbnB1dFNoYXBlIGFzIFNoYXBlO1xuICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGlucHV0U2hhcGVbM11dO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gW2lucHV0U2hhcGVbMF0sIGlucHV0U2hhcGVbMV1dO1xuICAgIH1cbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICB0aHJvdyBuZXcgTm90SW1wbGVtZW50ZWRFcnJvcigpO1xuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnID0ge2RhdGFGb3JtYXQ6IHRoaXMuZGF0YUZvcm1hdH07XG4gICAgY29uc3QgYmFzZUNvbmZpZyA9IHN1cGVyLmdldENvbmZpZygpO1xuICAgIE9iamVjdC5hc3NpZ24oY29uZmlnLCBiYXNlQ29uZmlnKTtcbiAgICByZXR1cm4gY29uZmlnO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBHbG9iYWxBdmVyYWdlUG9vbGluZzJEIGV4dGVuZHMgR2xvYmFsUG9vbGluZzJEIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnR2xvYmFsQXZlcmFnZVBvb2xpbmcyRCc7XG5cbiAgY2FsbChpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXSwga3dhcmdzOiBLd2FyZ3MpOiBUZW5zb3J8VGVuc29yW10ge1xuICAgIHJldHVybiB0aWR5KCgpID0+IHtcbiAgICAgIGNvbnN0IGlucHV0ID0gZ2V0RXhhY3RseU9uZVRlbnNvcihpbnB1dHMpO1xuICAgICAgaWYgKHRoaXMuZGF0YUZvcm1hdCA9PT0gJ2NoYW5uZWxzTGFzdCcpIHtcbiAgICAgICAgcmV0dXJuIHRmYy5tZWFuKGlucHV0LCBbMSwgMl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRmYy5tZWFuKGlucHV0LCBbMiwgM10pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5zZXJpYWxpemF0aW9uLnJlZ2lzdGVyQ2xhc3MoR2xvYmFsQXZlcmFnZVBvb2xpbmcyRCk7XG5cbmV4cG9ydCBjbGFzcyBHbG9iYWxNYXhQb29saW5nMkQgZXh0ZW5kcyBHbG9iYWxQb29saW5nMkQge1xuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGNsYXNzTmFtZSA9ICdHbG9iYWxNYXhQb29saW5nMkQnO1xuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBpbnB1dCA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgIGlmICh0aGlzLmRhdGFGb3JtYXQgPT09ICdjaGFubmVsc0xhc3QnKSB7XG4gICAgICAgIHJldHVybiB0ZmMubWF4KGlucHV0LCBbMSwgMl0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRmYy5tYXgoaW5wdXQsIFsyLCAzXSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhHbG9iYWxNYXhQb29saW5nMkQpO1xuIl19","/**\n * @license\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n * =============================================================================\n */\n/**\n * Layers that augment the functionality of a base layer.\n */\nimport * as tfc from '@tensorflow/tfjs-core';\nimport { serialization, tidy } from '@tensorflow/tfjs-core';\nimport * as K from '../backend/tfjs_backend';\nimport { nameScope } from '../common';\nimport { InputSpec, Layer, SymbolicTensor } from '../engine/topology';\nimport { NotImplementedError, ValueError } from '../errors';\nimport { VALID_BIDIRECTIONAL_MERGE_MODES } from '../keras_format/common';\nimport * as generic_utils from '../utils/generic_utils';\nimport { getExactlyOneShape, getExactlyOneTensor } from '../utils/types_utils';\nimport { rnn, standardizeArgs } from './recurrent';\nimport { deserialize } from './serialization';\n/**\n * Abstract wrapper base class.\n *\n * Wrappers take another layer and augment it in various ways.\n * Do not use this class as a layer, it is only an abstract base class.\n * Two usable wrappers are the `TimeDistributed` and `Bidirectional` wrappers.\n */\nexport class Wrapper extends Layer {\n    constructor(args) {\n        // Porting Note: In PyKeras, `self.layer` is set prior to the calling\n        //   `super()`. But we can't do that here due to TypeScript's restriction.\n        //   See: https://github.com/Microsoft/TypeScript/issues/8277\n        //   As a result, we have to add checks in `get trainable()` and\n        //   `set trainable()` below in order to prevent using `this.layer` when\n        //   its value is `undefined`. The super constructor does use the getter\n        //   and the setter of `this.layer`.\n        super(args);\n        this.layer = args.layer;\n    }\n    build(inputShape) {\n        this.built = true;\n    }\n    // TODO(cais): Implement activityRegularizer getter.\n    get trainable() {\n        // Porting Note: the check of `this.layer` here is necessary due to the\n        //   way the `constructor` of this class is written (see Porting Note\n        //   above).\n        if (this.layer != null) {\n            return this.layer.trainable;\n        }\n        else {\n            return false;\n        }\n    }\n    set trainable(value) {\n        // Porting Note: the check of `this.layer` here is necessary due to the\n        //   way the `constructor` of this class is written (see Porting Note\n        //   above).\n        if (this.layer != null) {\n            this.layer.trainable = value;\n        }\n    }\n    get trainableWeights() {\n        return this.layer.trainableWeights;\n    }\n    // TODO(cais): Implement setter for trainableWeights.\n    get nonTrainableWeights() {\n        return this.layer.nonTrainableWeights;\n    }\n    // TODO(cais): Implement setter for nonTrainableWeights.\n    get updates() {\n        // tslint:disable-next-line:no-any\n        return this.layer._updates;\n    }\n    // TODO(cais): Implement getUpdatesFor().\n    get losses() {\n        return this.layer.losses;\n    }\n    // TODO(cais): Implement getLossesFor().\n    getWeights() {\n        return this.layer.getWeights();\n    }\n    setWeights(weights) {\n        this.layer.setWeights(weights);\n    }\n    getConfig() {\n        const config = {\n            'layer': {\n                'className': this.layer.getClassName(),\n                'config': this.layer.getConfig(),\n            }\n        };\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n    setFastWeightInitDuringBuild(value) {\n        super.setFastWeightInitDuringBuild(value);\n        if (this.layer != null) {\n            this.layer.setFastWeightInitDuringBuild(value);\n        }\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config, customObjects = {}) {\n        const layerConfig = config['layer'];\n        const layer = deserialize(layerConfig, customObjects);\n        delete config['layer'];\n        const newConfig = { layer };\n        Object.assign(newConfig, config);\n        return new cls(newConfig);\n    }\n}\nexport class TimeDistributed extends Wrapper {\n    constructor(args) {\n        super(args);\n        this.supportsMasking = true;\n    }\n    build(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        if (inputShape.length < 3) {\n            throw new ValueError(`TimeDistributed layer expects an input shape >= 3D, but received ` +\n                `input shape ${JSON.stringify(inputShape)}`);\n        }\n        this.inputSpec = [{ shape: inputShape }];\n        const childInputShape = [inputShape[0]].concat(inputShape.slice(2));\n        if (!this.layer.built) {\n            this.layer.build(childInputShape);\n            this.layer.built = true;\n        }\n        super.build(inputShape);\n    }\n    computeOutputShape(inputShape) {\n        inputShape = getExactlyOneShape(inputShape);\n        const childInputShape = [inputShape[0]].concat(inputShape.slice(2));\n        const childOutputShape = this.layer.computeOutputShape(childInputShape);\n        const timesteps = inputShape[1];\n        return [childOutputShape[0], timesteps].concat(childOutputShape.slice(1));\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            // TODO(cais): Add 'training' and 'useLearningPhase' to kwargs.\n            inputs = getExactlyOneTensor(inputs);\n            // Porting Note: In tfjs-layers, `inputs` are always concrete tensor\n            // values. Hence the inputs can't have an undetermined first (batch)\n            // dimension, which is why we always use the K.rnn approach here.\n            const step = (inputs, states) => {\n                // TODO(cais): Add useLearningPhase.\n                // NOTE(cais): `layer.call` may return a length-1 array of Tensor in\n                //   some cases (e.g., `layer` is a `Sequential` instance), which is\n                //   why `getExactlyOneTensor` is used below.\n                const output = getExactlyOneTensor(this.layer.call(inputs, kwargs));\n                return [output, []];\n            };\n            const rnnOutputs = rnn(step, inputs, [], false /* goBackwards */, null /* mask */, null /* constants */, false /* unroll */, true /* needPerStepOutputs */);\n            const y = rnnOutputs[1];\n            // TODO(cais): Add activity regularization.\n            // TODO(cais): Add useLearningPhase.\n            return y;\n        });\n    }\n}\n/** @nocollapse */\nTimeDistributed.className = 'TimeDistributed';\nserialization.registerClass(TimeDistributed);\nexport function checkBidirectionalMergeMode(value) {\n    generic_utils.checkStringTypeUnionValue(VALID_BIDIRECTIONAL_MERGE_MODES, 'BidirectionalMergeMode', value);\n}\nconst DEFAULT_BIDIRECTIONAL_MERGE_MODE = 'concat';\nexport class Bidirectional extends Wrapper {\n    constructor(args) {\n        super(args);\n        // Note: When creating `this.forwardLayer`, the original Layer object\n        //   (`config.layer`) ought to be cloned. This is why we call\n        //   `getConfig()` followed by `deserialize()`. Without this cloning,\n        //   the layer names saved during serialization will incorrectly contain\n        //   the 'forward_' prefix. In Python Keras, this is done using\n        //   `copy.copy` (shallow copy), which does not have a simple equivalent\n        //   in JavaScript. JavaScript's `Object.assign()` does not copy\n        //   methods.\n        const layerConfig = args.layer.getConfig();\n        const forwDict = {};\n        forwDict['className'] = args.layer.getClassName();\n        forwDict['config'] = layerConfig;\n        this.forwardLayer = deserialize(forwDict);\n        layerConfig['goBackwards'] =\n            layerConfig['goBackwards'] === true ? false : true;\n        const backDict = {};\n        backDict['className'] = args.layer.getClassName();\n        backDict['config'] = layerConfig;\n        this.backwardLayer = deserialize(backDict);\n        this.forwardLayer.name = 'forward_' + this.forwardLayer.name;\n        this.backwardLayer.name = 'backward_' + this.backwardLayer.name;\n        this.mergeMode = args.mergeMode === undefined ?\n            DEFAULT_BIDIRECTIONAL_MERGE_MODE :\n            args.mergeMode;\n        checkBidirectionalMergeMode(this.mergeMode);\n        if (args.weights) {\n            throw new NotImplementedError('weights support is not implemented for Bidirectional layer yet.');\n        }\n        this._stateful = args.layer.stateful;\n        this.returnSequences = args.layer.returnSequences;\n        this.returnState = args.layer.returnState;\n        this.supportsMasking = true;\n        this._trainable = true;\n        this.inputSpec = args.layer.inputSpec;\n        this.numConstants = null;\n    }\n    get trainable() {\n        return this._trainable;\n    }\n    set trainable(value) {\n        // Porting Note: the check of `this.layer` here is necessary due to the\n        //   way the `constructor` of this class is written (see Porting Note\n        //   above).\n        this._trainable = value;\n        if (this.forwardLayer != null) {\n            this.forwardLayer.trainable = value;\n        }\n        if (this.backwardLayer != null) {\n            this.backwardLayer.trainable = value;\n        }\n    }\n    getWeights() {\n        return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights());\n    }\n    setWeights(weights) {\n        const numWeights = weights.length;\n        const numeightsOver2 = Math.floor(numWeights / 2);\n        this.forwardLayer.setWeights(weights.slice(0, numeightsOver2));\n        this.backwardLayer.setWeights(weights.slice(numeightsOver2));\n    }\n    computeOutputShape(inputShape) {\n        let layerShapes = this.forwardLayer.computeOutputShape(inputShape);\n        if (!(Array.isArray(layerShapes) && Array.isArray(layerShapes[0]))) {\n            layerShapes = [layerShapes];\n        }\n        layerShapes = layerShapes;\n        let outputShape;\n        let outputShapes;\n        let stateShape;\n        if (this.returnState) {\n            stateShape = layerShapes.slice(1);\n            outputShape = layerShapes[0];\n        }\n        else {\n            outputShape = layerShapes[0];\n        }\n        outputShape = outputShape;\n        if (this.mergeMode === 'concat') {\n            outputShape[outputShape.length - 1] *= 2;\n            outputShapes = [outputShape];\n        }\n        else if (this.mergeMode == null) {\n            outputShapes = [outputShape, outputShape.slice()];\n        }\n        else {\n            outputShapes = [outputShape];\n        }\n        if (this.returnState) {\n            if (this.mergeMode == null) {\n                return outputShapes.concat(stateShape).concat(stateShape.slice());\n            }\n            return [outputShape].concat(stateShape).concat(stateShape.slice());\n        }\n        return generic_utils.singletonOrArray(outputShapes);\n    }\n    apply(inputs, kwargs) {\n        let initialState = kwargs == null ? null : kwargs['initialState'];\n        let constants = kwargs == null ? null : kwargs['constants'];\n        if (kwargs == null) {\n            kwargs = {};\n        }\n        const standardized = standardizeArgs(inputs, initialState, constants, this.numConstants);\n        inputs = standardized.inputs;\n        initialState = standardized.initialState;\n        constants = standardized.constants;\n        if (Array.isArray(inputs)) {\n            initialState = inputs.slice(1);\n            inputs = inputs[0];\n        }\n        if ((initialState == null || initialState.length === 0) &&\n            constants == null) {\n            return super.apply(inputs, kwargs);\n        }\n        const additionalInputs = [];\n        const additionalSpecs = [];\n        if (initialState != null) {\n            const numStates = initialState.length;\n            if (numStates % 2 > 0) {\n                throw new ValueError('When passing `initialState` to a Bidrectional RNN, ' +\n                    'the state should be an Array containing the states of ' +\n                    'the underlying RNNs.');\n            }\n            kwargs['initialState'] = initialState;\n            additionalInputs.push(...initialState);\n            const stateSpecs = initialState\n                .map(state => new InputSpec({ shape: state.shape }));\n            this.forwardLayer.stateSpec = stateSpecs.slice(0, numStates / 2);\n            this.backwardLayer.stateSpec = stateSpecs.slice(numStates / 2);\n            additionalSpecs.push(...stateSpecs);\n        }\n        if (constants != null) {\n            throw new NotImplementedError('Support for constants in Bidirectional layers is not ' +\n                'implemented yet.');\n        }\n        const isSymbolicTensor = additionalInputs[0] instanceof SymbolicTensor;\n        for (const tensor of additionalInputs) {\n            if (tensor instanceof SymbolicTensor !== isSymbolicTensor) {\n                throw new ValueError('The initial state of a Bidirectional layer cannot be ' +\n                    'specified as a mix of symbolic and non-symbolic tensors');\n            }\n        }\n        if (isSymbolicTensor) {\n            // Compute the full input and specs, including the states.\n            const fullInput = [inputs].concat(additionalInputs);\n            const fullInputSpec = this.inputSpec.concat(additionalSpecs);\n            // Perform the call temporarily and replace inputSpec.\n            // Note: with initial states symbolic calls and non-symbolic calls to\n            // this method differ in how the initial states are passed. For\n            // symbolic calls, the initial states are passed in the first arg, as\n            // an Array of SymbolicTensors; for non-symbolic calls, they are\n            // passed in the second arg as a part of the kwargs. Hence the need to\n            // temporarily modify inputSpec here.\n            // TODO(cais): Make refactoring so that this hacky code below is no\n            // longer needed.\n            const originalInputSpec = this.inputSpec;\n            this.inputSpec = fullInputSpec;\n            const output = super.apply(fullInput, kwargs);\n            this.inputSpec = originalInputSpec;\n            return output;\n        }\n        else {\n            return super.apply(inputs, kwargs);\n        }\n    }\n    call(inputs, kwargs) {\n        return tidy(() => {\n            const initialState = kwargs['initialState'];\n            let y;\n            let yRev;\n            if (initialState == null) {\n                y = this.forwardLayer.call(inputs, kwargs);\n                yRev = this.backwardLayer.call(inputs, kwargs);\n            }\n            else {\n                const forwardState = initialState.slice(0, initialState.length / 2);\n                const backwardState = initialState.slice(initialState.length / 2);\n                y = this.forwardLayer.call(inputs, Object.assign(kwargs, { initialState: forwardState }));\n                yRev = this.backwardLayer.call(inputs, Object.assign(kwargs, { initialState: backwardState }));\n            }\n            let states;\n            if (this.returnState) {\n                if (Array.isArray(y)) {\n                    states = y.slice(1).concat(yRev.slice(1));\n                }\n                else {\n                }\n                y = y[0];\n                yRev = yRev[0];\n            }\n            if (this.returnSequences) {\n                yRev = tfc.reverse(yRev, 1);\n            }\n            let output;\n            if (this.mergeMode === 'concat') {\n                output = K.concatenate([y, yRev]);\n            }\n            else if (this.mergeMode === 'sum') {\n                output = tfc.add(y, yRev);\n            }\n            else if (this.mergeMode === 'ave') {\n                output = tfc.mul(.5, tfc.add(y, yRev));\n            }\n            else if (this.mergeMode === 'mul') {\n                output = tfc.mul(y, yRev);\n            }\n            else if (this.mergeMode == null) {\n                output = [y, yRev];\n            }\n            // TODO(cais): Properly set learning phase.\n            if (this.returnState) {\n                if (this.mergeMode == null) {\n                    return output.concat(states);\n                }\n                return [output].concat(states);\n            }\n            return output;\n        });\n    }\n    resetStates(states) {\n        this.forwardLayer.resetStates();\n        this.backwardLayer.resetStates();\n    }\n    build(inputShape) {\n        nameScope(this.forwardLayer.name, () => {\n            this.forwardLayer.build(inputShape);\n        });\n        nameScope(this.backwardLayer.name, () => {\n            this.backwardLayer.build(inputShape);\n        });\n        this.built = true;\n    }\n    computeMask(inputs, mask) {\n        if (Array.isArray(mask)) {\n            mask = mask[0];\n        }\n        let outputMask;\n        if (this.returnSequences) {\n            if (this.mergeMode == null) {\n                outputMask = [mask, mask];\n            }\n            else {\n                outputMask = mask;\n            }\n        }\n        else {\n            if (this.mergeMode == null) {\n                outputMask = [null, null];\n            }\n            else {\n                outputMask = null;\n            }\n        }\n        if (this.returnState) {\n            const states = this.forwardLayer.states;\n            const stateMask = states.map(state => null);\n            if (Array.isArray(outputMask)) {\n                return outputMask.concat(stateMask).concat(stateMask);\n            }\n            else {\n                return [outputMask].concat(stateMask).concat(stateMask);\n            }\n        }\n        else {\n            return outputMask;\n        }\n    }\n    get trainableWeights() {\n        return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights);\n    }\n    get nonTrainableWeights() {\n        return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights);\n    }\n    // TODO(cais): Implement constraints().\n    setFastWeightInitDuringBuild(value) {\n        super.setFastWeightInitDuringBuild(value);\n        if (this.forwardLayer != null) {\n            this.forwardLayer.setFastWeightInitDuringBuild(value);\n        }\n        if (this.backwardLayer != null) {\n            this.backwardLayer.setFastWeightInitDuringBuild(value);\n        }\n    }\n    getConfig() {\n        const config = {\n            'mergeMode': this.mergeMode,\n        };\n        // TODO(cais): Add logic for `numConstants` once the property is added.\n        const baseConfig = super.getConfig();\n        Object.assign(config, baseConfig);\n        return config;\n    }\n    /** @nocollapse */\n    static fromConfig(cls, config) {\n        const rnnLayer = deserialize(config['layer']);\n        delete config['layer'];\n        // TODO(cais): Add logic for `numConstants` once the property is added.\n        if (config['numConstants'] != null) {\n            throw new NotImplementedError(`Deserialization of a Bidirectional layer with numConstants ` +\n                `present is not supported yet.`);\n        }\n        // tslint:disable-next-line:no-any\n        const newConfig = config;\n        newConfig['layer'] = rnnLayer;\n        return new cls(newConfig);\n    }\n}\n/** @nocollapse */\nBidirectional.className = 'Bidirectional';\nserialization.registerClass(Bidirectional);\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoid3JhcHBlcnMuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi90ZmpzLWxheWVycy9zcmMvbGF5ZXJzL3dyYXBwZXJzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7OztHQVFHO0FBRUg7O0dBRUc7QUFFSCxPQUFPLEtBQUssR0FBRyxNQUFNLHVCQUF1QixDQUFDO0FBQzdDLE9BQU8sRUFBQyxhQUFhLEVBQVUsSUFBSSxFQUFDLE1BQU0sdUJBQXVCLENBQUM7QUFDbEUsT0FBTyxLQUFLLENBQUMsTUFBTSx5QkFBeUIsQ0FBQztBQUM3QyxPQUFPLEVBQUMsU0FBUyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxTQUFTLEVBQUUsS0FBSyxFQUFhLGNBQWMsRUFBQyxNQUFNLG9CQUFvQixDQUFDO0FBQy9FLE9BQU8sRUFBQyxtQkFBbUIsRUFBRSxVQUFVLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDMUQsT0FBTyxFQUFnQywrQkFBK0IsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBR3RHLE9BQU8sS0FBSyxhQUFhLE1BQU0sd0JBQXdCLENBQUM7QUFDeEQsT0FBTyxFQUFDLGtCQUFrQixFQUFFLG1CQUFtQixFQUFDLE1BQU0sc0JBQXNCLENBQUM7QUFHN0UsT0FBTyxFQUFDLEdBQUcsRUFBTyxlQUFlLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDdEQsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBUzVDOzs7Ozs7R0FNRztBQUNILE1BQU0sT0FBZ0IsT0FBUSxTQUFRLEtBQUs7SUFHekMsWUFBWSxJQUFzQjtRQUNoQyxxRUFBcUU7UUFDckUsMEVBQTBFO1FBQzFFLDZEQUE2RDtRQUM3RCxnRUFBZ0U7UUFDaEUsd0VBQXdFO1FBQ3hFLHdFQUF3RTtRQUN4RSxvQ0FBb0M7UUFDcEMsS0FBSyxDQUFDLElBQUksQ0FBQyxDQUFDO1FBQ1osSUFBSSxDQUFDLEtBQUssR0FBRyxJ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VUFBVSxHQUFHLEtBQUssQ0FBQyxTQUFTLEVBQUUsQ0FBQztRQUNyQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sRUFBRSxVQUFVLENBQUMsQ0FBQztRQUNsQyxPQUFPLE1BQU0sQ0FBQztJQUNoQixDQUFDO0lBRUQsa0JBQWtCO0lBQ2xCLE1BQU0sQ0FBQyxVQUFVLENBQ2IsR0FBNkMsRUFDN0MsTUFBZ0M7UUFDbEMsTUFBTSxRQUFRLEdBQ1YsV0FBVyxDQUFDLE1BQU0sQ0FBQyxPQUFPLENBQTZCLENBQVEsQ0FBQztRQUNwRSxPQUFPLE1BQU0sQ0FBQyxPQUFPLENBQUMsQ0FBQztRQUN2Qix1RUFBdUU7UUFDdkUsSUFBSSxNQUFNLENBQUMsY0FBYyxDQUFDLElBQUksSUFBSSxFQUFFO1lBQ2xDLE1BQU0sSUFBSSxtQkFBbUIsQ0FDekIsNkRBQTZEO2dCQUM3RCwrQkFBK0IsQ0FBQyxDQUFDO1NBQ3RDO1FBQ0Qsa0NBQWtDO1FBQ2xDLE1BQU0sU0FBUyxHQUF5QixNQUFNLENBQUM7UUFDL0MsU0FBUyxDQUFDLE9BQU8sQ0FBQyxHQUFHLFFBQVEsQ0FBQztRQUM5QixPQUFPLElBQUksR0FBRyxDQUFDLFNBQVMsQ0FBQyxDQUFDO0lBQzVCLENBQUM7O0FBL1ZELGtCQUFrQjtBQUNYLHVCQUFTLEdBQUcsZUFBZSxDQUFDO0FBZ1dyQyxhQUFhLENBQUMsYUFBYSxDQUFDLGFBQWEsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTggR29vZ2xlIExMQ1xuICpcbiAqIFVzZSBvZiB0aGlzIHNvdXJjZSBjb2RlIGlzIGdvdmVybmVkIGJ5IGFuIE1JVC1zdHlsZVxuICogbGljZW5zZSB0aGF0IGNhbiBiZSBmb3VuZCBpbiB0aGUgTElDRU5TRSBmaWxlIG9yIGF0XG4gKiBodHRwczovL29wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL01JVC5cbiAqID09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09XG4gKi9cblxuLyoqXG4gKiBMYXllcnMgdGhhdCBhdWdtZW50IHRoZSBmdW5jdGlvbmFsaXR5IG9mIGEgYmFzZSBsYXllci5cbiAqL1xuXG5pbXBvcnQgKiBhcyB0ZmMgZnJvbSAnQHRlbnNvcmZsb3cvdGZqcy1jb3JlJztcbmltcG9ydCB7c2VyaWFsaXphdGlvbiwgVGVuc29yLCB0aWR5fSBmcm9tICdAdGVuc29yZmxvdy90ZmpzLWNvcmUnO1xuaW1wb3J0ICogYXMgSyBmcm9tICcuLi9iYWNrZW5kL3RmanNfYmFja2VuZCc7XG5pbXBvcnQge25hbWVTY29wZX0gZnJvbSAnLi4vY29tbW9uJztcbmltcG9ydCB7SW5wdXRTcGVjLCBMYXllciwgTGF5ZXJBcmdzLCBTeW1ib2xpY1RlbnNvcn0gZnJvbSAnLi4vZW5naW5lL3RvcG9sb2d5JztcbmltcG9ydCB7Tm90SW1wbGVtZW50ZWRFcnJvciwgVmFsdWVFcnJvcn0gZnJvbSAnLi4vZXJyb3JzJztcbmltcG9ydCB7QmlkaXJlY3Rpb25hbE1lcmdlTW9kZSwgU2hhcGUsIFZBTElEX0JJRElSRUNUSU9OQUxfTUVSR0VfTU9ERVN9IGZyb20gJy4uL2tlcmFzX2Zvcm1hdC9jb21tb24nO1xuaW1wb3J0IHtLd2FyZ3N9IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7UmVndWxhcml6ZXJGbiwgUm5uU3RlcEZ1bmN0aW9ufSBmcm9tICcuLi90eXBlcyc7XG5pbXBvcnQgKiBhcyBnZW5lcmljX3V0aWxzIGZyb20gJy4uL3V0aWxzL2dlbmVyaWNfdXRpbHMnO1xuaW1wb3J0IHtnZXRFeGFjdGx5T25lU2hhcGUsIGdldEV4YWN0bHlPbmVUZW5zb3J9IGZyb20gJy4uL3V0aWxzL3R5cGVzX3V0aWxzJztcbmltcG9ydCB7TGF5ZXJWYXJpYWJsZX0gZnJvbSAnLi4vdmFyaWFibGVzJztcblxuaW1wb3J0IHtybm4sIFJOTiwgc3RhbmRhcmRpemVBcmdzfSBmcm9tICcuL3JlY3VycmVudCc7XG5pbXBvcnQge2Rlc2VyaWFsaXplfSBmcm9tICcuL3NlcmlhbGl6YXRpb24nO1xuXG5leHBvcnQgZGVjbGFyZSBpbnRlcmZhY2UgV3JhcHBlckxheWVyQXJncyBleHRlbmRzIExheWVyQXJncyB7XG4gIC8qKlxuICAgKiBUaGUgbGF5ZXIgdG8gYmUgd3JhcHBlZC5cbiAgICovXG4gIGxheWVyOiBMYXllcjtcbn1cblxuLyoqXG4gKiBBYnN0cmFjdCB3cmFwcGVyIGJhc2UgY2xhc3MuXG4gKlxuICogV3JhcHBlcnMgdGFrZSBhbm90aGVyIGxheWVyIGFuZCBhdWdtZW50IGl0IGluIHZhcmlvdXMgd2F5cy5cbiAqIERvIG5vdCB1c2UgdGhpcyBjbGFzcyBhcyBhIGxheWVyLCBpdCBpcyBvbmx5IGFuIGFic3RyYWN0IGJhc2UgY2xhc3MuXG4gKiBUd28gdXNhYmxlIHdyYXBwZXJzIGFyZSB0aGUgYFRpbWVEaXN0cmlidXRlZGAgYW5kIGBCaWRpcmVjdGlvbmFsYCB3cmFwcGVycy5cbiAqL1xuZXhwb3J0IGFic3RyYWN0IGNsYXNzIFdyYXBwZXIgZXh0ZW5kcyBMYXllciB7XG4gIHJlYWRvbmx5IGxheWVyOiBMYXllcjtcblxuICBjb25zdHJ1Y3RvcihhcmdzOiBXcmFwcGVyTGF5ZXJBcmdzKSB7XG4gICAgLy8gUG9ydGluZyBOb3RlOiBJbiBQeUtlcmFzLCBgc2VsZi5sYXllcmAgaXMgc2V0IHByaW9yIHRvIHRoZSBjYWxsaW5nXG4gICAgLy8gICBgc3VwZXIoKWAuIEJ1dCB3ZSBjYW4ndCBkbyB0aGF0IGhlcmUgZHVlIHRvIFR5cGVTY3JpcHQncyByZXN0cmljdGlvbi5cbiAgICAvLyAgIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL01pY3Jvc29mdC9UeXBlU2NyaXB0L2lzc3Vlcy84Mjc3XG4gICAgLy8gICBBcyBhIHJlc3VsdCwgd2UgaGF2ZSB0byBhZGQgY2hlY2tzIGluIGBnZXQgdHJhaW5hYmxlKClgIGFuZFxuICAgIC8vICAgYHNldCB0cmFpbmFibGUoKWAgYmVsb3cgaW4gb3JkZXIgdG8gcHJldmVudCB1c2luZyBgdGhpcy5sYXllcmAgd2hlblxuICAgIC8vICAgaXRzIHZhbHVlIGlzIGB1bmRlZmluZWRgLiBUaGUgc3VwZXIgY29uc3RydWN0b3IgZG9lcyB1c2UgdGhlIGdldHRlclxuICAgIC8vICAgYW5kIHRoZSBzZXR0ZXIgb2YgYHRoaXMubGF5ZXJgLlxuICAgIHN1cGVyKGFyZ3MpO1xuICAgIHRoaXMubGF5ZXIgPSBhcmdzLmxheWVyO1xuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIHRoaXMuYnVpbHQgPSB0cnVlO1xuICB9XG5cbiAgLy8gVE9ETyhjYWlzKTogSW1wbGVtZW50IGFjdGl2aXR5UmVndWxhcml6ZXIgZ2V0dGVyLlxuXG4gIGdldCB0cmFpbmFibGUoKTogYm9vbGVhbiB7XG4gICAgLy8gUG9ydGluZyBOb3RlOiB0aGUgY2hlY2sgb2YgYHRoaXMubGF5ZXJgIGhlcmUgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGVcbiAgICAvLyAgIHdheSB0aGUgYGNvbnN0cnVjdG9yYCBvZiB0aGlzIGNsYXNzIGlzIHdyaXR0ZW4gKHNlZSBQb3J0aW5nIE5vdGVcbiAgICAvLyAgIGFib3ZlKS5cbiAgICBpZiAodGhpcy5sYXllciAhPSBudWxsKSB7XG4gICAgICByZXR1cm4gdGhpcy5sYXllci50cmFpbmFibGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBzZXQgdHJhaW5hYmxlKHZhbHVlOiBib29sZWFuKSB7XG4gICAgLy8gUG9ydGluZyBOb3RlOiB0aGUgY2hlY2sgb2YgYHRoaXMubGF5ZXJgIGhlcmUgaXMgbmVjZXNzYXJ5IGR1ZSB0byB0aGVcbiAgICAvLyAgIHdheSB0aGUgYGNvbnN0cnVjdG9yYCBvZiB0aGlzIGNsYXNzIGlzIHdyaXR0ZW4gKHNlZSBQb3J0aW5nIE5vdGVcbiAgICAvLyAgIGFib3ZlKS5cbiAgICBpZiAodGhpcy5sYXllciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmxheWVyLnRyYWluYWJsZSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuXG4gIGdldCB0cmFpbmFibGVXZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXIudHJhaW5hYmxlV2VpZ2h0cztcbiAgfVxuICAvLyBUT0RPKGNhaXMpOiBJbXBsZW1lbnQgc2V0dGVyIGZvciB0cmFpbmFibGVXZWlnaHRzLlxuXG4gIGdldCBub25UcmFpbmFibGVXZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXIubm9uVHJhaW5hYmxlV2VpZ2h0cztcbiAgfVxuICAvLyBUT0RPKGNhaXMpOiBJbXBsZW1lbnQgc2V0dGVyIGZvciBub25UcmFpbmFibGVXZWlnaHRzLlxuXG4gIGdldCB1cGRhdGVzKCk6IFRlbnNvcltdIHtcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XG4gICAgcmV0dXJuICh0aGlzLmxheWVyIGFzIGFueSkuX3VwZGF0ZXM7XG4gIH1cblxuICAvLyBUT0RPKGNhaXMpOiBJbXBsZW1lbnQgZ2V0VXBkYXRlc0ZvcigpLlxuXG4gIGdldCBsb3NzZXMoKTogUmVndWxhcml6ZXJGbltdIHtcbiAgICByZXR1cm4gdGhpcy5sYXllci5sb3NzZXM7XG4gIH1cblxuICAvLyBUT0RPKGNhaXMpOiBJbXBsZW1lbnQgZ2V0TG9zc2VzRm9yKCkuXG5cbiAgZ2V0V2VpZ2h0cygpOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRoaXMubGF5ZXIuZ2V0V2VpZ2h0cygpO1xuICB9XG5cbiAgc2V0V2VpZ2h0cyh3ZWlnaHRzOiBUZW5zb3JbXSk6IHZvaWQge1xuICAgIHRoaXMubGF5ZXIuc2V0V2VpZ2h0cyh3ZWlnaHRzKTtcbiAgfVxuXG4gIGdldENvbmZpZygpOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3Qge1xuICAgIGNvbnN0IGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge1xuICAgICAgJ2xheWVyJzoge1xuICAgICAgICAnY2xhc3NOYW1lJzogdGhpcy5sYXllci5nZXRDbGFzc05hbWUoKSxcbiAgICAgICAgJ2NvbmZpZyc6IHRoaXMubGF5ZXIuZ2V0Q29uZmlnKCksXG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBiYXNlQ29uZmlnID0gc3VwZXIuZ2V0Q29uZmlnKCk7XG4gICAgT2JqZWN0LmFzc2lnbihjb25maWcsIGJhc2VDb25maWcpO1xuICAgIHJldHVybiBjb25maWc7XG4gIH1cblxuICBzZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHZhbHVlOiBib29sZWFuKSB7XG4gICAgc3VwZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh2YWx1ZSk7XG4gICAgaWYgKHRoaXMubGF5ZXIgIT0gbnVsbCkge1xuICAgICAgdGhpcy5sYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKiogQG5vY29sbGFwc2UgKi9cbiAgc3RhdGljIGZyb21Db25maWc8VCBleHRlbmRzIHNlcmlhbGl6YXRpb24uU2VyaWFsaXphYmxlPihcbiAgICAgIGNsczogc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGVDb25zdHJ1Y3RvcjxUPixcbiAgICAgIGNvbmZpZzogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0LFxuICAgICAgY3VzdG9tT2JqZWN0cyA9IHt9IGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCk6IFQge1xuICAgIGNvbnN0IGxheWVyQ29uZmlnID0gY29uZmlnWydsYXllciddIGFzIHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdDtcbiAgICBjb25zdCBsYXllciA9IGRlc2VyaWFsaXplKGxheWVyQ29uZmlnLCBjdXN0b21PYmplY3RzKSBhcyBMYXllcjtcbiAgICBkZWxldGUgY29uZmlnWydsYXllciddO1xuICAgIGNvbnN0IG5ld0NvbmZpZyA9IHtsYXllcn07XG4gICAgT2JqZWN0LmFzc2lnbihuZXdDb25maWcsIGNvbmZpZyk7XG4gICAgcmV0dXJuIG5ldyBjbHMobmV3Q29uZmlnKTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgVGltZURpc3RyaWJ1dGVkIGV4dGVuZHMgV3JhcHBlciB7XG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgY2xhc3NOYW1lID0gJ1RpbWVEaXN0cmlidXRlZCc7XG4gIGNvbnN0cnVjdG9yKGFyZ3M6IFdyYXBwZXJMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gIH1cblxuICBidWlsZChpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogdm9pZCB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBpZiAoaW5wdXRTaGFwZS5sZW5ndGggPCAzKSB7XG4gICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICBgVGltZURpc3RyaWJ1dGVkIGxheWVyIGV4cGVjdHMgYW4gaW5wdXQgc2hhcGUgPj0gM0QsIGJ1dCByZWNlaXZlZCBgICtcbiAgICAgICAgICBgaW5wdXQgc2hhcGUgJHtKU09OLnN0cmluZ2lmeShpbnB1dFNoYXBlKX1gKTtcbiAgICB9XG4gICAgdGhpcy5pbnB1dFNwZWMgPSBbe3NoYXBlOiBpbnB1dFNoYXBlfV07XG4gICAgY29uc3QgY2hpbGRJbnB1dFNoYXBlID0gW2lucHV0U2hhcGVbMF1dLmNvbmNhdChpbnB1dFNoYXBlLnNsaWNlKDIpKTtcbiAgICBpZiAoIXRoaXMubGF5ZXIuYnVpbHQpIHtcbiAgICAgIHRoaXMubGF5ZXIuYnVpbGQoY2hpbGRJbnB1dFNoYXBlKTtcbiAgICAgIHRoaXMubGF5ZXIuYnVpbHQgPSB0cnVlO1xuICAgIH1cbiAgICBzdXBlci5idWlsZChpbnB1dFNoYXBlKTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgaW5wdXRTaGFwZSA9IGdldEV4YWN0bHlPbmVTaGFwZShpbnB1dFNoYXBlKTtcbiAgICBjb25zdCBjaGlsZElucHV0U2hhcGUgPSBbaW5wdXRTaGFwZVswXV0uY29uY2F0KGlucHV0U2hhcGUuc2xpY2UoMikpO1xuICAgIGNvbnN0IGNoaWxkT3V0cHV0U2hhcGUgPVxuICAgICAgICB0aGlzLmxheWVyLmNvbXB1dGVPdXRwdXRTaGFwZShjaGlsZElucHV0U2hhcGUpIGFzIFNoYXBlO1xuICAgIGNvbnN0IHRpbWVzdGVwcyA9IGlucHV0U2hhcGVbMV07XG4gICAgcmV0dXJuIFtjaGlsZE91dHB1dFNoYXBlWzBdLCB0aW1lc3RlcHNdLmNvbmNhdChjaGlsZE91dHB1dFNoYXBlLnNsaWNlKDEpKTtcbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgJ3RyYWluaW5nJyBhbmQgJ3VzZUxlYXJuaW5nUGhhc2UnIHRvIGt3YXJncy5cbiAgICAgIGlucHV0cyA9IGdldEV4YWN0bHlPbmVUZW5zb3IoaW5wdXRzKTtcbiAgICAgIC8vIFBvcnRpbmcgTm90ZTogSW4gdGZqcy1sYXllcnMsIGBpbnB1dHNgIGFyZSBhbHdheXMgY29uY3JldGUgdGVuc29yXG4gICAgICAvLyB2YWx1ZXMuIEhlbmNlIHRoZSBpbnB1dHMgY2FuJ3QgaGF2ZSBhbiB1bmRldGVybWluZWQgZmlyc3QgKGJhdGNoKVxuICAgICAgLy8gZGltZW5zaW9uLCB3aGljaCBpcyB3aHkgd2UgYWx3YXlzIHVzZSB0aGUgSy5ybm4gYXBwcm9hY2ggaGVyZS5cbiAgICAgIGNvbnN0IHN0ZXA6IFJublN0ZXBGdW5jdGlvbiA9IChpbnB1dHM6IFRlbnNvciwgc3RhdGVzOiBUZW5zb3JbXSkgPT4ge1xuICAgICAgICAvLyBUT0RPKGNhaXMpOiBBZGQgdXNlTGVhcm5pbmdQaGFzZS5cbiAgICAgICAgLy8gTk9URShjYWlzKTogYGxheWVyLmNhbGxgIG1heSByZXR1cm4gYSBsZW5ndGgtMSBhcnJheSBvZiBUZW5zb3IgaW5cbiAgICAgICAgLy8gICBzb21lIGNhc2VzIChlLmcuLCBgbGF5ZXJgIGlzIGEgYFNlcXVlbnRpYWxgIGluc3RhbmNlKSwgd2hpY2ggaXNcbiAgICAgICAgLy8gICB3aHkgYGdldEV4YWN0bHlPbmVUZW5zb3JgIGlzIHVzZWQgYmVsb3cuXG4gICAgICAgIGNvbnN0IG91dHB1dCA9IGdldEV4YWN0bHlPbmVUZW5zb3IodGhpcy5sYXllci5jYWxsKGlucHV0cywga3dhcmdzKSk7XG4gICAgICAgIHJldHVybiBbb3V0cHV0LCBbXV07XG4gICAgICB9O1xuICAgICAgY29uc3Qgcm5uT3V0cHV0cyA9XG4gICAgICAgICAgcm5uKHN0ZXAsIGlucHV0cywgW10sIGZhbHNlIC8qIGdvQmFja3dhcmRzICovLCBudWxsIC8qIG1hc2sgKi8sXG4gICAgICAgICAgICAgIG51bGwgLyogY29uc3RhbnRzICovLCBmYWxzZSAvKiB1bnJvbGwgKi8sXG4gICAgICAgICAgICAgIHRydWUgLyogbmVlZFBlclN0ZXBPdXRwdXRzICovKTtcbiAgICAgIGNvbnN0IHkgPSBybm5PdXRwdXRzWzFdO1xuICAgICAgLy8gVE9ETyhjYWlzKTogQWRkIGFjdGl2aXR5IHJlZ3VsYXJpemF0aW9uLlxuICAgICAgLy8gVE9ETyhjYWlzKTogQWRkIHVzZUxlYXJuaW5nUGhhc2UuXG4gICAgICByZXR1cm4geTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIFRPRE8oY2Fpcyk6IEltcGxlbWVudCBkZXRhaWxlZCBjb21wdXRlTWFzaygpIGxvZ2ljLlxufVxuc2VyaWFsaXphdGlvbi5yZWdpc3RlckNsYXNzKFRpbWVEaXN0cmlidXRlZCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjaGVja0JpZGlyZWN0aW9uYWxNZXJnZU1vZGUodmFsdWU/OiBzdHJpbmcpOiB2b2lkIHtcbiAgZ2VuZXJpY191dGlscy5jaGVja1N0cmluZ1R5cGVVbmlvblZhbHVlKFxuICAgICAgVkFMSURfQklESVJFQ1RJT05BTF9NRVJHRV9NT0RFUywgJ0JpZGlyZWN0aW9uYWxNZXJnZU1vZGUnLCB2YWx1ZSk7XG59XG5cbmV4cG9ydCBkZWNsYXJlIGludGVyZmFjZSBCaWRpcmVjdGlvbmFsTGF5ZXJBcmdzIGV4dGVuZHMgV3JhcHBlckxheWVyQXJncyB7XG4gIC8qKlxuICAgKiBUaGUgaW5zdGFuY2Ugb2YgYW4gYFJOTmAgbGF5ZXIgdG8gYmUgd3JhcHBlZC5cbiAgICovXG4gIGxheWVyOiBSTk47XG5cbiAgLyoqXG4gICAqIE1vZGUgYnkgd2hpY2ggb3V0cHV0cyBvZiB0aGUgZm9yd2FyZCBhbmQgYmFja3dhcmQgUk5OcyBhcmVcbiAgICogY29tYmluZWQuIElmIGBudWxsYCBvciBgdW5kZWZpbmVkYCwgdGhlIG91dHB1dCB3aWxsIG5vdCBiZVxuICAgKiBjb21iaW5lZCwgdGhleSB3aWxsIGJlIHJldHVybmVkIGFzIGFuIGBBcnJheWAuXG4gICAqXG4gICAqIElmIGB1bmRlZmluZWRgIChpLmUuLCBub3QgcHJvdmlkZWQpLCBkZWZhdWx0cyB0byBgJ2NvbmNhdCdgLlxuICAgKi9cbiAgbWVyZ2VNb2RlPzogQmlkaXJlY3Rpb25hbE1lcmdlTW9kZTtcbn1cblxuY29uc3QgREVGQVVMVF9CSURJUkVDVElPTkFMX01FUkdFX01PREU6IEJpZGlyZWN0aW9uYWxNZXJnZU1vZGUgPSAnY29uY2F0JztcblxuZXhwb3J0IGNsYXNzIEJpZGlyZWN0aW9uYWwgZXh0ZW5kcyBXcmFwcGVyIHtcbiAgLyoqIEBub2NvbGxhcHNlICovXG4gIHN0YXRpYyBjbGFzc05hbWUgPSAnQmlkaXJlY3Rpb25hbCc7XG4gIG1lcmdlTW9kZTogQmlkaXJlY3Rpb25hbE1lcmdlTW9kZTtcbiAgcHJpdmF0ZSBmb3J3YXJkTGF5ZXI6IFJOTjtcbiAgcHJpdmF0ZSBiYWNrd2FyZExheWVyOiBSTk47XG4gIHByaXZhdGUgcmV0dXJuU2VxdWVuY2VzOiBib29sZWFuO1xuICBwcml2YXRlIHJldHVyblN0YXRlOiBib29sZWFuO1xuICBwcml2YXRlIG51bUNvbnN0YW50cz86IG51bWJlcjtcbiAgcHJpdmF0ZSBfdHJhaW5hYmxlOiBib29sZWFuO1xuXG4gIGNvbnN0cnVjdG9yKGFyZ3M6IEJpZGlyZWN0aW9uYWxMYXllckFyZ3MpIHtcbiAgICBzdXBlcihhcmdzKTtcblxuICAgIC8vIE5vdGU6IFdoZW4gY3JlYXRpbmcgYHRoaXMuZm9yd2FyZExheWVyYCwgdGhlIG9yaWdpbmFsIExheWVyIG9iamVjdFxuICAgIC8vICAgKGBjb25maWcubGF5ZXJgKSBvdWdodCB0byBiZSBjbG9uZWQuIFRoaXMgaXMgd2h5IHdlIGNhbGxcbiAgICAvLyAgIGBnZXRDb25maWcoKWAgZm9sbG93ZWQgYnkgYGRlc2VyaWFsaXplKClgLiBXaXRob3V0IHRoaXMgY2xvbmluZyxcbiAgICAvLyAgIHRoZSBsYXllciBuYW1lcyBzYXZlZCBkdXJpbmcgc2VyaWFsaXphdGlvbiB3aWxsIGluY29ycmVjdGx5IGNvbnRhaW5cbiAgICAvLyAgIHRoZSAnZm9yd2FyZF8nIHByZWZpeC4gSW4gUHl0aG9uIEtlcmFzLCB0aGlzIGlzIGRvbmUgdXNpbmdcbiAgICAvLyAgIGBjb3B5LmNvcHlgIChzaGFsbG93IGNvcHkpLCB3aGljaCBkb2VzIG5vdCBoYXZlIGEgc2ltcGxlIGVxdWl2YWxlbnRcbiAgICAvLyAgIGluIEphdmFTY3JpcHQuIEphdmFTY3JpcHQncyBgT2JqZWN0LmFzc2lnbigpYCBkb2VzIG5vdCBjb3B5XG4gICAgLy8gICBtZXRob2RzLlxuICAgIGNvbnN0IGxheWVyQ29uZmlnID0gYXJncy5sYXllci5nZXRDb25maWcoKTtcbiAgICBjb25zdCBmb3J3RGljdDogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge307XG4gICAgZm9yd0RpY3RbJ2NsYXNzTmFtZSddID0gYXJncy5sYXllci5nZXRDbGFzc05hbWUoKTtcbiAgICBmb3J3RGljdFsnY29uZmlnJ10gPSBsYXllckNvbmZpZztcbiAgICB0aGlzLmZvcndhcmRMYXllciA9IGRlc2VyaWFsaXplKGZvcndEaWN0KSBhcyBSTk47XG4gICAgbGF5ZXJDb25maWdbJ2dvQmFja3dhcmRzJ10gPVxuICAgICAgICBsYXllckNvbmZpZ1snZ29CYWNrd2FyZHMnXSA9PT0gdHJ1ZSA/IGZhbHNlIDogdHJ1ZTtcbiAgICBjb25zdCBiYWNrRGljdDogc2VyaWFsaXphdGlvbi5Db25maWdEaWN0ID0ge307XG4gICAgYmFja0RpY3RbJ2NsYXNzTmFtZSddID0gYXJncy5sYXllci5nZXRDbGFzc05hbWUoKTtcbiAgICBiYWNrRGljdFsnY29uZmlnJ10gPSBsYXllckNvbmZpZztcbiAgICB0aGlzLmJhY2t3YXJkTGF5ZXIgPSBkZXNlcmlhbGl6ZShiYWNrRGljdCkgYXMgUk5OO1xuICAgIHRoaXMuZm9yd2FyZExheWVyLm5hbWUgPSAnZm9yd2FyZF8nICsgdGhpcy5mb3J3YXJkTGF5ZXIubmFtZTtcbiAgICB0aGlzLmJhY2t3YXJkTGF5ZXIubmFtZSA9ICdiYWNrd2FyZF8nICsgdGhpcy5iYWNrd2FyZExheWVyLm5hbWU7XG5cbiAgICB0aGlzLm1lcmdlTW9kZSA9IGFyZ3MubWVyZ2VNb2RlID09PSB1bmRlZmluZWQgP1xuICAgICAgICBERUZBVUxUX0JJRElSRUNUSU9OQUxfTUVSR0VfTU9ERSA6XG4gICAgICAgIGFyZ3MubWVyZ2VNb2RlO1xuICAgIGNoZWNrQmlkaXJlY3Rpb25hbE1lcmdlTW9kZSh0aGlzLm1lcmdlTW9kZSk7XG4gICAgaWYgKGFyZ3Mud2VpZ2h0cykge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ3dlaWdodHMgc3VwcG9ydCBpcyBub3QgaW1wbGVtZW50ZWQgZm9yIEJpZGlyZWN0aW9uYWwgbGF5ZXIgeWV0LicpO1xuICAgIH1cbiAgICB0aGlzLl9zdGF0ZWZ1bCA9IGFyZ3MubGF5ZXIuc3RhdGVmdWw7XG4gICAgdGhpcy5yZXR1cm5TZXF1ZW5jZXMgPSBhcmdzLmxheWVyLnJldHVyblNlcXVlbmNlcztcbiAgICB0aGlzLnJldHVyblN0YXRlID0gYXJncy5sYXllci5yZXR1cm5TdGF0ZTtcbiAgICB0aGlzLnN1cHBvcnRzTWFza2luZyA9IHRydWU7XG4gICAgdGhpcy5fdHJhaW5hYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmlucHV0U3BlYyA9IGFyZ3MubGF5ZXIuaW5wdXRTcGVjO1xuICAgIHRoaXMubnVtQ29uc3RhbnRzID0gbnVsbDtcbiAgfVxuXG4gIGdldCB0cmFpbmFibGUoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYWluYWJsZTtcbiAgfVxuXG4gIHNldCB0cmFpbmFibGUodmFsdWU6IGJvb2xlYW4pIHtcbiAgICAvLyBQb3J0aW5nIE5vdGU6IHRoZSBjaGVjayBvZiBgdGhpcy5sYXllcmAgaGVyZSBpcyBuZWNlc3NhcnkgZHVlIHRvIHRoZVxuICAgIC8vICAgd2F5IHRoZSBgY29uc3RydWN0b3JgIG9mIHRoaXMgY2xhc3MgaXMgd3JpdHRlbiAoc2VlIFBvcnRpbmcgTm90ZVxuICAgIC8vICAgYWJvdmUpLlxuICAgIHRoaXMuX3RyYWluYWJsZSA9IHZhbHVlO1xuICAgIGlmICh0aGlzLmZvcndhcmRMYXllciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZvcndhcmRMYXllci50cmFpbmFibGUgPSB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja3dhcmRMYXllciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlID0gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgZ2V0V2VpZ2h0cygpOiBUZW5zb3JbXSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLmdldFdlaWdodHMoKS5jb25jYXQoXG4gICAgICAgIHRoaXMuYmFja3dhcmRMYXllci5nZXRXZWlnaHRzKCkpO1xuICB9XG5cbiAgc2V0V2VpZ2h0cyh3ZWlnaHRzOiBUZW5zb3JbXSk6IHZvaWQge1xuICAgIGNvbnN0IG51bVdlaWdodHMgPSB3ZWlnaHRzLmxlbmd0aDtcbiAgICBjb25zdCBudW1laWdodHNPdmVyMiA9IE1hdGguZmxvb3IobnVtV2VpZ2h0cyAvIDIpO1xuICAgIHRoaXMuZm9yd2FyZExheWVyLnNldFdlaWdodHMod2VpZ2h0cy5zbGljZSgwLCBudW1laWdodHNPdmVyMikpO1xuICAgIHRoaXMuYmFja3dhcmRMYXllci5zZXRXZWlnaHRzKHdlaWdodHMuc2xpY2UobnVtZWlnaHRzT3ZlcjIpKTtcbiAgfVxuXG4gIGNvbXB1dGVPdXRwdXRTaGFwZShpbnB1dFNoYXBlOiBTaGFwZXxTaGFwZVtdKTogU2hhcGV8U2hhcGVbXSB7XG4gICAgbGV0IGxheWVyU2hhcGVzOiBTaGFwZXxTaGFwZVtdID1cbiAgICAgICAgdGhpcy5mb3J3YXJkTGF5ZXIuY29tcHV0ZU91dHB1dFNoYXBlKGlucHV0U2hhcGUpO1xuICAgIGlmICghKEFycmF5LmlzQXJyYXkobGF5ZXJTaGFwZXMpICYmIEFycmF5LmlzQXJyYXkobGF5ZXJTaGFwZXNbMF0pKSkge1xuICAgICAgbGF5ZXJTaGFwZXMgPSBbbGF5ZXJTaGFwZXMgYXMgU2hhcGVdO1xuICAgIH1cbiAgICBsYXllclNoYXBlcyA9IGxheWVyU2hhcGVzIGFzIFNoYXBlW107XG5cbiAgICBsZXQgb3V0cHV0U2hhcGU6IFNoYXBlO1xuICAgIGxldCBvdXRwdXRTaGFwZXM6IFNoYXBlW107XG4gICAgbGV0IHN0YXRlU2hhcGU6IFNoYXBlW107XG4gICAgaWYgKHRoaXMucmV0dXJuU3RhdGUpIHtcbiAgICAgIHN0YXRlU2hhcGUgPSBsYXllclNoYXBlcy5zbGljZSgxKTtcbiAgICAgIG91dHB1dFNoYXBlID0gbGF5ZXJTaGFwZXNbMF07XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dHB1dFNoYXBlID0gbGF5ZXJTaGFwZXNbMF07XG4gICAgfVxuICAgIG91dHB1dFNoYXBlID0gb3V0cHV0U2hhcGU7XG4gICAgaWYgKHRoaXMubWVyZ2VNb2RlID09PSAnY29uY2F0Jykge1xuICAgICAgb3V0cHV0U2hhcGVbb3V0cHV0U2hhcGUubGVuZ3RoIC0gMV0gKj0gMjtcbiAgICAgIG91dHB1dFNoYXBlcyA9IFtvdXRwdXRTaGFwZV07XG4gICAgfSBlbHNlIGlmICh0aGlzLm1lcmdlTW9kZSA9PSBudWxsKSB7XG4gICAgICBvdXRwdXRTaGFwZXMgPSBbb3V0cHV0U2hhcGUsIG91dHB1dFNoYXBlLnNsaWNlKCldO1xuICAgIH0gZWxzZSB7XG4gICAgICBvdXRwdXRTaGFwZXMgPSBbb3V0cHV0U2hhcGVdO1xuICAgIH1cblxuICAgIGlmICh0aGlzLnJldHVyblN0YXRlKSB7XG4gICAgICBpZiAodGhpcy5tZXJnZU1vZGUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gb3V0cHV0U2hhcGVzLmNvbmNhdChzdGF0ZVNoYXBlKS5jb25jYXQoc3RhdGVTaGFwZS5zbGljZSgpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBbb3V0cHV0U2hhcGVdLmNvbmNhdChzdGF0ZVNoYXBlKS5jb25jYXQoc3RhdGVTaGFwZS5zbGljZSgpKTtcbiAgICB9XG4gICAgcmV0dXJuIGdlbmVyaWNfdXRpbHMuc2luZ2xldG9uT3JBcnJheShvdXRwdXRTaGFwZXMpO1xuICB9XG5cbiAgYXBwbHkoXG4gICAgICBpbnB1dHM6IFRlbnNvcnxUZW5zb3JbXXxTeW1ib2xpY1RlbnNvcnxTeW1ib2xpY1RlbnNvcltdLFxuICAgICAga3dhcmdzPzogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdfFN5bWJvbGljVGVuc29yfFN5bWJvbGljVGVuc29yW10ge1xuICAgIGxldCBpbml0aWFsU3RhdGU6IFRlbnNvcltdfFN5bWJvbGljVGVuc29yW10gPVxuICAgICAgICBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddO1xuICAgIGxldCBjb25zdGFudHM6IFRlbnNvcltdfFN5bWJvbGljVGVuc29yW10gPVxuICAgICAgICBrd2FyZ3MgPT0gbnVsbCA/IG51bGwgOiBrd2FyZ3NbJ2NvbnN0YW50cyddO1xuICAgIGlmIChrd2FyZ3MgPT0gbnVsbCkge1xuICAgICAga3dhcmdzID0ge307XG4gICAgfVxuICAgIGNvbnN0IHN0YW5kYXJkaXplZCA9XG4gICAgICAgIHN0YW5kYXJkaXplQXJncyhpbnB1dHMsIGluaXRpYWxTdGF0ZSwgY29uc3RhbnRzLCB0aGlzLm51bUNvbnN0YW50cyk7XG4gICAgaW5wdXRzID0gc3RhbmRhcmRpemVkLmlucHV0cztcbiAgICBpbml0aWFsU3RhdGUgPSBzdGFuZGFyZGl6ZWQuaW5pdGlhbFN0YXRlO1xuICAgIGNvbnN0YW50cyA9IHN0YW5kYXJkaXplZC5jb25zdGFudHM7XG5cbiAgICBpZiAoQXJyYXkuaXNBcnJheShpbnB1dHMpKSB7XG4gICAgICBpbml0aWFsU3RhdGUgPSAoaW5wdXRzIGFzIFRlbnNvcltdIHwgU3ltYm9saWNUZW5zb3JbXSkuc2xpY2UoMSk7XG4gICAgICBpbnB1dHMgPSAoaW5wdXRzIGFzIFRlbnNvcltdIHwgU3ltYm9saWNUZW5zb3JbXSlbMF07XG4gICAgfVxuXG4gICAgaWYgKChpbml0aWFsU3RhdGUgPT0gbnVsbCB8fCBpbml0aWFsU3RhdGUubGVuZ3RoID09PSAwKSAmJlxuICAgICAgICBjb25zdGFudHMgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHN1cGVyLmFwcGx5KGlucHV0cywga3dhcmdzKTtcbiAgICB9XG4gICAgY29uc3QgYWRkaXRpb25hbElucHV0czogQXJyYXk8VGVuc29yfFN5bWJvbGljVGVuc29yPiA9IFtdO1xuICAgIGNvbnN0IGFkZGl0aW9uYWxTcGVjczogSW5wdXRTcGVjW10gPSBbXTtcbiAgICBpZiAoaW5pdGlhbFN0YXRlICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IG51bVN0YXRlcyA9IGluaXRpYWxTdGF0ZS5sZW5ndGg7XG4gICAgICBpZiAobnVtU3RhdGVzICUgMiA+IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFZhbHVlRXJyb3IoXG4gICAgICAgICAgICAnV2hlbiBwYXNzaW5nIGBpbml0aWFsU3RhdGVgIHRvIGEgQmlkcmVjdGlvbmFsIFJOTiwgJyArXG4gICAgICAgICAgICAndGhlIHN0YXRlIHNob3VsZCBiZSBhbiBBcnJheSBjb250YWluaW5nIHRoZSBzdGF0ZXMgb2YgJyArXG4gICAgICAgICAgICAndGhlIHVuZGVybHlpbmcgUk5Ocy4nKTtcbiAgICAgIH1cbiAgICAgIGt3YXJnc1snaW5pdGlhbFN0YXRlJ10gPSBpbml0aWFsU3RhdGU7XG4gICAgICBhZGRpdGlvbmFsSW5wdXRzLnB1c2goLi4uaW5pdGlhbFN0YXRlKTtcbiAgICAgIGNvbnN0IHN0YXRlU3BlY3MgPSAoaW5pdGlhbFN0YXRlIGFzIEFycmF5PFRlbnNvcnxTeW1ib2xpY1RlbnNvcj4pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoc3RhdGUgPT4gbmV3IElucHV0U3BlYyh7c2hhcGU6IHN0YXRlLnNoYXBlfSkpO1xuICAgICAgdGhpcy5mb3J3YXJkTGF5ZXIuc3RhdGVTcGVjID0gc3RhdGVTcGVjcy5zbGljZSgwLCBudW1TdGF0ZXMgLyAyKTtcbiAgICAgIHRoaXMuYmFja3dhcmRMYXllci5zdGF0ZVNwZWMgPSBzdGF0ZVNwZWNzLnNsaWNlKG51bVN0YXRlcyAvIDIpO1xuICAgICAgYWRkaXRpb25hbFNwZWNzLnB1c2goLi4uc3RhdGVTcGVjcyk7XG4gICAgfVxuICAgIGlmIChjb25zdGFudHMgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgJ1N1cHBvcnQgZm9yIGNvbnN0YW50cyBpbiBCaWRpcmVjdGlvbmFsIGxheWVycyBpcyBub3QgJyArXG4gICAgICAgICAgJ2ltcGxlbWVudGVkIHlldC4nKTtcbiAgICB9XG5cbiAgICBjb25zdCBpc1N5bWJvbGljVGVuc29yID0gYWRkaXRpb25hbElucHV0c1swXSBpbnN0YW5jZW9mIFN5bWJvbGljVGVuc29yO1xuICAgIGZvciAoY29uc3QgdGVuc29yIG9mIGFkZGl0aW9uYWxJbnB1dHMpIHtcbiAgICAgIGlmICh0ZW5zb3IgaW5zdGFuY2VvZiBTeW1ib2xpY1RlbnNvciAhPT0gaXNTeW1ib2xpY1RlbnNvcikge1xuICAgICAgICB0aHJvdyBuZXcgVmFsdWVFcnJvcihcbiAgICAgICAgICAgICdUaGUgaW5pdGlhbCBzdGF0ZSBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgY2Fubm90IGJlICcgK1xuICAgICAgICAgICAgJ3NwZWNpZmllZCBhcyBhIG1peCBvZiBzeW1ib2xpYyBhbmQgbm9uLXN5bWJvbGljIHRlbnNvcnMnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoaXNTeW1ib2xpY1RlbnNvcikge1xuICAgICAgLy8gQ29tcHV0ZSB0aGUgZnVsbCBpbnB1dCBhbmQgc3BlY3MsIGluY2x1ZGluZyB0aGUgc3RhdGVzLlxuICAgICAgY29uc3QgZnVsbElucHV0ID0gW2lucHV0c10uY29uY2F0KGFkZGl0aW9uYWxJbnB1dHMpO1xuICAgICAgY29uc3QgZnVsbElucHV0U3BlYyA9IHRoaXMuaW5wdXRTcGVjLmNvbmNhdChhZGRpdGlvbmFsU3BlY3MpO1xuICAgICAgLy8gUGVyZm9ybSB0aGUgY2FsbCB0ZW1wb3JhcmlseSBhbmQgcmVwbGFjZSBpbnB1dFNwZWMuXG4gICAgICAvLyBOb3RlOiB3aXRoIGluaXRpYWwgc3RhdGVzIHN5bWJvbGljIGNhbGxzIGFuZCBub24tc3ltYm9saWMgY2FsbHMgdG9cbiAgICAgIC8vIHRoaXMgbWV0aG9kIGRpZmZlciBpbiBob3cgdGhlIGluaXRpYWwgc3RhdGVzIGFyZSBwYXNzZWQuIEZvclxuICAgICAgLy8gc3ltYm9saWMgY2FsbHMsIHRoZSBpbml0aWFsIHN0YXRlcyBhcmUgcGFzc2VkIGluIHRoZSBmaXJzdCBhcmcsIGFzXG4gICAgICAvLyBhbiBBcnJheSBvZiBTeW1ib2xpY1RlbnNvcnM7IGZvciBub24tc3ltYm9saWMgY2FsbHMsIHRoZXkgYXJlXG4gICAgICAvLyBwYXNzZWQgaW4gdGhlIHNlY29uZCBhcmcgYXMgYSBwYXJ0IG9mIHRoZSBrd2FyZ3MuIEhlbmNlIHRoZSBuZWVkIHRvXG4gICAgICAvLyB0ZW1wb3JhcmlseSBtb2RpZnkgaW5wdXRTcGVjIGhlcmUuXG4gICAgICAvLyBUT0RPKGNhaXMpOiBNYWtlIHJlZmFjdG9yaW5nIHNvIHRoYXQgdGhpcyBoYWNreSBjb2RlIGJlbG93IGlzIG5vXG4gICAgICAvLyBsb25nZXIgbmVlZGVkLlxuICAgICAgY29uc3Qgb3JpZ2luYWxJbnB1dFNwZWMgPSB0aGlzLmlucHV0U3BlYztcbiAgICAgIHRoaXMuaW5wdXRTcGVjID0gZnVsbElucHV0U3BlYztcbiAgICAgIGNvbnN0IG91dHB1dCA9XG4gICAgICAgICAgc3VwZXIuYXBwbHkoZnVsbElucHV0IGFzIFRlbnNvcltdIHwgU3ltYm9saWNUZW5zb3JbXSwga3dhcmdzKTtcbiAgICAgIHRoaXMuaW5wdXRTcGVjID0gb3JpZ2luYWxJbnB1dFNwZWM7XG4gICAgICByZXR1cm4gb3V0cHV0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gc3VwZXIuYXBwbHkoaW5wdXRzLCBrd2FyZ3MpO1xuICAgIH1cbiAgfVxuXG4gIGNhbGwoaW5wdXRzOiBUZW5zb3J8VGVuc29yW10sIGt3YXJnczogS3dhcmdzKTogVGVuc29yfFRlbnNvcltdIHtcbiAgICByZXR1cm4gdGlkeSgoKSA9PiB7XG4gICAgICBjb25zdCBpbml0aWFsU3RhdGUgPSBrd2FyZ3NbJ2luaXRpYWxTdGF0ZSddO1xuXG4gICAgICBsZXQgeTogVGVuc29yfFRlbnNvcltdO1xuICAgICAgbGV0IHlSZXY6IFRlbnNvcnxUZW5zb3JbXTtcbiAgICAgIGlmIChpbml0aWFsU3RhdGUgPT0gbnVsbCkge1xuICAgICAgICB5ID0gdGhpcy5mb3J3YXJkTGF5ZXIuY2FsbChpbnB1dHMsIGt3YXJncyk7XG4gICAgICAgIHlSZXYgPSB0aGlzLmJhY2t3YXJkTGF5ZXIuY2FsbChpbnB1dHMsIGt3YXJncyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBmb3J3YXJkU3RhdGUgPSBpbml0aWFsU3RhdGUuc2xpY2UoMCwgaW5pdGlhbFN0YXRlLmxlbmd0aCAvIDIpO1xuICAgICAgICBjb25zdCBiYWNrd2FyZFN0YXRlID0gaW5pdGlhbFN0YXRlLnNsaWNlKGluaXRpYWxTdGF0ZS5sZW5ndGggLyAyKTtcbiAgICAgICAgeSA9IHRoaXMuZm9yd2FyZExheWVyLmNhbGwoXG4gICAgICAgICAgICBpbnB1dHMsIE9iamVjdC5hc3NpZ24oa3dhcmdzLCB7aW5pdGlhbFN0YXRlOiBmb3J3YXJkU3RhdGV9KSk7XG4gICAgICAgIHlSZXYgPSB0aGlzLmJhY2t3YXJkTGF5ZXIuY2FsbChcbiAgICAgICAgICAgIGlucHV0cywgT2JqZWN0LmFzc2lnbihrd2FyZ3MsIHtpbml0aWFsU3RhdGU6IGJhY2t3YXJkU3RhdGV9KSk7XG4gICAgICB9XG5cbiAgICAgIGxldCBzdGF0ZXM6IFRlbnNvcltdO1xuICAgICAgaWYgKHRoaXMucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoeSkpIHtcbiAgICAgICAgICBzdGF0ZXMgPSB5LnNsaWNlKDEpLmNvbmNhdCgoeVJldiBhcyBUZW5zb3JbXSkuc2xpY2UoMSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICB9XG4gICAgICAgIHkgPSAoeSBhcyBUZW5zb3JbXSlbMF07XG4gICAgICAgIHlSZXYgPSAoeVJldiBhcyBUZW5zb3JbXSlbMF07XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJldHVyblNlcXVlbmNlcykge1xuICAgICAgICB5UmV2ID0gdGZjLnJldmVyc2UoeVJldiBhcyBUZW5zb3IsIDEpO1xuICAgICAgfVxuXG4gICAgICBsZXQgb3V0cHV0OiBUZW5zb3J8VGVuc29yW107XG4gICAgICBpZiAodGhpcy5tZXJnZU1vZGUgPT09ICdjb25jYXQnKSB7XG4gICAgICAgIG91dHB1dCA9IEsuY29uY2F0ZW5hdGUoW3kgYXMgVGVuc29yLCB5UmV2IGFzIFRlbnNvcl0pO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1lcmdlTW9kZSA9PT0gJ3N1bScpIHtcbiAgICAgICAgb3V0cHV0ID0gdGZjLmFkZCh5IGFzIFRlbnNvciwgeVJldiBhcyBUZW5zb3IpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLm1lcmdlTW9kZSA9PT0gJ2F2ZScpIHtcbiAgICAgICAgb3V0cHV0ID0gdGZjLm11bCguNSwgdGZjLmFkZCh5IGFzIFRlbnNvciwgeVJldiBhcyBUZW5zb3IpKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tZXJnZU1vZGUgPT09ICdtdWwnKSB7XG4gICAgICAgIG91dHB1dCA9IHRmYy5tdWwoeSBhcyBUZW5zb3IsIHlSZXYgYXMgVGVuc29yKTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5tZXJnZU1vZGUgPT0gbnVsbCkge1xuICAgICAgICBvdXRwdXQgPSBbeSBhcyBUZW5zb3IsIHlSZXYgYXMgVGVuc29yXTtcbiAgICAgIH1cblxuICAgICAgLy8gVE9ETyhjYWlzKTogUHJvcGVybHkgc2V0IGxlYXJuaW5nIHBoYXNlLlxuICAgICAgaWYgKHRoaXMucmV0dXJuU3RhdGUpIHtcbiAgICAgICAgaWYgKHRoaXMubWVyZ2VNb2RlID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gKG91dHB1dCBhcyBUZW5zb3JbXSkuY29uY2F0KHN0YXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFtvdXRwdXQgYXMgVGVuc29yXS5jb25jYXQoc3RhdGVzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfSk7XG4gIH1cblxuICByZXNldFN0YXRlcyhzdGF0ZXM/OiBUZW5zb3J8VGVuc29yW10pOiB2b2lkIHtcbiAgICB0aGlzLmZvcndhcmRMYXllci5yZXNldFN0YXRlcygpO1xuICAgIHRoaXMuYmFja3dhcmRMYXllci5yZXNldFN0YXRlcygpO1xuICB9XG5cbiAgYnVpbGQoaW5wdXRTaGFwZTogU2hhcGV8U2hhcGVbXSk6IHZvaWQge1xuICAgIG5hbWVTY29wZSh0aGlzLmZvcndhcmRMYXllci5uYW1lLCAoKSA9PiB7XG4gICAgICB0aGlzLmZvcndhcmRMYXllci5idWlsZChpbnB1dFNoYXBlKTtcbiAgICB9KTtcbiAgICBuYW1lU2NvcGUodGhpcy5iYWNrd2FyZExheWVyLm5hbWUsICgpID0+IHtcbiAgICAgIHRoaXMuYmFja3dhcmRMYXllci5idWlsZChpbnB1dFNoYXBlKTtcbiAgICB9KTtcbiAgICB0aGlzLmJ1aWx0ID0gdHJ1ZTtcbiAgfVxuXG4gIGNvbXB1dGVNYXNrKGlucHV0czogVGVuc29yfFRlbnNvcltdLCBtYXNrPzogVGVuc29yfFRlbnNvcltdKTogVGVuc29yXG4gICAgICB8VGVuc29yW10ge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hc2spKSB7XG4gICAgICBtYXNrID0gbWFza1swXTtcbiAgICB9XG4gICAgbGV0IG91dHB1dE1hc2s6IFRlbnNvcnxUZW5zb3JbXTtcbiAgICBpZiAodGhpcy5yZXR1cm5TZXF1ZW5jZXMpIHtcbiAgICAgIGlmICh0aGlzLm1lcmdlTW9kZSA9PSBudWxsKSB7XG4gICAgICAgIG91dHB1dE1hc2sgPSBbbWFzaywgbWFza107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvdXRwdXRNYXNrID0gbWFzaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHRoaXMubWVyZ2VNb2RlID09IG51bGwpIHtcbiAgICAgICAgb3V0cHV0TWFzayA9IFtudWxsLCBudWxsXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG91dHB1dE1hc2sgPSBudWxsO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodGhpcy5yZXR1cm5TdGF0ZSkge1xuICAgICAgY29uc3Qgc3RhdGVzID0gdGhpcy5mb3J3YXJkTGF5ZXIuc3RhdGVzO1xuICAgICAgY29uc3Qgc3RhdGVNYXNrOiBUZW5zb3JbXSA9IHN0YXRlcy5tYXAoc3RhdGUgPT4gbnVsbCk7XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheShvdXRwdXRNYXNrKSkge1xuICAgICAgICByZXR1cm4gb3V0cHV0TWFzay5jb25jYXQoc3RhdGVNYXNrKS5jb25jYXQoc3RhdGVNYXNrKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbb3V0cHV0TWFza10uY29uY2F0KHN0YXRlTWFzaykuY29uY2F0KHN0YXRlTWFzayk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBvdXRwdXRNYXNrO1xuICAgIH1cbiAgfVxuXG4gIGdldCB0cmFpbmFibGVXZWlnaHRzKCk6IExheWVyVmFyaWFibGVbXSB7XG4gICAgcmV0dXJuIHRoaXMuZm9yd2FyZExheWVyLnRyYWluYWJsZVdlaWdodHMuY29uY2F0KFxuICAgICAgICB0aGlzLmJhY2t3YXJkTGF5ZXIudHJhaW5hYmxlV2VpZ2h0cyk7XG4gIH1cblxuICBnZXQgbm9uVHJhaW5hYmxlV2VpZ2h0cygpOiBMYXllclZhcmlhYmxlW10ge1xuICAgIHJldHVybiB0aGlzLmZvcndhcmRMYXllci5ub25UcmFpbmFibGVXZWlnaHRzLmNvbmNhdChcbiAgICAgICAgdGhpcy5iYWNrd2FyZExheWVyLm5vblRyYWluYWJsZVdlaWdodHMpO1xuICB9XG5cbiAgLy8gVE9ETyhjYWlzKTogSW1wbGVtZW50IGNvbnN0cmFpbnRzKCkuXG5cbiAgc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh2YWx1ZTogYm9vbGVhbikge1xuICAgIHN1cGVyLnNldEZhc3RXZWlnaHRJbml0RHVyaW5nQnVpbGQodmFsdWUpO1xuICAgIGlmICh0aGlzLmZvcndhcmRMYXllciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmZvcndhcmRMYXllci5zZXRGYXN0V2VpZ2h0SW5pdER1cmluZ0J1aWxkKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuYmFja3dhcmRMYXllciAhPSBudWxsKSB7XG4gICAgICB0aGlzLmJhY2t3YXJkTGF5ZXIuc2V0RmFzdFdlaWdodEluaXREdXJpbmdCdWlsZCh2YWx1ZSk7XG4gICAgfVxuICB9XG5cbiAgZ2V0Q29uZmlnKCk6IHNlcmlhbGl6YXRpb24uQ29uZmlnRGljdCB7XG4gICAgY29uc3QgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QgPSB7XG4gICAgICAnbWVyZ2VNb2RlJzogdGhpcy5tZXJnZU1vZGUsXG4gICAgfTtcbiAgICAvLyBUT0RPKGNhaXMpOiBBZGQgbG9naWMgZm9yIGBudW1Db25zdGFudHNgIG9uY2UgdGhlIHByb3BlcnR5IGlzIGFkZGVkLlxuICAgIGNvbnN0IGJhc2VDb25maWcgPSBzdXBlci5nZXRDb25maWcoKTtcbiAgICBPYmplY3QuYXNzaWduKGNvbmZpZywgYmFzZUNvbmZpZyk7XG4gICAgcmV0dXJuIGNvbmZpZztcbiAgfVxuXG4gIC8qKiBAbm9jb2xsYXBzZSAqL1xuICBzdGF0aWMgZnJvbUNvbmZpZzxUIGV4dGVuZHMgc2VyaWFsaXphdGlvbi5TZXJpYWxpemFibGU+KFxuICAgICAgY2xzOiBzZXJpYWxpemF0aW9uLlNlcmlhbGl6YWJsZUNvbnN0cnVjdG9yPFQ+LFxuICAgICAgY29uZmlnOiBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QpOiBUIHtcbiAgICBjb25zdCBybm5MYXllciA9XG4gICAgICAgIGRlc2VyaWFsaXplKGNvbmZpZ1snbGF5ZXInXSBhcyBzZXJpYWxpemF0aW9uLkNvbmZpZ0RpY3QpIGFzIFJOTjtcbiAgICBkZWxldGUgY29uZmlnWydsYXllciddO1xuICAgIC8vIFRPRE8oY2Fpcyk6IEFkZCBsb2dpYyBmb3IgYG51bUNvbnN0YW50c2Agb25jZSB0aGUgcHJvcGVydHkgaXMgYWRkZWQuXG4gICAgaWYgKGNvbmZpZ1snbnVtQ29uc3RhbnRzJ10gIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IE5vdEltcGxlbWVudGVkRXJyb3IoXG4gICAgICAgICAgYERlc2VyaWFsaXphdGlvbiBvZiBhIEJpZGlyZWN0aW9uYWwgbGF5ZXIgd2l0aCBudW1Db25zdGFudHMgYCArXG4gICAgICAgICAgYHByZXNlbnQgaXMgbm90IHN1cHBvcnRlZCB5ZXQuYCk7XG4gICAgfVxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcbiAgICBjb25zdCBuZXdDb25maWc6IHtba2V5OiBzdHJpbmddOiBhbnl9ID0gY29uZmlnO1xuICAgIG5ld0NvbmZpZ1snbGF5ZXInXSA9IHJubkxheWVyO1xuICAgIHJldHVybiBuZXcgY2xzKG5ld0NvbmZpZyk7XG4gIH1cbn1cbnNlcmlhbGl6YXRpb24ucmVnaXN0ZXJDbGFzcyhCaWRpcmVjdGlvbmFsKTtcbiJdfQ==","/** @license See the LICENSE file. */\n// This code is auto-generated, do not modify this file!\nconst version = '3.18.0';\nexport { version };\n//# sourceMappingURL=version.js.map","/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport '@tensorflow/tfjs-core';\n// tslint:disable-next-line: no-imports-from-dist\nimport '@tensorflow/tfjs-core/dist/register_all_gradients';\n// tslint:disable-next-line: no-imports-from-dist\nimport '@tensorflow/tfjs-core/dist/public/chained_ops/register_all_chained_ops';\nexport * from '@tensorflow/tfjs-core';\nexport * from '@tensorflow/tfjs-layers';\nexport * from '@tensorflow/tfjs-converter';\n// Export data api as tf.data\nimport * as data from '@tensorflow/tfjs-data';\nexport { data };\n// Import and register backends.\nimport '@tensorflow/tfjs-backend-cpu';\nimport '@tensorflow/tfjs-backend-webgl';\n// Import versions of all sub-packages.\nimport { version_core } from '@tensorflow/tfjs-core';\nimport { version_cpu } from '@tensorflow/tfjs-backend-cpu';\nimport { version_webgl } from '@tensorflow/tfjs-backend-webgl';\nimport { version_data } from '@tensorflow/tfjs-data';\nimport { version_layers } from '@tensorflow/tfjs-layers';\nimport { version_converter } from '@tensorflow/tfjs-converter';\nimport { version as version_union } from './version';\nexport const version = {\n    'tfjs-core': version_core,\n    'tfjs-backend-cpu': version_cpu,\n    'tfjs-backend-webgl': version_webgl,\n    'tfjs-data': version_data,\n    'tfjs-layers': version_layers,\n    'tfjs-converter': version_converter,\n    'tfjs': version_union\n};\n//# sourceMappingURL=index.js.map"],"names":["AttributeError","Error","constructor","message","super","Object","setPrototypeOf","this","prototype","RuntimeError","AssertionError","LruCache","maxEntries","cache","Map","get","key","entry","has","delete","set","put","value","size","keyToDelete","keys","next","getMaxEntries","setMaxEntries","i","pyListRepeat","numValues","Array","isArray","newArray","concat","fill","assert","val","count","array","refernce","counter","item","singletonOrArray","xs","length","toList","x","toSnakeCase","name","intermediate","replace","insecure","toLowerCase","toCamelCase","identifier","indexOf","m","p1","toUpperCase","_GLOBAL_CUSTOM_OBJECTS","serializeKerasObject","instance","undefined","dict","getClassName","getConfig","convertNDArrayScalarsInConfig","config","forEach","configItem","fields","field","deserializeKerasObject","moduleObjects","customObjects","printableModuleName","fastWeightInit","functionName","fn","JSON","stringify","className","cls","fromConfig","customObjectsCombined","nestedConfig","backupCustomObjects","assign","returnObj","numberCompare","a","b","reverseNumberCompare","unique","out","push","isObjectEmpty","obj","hasOwnProperty","checkStringTypeUnionValue","values","label","checkArrayTypeAndLength","expectedType","minLength","maxLength","Infinity","every","e","assertPositiveInteger","util","v","Number","isInteger","formatAsFriendlyString","map","join","debounce","f","waitMs","nowFunc","lastResult","lastTime","f2","args","now","mapActivationToFusedKernel","activationName","_nextUniqueTensorId","getNextUniqueTensorId","_uidPrefixes","getUid","prefix","toString","VALID_DATA_FORMAT_VALUES","VALID_INTERPOLATION_FORMAT_VALUES","VALID_PADDING_MODE_VALUES","VALID_POOL_MODE_VALUES","VALID_BIDIRECTIONAL_MERGE_MODES","nameMap","checkInterpolationFormat","checkPaddingMode","checkPoolMode","_nameScopeStack","_nameScopeDivider","nameScope","pop","currentNameScopePrefix","getScopedTensorName","tensorName","isValidTensorName","getUniqueTensorName","scopedName","index","result","tensorNameRegex","RegExp","match","parseInt","arrayProd","begin","end","prod","min","NaN","POSITIVE_INFINITY","max","NEGATIVE_INFINITY","range","_epsilon","epsilon","backend","imageDataFormat","cast","dtype","expandDims","axis","outShape","shape","slice","splice","repeat","n","tidy","y","tile","flatten","newShape","batchFlatten","rank","sliceAlongFirstAxis","start","sliceAlongLastAxis","sliceAlongAxis","concatenate","tensors","concatAlongFirstAxis","randomNormal","mean","stddev","seed","dot","activation","bias","xLastDim","ySecondLastDim","transposeA","transposeB","reshapeBias","aFirstDims","aLastDim","bShape","bLastDim","yOtherDims","perm","from","_","outputShape","gather","reference","indices","tensor1d","square","xRank","dataFormat","biasShape","biasAdd","elu","alpha","softsign","dropout","level","noiseShape","hardSigmoid","inTrainPhase","alt","training","VALID_FAN_MODE_VALUES","VALID_DISTRIBUTION_VALUES","checkFanMode","checkDistribution","Initializer","serialization","fromConfigUsesCustomObjects","apply","zeros","ones","mul","scalar","DEFAULT_MINVAL","DEFAULT_MAXVAL","minval","maxval","randomUniform","DEFAULT_MEAN","DEFAULT_STDDEV","truncatedNormal","gain","eye","computeFans","fanIn","fanOut","receptiveFieldSize","shapeProd","Math","sqrt","scale","mode","distribution","fans","limit","DEFAULT_GAIN","console","warn","normalizedShape","q","linalg","gramSchmidt","transpose","INITIALIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP","deserializeInitializer","getMap","classNameMap","serializeInitializer","initializer","getInitializer","isArrayOfShapes","normalizeShapeList","getExactlyOneTensor","getExactlyOneShape","shapes","countParamsInWeights","weights","weight","reduce","DEFAULT_VARIABLE_NAME_PREFIX","LayerVariable","trainable","constraint","id","originalName","trainable_","read","assertNotDisposed","write","newVal","checkShapesMatch","dispose","isDisposed","batchGetValue","batchSetValue","variablesAndValues","variableAndValue","variable","InputSpec","ndim","maxNDim","minNDim","axes","SymbolicTensor","sourceLayer","inputs","callArgs","outputTensorIndex","_nextNodeID","Node","outboundLayer","inboundLayers","nodeIndices","tensorIndices","inputTensors","outputTensors","inputMasks","outputMasks","inputShapes","outputShapes","layer","outboundNodes","inboundNodes","inboundNames","_nextLayerID","Layer","_callHook","_addedWeightNames","_stateful","activityRegularizer","inputSpec","supportsMasking","_trainableWeights","_nonTrainableWeights","_losses","_updates","_built","inputShape","batchInputShape","batchSize","inputDType","initialWeights","_refCount","fastWeightInitDuringBuild","nodeKey","nodeIndex","getNodeAtIndex","attrName","getInputAt","getOutputAt","input","output","losses","calculateLosses","lossFn","updates","built","w","trainableWeights","filter","nonTrainableWeights","stateful","resetStates","assertInputCompatibility","inputIndex","spec","xShape","xShapeAtAxis","specDim","dim","call","kwargs","invokeCallHook","setCallHook","callHook","clearCallHook","inputsList","allAreSymbolic","noneAreSymbolic","xElem","build","setWeights","outputList","outputListCopy","clone","collectInputShape","computeOutputShape","outputDType","guessOutputDType","warnOnIncompatibleInputShape","addInboundNode","dimMismatch","dimension","allOutputShapes","node","shapeString","countParams","getWeights","trainableOnly","params","weightValueTuples","paramValues","pv","p","addWeight","regularizer","getInitializerFunc","initValue","addLoss","setFastWeightInitDuringBuild","computeMask","mask","TypeError","maskElement","inputTensorList","tensorIndex","disposeWeights","numDisposedVariables","refCountAfterDispose","getSourceInputs","tensor","sourceTensors","previousSources","sparse","inputTensor","batchShape","inputLayer","outputs","assertFeedCompatibility","err","FeedDict","feeds","id2Value","id2Mask","name2Id","feed","add","addFeed","hasKey","names","getValue","getMask","disposeMasks","cachedSorted","cachedRecipientCounts","updateCacheMaxEntries","execute","fetches","feedDict","probe","arrayFetches","fetchArray","outputNames","t","finalOutputs","feedNames","outputName","maxNumTensors","minNumTensors","fetchAndFeedKey","sort","recipientCounts","sorted","getTopologicalSortAndRecipientCounts","internalFeedDict","numTensors","memory","symbolic","srcLayer","inputValues","tensorsToDispose","maskExists","outputMask","layerOutputs","getNodeOutputs","outputSymbolicTensors","finalSorted","finalRecipientMap","getTopologicalSortAndRecipientCountsForOneFetch","recipientMap","visited","Set","fetch","symbolicTensor","recipient","recipientMap2Counts","stack","marks","top","topIsMarked","outputTensor","ENV","env","calcL2Norms","registerFlag","Constraint","defaultMaxValue","defaultAxis","maxValue","norms","desired","defaultMinValue","defaultRate","minValue","rate","CONSTRAINT_IDENTIFIER_REGISTRY_SYMBOL_MAP","serializeConstraint","deserializeConstraint","getConstraint","async","resolveScalarsInLogs","logs","promises","scalarsToDispose","valueScalar","data","Promise","all","disposeTensorsInLogs","ModelLoggingVerbosity","DEFAULT_YIELD_EVERY_MS","BaseCallback","validationData","setParams","onEpochBegin","epoch","onEpochEnd","onBatchBegin","batch","onBatchEnd","onTrainBegin","onTrainEnd","setModel","model","CallbackList","callbacks","queueLength","append","callback","BaseLogger","seen","totals","oldTotalsToDispose","total","log","div","keep","History","history","syncData","valueArray","tensorToDispose","CustomCallback","yieldEvery","currentEpoch","nextFrameFunc","nextFrame","onYield","maybeWait","bind","trainBegin","trainEnd","epochBegin","epochEnd","batchBegin","batchEnd","yield","ps","standardizeCallbacks","callbackConfigs","callbackConfig","registerCallbackConstructor","verbosityLevel","callbackConstructor","checkForDuplicate","constructors","levelName","ctor","clear","createCallbacks","configureCallbacks","verbose","epochs","initialEpoch","numTrainSamples","stepsPerEpoch","doValidation","callbackMetrics","actualCallbacks","callbackList","samples","steps","metrics","l2Normalize","squareSum","epsilonTensor","norm","meanSquaredError","yTrue","yPred","meanAbsoluteError","meanAbsolutePercentageError","diff","clippedTrue","MAX_VALUE","absResult","meanSquaredLogarithmicError","clippedPred","firstLog","secondLog","squaredHinge","maxResult","hinge","categoricalHinge","pos","neg","logcosh","log2","predictionDiff","logcoshResult","categoricalCrossentropy","target","fromLogits","outputSum","sparseCategoricalCrossentropy","flatTarget","oneHotTarget","sigmoidCrossEntropyWithLogits","labels","logits","reluLogits","negAbsLogits","binaryCrossentropy","kullbackLeiblerDivergence","poisson","logPred","cosineProximity","trueNormalized","predNormalized","trueXPred","lossesMap","identifierOrFn","errMsg","includes","binaryAccuracy","threshold","yPredThresholded","categoricalAccuracy","truePositives","falsePositives","precision","tp","fp","denominator","sparseCategoricalAccuracy","metricsMap","mse","MSE","mae","MAE","mape","MAPE","cosine","getLossOrMetricName","fnName","getOptimizer","optimizerMap","train","adagrad","adadelta","adam","adamax","rmsprop","sgd","MAX_USER_DEFINED_METADATA_SERIALIZED_LENGTH","checkUserDefinedMetadata","userDefinedMetadata","modelName","checkSize","getPrototypeOf","plainObjectCheck","xType","printSummary","lineLength","positions","printFn","sequentialLike","isModelSequentialLike","toDisplay","relevantNodes","floor","depth","nodesByDepth","printRow","layers","printLayerSummary","printLayerSummaryWithConnections","checkTrainableWeightsConsistency","trainableCount","countTrainableParams","nonTrainableCount","collectedTrainableWeights","nodes","depthNodes","flag","line","connections","inboundLayer","inboundLayerIndex","inboundTensorIndex","firstConnection","isArrayItemInputOrOutputName","pythonicConfig","tsArray","arrayLength","tsDict","pythonicKey","pythonicValue","tsKey","convertTsToPythonic","tsConfig","pyArray","pyDict","tsValue","pyKey","version","Container","containerNodes","inputLayers","inputLayersNodeIndices","inputLayersTensorIndices","outputLayers","outputLayersNodeIndices","outputLayersTensorIndices","internalContainerRefs","inputNames","feedInputShapes","feedInputNames","feedOutputNames","internalInputShapes","internalOutputShapes","nodesDepths","nodeIDToNode","layersDepths","layerIDToLayer","layerIndices","nodesInDecreasingDepth","buildMapOfGraph","finishedNodes","nodesInProgress","numInboundLayers","reversedNodesInDecreasingDepth","reverse","previousDepth","inboundNode","nodeID","layersByDepth","layerID","depthKeys","layersForDepth","aIndex","bIndex","computableTensors","layersWithCompleteInput","allNames","numOccurrences","container","loadWeights","strict","nameToWeight","totalWeightsCount","validatedName","tokens","split","shortenNameArray","unsetNames","updatedConfig","theConfig","modelConfig","toJSON","unused","returnString","masks","runInternalGraph","layersToOutputShapes","shapeKey","j","outputShapeKeys","tensorMap","referenceInputTensors","referenceOutputTensors","computedData","computedTensors","computedMasks","computedTensor","computedMask","buildNodeConversionMap","nodeConversionMap","keptNodes","originalNodeIndex","getLayer","layerConfigs","layerClassName","layerConfig","filteredInboundNodes","nodeData","newNodeIndex","modelInputs","modelOutputs","createdLayers","unprocessedNodes","addUnprocessedNode","processNode","inputData","inboundLayerName","inboundNodeIndex","processLayer","layerData","layerName","inboundNodesData","layersFromConfig","currentUnprocessedNodesForLayer","inputLayersFromConfig","layerOutputTensors","outputLayersFromConfig","standardizeSampleOrClassWeights","xWeight","weightType","numOutputs","standardizeClassWeights","classWeight","standardizeWeights","sampleWeight","sampleWeightMode","yClasses","argMax","reshape","yClassIndices","classSampleWeight","classIndex","computeWeightedLoss","sampleWeights","DEFAULT_VALIDATION_BATCH_SIZE","standardizeDataIteratorOutput","iteratorOut","ys","iteratorOutObj","flattenedXs","flattenTensorOrArrayOrMap","flattenedYs","xIndex","yIndex","inputOrOutput","standardizeTensorValidationData","fitDataset","dataset","hasBatchesPerEpoch","batchesPerEpoch","optimizer","isTraining","valXs","valYs","isDatasetObject","validationBatches","trainFunction","makeTrainFunction","outLabels","getDedupedMetricsNames","getStepsPerEpoch","stopTraining_","dataIterator","iterator","epochLogs","stepsDone","batchIndex","done","batchLogs","standardClassWeights","ins","outs","valOuts","evaluateDataset","batches","evaluate","validationBatchSize","metricsNames","isFinite","isLazyIteratorObject","hasBatches","testFunction","numExamples","xsAndYs","batchOuts","batchOut","oldScalar","checkBatchSize","sliceArrays","arrays","stop","sliceArraysByIndices","makeBatches","batchStart","fitLoop","valF","valIns","shuffle","validationSteps","checkNumSamples","indexArray","epochIndexArray1D","batchIds","insBatch","testLoop","fitTensors","targets","originalInputs","originalTargets","inputValX","inputValY","valX","valY","checkBatchAxis","standardizedOuts","standardizeUserData","valStandardized","validationSplit","splitAt","originalBatchSize","valFunction","makeTestFunction","disposeNewTensors","ensureTensorsRank2OrHigher","Tensor","refTensors","oldTensorIds","oldTensor","isDataTensor","isDataArray","isDataDict","standardizeInputData","exceptionPrefix","gotUnexpectedData","refDim","checkArrayLengths","setX","setY","checkLossAndTargetCompatibility","lossFns","keyLosses","loss","slicedYShape","slicedShape","targetDim","outDim","checkInputData","collectMetrics","wrappedMetrics","nestedMetrics","outputMetrics","LAYERS_MODEL_FORMAT_NAME","summary","compile","optimizer_","isOptimizerOwned","Optimizer","lossFunctions","theLosses","l","lossFunction","feedOutputShapes","feedLossFns","skipTargetIndices","metricsTensors","weightedLoss","appendMetric","outputIndex","metricName","metricTensor","handleMetrics","metricNamePrefix","accFn","weightedMetricFn","metric","suffix","metricFn","metricResult","standardizeUserDataXY","testOuts","stepsName","numSamples","outputsIsArray","retrieveSymbolicTensors","tensorValue","executeOutputs","symbolicTensorNames","outputsRemaining","layerOutputNames","remainingNames","predictLoop","outsBatches","predict","xsRank2OrHigher","predictOnBatch","standardXs","standardYs","standardSampleWeights","classWeights","dedupedOutLabels","newLabel","dupIndex","lossValues","metricsValues","totalLossFunction","totalLoss","meanLoss","weightedMetric","regularizerLoss","variables","param","returnCost","totalLossValue","minimize","valOutputs","meanMetric","fit","trainOnBatch","standardizeOut","getNamedWeights","namedWeights","weightValues","stopTraining","numTensorsBeforeOptmizerDisposal","getLossIdentifiers","lossNames","getMetricIdentifiers","metricsIdentifiers","getTrainingConfig","optimizer_config","class_name","loadTrainingConfig","trainingConfig","weighted_metrics","loss_weights","sample_weight_mode","lossEntry","save","handlerOrURL","handlers","io","weightDataAndSpecs","unusedArg","modelArtifacts","modelTopology","format","generatedBy","convertedBy","includeOptimizer","optimizerWeightData","specs","optimizerWeightSpecs","weightData","weightSpecs","setUserDefinedMetadata","getUserDefinedMetadata","Functional","checkShape","some","isLayerModelInstance","modelLayer","lastLayerIndex","configArray","extraModelConfig","conf","Elu","Selu","Relu","Relu6","Linear","Sigmoid","HardSigmoid","Softplus","Softsign","Tanh","LogSoftmax","Swish","Mish","serializeActivation","deserializeActivation","getActivation","assertObjectArgs","Regularizer","l1","l2","hasL1","hasL2","regularization","sum","abs","REGULARIZER_IDENTIFIER_REGISTRY_SYMBOL_MAP","serializeRegularizer","deserializeRegularizer","getRegularizer","relu","clipByValue","baseConfig","DEFAULT_ALPHA","leakyRelu","DEFAULT_ALPHA_INITIALIZER","alphaInitializer","alphaRegularizer","alphaConstraint","sharedAxes","paramShape","prelu","DEFAULT_THETA","theta","greater","DEFAULT_AXIS","softmax","normalizeArray","singleValue","convOutputLength","inputLength","filterSize","padding","stride","dilation","dilatedFilterSize","outputLength","deconvLength","dimSize","strideSize","kernelSize","preprocessConv2DInput","preprocessConv3DInput","conv1dWithBias","kernel","strides","dilationRate","conv2dWithBiasActivation","pad","dilations","conv3dWithBias","BaseConv","DEFAULT_KERNEL_INITIALIZER","DEFAULT_BIAS_INITIALIZER","verifyArgs","useBias","biasInitializer","biasConstraint","biasRegularizer","Conv","filters","kernelInitializer","kernelConstraint","kernelRegularizer","channelAxis","inputDim","kernelShape","biasValue","fusedActivationName","newSpace","space","newDim","hAxis","wAxis","height","width","kernelH","kernelW","strideH","strideW","outHeight","outWidth","heightAxis","widthAxis","dAxis","kernelD","strideD","outDepth","depthAxis","SeparableConv","DEFAULT_DEPTHWISE_INITIALIZER","DEFAULT_POINTWISE_INITIALIZER","depthwiseKernel","pointwiseKernel","depthMultiplier","depthwiseInitializer","depthwiseRegularizer","depthwiseConstraint","pointwiseInitializer","pointwiseRegularizer","pointwiseConstraint","depthwiseKernelShape","pointwiseKernelShape","cropping","hSliced","DEFAULT_SIZE","interpolation","resized","resizeNearestNeighbor","resizeBilinear","depthwiseConv2d","rows","cols","outFilters","outRows","outCols","standardizeArgs","initialState","constants","numConstants","toListOrNull","rnn","stepFunction","initialStates","goBackwards","unroll","needPerStepOutputs","perStepOutputs","lastOutput","states","timeSteps","perStepInputs","perStepMasks","currentInput","stepOutputs","maskedOutputs","stepMask","negStepMask","newStates","state","cell","cells","stateSize","returnSequences","returnState","stateSpec","states_","keptStates","getStates","numStates","setStates","outputDim","stateShape","stateMask","s","constantShape","stepInputShape","expectedShape","standardized","additionalInputs","additionalSpecs","isTensor","fullInput","fullInputSpec","originalInputSpec","getInitialState","cellCallKwargs","step","rnnOutputs","cellConfig","DEFAULT_ACTIVATION","DEFAULT_RECURRENT_INITIALIZER","units","recurrentInitializer","recurrentRegularizer","recurrentConstraint","recurrentDropout","dropoutFunc","dropoutMask","recurrentDropoutMask","recurrentKernel","prevOutput","h","generateDropoutMask","dpMask","recDpMask","DEFAULT_RECURRENT_ACTIVATION","resetAfter","recurrentActivation","implementation","hTMinus1","z","r","hh","matrixX","recurrentKernelValue","rk1","rk2","matrixInner","xZ","xR","xH","recurrentZ","recurrentR","recurrentH","unitForgetBias","_a","capturedBiasInit","capturedUnits","bI","bF","bCAndH","cTMinus1","c","o","z0","z1","z2","z3","nestedStates","newNestedStates","callInputs","cellStates","getCellConfig","cellConfigs","tuples","numParams","inputWeights","droppedInputs","createMask","__rest","getOwnPropertySymbols","propertyIsEnumerable","ConvRNN2D","computeSingleOutputShape","isChannelsFirst","hOut","wOut","numOfKernels","recurrentKernelShape","init","biasI","biasF","biasCAndO","applyDropout","xI","xF","xC","xO","recDropoutMask","hI","hF","hC","hO","kernelChannelAxis","kernelI","kernelF","kernelC","kernelO","biasC","biasO","inputConv","recKernelI","recKernelF","recKernelC","recKernelO","recurrentConv","getNoiseShape","inputLastDim","permutation","targetShape","isUnknown","fixUnknownDimension","errorMsg","finalShape","known","unknown","originalSize","anyUnknownDims","dims","expectedSortedIndices","dimsIncludingBatch","maskValue","any","notEqual","keepDims","booleanMask","embeddings","DEFAULT_EMBEDDINGS_INITIALIZER","embeddingsInitializer","embeddingsRegularizer","embeddingsConstraint","maskZero","zerosLike","inLens","k","s1","s2","Merge","mergeFunction","computeElementwiseOpOutputShape","shape1","shape2","batchSizes","allRanks","reshapeRequired","reshapedInputs","inputDims","xNDim","transposed","xTransposed","yNDim","yShape","allNoneShape","shapeSet","shapeWithoutConcatAxis","exists","allNullMasks","concatenatedMasks","interpretAxis","batchDot","axesArray","diffShape","adjX","adjY","idx","squeezeAxes","normalize","interpretAxes","x1","x2","noised","_getNoiseShape","alphaP","keptIdx","greaterEqual","batchNormalization","variance","beta","gamma","regularNormalizeBatchInTraining","reductionAxes","meanAndVariance","normed","broadcastNormalizeBatchInTraining","broadcastMean","broadcastVariance","broadcastGamma","broadcastBeta","normalizeBatchInTraining","momentum","center","betaInitializer","gammaInitializer","movingMeanInitializer","movingVarianceInitializer","betaConstraint","gammaConstraint","betaRegularizer","gammaRegularizer","movingMean","movingVariance","broadcastShape","sortedReductionAxes","needsBroadcasting","normalizeInference","broadcastMovingMean","broadcastMovingVariance","normedTraining","doMovingAverage","decay","origValue","updateDelta","updateMovingMeanAndVariance","nDims","moments","broadcast","offset","momentsTiling","scaleOffsetTiling","spatial2dPadding","pattern","heightPadding","widthPadding","pool2d","poolSize","poolMode","paddingString","pool3d","Pooling1D","poolingFunction","Pooling2D","Pooling3D","depths","GlobalPooling1D","GlobalPooling2D","Wrapper","newConfig","childInputShape","childOutputShape","timesteps","checkBidirectionalMergeMode","DEFAULT_BIDIRECTIONAL_MERGE_MODE","forwDict","forwardLayer","backDict","backwardLayer","mergeMode","_trainable","numWeights","numeightsOver2","layerShapes","stateSpecs","isSymbolicTensor","yRev","forwardState","backwardState","rnnLayer","version_core"],"sourceRoot":""}